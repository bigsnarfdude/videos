Yeah, it's very nice to see everybody here. I really wish I can be there in person. So what I'm going to talk about today is a unified trapezoidal quadrature method for integral operators. So we had a pretty So we had a pretty nice discussion. We just had a pretty nice discussion about quadratures and geometries and very exciting topics like complex geometry and adaptive quadratures. But what I'm going to talk about today is not going to solve any of those complicated problems. As you can see, As you can see from the title, it's a trapezoidal culture. So it's going to be applicable to relatively simple surfaces. But it's going to, the nice thing is this is going to work for very, it's a very simple method and it's going to work for And it's going to work for a variety of problems and very efficiently. So, just to set things up, let me move my Zoom a bit so that I can see my slides. All right. So, just quickly set things up. So, suppose So suppose we want to solve some nice integral equations, second kind of integral equations. So a typical way of doing this is to use the Naistron discretization where we first collocate an equation at a bunch of collocation points. And so it gets discretized. And then we apply some. And then we applied some quadrature to further discretize the integral such that it returns us a linear system. So if the kernel is smooth, then you can, of course, use any nice regular quadrature rules with nodes xi and weights wi and get an equation with matrix with matrix n. With matrix energies given by this. But as we all know, the kernels are typically singular. For example, we can have all these kind of singularities like weak singularity in 2D or this Cauchy type singularity or even hyper singularity. So So I'm going to, so what I'm going to present is this quadrature method. So first I'm going to focus on 2D, so the quadratures on curves in 2D. This will be the main part of this talk. And then I'll show some examples and briefly talk about doing things in 3D. So, first of all, the basic idea for this, for the method in general, is very simple. So, it's an error correction idea. So, basically, suppose we have some singular function g that we want to integrate. And we use the trick of singularity subtraction. Singularity subtraction. So, first of all, we find something, some simpler function h that acts behaves similarly as g. So when we subtract from g this approximation, we get a much smoother function. And of course, we need to add them back. Then for this smoother integrand, you can use some simple smooth quadrature rules to approximate it to. Rules to approximate it to high order. And then next, we do some transformation and combine the integral and this quadrature applied to this simple integrand, combine them together, and we call this an error term due to using this approximation. So what you end up with is a simple regular quadrature applied to the original indigram. To the original indegram, plus some error term that due to using this approximation. So it would be nice if we know an expression for this error, for this error term. Sorry, so let me. So let me motivate this by doing maybe the simplest kernel into the Laplace kernel. So suppose we have an integral of a log log kernel times some smooth density. Then this is the difference between the integral and the Chebezoidal rule, ignoring the singular points, and that's the error. Points, and that's the error we're interested in. And we are aiming at approximating this error term using some local corrections near the singular point. And for simplicity, I'm going to assume that the integrand is smooth and supported in this interval. So So, a simple way to understand how this can be done can be, and we can do this by answering two simple questions. So first, what is the error? And second, how to correct the error. So, and it turns out that the error can be given by the general Euler-McLaren formula. Suppose we expand a smooth component phi into a Taylor series expansion, then the error can be decomposed into these components. So among those components, the x to the odd powers are going to vanish due to data symmetry. So what you end up with are the error terms that associated to the log kernel times. The log kernel times these even powers. And by the automaker formula, they are given by these derivatives of the Riemann zeta function evaluated at points that are dictated by the power of these components. So once we have this error expansion, then we can Then we can, of course, add this back to the quadrature to correct and get a high-order method. The only trouble is there will be these coefficients that depends on the derivative of the smooth part. So to avoid computing those high-order derivatives, we can do this trick called moment fitting, where we simply just fit this. We simply just fit this error expansion locally on a grid around a singular point. And this can be done by solving a simple linear system like so. And this will give us some special weights on those blue points. And if we combine those together, we are going to get a very high order accurate quadrature. accurate quadrature. And it's basically the very simple trapizoidal rule plus some error correction. And I'm color coding this error correction term into the blue part is handle the singular component and the green part is the regular component and that's going to be the color code. That's going to be the color code for the rest of the slides. So, this quarter chair actually appears in an early paper by Capua and Rockland. It's very nice, very stable, high order, but it's not used by many people. It's not the popular cordager that's used by many people because mostly because this is only working. Because this is only working on an interval or on a flat geometry. So, a natural question is: how do you extend it to curves? So, just a recap of what we have. So, basically, we have an integral that consists of a singular part and a smooth part. And then we simply use And then we simply applied the Chubby Sodo rule to it. And we figured out what are the error corrections. And it turns out that it's actually not hard to extend this to quadratures on curves. Suppose we have some curves gamma that's parametrized by R of t. By R and assume that our singular point is at zero, then you can discretize this analogously by replacing the H weights with the octleng elements. And just by doing that, you get directly the high-order quadrature for For this single integral on curves. If you compare this with the quadrature that we have for an interval, it looks completely analogous. Everything are the same except that we replace the H weights in the flat geometry case with the arc length element and the singular ways, these WJ. Singular ways, these WJs, the blue, this in blue, they're exactly the same. So that's a little bit surprising because you think that the geometry must have some effect on the singular weights because instead of one of X, we have one over R here. But it turns out that the same quadrature weight just works. So, and we have shown some analysis in this paper. And by the way, all of these works are collaboration with Gander. All right. So, but this is kind of a special case because it's just log of one over R. So, and Uh and and we we happen to have weights that are exactly the same as in the interval case. So so can you do that also for other kernels? And it turns out that you can and it's it's the idea we have actually discussed earlier in the morning as the kernel split quadrature idea. So here is the Hamhost kernel in 2D and Hamhost kernel into the and you can split it into a singular part that consists of the log times some smooth function, mental function, and then a smooth part. And I'm including the constant component in the smooth part, which will be useful later. And the way you can handle this is for the singular parts, we can integrate a singular part. We can integrate a singular part actually in a very similar fashion as before. And it's the trapezoidal rule plus some local correction. And this weight in blue is the same as before for the log one over our kernel. And you can see this is completely analogous to what we have here. We simply replace the smooth component phi with, in this phi with in this case the smooth component the Basel function times the density and that's and that's it right so then to get the quadrature for the whole for the for the full kernel we simply handle the smooth part using the usual trapezoidal rule and add all of these together so at the end you're getting something very similar You're getting something very similar. So, a naive discretization using the trapezoidal rule plus some local correction. And the structure is exactly the same. You have these blue waves that handle the singular component and this move part specific to the kernel that you are dealing with. So, to do this for a general kernel, For a general kernel, the theoretical basis is the generalized Euler-McLaren formula. So what we have just did is using this log version of the Euler-McLaren formula, where we assume the function is given by log times move part, and then we have this expansion. And there's actually an algebraic version of the generalized formula where we assume the singularity is 1 over r to the s power. And then you can actually get a similar error expansion where the singular component is handled by these zeta function values evaluated at appropriate. Evaluated at appropriate entries. And one thing I want to say is this also applies to hypersingular kernels. For example, if you have S equals 2 into D, then this is hypersingular, but it's going to work just as well. And there's a more general version of this quadrature that combines both of these two cases. Both of these two cases that you can find in this book chapter by CD 2018. And this is probably the takeaway slides if you want to construct a quadrature, a trapezoidal quadrature on your own. I'm going to use the singular, the Laplace hyper singular potential as an example, and we're going to. And we're considering this: this is the hypersingular component of that potential, which has a one over r squared component. So it can be done in three simple steps. So the first step is we are going to identify the singular component. So we know that it's one of the R square, but we want to be more specific. And here we're using a binomial expression. A binomial expansion to expand this one over r square in terms of this so-called local banding term. And we get an X series expansion and we split out the one over t squared, the singularity in the simplest form. So here, this so-called local banding term is how much the geometry. How much the geometry deviates from the tangent line, basically, and it's vanishing at zero and it's moved. And with that, then you can compute the zeta function values according to the Euler-McLaren formula. And here is the error correction for this kernel, where we have these error correction terms that again can Error correction terms that again consist of the blue that's the singular singular part and then the green the regular part so and it just so happened that for the hypersingular case we get a spectral method here but in general it's going to be an algebraic order of convergence the only thing that's that's bugging bugging me here is we have a second direction Me here is we have a second derivative of this move part here, and it involves a very complicated expression within here. If you're going to just compute the second derivative of this function, it's going to be, first of all, a very complicated expression. And second of all, the density is probably only available numerically. Numerically. So, and of course, we can solve this problem again by moment fitting. We simply fit this error on a local stencil by solving a simple algebra equation. And at the end, in this case, it's equivalent to applying a finite difference to approximate the second-order derivative. And maybe one final comment is. one final comment is all of these can actually be done be pre-computed so you can just pre-compute a lot of these steps and for a new kernel that you're considering the only thing you actually need to figure out is the smooth the green smooth component specific to the kernel all right so that's the main part of this talk and then Of this talk, and then it'll be. I'll go quickly with for the rest of the talk. So, first of all, just some simple examples to show that this actually works to high order. For example, for the Stokes potential, you can easily analyze the kernel for the single-layer potential and the double-layer potential for the velocity. For the velocity, pressure, and traction kernels. They have different types of singularities, like weekly singular, Cauchy type singular, regular, hyper singular. And you can treat all of these in a similar fashion, like what I have just shown in the previous slides. And this is just showing a 16th order quarter. A 16th order quadrature applied to all of these kernels, and as expected, it is converging very quickly. Another example is a layered media transmission problem. So it's a problem where you have some incident wave that's coming from above and it's traveling. And it's traveling. There are two layers of media here. One has wave number K1, and then it gets transmitted to the bottom layer with wave number K2. And then we can use a simulation that's by Cho and Burnett back in 2015. And actually, there's a fast app. A fast algorithm for this as well. That's by Zhang and Yuman. And we probably will hear more about this tomorrow. But basically, this is the result of applying the quadrature that I described to solve this problem on an 11-layer medium. Bobby, maybe one or two more examples or comments, and then we'll try to take some questions before the next talk. All right. Before the next talk, all right. Yeah, sorry. Okay, so yeah. So, what I'm trying to show with this example is you have slightly different kernels here, and it's the difference between the single layer associated with different wave numbers, but you can do the analysis similarly and design the curator. So it's pretty flexible. And then for 3D, you can do similar things. Can do similar things. And it's completely analogous to the 2D case. The only thing that you're missing here is for the error correction component, the blue part for the singular associated with the singular component is handled by this zeta function called the Epstein Zeta function, first studied by Paul Epstein a century ago. A century ago. It's basically analogous to two times the Riemann zeta function in 1D. And it's a zeta function that needs the first fundamental form of the geometry at the singular point so that both the geometry and the singularity are handled by this data function. And these are the same. And these are the same steps that as in 2D, where you apply the generalized order McLean formula and do moment fitting to fit the errors on some local grid. And this is just the examples of how the convergence and similarly for the layered median example, but a 3D analog. To conclude, Include, I have introduced this unified treatment of this unified quadrature that treats all kinds of singularities, including regular integrals. And it's kernel dependent, but it's actually very easy to derive these quadrature for a variety of kernels. And it can be, it's a local correction, so it can be combined with fast algorithms. Combined with fast algorithms. And also, because it is a very simple producture, it can be used for testing and prototyping a lot of numerical schemes for 3D objects. And although it's not adaptive, you can also combine this with some simple domain decomposition method to treat more general surfaces. Okay, and these are the codes. And these are the codes available on GitHub, and I'll update them soon to include the unified version. Thank you. Great. Thanks very much, Bobby. Maybe we have time for one or two quick questions. You can ask or raise your hand. Anna Karen? Yes, can I ask that? So we didn't see much of the pred things now, but it do I understand correctly? So it should be surfaces where you have trapezoidal rule in both directions, like a tensor product kind of question. Product kind of question. That's right. That's right. But but the weights that you find, these correction weights, it's still simple to find. Yes, the correction weights, so this is again given by this zeta function, but in 3D, it's slightly more complicated. You have to also use the parametric derivative of this. Tips of this later function. So it's slightly more complicated. And but it can be done. And how would you do in practice? Would you pre-compute for all? I mean, it depends a lot on the symmetry, right? How many different ones you need? Yeah, so in this case, it's probably harder to pre-compute because it's going to depend on the first fundamental form. So currently I'm. So, currently, I'm computing these on the fly, and it's quite efficient, but it can be improved. So, you can probably do some interpolation scheme to pre-compute these things and interpolate when you need it. Yeah. Okay. So, is it so? Now it's trapezoidally, and I understand it's quite specific. I understand it's quite specific for that, but is there any chance of extending to any other culture scheme like Gal Slach Andre? That's a great question. So in this, I've mentioned this book chapter by CIDI and it has some discussion for the Gauss-Legron quadrature, but of course those correction coefficients are not going to be as easy to compute. As easy to compute as in the trapezoidal rule case, and there's no simple explicit formulas, but things worked analogously there. So I know you have like leading order estimates, but yeah, maybe it can be generalized to higher order. Then you can do something similar to what I'm doing for the trapezoidal rule. Okay, okay, fine. Thank you. Okay, fine. Thank you. Great. And we have, I guess, there were some technical difficulties in Oaxaca. Alex has a question for you, Bobby. Okay. We still can't hear you, Alex. Okay, while Alex tries to figure out the technical difficulties there, is the microphone on now? Yes, now we hear you. Okay. Do you want to go or? I'll just say, well, thanks for a great talk, Bobby. But is there any, as Anna Karen suggested, something like a spherical A spherical, a cover, you know, a spectral quadrature on the sphere-like object would be really cool. Yeah, yeah, that would be very cool. So, I hope you get to do that. And also, I wonder, so every time you have a new kernel, you have to analytically write down the split for do you think there's a way that we could sort of do that numerically so that you could make this kernel independent in some way? Yeah, so. Yeah, so yeah, that's a good question. So I've thought a little bit about it, and I don't have an easy way to do that. But my only comment is, although it's kernel dependent, the kernel split is a little bit different from, for example, the CRES spectral quadrature where the kernel split in the The kernel split in the crest case is all the way down to the parameter domain, whereas in this case, we're only splitting down to the geometric level. So we only have one over r here. And it makes it a little bit easier to derive formula for a variety of kernels. So, yeah, but like you said, Yeah, but like you said, it would be nice to avoid even that. Cool. Thank you. I hadn't appreciated that difference, so that's great. Great. Well, thanks very much, Bobby. So let's turn it over to, is it Curiel next? Yes, Curiel is next. 