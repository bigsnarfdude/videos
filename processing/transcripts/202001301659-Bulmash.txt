Thanks so much to the organizers for inviting me into this wonderful conference, and thank you to you all for sticking around for the very last talk on this marathon day. So today I'm going to be talking about getting type 2 fractons from defects in topological order. So this is going to be related to a talk that Kevin Slagel gave on Monday. This was a collaboration between Dave Avanov, Kevin Dahm, and myself. Than Dom and myself, which hopefully will be coming out relatively soon. So, let me just start with a few comments on type 2 fractons, since they haven't been a big focus of the conference. So, I'm using type 2 to mean that isolated excitations are created by operators with fractal support, and that no local operator can move any of the non-trivial point-like excitations here. And we know from the From the work of Ha and Bravi, that these have the potential to be excellent quantum memories, although not self-correcting, or not purely self-correcting quantum memorials. However, we have very few examples of type II fractons at the moment. There's several of Haas codes and the B code that came out of that, which will play a big role in this talk. And there's a construction from partons due to Halage and Shea. And then there's a few models. And then there's a few models that don't fit very cleanly into the type 2, type 1 framework, such as the Sierpinski model, which has fractal properties in plane, but has mobile charges out of plane, and the gauge bilayer Haas code, which has some non-abelian fractal-like fractons, but also has mobile particles and mobile string excitations inside of it. So why is it that we don't really have many examples of these? Have many examples of these? Well, I think part of the reason is that they're pretty hard to understand. And it's very hard to even understand why things are type 2. Sorry, when something is type 2, much less to understand the properties of type 2 model. The ground state degeneracy tends to be quite complicated. The wave function operator and local operator structure also is pretty complicated. So at the moment, to my knowledge, there's two main approaches to relate type 2 fractons to. To relate type II fractons to better understood systems, including gauging fractal subsystem symmetries of spin models, which is something that has been done by people in this room. And a recent paper from Albert Schmitz talking about distillation from subsystem SPTs. Now, one of the things that we were aiming to do was to have a construction that can relate to the subject. That can relate all types of fractons to topological quantum field theories: type 1, type 2, abelian, non-abelian. So there are many constructions, including these sorts of constructions, which can deal with some subset of these properties. But to my knowledge, there's no construction that can do all of these things, that can construct examples that have of all of these different properties. Properties. And so, what we were doing is using the defect construction, which is what I'll explain for the rest of the talk. So, it's actually known from some work by Dominic and Ryan Thorngren that defect networks are good for constructing crystalline SPTs. And so, this is a generalization of that sort of procedure, which uses non-invertible defect networks. And we're able to relate fracton order to topological order. Fracton order to topological order without driving any phase transitions. So you could compare this to the layer construction where you start from some topological order and then have to drive a phase transition to get into the fracton phase. And we are able to generate examples that are using this construction that are in all known classes of fracton order. So Kevin talked on Monday about generating x cubed from this construction. x cubed from this construction. There's some work that has not appeared in one of our talks, but it'll be in the paper looking at non-abelian fractons. And in this talk, I'm going to show how to get type II fractons from the defect network construction. So the example that I'm going to use, for reasons that'll become a little clearer later, is not HAAS A code. It's instead Haas B code. So since this is a bit of a lesser known So since this is a bit of a lesser known model in the community, though I think its existence is pretty well known, the details are not super well known, I'm going to talk about it in a little bit of detail before getting into the defect construction. So Haas qubit code, if you do entanglement renormalization, bifurcates into another copy of the qubit code and this B code. And the B code has the following Hamiltonian: it has a Hilbert space with four A Hilbert space with four spins on each site of the cubic lattice, and there's four different terms in the Hamiltonian, which I'm going to call A, B, C, and D. The A and B terms are X-type stabilizers, so just products of poly X's in various configurations. The details aren't super important for the moment. While the C and D stabilizers are just products of poly Z's. So in the ground, these all mutually commute. Now, these all mutually commute. In the ground state, they all have eigenvalue plus one. And there's four different types of excitations where each of these things has an eigenvalue of minus one. And all of them are fractons. So let's see how that comes about. So I'm going to just focus in on the a and b terms in the Hamiltonian, which are the x-type stabilizers, and those are excited by polyz operators. So what I'm going to do is just look at... So what I'm going to do is just look at what the local operator, polyz-type operators, do, what types of excitations they create. So suppose that we act on this site in the middle, this is just a site in the cubic lattice here with the poly operator 11ZZ. So that's just a polyz on the third and fourth spins. And what this does, you can just stare at this Hamiltonian and back this out, is it creates the following excitations. So on this cube, So on this cube of the cubic lattice, it flips the B term to have eigenvalue minus 1. On this cube, it gives you an A with an eigenvalue minus 1. And on this cube, it flips both the A and B terms in the Hamiltonian to have eigenvalue minus 1. Now, you can stare at this at a couple of other operators and see that you actually get very similar looking configurations. So this is if you apply poly Z on the fourth spin and on the third spin. Spin and on the third spin. And if you kind of stare at this for a little bit, what's happening here is that we're cyclically permuting these terms. So A moves to B over here, B moves over here, this AB excitation moves over here. And then you do it one more time. And of course, the product of these three operators is the identity, and the excitations all disappear as they should. So you'll also notice. So, you'll also notice that all of these excitations lie in a plane, despite the fact that these operators sit on sites. That's actually going to be very convenient for us later, for reasons that will become clear. But let me just take this and put this over to the side for the moment. Because I've shown you what two of the poly Z's on two of the spins do. There's still two spins left. And you can check that they give very similar configurations of local operators. Of local operators in different planes. So you can get this configuration by acting with this one, and cyclic permutations thereof by acting on the first two spins, and then some product of the various poly Z operators gives you the same type of excitation configuration in the third plane. And these are all of the local operators. They all create these types of excitations. So you... So, you don't get any obvious hopping operator from this. So, now let's see why these things are fractons. So, suppose that I'm just going to remind you of all of the operators that act in a single plane, and this is just what their local action is. And so, suppose that I act on some site with the 111z operator, which is here. So, what you can see is that. So, what you can see is that I can act with this operator on the site here, and that will cancel out this product of this cube here where both the a and b terms in the Hamiltonian are excited, at the cost of creating two additional excitations. But then I can do the same thing using this operator on this site to cancel out this B excitation here, and it just so happens that this. And it just so happens that this winds up canceling out another excitation conveniently for us, and we get wider separated fractons. And then you can keep iterating on this process, and what you get is a fractal-shaped operator, or an operator with fractal-looking support that has excitations only at its corners. And you'll notice that this configuration is exactly the same configuration that we could make locally, just the fractons are more widely separated. Are more widely separated. And if you stare at it for a while, you can convince yourself that these are the only processes that can move fractons around. You're not going to actually get any fracton hopping operators. So having reviewed, I've now finished giving you a brief idea of how Haas B code works, and all this local operator structure is going to be important for the defect construction. So I'm now going to For the defect construction. So I'm now going to move on to the defect construction. So I'll pause for a second if there are any questions about the B code itself. All right. So what is the defect construction? So the idea here is that we're going to have an ambient three-dimensional topological... Oh, sorry. Oh, yeah, sorry. The C the C term and D term look basically the same. They're just reflected. Sorry, they're if you do an inversion. If you do inversion and I think A maps to D and B maps to C, it's the same type of configurations, just inverted. Yeah, thanks. All right, so the idea behind the defect construction is the following. So we're going to take an ambient three-dimensional topological order and insert non-invertible defects into it. And so on Monday, the way that Kevin presented So on Monday, the way that Kevin presented the X cube model is taking 2D topological orders and inserting them into three dimensions into the 3D topological order with certain couplings. So I'm going to present a somewhat different perspective, which is perhaps a little more convenient for this particular application, trying to get a B code out, where I'm going to think of the defects as being like gap boundaries. So what this means. Like gap boundaries. So, what this means is that I've split space into little cells, which we're calling three strata. I've stratified space. These can have many, at a microscopic level, these could have many microscopic degrees of freedom, but I put one topological, 3D topological order in there. And then there's going to be a junction between two of these three strata at a two strata, some two-dimensional tile here. And we're going to put a gap boundary there. And we're going to put a gap boundary there. And then there's an intersection of four gap boundaries, these two strata, at a line, which is a one strata. And we're going to put a gap boundary between the gap boundaries, and so on down to the points. So let me just give a quick one slide. Oh, yeah, so the overview of the defect construction is the following. So on the three strata, we're going to put data, which is a 3 plus 1D topological order. And our choice of the 3 plus 1D topological order is going to change. 1D topological order is going to choose a set of excitations that we have to work with. The data on the two strata is going to be a choice of a gap boundary between two copies of this 3D topological order. And we're going to choose this to lower the point particle mobility, because if we didn't have any defect there, all of the point particles in the topological order could just move around freely, and we can't possibly have any fractons if point particles can, if all the point particles move around. Point particles move around. On the one strata, we're going to put a gapped boundary between gap boundaries, and this actually is going to set the local excitation structure of the model. And this is going to be very closely related to the operators that I was just, for the B code, it's going to be very closely related to all of those three cube setups that I was showing earlier, and I'll explain that. And on the zero strata, roughly speaking, we choose a point particle there. There. We're not going to worry about this for our examples. It doesn't play a significant, we have to make a choice there, but it doesn't play any significant. The choice we make doesn't really play an important role in the physics, so I'm not going to worry about that too much at the moment. So let me just briefly give a very short overview of gap boundaries of topological order. So in general, if you have some topological order, what you do at a gap boundary is condense. What you do at a gap boundary is condense some stuff. And so you make, you take objects which are topologically nontrivial, and you say that at the gap boundary, you can make them with a local operator. And you have to condense enough of them in the sense that you need to make what's called the Lagrangian algebra object. Doesn't matter for the purposes of this talk, but you have to condense enough objects to gap out the whole boundary. And the idea for defects is. The idea for defects is very similar. You can use a trick of folding two copies of topological order over to convert the problem of defects in topological order to a gapped boundary of a single topological order. But an example would be in the 2 plus 1D toric code. So if this is my Toric code and this is the boundary, in the bulk, I can only make E excitations in pairs, but on the surface, But on the surface, I can delete, or on the edge, I can delete an E excitation locally. So the E is condensed there. And it turns out that this is enough to make a gapped boundary to the vacuum. So now let me describe the defect construction for HaasB code. So what data am I going to put on the three strata, these cubes? I'm going to put an ambient bilayer 3D toric code. So what this means. Code. So, what this means is that the excitations inside a cube, or there's going to be four types of excitations inside a cube. One of them are point particles, which I'll layer the label, sorry, I will label the layers of this 3D Tor of code with A and B. That's intentionally suggested. So, in the bulk, I can create a pair of E's, and so far, those E's just need to stay inside this cube. Inside this cube. They can't move out of it so far. Can do the same thing for pairs of EB particles. They also can move around inside, and I haven't said if they can escape in any way for them to escape yet. Then there's also flux strains, which I'll call MA and MB. There's one for each layer. This thing costs energy proportional to its length. It can change in size, but also can't escape its Q. Escape, it's cute. So, why did I choose a 3D torque code? So, the reason is the following. So, what I'm going to think of is a single E inside one of these cubes as a fracton. And that's my aim, to show that in this construction, a single E inside a cube behaves like a fracton. Now, in X cube, there's only one type of fracton, so in the defect construction for there, as Kevin told us on Monday, And for there, as Kevin told us on Monday, but if you don't remember, just take my word for it, we just put a single 3D torque code in here because we only need one type of E. There's only one type of fracton. However, we have A and B fractons in the B code, pardon the overload of the letter B, and so what we're going to think of is that if there's a single EA inside this one of these cubes, there's an A fracton there, and if there's a single EB inside, there's a B fracton there. So that's why we chose. On there. So that's why we chose two copies of 3D Tor code. So now, having chosen my three-strata data, I now need to say what happens when two of these cubes meet each other. So what I'm going to choose is to condense the flux string excitations from both sides of this two strata. So what this means is that if I have an M flux string excitation here, I can move it to the boundary. Move it to the boundary, and then delete all of the stuff that's on the boundary. And so this flux string just ends at the boundary. And I'm going to do this on both sides, so same thing can happen here. And for both the A and B layers. It turns out that this is enough to gap out this boundary, and it actually means that the E particles can't move through this 2 strata whatsoever. And so what this has done is. Whatsoever. And so, what this has done is it's made it so that now it really is the case that these E's are stuck inside their cube and so they can't propagate freely. Which is why it's plausible that I can call them a fracton. But I still need to, oh, and yeah, so if I try to move that into the boundary, it can't move through it, can't condense, nothing of that sort. So now, I still need to tell you how. I still need to tell you how I actually can make the excitations that I know I can make in B code. Because it's not that I can't make any fractons. I can make fractons, but only in certain patterns. And this data is going to come from our data on the one strata. So what we're going to do is make a choice to condense certain bound states of four E particles on the one strata. And one of those configurations is this one. So what this means is that Is this one. So, what this means is that locally at this one strata in the middle here, I can create a set of the this particular set of four e particles and then move them away from the one strata. So these two are in the front cube on the left, this one is in the front cube on the right, this one's in the back cube on the right. And this is done using a string operator, which, like a pair of string operators, both of which are stuck onto this one strata here. Stuck onto this one strata here. Now, this set of excitations is very suggestively consistent with the effect of one of the local operators in the B code. In particular, I said that a single EA in a box is an A fracton. Well, and a single EB in a box is a B fracton. So I've chosen this condensation so that the objects I can create locally on this one strata Locally, on this one strata, are exactly the sort of excitations that I can create using local operators in the B code. In fact, I'm going to choose to condense three different sets of E particles at this one strata, each of which corresponds to a different local operator's action in the B code. And so in this way, the choice of data on the one strata specifies the On the one strata specifies the patterns in which we can create these fractons. So, in fact, you can create widely separated fractons in this defect network picture as well. You can take, so at each of these one strata here, there's one of these patterns of string operators that passes through it, and goals are chosen, and I've chosen all of these things very judiciously, so that all of the excitations. So that all of the excitations cancel out except at the corners. And so I've now created widely separated E-particles. And this is exactly analogous, or this maps exactly onto the statement that this particular funny pattern of operators in Haas B code creates a widely separated set of fractons of exactly this type. And actually, each one of these local operators in the B code. In the B code, maps exactly onto a local operator on one of the one strata in this diagram here. So it's a little hard to see, but some of these, for example, this one strata is empty. It has nothing running into it. That maps onto the fact that there's no operator here. And so these complicated networks of string operators is how we create widely separated fractons in the B code picture, or sorry, in the defect network picture. So it turns out that this is not enough. Condensing these sets of E's is not enough to gap out the one strata. We have to do some extra condensations on there, which come, which we're going, we could condense more E's, but that would mean that we could create more sets of fractons locally. And so we don't want to be doing that. So what we're going to do instead is do some condensations in the M sector on this one strata to make sure that this is a fully gapped Make sure that this is a fully gapped boundary so that we don't have any gapless degrees of freedom running around. Now, what I'm going to do is look at focus in on this one strata here, and let's call this the Z direction. I'm just going to draw these two strata here, just to get rid of a little bit of the data. And I'm going to look at this edge-on. So, this picture here, I'm looking at from the top in these pictures here. So, one of the things that I'm going to declare that I condense at this one strata, which is this, so this line looking from the top down is this dot, is an M flux string in this quadrant. So if you look back to the set of local operator, set of condensed excitations I had here, nothing at all, there was nothing I could do on this one strata to create. Nothing I can do on this one strata to create any E excitations in this back left corner. And so I actually want to just be able to create a flux string locally at this one strata without anything else. And then once I've created this locally here, I can grow it away from the one strata a bit if I so desire. And so this is something that I can create locally at the one strata. Locally at the one strata. However, in the other quadrants, I don't want to be able to condense those things. And in fact, choosing to condense this would be incompatible with the choice of E's that I've condensed on that one strata. So this cannot be created by a local operator at the one strata. There are several other things that are condensed. There's a list of, I think, five or six different generating configurations. I'm not going to show them all for you here because it's not. For you here, because it's not very enlightening. But for example, one of the configurations that you can create with a local operator is an A layer M string here and a B layer M string in this other quadrant. So after having specified all of these configurations, you can just, we've now fully specified the boundaries, the boundary conditions on the one strata. Now, all of this M stuff I haven't really explained. M stuff, I haven't really explained what it does, and I also haven't explained how to get the C and D type fractons from this construction. And so these, let me now turn to that. So imagine that I take one of these three strata and I create a flux loop in the middle of it. Now this costs some energy, but I can take this thing and move it out, and I can move it further out until it runs into the boundary. And so once it runs into the boundary, because these M excitations are... Boundary, because these M excitations are condensed on the boundary, I can just delete parts of this flux string on the boundary. And I can get a configuration that looks something like this. And then I can move these things, shrink all of those little arcs down to very small size right next to the one strata. So they cost very little energy. Now, each one costs very little energy. And now I can ask: can I create this little arc locally with? Locally, with at the one strata, with the stuff that I condensed there. And it turns out that on this corner, you can create this thing locally. So I can just go ahead and delete this little arc. But these other three things can't be deleted locally. And so what this means is that we're left over with three different, with excitations on each of these one strata, but there's no excitation left over here up to local operators. And my And my claim is that these are exactly the C and D type fractons that showed up in Haas Plan code. And one way to see this is that you can create a oh sorry, and the thing that creates this set of operator, sorry, this set of excitations is a membrane operator in the B layer, which is this blue square here. Now, you can ask, is this really a ask is this really a are these really the C and D type fractons and in fact you can make a membrane operator network in such a way that there's no excitations at any of the one strata here based on what's condensed in the M sector except at these three corners. And this pattern of operators maps precisely onto the pattern of operators that you would need to apply in the B code to create this widely separated set of C and D X. This widely separated set of C and D excitations. And so this really does produce something that behaves exactly the same way as a C and D type fracton from the B code. So I've now explained how in our defect construction, we can generate all of the excitations that map onto the excitations in the B code. And there's no other excitations to even think about here. I've exhausted everything that's present. That's present. So now let me just have some closing comments. So, first of all, why no A code? Yes? Can I ask a question first? What's happening to the non-vertical edges? The non-vertical edges. Ah, good. So you have to, you can run the same type of analysis based on the configurations that you can create in the vertical directions. And so you choose in an analogous fashion the boundary. Analogous fashion, the boundary conditions there. You condense three sets of four E's and a bunch of M's appropriately. Right, okay, then, okay, good. So I have another question, which is, maybe I'm just missing something, but like, so in the original model, if I remember right, all of the fractons were living on cubes, the original cubic lattice. Correct. But now the A and B fractons are living on cubes, but the C and D fractons are living on edges. That's right. They're sort of more edges than cubes. That's right. There's sort of more edges than cubes. That's right. Some kind of conf slightly confusing. So it turns out, I think it's a little messy to explain up here, so I'm happy to tell you the details offline. It turns out that you can associate, there's a very precise way in which you can associate excitations on three edges that all touch the same site to that site. And then you can associate each site to a cube. So there is, in fact, a mapping of that sort. And it also is used. That sort, and it also is used. That particular mapping is important in why I've chosen to call these C D and C D as opposed to rotating those excitation labels around. But the details are a little messy, so I can talk about that offline. All right. So, one of the big elephants in the room, why no A code? So, we are working on several possible ways to construct the A code at the moment, but let me just give you a flavor. But let me just give you a flavor for why it's more difficult. So, the locally created fracton configurations in the A code are naturally associated to sites of the cubic lattice. And there's no obvious connection to the one strata. And the one strata are really where we want to be looking to create, to locally create excitations. And this is contrasted to the B code, where despite the fact that in the B code, the operators actually live on That in the B code, the operators actually live on the sites. All the excitations really look like they live on this single one strata, or on the single edge of the cubic lattice. So it's very easy to decide on what the defect on the one strata is just by kind of staring at these pictures, where that's not as clear here. So that's the main obstruction, but there are several possibilities for how we might go about constructing the A code. And we really do think that it's more of a lack of creativity, to use Dave's phrase, than Than any intrinsic obstruction. So perhaps we just need a more complicated defect geometry. We could use some sort of icosahedral type lattice, something a little more complicated. We could also imagine doing some sort of coarse graining where a single cube of A code or maybe several cubes of A code have to relate to multiple three strata in the defect construction in some nontrivial way. And you could also Way. And you could also imagine using some extra auxiliary topological order such that you arrange such that none of its excitations really can move about, but those extra excitations constrain the way that you can create charges in such a way that you can actually make this as the appropriate charge configuration. So there's a few possibilities. We think at least one or two of them should work and are working on that. So with that in mind, let me just So, with that in mind, let me just, oh, yeah, and so as such, we generally think that all fracton phases should be describable by this defect construction, partly because it is, there are an enormous number of possibilities for, and it's a very, very general construction, and because it creates fracton phases of all of these different types. So, with that in mind, some of the speculative applications of this defect picture. So, we could get some nice wave functions. So, we could get some nice wave functions perhaps for more fracton orders. The type 2 fractons really don't have very nice wave function pictures that I'm aware of. So this could be a nice route because we know how to do wave function pictures for TQFTs. It's more plausible that we could use this for some sort of systematic classification. This is definitely a challenging route. In particular, it's important to have a more complete understanding of defects. Complete understanding of defects in 3D topological order if we're going to go down this route. You might also hope that this could inspire some sort of field-theoretic treatment for general fracton theories. There's some connections to the foliated field theory construction that some people in the room have constructed here. And perhaps we could also clarify the role of geometry in foliation, since the way that we choose to stratify space here seems to have some connection. Space here seems to have some connections to this question. And you could also imagine using this to look at gap boundaries of fracton orders, because we know, we hope to know in more generality what gap boundaries of topological orders look like. So with that, let me just leave you with the following conclusions: that the defect construction is very powerful and general, and it can construct fracton models of all types. And we conjecture that all fracton phases can be That all fracton phases can be realized as a defect construction, perhaps if chiral fracton phases exist, maybe as the boundary of some higher-dimensional defect construction, something of that sort. And it suggests that we can apply some TQFT machinery to understand fractons, but there's a fair bit of work that we still have to do in order to use this in any generality. So thank you very much. Questions? Last talk of the day, I know. Last talk of the conference. Well, if there's no other questions, let's thank Danny again. There's no other questions. Let's thank Danny again. And also thank the organizers for putting together such a great workshop.