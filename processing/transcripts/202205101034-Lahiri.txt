So, yeah, I'm Kshitej and this is a joint work with Agastya, Manish, and Abhihook. And it's about reconfiguring shortest paths in graphs. So, let me just start. Just a second. Yeah. Okay. So, we'll start off with a short story. So, this is a grad student in Princeton somewhere in the 1940s. And he's in his room. He's in his dorm room. Okay. And in one corner of the dorm room, there is some sugar. And in one corner of the dorm room, there is some sugar, and he has a bit of a sweet tooth. So, sugar is sweet in its purest form. Okay, and he's very happy. In the other corner of the room, there is an ant. And so, the grad student already has competition. Okay, so the ant doesn't know where the sugar is. So, the ant just sort of randomly goes around the room surveying to see if it finds anything interesting. And eventually, it lands upon the sugar. Okay, and then the grad student starts wondering: okay, that was a really long path, okay, like nowhere close to a shortest path. And he was curious that how do groups of ants travel in straight lines if this single ant couldn't get there in a straight line itself? So he had this question, but I guess he was busy with other things, so he could not answer it at that time. Later on, around 10 or 20 years later, he became a professor, and at that time, he was older, wiser, and he had. Was older, wiser, and he had some more time. I guess he was tenured. So, again, he was in a similar situation. There was sugar in one corner of the room, and there was an ant in the opposite corner. And this time, you know, he just thought, let me stand back and watch what happens. So, he stood back and he watched what happened. And as expected, as it had happened in the first thing, in the first instant, 10 years ago, the ant took a really long path because it doesn't know where the sugar is. Eventually, it gets there. And this time, what he did is he noted down the path. Time, what he did is he noted down the path with a piece of pencil, okay, and he made sure that the pencil mark does not affect the ant. That is, the ant cannot see the pencil mark, so the ant, the ant doesn't know that there is a pencil mark and it's just for his own reference. Okay, so good enough. Then the ant took the piece of sugar, it followed the exact same path that it came by, which suggested to the professor that the ant leaves behind some sort of a trail because it cannot see the pencil mark, it must leave some sort of chemicals, and those chemicals are. Chemicals and those chemicals are guiding the ant. Now, the ant goes back to its home and it informs its friends that there's some sugar over there. So, one of its friends comes out. Now, the trail left behind by the first ant is slightly weak. Some of the chemicals have evaporated. So, it roughly follows the trail. It does not follow the trail exactly. At some points, it takes a short jump. Like in this example, if you notice, what has happened is wherever there was where Wherever the ant notices that it has to follow the same path anyway, it might just take a short jump over there. So there are a couple of jumps: one over here, one over here, one over here. And this is roughly, this is a heuristic, obviously, is not a proper algorithm. But again, so then the next ant comes and the first hand's trail has almost vanished. The second hand's trail is fresh. And again, wherever it can take, it takes these short jumps. Okay. Then comes the fourth hand and it does something similar. The first hand's trail is completely evaporated and Completely evaporated, and the latest ant is the most fresh trail, and that's why it follows that. And you can see what is happening slowly by slowly. The every subsequent ant that is coming up, they are finding a shorter and a shorter path, and so on. They are doing this very inadvertently. They are just doing it very selfishly, but eventually they are building a shorter and shorter path. And finally, what happens is the path is a straight line, and now there is nothing more to optimize. So, every ant that comes after it just follows a straight path. Straight path. Okay. And yeah, so that was a story. And turns out this is actually a true story. So the student who grew up to be a professor was in fact a famous scientist and a Nobel laureate. Although the Nobel Prize he won was had nothing to do with ants or shortest paths. And if you are interested in more stories like this, you can read this book. Okay, so yeah, that was the story. So what did we learn from it? So the initial ant it just gave one path. It was not a shortest path. Was not a shortest path, but by modifying that path gradually, they came up with the shortest path. So, in the problem that we are going to study, it's called shortest path reconfiguration. We are given two shortest paths. Okay, so in the ants case, the first path need not be a shortest path, but we are given both a shortest path in a graph. And you want to gradually modify it, modify the first path to come to the second path. Okay. And we can do this by gradual, I mean you can only change one vertex at a time. So, let me show you an example. Let me show you an example. So, this is a path from S to T, that is S, V1, V2, V3, V4, V5, and T, the red path. Okay, so you can change one vertex on this path. So, you can change V3 to U3, and now this becomes your shortest path. Okay, so yeah, this problem has several applications. The most natural application is errouting traffic when you're renovating a road. So, when you're renovating one part of the road, you can't use that, you want to use another part. That you want to use another part, but now this part is renovated. You want to renovate another part, so then that part is blocked, and so on. So you can gradually modify it step by step. Okay. And obviously, this is mostly for planar networks because roads are generally planar. Okay. There's also rerouting networks in case of a node failure. So you have a telecom network, and if you look at the top view of the city, then each pole, each pole is a vertical telecom tower. It looks like a point in the top view. Looks like a point in the top view, and a disc covering it or a unit disc covering it is the range of the pole. And if two poles intersect, that is their range is matched, then there's an edge between them. So, this is a unit disk graph, and a similar application is here. The third one is the shipping container storage problem, and this is an application in circle graph. This is what the last one is what we'll study in today's talk. Okay, yeah, so more formally speaking, what is the SPR problem? It's the decision problem of you're given two paths. Problem of you're given two paths. Can you reconfigure one to the other? Okay, so here is an example. You have two paths P1 and P2 in the same graph, and you want to reconfigure P1 to P2. And as you can see in this example, you can do that. So at every step, you're only changing one vertex, and all the intermediate paths also have to be shortest paths. And in this manner, you can change it. So the general, the SPR question in general, is like, can you do this given any graph? You're given a graph G, and you're given You're given a graph G and you're given two paths P1 and P2 in this graph. And can you modify P1 to P2 in a series of steps? Okay, so this problem has been studied before. And here are some known works. So around a decade ago, it was shown that this is NP-hard. And note that I haven't said NP-complete because it's not trivial to see that it is an NP. So generally, what you would do is the NP certificate would be just a polynomial size certificate. A polynomial size certificate. But in this case, the trivial certificate doesn't work because there are examples, and in the same paper, they had shown this that two parts which are reconfigurable, but every sequence of reconfiguration between them is of exponential size. So the trivial certificate does not work, or rather, the natural certificate does not work. Okay. And turns out it is in fact P-space complete. Okay. And in the same paper, it was also shown that for specific graph classes like caudal graphs and cloth free graphs, this can be. Graphs and cloppy graphs, this can be solved in polynomial time, and in fact, later it was shown that even for planar graphs, it can be solved in polynomial. Okay, so our contribution is for circle graphs, as I mentioned earlier. In circle graphs, we provide like a complete characterization of all the shortest parts in the graph, and that's how we answer the question. We also solve some other special specific graph classes like Boolean hypercube, Big graph, circular graphs, and constant diameter graphs. We won't go through these. Diameter graph. We won't go through these during the talk, only we'll look at constant diameter graph. Okay, and we also study a more practical variant of SPR. So, in SPR or shortest path reconfiguration, what we do is we just change one vertex at a time, but this one is too restrictive for a more practical application. Why can you change only one vertex? Maybe you can change five vertices at a time, right? So, in that case, when k is equal to five, this becomes a five SPR problem. And we study it's this thing. We show that it is p-space complete even for. thing we show that it is p-space complete even for very specific graph classes and we in fact the kspr problem also shows for some spr problems it is p-space complete okay and we also plot some graphs this we look at this later if there is time okay yeah so let's start off with a small puzzle it's something i expect you guys to answer so you all know what's the diameter of a graph it's uh so these are undirected graphs so there are there are no edge weights or anything There are no edge weights or anything, or rather, all the edge weights are one. So the diameter of the graph is just the distance between the two farthest apart vertices. Okay. And can you tell me which of these three graph classes has bounded diameter or rather constant diameter? Always. And assume the graphs are connected, otherwise the diameter is infinity. Yeah. So can anyone answer this? It's not very hard. I can't see the chat. I don't know if someone has written the chat. Okay. Okay, I'll wait a few more seconds and then I'll give the answer. Or you can just take a shot at it. Split graphs and cobipartite graphs, right? Yeah, yeah, that's right. Yeah, so yeah, so the reason I'm going through the graph diameter is because so split graphs and cobi-parted graphs have bounded diameter or diameter at most three. And it turns out for this very reason, SPR can be solved in. Very reason SPR can be solved in polynomial time for split graphs and co-biotiparted graph, and for bipartite graph, it's p-space complete. Okay, so yeah, so um, so these are the definitions. So, a bipartite graph, all of you know, like its vertex set can be partitioned into two independent sets, okay. In a split graph, it's uh the vertex set can be partitioned into an independent set and a clique, okay. And in a co-biparted graph, it can be partitioned into two cliques, as you can see here, okay, and. See here, okay, and um, yeah, so um, turns out uh, split graphs and co-bipartite graphs have constant diameter, and bipartite graphs can have like n minus one also because that's like as bad as it can get. Okay. Um, and the reason is this: so suppose you have two vertices in a co-bipartite graph, okay. Now, since the graph is connected, there are two vertices on the left. There is one vertex on the left and one vertex on the right, which is connected by an edge, and because the left And because the left one is a clique, these two have an edge, and the right one is a clique, these two have an edge. So its diameter is atmosphere. For a split graph, the worst case is when both the vertices are on the independent set size. So since the graph is connected, there is an edge here. Since it's connected, there's an edge here. And these two are, this is part of a clique. So there's an edge here. Okay. And yeah, for bipartite graph, the worst case is just a path which has diameter n minus one. Okay. Yeah. So we'll quickly. Yeah, so we'll quickly look at these proofs also and give you some idea about what it goes through. So, for general graphs, so why is bipartite graph P-space complete? Because general graphs, it's P-space complete. So, you take a general graph, you start from the vertex S and just construct the layered representation. Okay, so all edges are either between constitutive layers or there are edges between two vertices in the same layer. Okay, so just delete all intra-layer edges because two vertices in the same layer, that edge cannot be part. Vertices in the same layer, that edge cannot be part of a shortest path from S to T. So we delete them. And now the resulting graph is bipartite. Okay, so alternate layers, odd layers are one partition, or even layers are the other partition. Okay. And every path in this graph is every ST shortest path in this graph is a ST shortest path in the original graph. Okay. And let me also quickly prove this that for constant diameter graphs, you can solve SPR in polynomial time. So you're given an n-vertex graph, okay, and diameter is some constant, say C. Okay, and diameter is some constant, say c. Okay, so for every path, every shortest path, you create a vertex. Okay, so there is one vertex for each shortest path, and there is an edge between two vertices. If you can go from one to the between two paths, if you can go from one to the other with a single gene, okay. So, for example, there is an edge between P1 and P2, which means that if you change just one vertex in P1, you can go to P2 and so on. Okay, now notice that the number of vertices in this graph is at The number of vertices in this graph is at most n to the c, right? Because its diameter is at most c. So, and that's it. Just study the reachability problem on this graph that is the same as the reef configuration problem. So, P1 and P7, for example, they are reachable. So, P1 can be reconfigured to P7. However, P1 and T8 are not reachable and they cannot be reconfigured. So, I hope by now everyone has a fair idea of SPR and what is shortest path-free configurability. Configurability. Okay. And this is our main result. So we study SPR for circle graphs. So what is a circle graph? So given a circle with some chords, here you have a circle with five chords in it. Okay. And every vertex is a chord. So since there are five chords, there are five vertices in this graph. And there is an edge between two vertices if and only if those chords intersect. So A and C, the orange chord and the red chord intersect. So there's an edge between A and C. And similarly, A and C, and similarly, A and E, the red and the green chord they do not intersect, hence, there is no edge between A and E. Okay, so this is the graph. Um, so I won't go through the proof, but I'll explain what our basic idea is. So, here you're given a graph and a circle graph. I've just expanded it into an ellipse, okay? So, ellipse graphs are the same as circle graphs, and um, you want to know. So, uh, here I've taken a path of length six, okay. Of length six, okay. Paths of length two or length three, you can just trivially solve them like by brute force, okay. So, say paths are of length three or more, okay. And let's construct them one by one. So, first you have this chord S, then you put the chord V1, then you put the chord V2, V3, V4, V5, and then T. Okay, so I will label these regions. So, the region between S and T, I'll revert this arc on top of it. So, note that these two quadrants. On top of it, so note that these two chords divide the circle or rather the ellipse into four arcs. This arc, I'll label it as T standing for top, this I'll label it as B standing for bottom, and the remaining two words, I'll just label them star, okay, star and star. And it'll be clear soon why I'm doing this labeling, okay? So the first chord, it is V1, okay. And if you notice, one end of the chord is inaccessible, sort of if you want to get to T, you cannot access V1 because then you'll have to intersect S again. To intersect S again, and the next vertex on the path that is v2 can never intersect s because it's the shortest path. So, a person starting from v1 it goes from one endpoint of v1 to the other endpoint. So, we label this chord as this direction. Okay, it seems a bit weird to put direction on vertices because a chord is a vertex, but here it is helpful to us. So, we will label it in this, we put the arrow in this direction, okay. And we label this chord as star B because it starts from the star region and ends at the From the star region and ends at the bottom, so it's star B. Okay, similarly, now the second chord is in this inaccessible region. Okay, so we go over here to V2 and we label it. The arrow is in this direction. So it is BT. So it starts from the bottom and goes to the top. The next chord, it starts from V3 and goes to the end of V3, and both are at the top. So it is a TT. Okay. Next one starts at the top and goes to the bottom. So again, it's a TB, as you can see here. TB, as you can see here, and the last one is starts from the bottom, okay, and goes to the star region. So it's a B star. So the label of this path is star B B T T T T B B star. Okay. And this labeling scheme is important as I will explain later. Okay. And yeah, this is basically how your path goes if like a person is going through it. And it is kind of crucial that when you go, when this green thing goes into the top. Green thing it goes into the top and the bottom, it is going in the reverse direction of the path. Notice that it's always going backwards, right? So it goes along the red chord, okay? Then along B, it goes backwards, then it goes up, then along T it goes backwards, again backwards, again backwards, and then it reaches down. Okay. And why is this labeling important is because of our main theorem. So after we label each path, so you're given two paths in the graph, P1 and P2, and maybe even more, you label each path according to these arrow notes. You label each path according to these arrow notations, what I just described, and two paths may have the same label, two different paths can have the same label. In this case, as you can see, paths P1 and P2 have the same label, okay, but P3 has a different label, okay. And this is our main theorem. Two shortest paths in a circle graph can be reconfigured if and only if the two paths have the same label. That's it. So just look at the labels of the two paths. If they are the same output, yes. Okay, they have to be the exact same label. Okay, they have to be the exact same label. Output, yes. If they are not the same label, output no. Okay, so and it turns out we can also obtain the reconfiguration sequence in polynomial time. Yeah, okay, so this is yeah, so this is basically this is it. This is our main theorem. Before ending, let me also describe one more result. So we generalize SPR to K SPR, right? So in SPR, what we do, we change only one vertex at a time of the given path at each step. Of the given path at each step in K SPR, you change at most K vertices at a time. Okay, so here is an example of two SPR. So here you have these two vertices and you change to these two vertices to get this new path. Okay, so yeah, so we'll show that for K greater than equal to 2, K S P R is P space complete, even for a restricted graph class called line graph. So what is a line graph? Given a graph, so here you have a graph on five vertices. Okay. Okay, uh, you each of these edges is labeled by a green color, so here you can see each edge is labeled. Now, the edges become the vertices. Okay, so these become the vertices, and you connect two vertices if and only if those two corresponding edges share a vertex. Okay, so in this example, for like the edge one, two and the edge one, three, it shares the vertex one. So there is a edge between one, two and one, three, and so on. Okay, so this is this type of graph is called a Okay, so this is this type of graph is called a line graph. Okay, so again, I'll just give the proof idea. So we know that for line graphs, the normal SPR problem or just one SPR problem can be solved in polynomial time. And we'll show that as soon as you go from one to two, it becomes P-space complete for line graphs. And in fact, we'll show that this is true for all constants greater than equal to two. So, okay, ignore what is written on the right. Okay, ignore what is written on the right for now. Just look at the diagram. So, in one SPR, what you would do is take this vertex, change it to this vertex, and then go through. Right now, let me define an R subdivision. So, an R subdivision means adding R new vertices on a single edge. Okay, so here I'll take R equal to 2 and I'll do a 2 subdivision. So, notice that for this edge here and for this edge here, I have done a two subdivision. I've added two new vertices. Now, you can no longer perform one SPR, but you can perform. Longer perform one SPR, but you can perform three SPR. So if you change these three vertices, you get this new path. Okay, so because I did a two subdivision, I could do a three SPR. And in general, if I could do an R subdivision, then I could do a R plus one SPR. Okay. Now I want to convert this to a line graph. So now notice that the red thing, they are the vertices. So there is an edge between this and this, labeled in green. Then there is an edge here, an edge here. Then there is an edge here, an edge here, another edge here, and another edge here. Okay, and similarly at the top. Okay, now you replace each edge by a vertex, and now note that you have to change four vertices in the middle, right? So because it was a three SPR in the original graph, now it becomes a four SPR on the line graph. So it again increases by one. So R plus one SPR on the original graph becomes an R plus two SPR on the line graph. Okay. And this means, so suppose you're given a K and you want a K SPR on the line graph, just reverse engineering. line graph just reverse engineering the k spr on the line graph means k minus one spr on the original graph which means a k minus two subdivision of the original graph and this is why this only works for k greater than equal to two because otherwise you cannot do k minus two okay right um so yeah basically the proof just goes like this somebody gives you a graph and these are say the two paths now this is just a one spr problem you can see the first path goes like this and the second path goes like this so this is just a one spr what you do now uh What you do now, uh, fix k equal to 5. Okay, so we'll do a k minus 2 subdivision, so we'll do a 3 subdivision of alternate edges. So, this the edge between layer 0 and layer 1, we are subdividing it. All edges between 1 and 2, we leave it as it is. Then again, between 2 and 3, we subdivide it. Then 3 and 4, we do it as and so on, just alternate errors. Okay, we do a three subdivision. Now, you replace the edges by you do the line graph thing, okay? Edges by vertices, vertices by edges, and it Vertica biages, and it turns out that SPR on the original graph is equivalent to K SPR on this new line graph. And yeah, that's it. So that's what I wanted to talk about. And yeah, just before ending, let me just show you a few plots. So this we did just for fun. So we wanted to know like, how does the complexity of K SPR vary with K, right? sphere vary with k right so suppose k is a constant then we already proved that it is p space complete as you can see once k becomes n by 2 okay when k becomes really close to n then this becomes polynomial time and intuitively the reason is like because you're allowed to change n by 2 vertices on a path you have a lot of freedom and you can just uh like change almost the entire path in one or two steps okay uh also we wanted to study like uh what is the maximum possible distance between s and t Maximum possible distance between S and T with respect to the maximum number of shortest paths that the graph can have. Okay, so it increases as you would normally expect. It increases as the distance between S and T increases. Towards the end, it decreases because if the distance between S and T is so large, like so close to N, obviously what that means is that most of the vertices in the graph are on the path itself. So there are very few other paths. And that's why it just decreases towards n. Okay, yeah. So Okay, yeah, so before ending, I would just like to state some few open questions. So, maybe you can one can also do some experimental things because in the paper that we wrote, we had a lot of like practical applications, but no one has actually done it. So, and these are all theoretical results. So, maybe there is something to be gained from that. Yeah, so we also want to know that, so we have these polynomial time algorithms, but every graph class that you have, you have a separate algorithm. Class that you have, you have a separate algorithm for it. I mean, can't we have just like one algorithm like based on some parameter like tree with? Okay, maybe even parameterized. And what we really wanted to solve was SPR for unit disk graphs. And we don't even have an approximation algorithm for it so far. And that is that'll be a really good open question to solve. Again, so if you want to have parameterized complexity, what is your parameter? Is your parameter the distance between the two, like the distance between SNT, or is it something else? We don't know. Is it something else? We don't know. Uh, yeah, so the ants example, and what ants are doing, they're actually computing shortest paths, whereas we are given two shortest paths. So, can we use some ideas from here to compute shortest paths? And finally, in reconfiguration, what we do, we let the whole path stay as it is, and we just change one vertex on it. But maybe once you have access to a new vertex, you can hop onto another already existing path. So, maybe by using this hop strategy, you can come up with a new variant of the configurable. New variant of the configurability, and maybe you can solve that more efficiently. Okay, so yeah, thank you very much, and I'll stop here. Thanks. So, thanks a lot.