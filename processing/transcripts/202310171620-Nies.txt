All right, this is on joint work with Joseph Miller, Stefan Lemp, and Maria Soskova. The paper has just appeared, so I thought that was a good occasion to give a talk about this work that actually dates back to 2019. So just pre and during COVID, it was finished. Finished. So it's a bit of going back to the roots of computability, just sets of natural numbers and their complexity. But with a twist, it makes a nice, I think, connection to something from set theory, namely cardinal characteristics. And it works by analogy. So let me tell you what this connection is. What is the connection? First, so there's been quite a bit of work on the connection between cardinal characteristics and computability. Mainly so far it was based on characteristics defined via relations, say, on the functions on omega. So, and here we look at different ones and see what their analogs are in computer. And see what their analogs are in computability. Generally, a cardinal characteristics of the continuum, people sometimes say a bit silly, but that's what I say. So these are natural cardinals that tell you how far the set theoretic universe is from satisfying CH. So these cardinals are all at most 2 to the omega and greater than omega. So if CH holds, they're all equal to. Holes, they are all equal to 2 to the LF0. Probably the easiest to explain and best known is B and also D. So those are based on the relation of eventual domination between functions on omega. So g of n is greater or equal to f of n for sufficiently large n. The bounding number, which I actually The bounding number, which I actually prefer to call the unbounding number, b, the least size of a set of functions that is not dominated by a single function. So the set is so big that no single function can dominate all those. So such a set is, of course, uncountable. And well, so two to the LF0 is certainly enough, but the question is, how low can I get and still have? Low, can I get and still have such a set that cannot be bounded by a single function? Dual, the dominating number is the least size of a set of functions, so that each function is dominated by one in the set. So such a set, of course, cannot be dominated by a single function. Let's just take that function plus one, and therefore b is at most d so. So here's a different approach where you just look at ad hoc properties defined using subclasses of the infinite sets of omega, infinite subsets of omega. So far, just look again, we were based on relations, and there is really a uniform way to get from relations to dual pairs of cardinal characteristics and group rate. Ruprecht and then Brentle book Selvin and me in a 2014 paper, and later many others tried to find a mechanism to always translate such relations and their cardinals into properties, complexity properties in computability theory. So that works because it's based on relations, but for I talk properties like this. I talk properties like this, it doesn't work quite as well. So, we actually have to think what the analogs should reasonably be. So, omega, this thing here denotes infinite subsets of omega, as in set theory. So, we look at characteristics that are based on the size of subsets of omega to the omega, where the relation is almost equality. Relation is almost equality and sometimes almost inclusion. So the almost disjointness number A is the least size of a maximal almost disjoint family of subsets. So it should really be called a maximum almost disjointness number, but that's what is called A. You can build a method and that's all. Can build another set that's almost disjoint from every given set. Got it? So the least size of an maximal almost disjoint collection must be, cannot be less than B. Any questions so far? Okay, here's another one: the two rider, the ultra filter, and tower numbers, which are And tower numbers, which are domain numbers I'm addressing in this talk. So we lost for about a minute because we had some connection problems here with Wi-Fi. Can you please go back to the slide and maybe say a few more words? Because otherwise, it's difficult to follow. Thank you. Which one? This one? No, the next one. Yeah. Okay. So here I was saying that sometimes there are cardinal characteristics based on a talk property. Characteristics based on ad hoc properties, not just on binary relations. For instance, the almost disjointness number. How big is the size of a set of subsets of omega to the omega so that I can't add another set and keep it almost disjoint? So here's the definition. This is all familiar from algebra. Is all familiar from algebra, like a basis, a maximum linear independent set, is something like that, but for disjointness. And then I just explained a bit of the standard proof that B, the unbounding number is at most A. If a set of infinite subsets of omega is size less than B, each set is turned into a function and the dominating function for all these. Dominating function for all these functions then leads to another set that's almost disjoint from all the given ones. This is one example how ZFC proofs work. So if you have two characteristics, first you try to find out if in the usual set theory you can prove relations between them. And if not, well you usually try to Well, you usually try to show it's consistent that they are separated because, of course, it's consistent that they're all equal via CH. So, the best you can hope for is make some model where they are different. And that leads to complicated iterating forcing constructions where people like John Grandley are experts. So, here's another one: the ultrafilter num with the least size of sets with upward closure. That's a free ultra filter on omega. Ultra filter on omega and the tower number is the least size of a linearly ordered subset, so I that I can't put a new element below all the given ones. The tower grows downward and I want it to be maximum. So these are UNT. Sukhob has summarized the non-relations in a short Relations in a short survey paper 2018. I've taken this diagram here actually without his permission. Sorry for that. At least I'm saying it. So here are lots of cardinal characteristics. The paper is really about the pretty famous equality of P, the intersection number and T, which Shelai Mayaris proved back then. So sometimes there are surprising equalities, but more often. But more often than not, things just split apart consistently. So, here's a few more numbers. I haven't mentioned R and S, the unreaping and splitting numbers. Okay, Robert studied in general terms the analogs and computability. But actually, listen, aren't as were first studied in our proceedings of the LC paper, the analogues and computability. The analogs and computability of those were studied. And for many other numbers, there are now papers also studying the analogs. For instance, E is the escaping number of Brent and Schella and Valverde and Tweety have studied it and made an Aval paper out of that that appeared two years ago. So E can be found here. So the main ones we're talking about are well, U. Well, U here and T down there, and also A, this one. So I'll tell you what analogs of those are in computability, and then lots of things will be equal. A and T are actually equal now. I also look at I, the independence number, and show it equals U in computability. All right, that's the plan. So here's some. The plan. So, here's some notation. First of all, in computability, how should I talk about collections of sets? So, you have to make a choice. In the paper, the JSL paper, we actually do all this for general countable Boolean algebras of sets, though mainly we think of the computable sets. And there, but later we go also to k-trivial sets. Later, we go also to k-trivial sets and a bit to primitive recursive sets. So, the way to represent a collection is by looking at columns. So, I have one set, but I see the collection of columns as a collection of sets I'm interested in. So it's defined like this. Usually, F super n in brackets is the notation, but we abbreviate that to Fn. Abbreviate that to Fn. So the basic objects are collections of infinite computable sets under almost inclusion, and I encode them by a single set F so that the collection is the set of columns. Okay. I think that's a reasonable way to do it. So all these sets F could be complicated, but all the columns will be complicated. But all the columns will be computable. And now I compare them using Medvedev and sometimes Muchnik reducibility. So recall that a mass problem is quite generally a set of functions on the natural numbers. And the encoded collections of computable sets will be seen as mass problems. Mass problems. So I actually take the characteristic functions of the encoding sets f. So I have three levels here. I have just the basic objects, computable sets, then collections of them given by single sets, but via their columns. And then I look at properties of such collections, and those are my mass problems, such as the almost disjoint F or whatever the characteristic was. The characteristic was. So recall that the complexity of mass problems is compared via Muchnik and the stronger Medvellev reducibility, which I define here. C is as strongly below D if there's some Turing function of phi, so that whenever x is in D, then phi x is in C. Phi x is defined and in C. Is defined and in C. Any solution to the problem D leads to a solution of the problem C in a uniform way. So the expectation or question perhaps is whether ZFC relations of cardinal characteristics correspond to reductions between the analogues in computability. Okay, that's what I have to study. And I'll start with A and T, the almost disjoint sets and the maximum towers. Okay, so what is A? First of all, I often use the terminology that really refers to the collection directly. The collection directly for a set F. Don't get confused by that. For instance, I say F is almost disjoint if well the collection is. So each Fn is infinite computable, and for any n equals K, Fn and F K have finite intersection. So now the analog of the almost disjointness number is the mass problem A. Is the mass problem A. So it's all the sets F so that the collection Fn is the maximal almost disjoint family for the computable sets. So what's that mean? Well, it's almost disjoint. And if I give you another infinite computable set, R, it has infinite intersection with one of the Fn's. I can't add it as another column. Can't add it as another column. So you can work it out yourself in your head that no MAD set F is computable. Can you just stop a moment, try to do it? Add a bit of water. Right, if f is computable, I can make an increasing sequence the case element in fn and that will be almost disjoint from all of the columns. So I've made another one. So f clearly cannot be computable. Great. And now here's a parallel problem, the maximum towers. It's really here a notational change. Really, here a notational change only, but these are easier to handle in constructions. So, a tower is a collection so that the next thing is almost included in the previous one and infinitely many elements get dropped. And now the analog of T is the mass problem script T of collections of sets G so that the columns form a tower that's maximal in the computable set. Maximal in the computable sets. So I cannot put another computable set below all of them. So for each infinite computable set, R is not star contained in some GN. So what I said that A and T are equivalent has a formal meaning. They are Medvedev equivalent in the strongest possible sense. You can just define the functionals directly. Directly, it's easy, but let me do it so you get the notation right. So, for a below t, I have the diff functional. So, diff simply has as columns all the differences. If g is maximal tower, then diff of g is mad, right? Because if I take an infinite computable r. take an infinite computable R, then it's R with our G N is infinite for some n. So that means R must be R must be infinite on some Fi that's less than, where I is less than N. It has to go somewhere. The genes are decreasing, so R has to, has an infinite amount of numbers outside Gn, so in the first n of i's. The first NFIs. And similarly, T is below A by the functional CP, which in some sense complements G N is N without the union of the first N many F's. If F is almost disjoint and G is a tower and F is MLD, then G is the maximal tower. Okay, I have a little noise problem here. Just give me a moment. One second. Need to get my headphones. Think of any questions you may have.  Let's look at the weirdness. At this moment, there's some music outside. I need to get right so you don't need to. I mean, this isn't bother. Okay, it seems. Okay, it seems to have stopped. You couldn't heal it anyway, so I mean, you can go to meeting. You can continue. Yeah, okay, I'll continue. Any questions? Use chat. So here's now the first substantial result. T is S below non-low. So if I give you a non-low set, I can compute. On low set, I can compute uniformly a maximal tower from it. So the proof is deceptively short, but some people find it confusing like this. So I have to define the Turing functional phi for the med varied reduction. And I do it as follows. Gn, the nth column, is the axis. X's, which are strings, but sort of as numbers, so that n is less than or equal to their length, and Z prime at stage S up to n is equal to X up to n. Can you picture it? So here's the string up to n. I mean, the initial segment up to n, I go all the way down to the length of s. Of S and computes Z prime at stage S. I mean, I well, I see what Z prime is doing at stage S. I have Z as an oracle after all, so I can do that. And I see if the first n bits coincide with X. If so, I put X into G N. So it's quite clear that, well, by definition, Gn plus one is. By definition, gn plus one is star included in g n, and the difference is infinite. Right, because each time each time I look at another bit when I increase n, since z prime settles up to n, eventually it will always be looking at the same bits. So the d. bits so the g n is computable and finally if i have an infinite subset i mean if i have an infinite set that's almost included in each g n then i can use that to compute z prime in the limit because i just have to look at strings x and r lengths greater than k and output their value eventually this Their value. Eventually, this will converge to z prime of k simply because I take the length of x as the state, and eventually that will be right. R is infinite, so this limit makes sense. So, by the limit lemma, z prime is below r prime. And that means if these non-lemmels are lemma, And that means if z is non-low, then r cannot be computable. And that's what we needed for asserting that phi z is a maximum tower. There's no computable infinite set star included in each of the g n's. Okay, sorry. All right, so each if you can't compute the maximal tower, you must be low. Maximal tower, you must be low. That's what it says. And now let's see how to build maximally almost disjoint sets. Now in the CE setting, there's just a finitary construction doing that, akin to really post-simple set. It's very easy. And it works with permitting. So for each non-computable CE set A, there is the CE maximum almost disjoint set or collection. Set or collection F below it. So, yeah, there's a bit of techniques to ensure that each column is infinite, but basically you could ignore this for a moment and think of VE as being WE. So, and then S is really equal to F. In general, you have to devote. In general, you have to devote one column to be make the E set infinite. So the requirement is if the requirements are if V E without a union, S i is infinite, where I is less than N. And what's N? N is the pair of E and K. If all is holds, then I want S E intersect V E to be at least K in size. So if at stage S this has already happened, we see P and S. Already happened, we see Pn is satisfied, and in the construction, I look at each n where Pn is not satisfied, and there's a candidate, meaning there's an X in this bigger than the previous in that column, and also X is at least 2n. That's similar to making postset co-infinite, and it's needed in a verification. So, if I have an X like that and also A permits, then I. X like that and also A permits, then I throw the pair XE into S. So it's easy to verify that the set I make must be maximally almost disjoint. Do you see it? Basically, for each E, it has size at least K on V E because Um well you look at the SIs and if it hasn't happened so far, you can ensure it by meeting the requirements. Anyway, it's a short verification. So we have lots of MAD sets and they're all incomputable. And now let's look as a bit of a sight at the complexity of oracles that compute no maximum. That compute no maximally almost disjoint. First, let's note that the indices of the columns are hard to compute. Recall what the characteristic index for m is: it's just an index for the characteristic function like this. So, if a is maximally almost disjoint, then even zero. Almost disjoint, then even 0' cannot compute from n a characteristic index for fn. That's just the limit lemma again. If otherwise, there would be a computable function f so that this here is the characteristic function of fn. So eventually if f is right, and then I can well modify it to get a computable maximally almost disjoint set. Almost disjoint set, which is impossible. So, f hat, the new set, is defined as follows. If I'm given nx, I look at the next s where this is defined and then follow its recommendation. F hat is computable, but for each column, f hat n and fn coincide almost. So, F hat is also mad. Sorry, maximally almost disjoint. And that's impossible as we've just observed. Okay, so the indices for the columns are hard to compute, and that's what goes in the definition of a complexity property that sits pretty low, but has enough examples. But has enough examples, and that is worth further study. That property we call L index-gasable if, well, this property holds. Whenever phi L is computable, then zero prime can compute from EN index for its characteristic function. Okay, it's the opposite of what I had before. So the index guessable means the index is for the columns. For the columns, if the columns are computable, can be obtained using zero prime. So it means in formulas, if phi L is computable, then Phi L is phi gamma of zero prime and E for some fixed gamma. So you can directly prove that index guessability implies lowness, which also follows from what I've said before, right? That a non-low computes the maximum. Low computes a maximumly almost disjoint. And that cannot be index guessable. So you can also prove directly that this property implies lowness. And well, as I said, no index guessable computes an MAD set. So this property is incompatible with being CE outside computable because by permitting every CE computes MAD set. So I have two. Set. So I have two subclasses. Well, I have the low C sets and I have the index guessable sets, and their intersection is zero prime. So you may ask, what is in this class? Well, any delta to one generic. Here's the definition again. So every delta to one generic is index guessable. Proof is easy. Well, one generic means meets every Generic means meets every sigma one set that's dense along it. So that means this sigma one set here cannot be dense along L. If F is computable, this thing is sigma one, right? The tau so that for some p, phi e disagrees from f. So where is the index of a Turing function? Where E is the index of a Turing functional. So for each E, this is not dense along L. And now, since L is delta 2, I know L up to any finite piece. So I can compute the least tau prefix of L using L0 prime, so that there's no phi splitting above that tor. And that is an index for Xi F. X for ψ f, the characteristic function of f. Right? There's no phase splitting above, so take any value, it must be f. That's how you get the index. So every delta to one generic is index guessable. So we have a suite of properties with implications all inside low. Quite a bit is known about this class here. Christine Hort proved it's down at closed, and Sleiman Solovey showed using Hort's result that it coincides with loneliness for X learning, or sometimes called EX trivial. We don't know if these are different, perhaps these results can be used. We also don't know whether index guessable. We also don't know whether index guessable is different from compute snow MAD, but the proof suggests it is because here we don't use the whole power of index guessable. We only use a bit of it. However, the last error cannot be reversed because of the non-computable CE sets. So a low C set sits here but not there. Yeah, so I have to. Yeah, so I've been thinking about more separating these properties in Singapore in June, but so far no progress. All right, so that's all about A and T. And now the last part of the talk will talk about the mass problem U. Will talk about the mass problem u, which is an analog of the ultrafilter number. So, how should I define this? Remember, ultrafilter number was the least set, least size of an ultrafilter base. So, the output closure is a non-principal ultrafilter. So, here we define those as linear bases. So, they are also towers, just made more sense. More sense. So the mass problem U consists of the sets F, so that, as usual, each Fn is computable, Fn plus one star included in Fn, and the difference is infinite, i.e. F is a tower. But now the stronger property for each computable set R, either Fn is in R or Fn is in R complement. So the ultra part in ultra filter. Of course, that's also maximal tower then. So, if f is of this kind, we call it an ultrafilter base within the computable sets. All right, as I said, u is contained in t, so trivially by identity reduction, u is meant valve above t. But I'll show you it's quite a bit higher. In fact, it corresponds to high. First, here's an example out of old-fashioned RE sets under inclusion. So if you learned recursion theory, you may remember an R maximal set is one where for each computable set, C, either the union with C or the union of its complement with C is co-finite. With C is co-finite and C is co-infinite and CE. So that's an R maximal set. So that means the computable sets are so that the co-finite alternative holes form an alter filter in the computable sets. And now I can make a zero-double alter filter. Zero double ultra filter base out of this because given R, okay, first I can see is it really an index for a computable set, the index I have there. But if so, zero double suffices. I can decide which of the two is cofinite, because cofinite is sigma three. And then I can just basically take intersections of the Intersections of the ones where it's co-finite and also make sure it goes down infinitely often and at each step to get an ultrafilter base F trying below zero double. All right, so that's a bit poor maybe you think. Can we get any lower? I will get there. In fact, I'll make a COCE one later. But let's start a bit modestly and actually looking at the lower bound. So unlike the maximal towers, these guys cannot be computably dominated. Meaning they're yeah. So the hyperimmune-free, they cannot be hyperimmune-free, which isn't the case for the maximal towers, because of course there's a non-low hyperimmune-free set. So that means some maximal tower fails to compute an ultra-filter base. It's a stricter property to be an ultrafilter base. So how do we see that? Well, using F as an order. Using f as an oracle, define g to be the least number. g of n is the least number, at least n in the intersection of the first n fi's. g is below f. If there's a computable function p always above g, I can basically iterate it starting from one. And that's a computable sequence. And now I take E as the collection of all even intervals given. Of all even intervals given by that sequence. So always from n to i to n to i plus 1, excluding the n to i plus 1. So that set is computable because I omit every other and every interval contains something of the intersection of the first almost all f i's. fn is not contained in e and fn is also not star contained in e. Is also not star contained in E bar for each end. So that contradicts the definition of ultrafilter base, since E is computable. The ultrafilter generated doesn't make up its mind about E. All right, so that's the proof, but in fact, it's highness, so it's much better. So, first, I tell you how to deal. First, I tell you how to deal with highness using mass problems. So, well, I use the dominating functions, of course, the mass problem of dominating functions, which means dominates each computable function and for technical reasons also never below the input. So, also let TOT or TOG be the indices of total. Of total phi E's. F is high just if the tot is doing below F prime. That's basic like source style recursion theory. The approximations to tort, that's a class. It's the zero, one valued binary functions that give tort in the limit. So basically Martin's theorem can be used or seen. Can be used or seen as showing that DOM function is mediocre equivalent to the mass problem of approximations to a tot. Okay, that's a pretty easy exercise. So I can work with this one here if I need it. So I use it to show the dominating functions is much better. Dominating functions is might well have equivalent to the mass problem of ultrafilter basis. And that means the degrees are just the high degrees, while any non-low can compute a maximal tower. So we have two, sorry, two. Sorry, two. The reductions, the proofs are quite different. To get dominating functions below u well, we build using basically a technique of Jokus a uniformly computable sequence of non-empty Pier 1 classes so that, well, if E is in tot, then P e is only one element, which is then computable, of course. But if phi is not total, then Is not total, then PE only contains bi-immune elements. So, those sets that neither the set nor its complement has an infinite recursive subset. And now, given an alter filter base, I can now express whether phi E is total in this way. For some i and some n, if i take out zero, n is a subset of some x and p e or its complement. Yeah, so that that's true because of the properties of the sequence PE. And because this is an ultrafilter base, so any computable set or its complement is eventually taken care of here. So this can be used to uniformly from F compute an approximation to tot in the sense that I had before, and therefore a dominating function. Detail is in that 2023 JSL paper. And the other implications. And the other implication, other reduction. Well, that's a bit of a looking at the tree. So start with an effective listing of the zero, one valued partial computable functions defined on initial segments of n and v e k is the x's so that psi e of x is k. Psi e could be partial. And now let t be the ternary tree. The ternary tree and given alpha and t enumerate a c set as alpha in an increasing fashion. So that's used to later get the altar filter base from the dominating function. The idea being that the dominating function tells me the leftmost path where all these s alphas stay infinite. So I thin them out. If I'm given s alpha, If I'm given S alpha, first as alpha tilde is every second number of those that I have already, that takes care of the strictly descending in the star sense part of the definition. Now, S alpha 2 just copies that, and S alpha K is S alpha tilde intersect Ve K, where E is of course the length of alpha. So basically copy V E or V 0 or V 1. Or V0, V1 into the zero and one children of alpha. And now I define a uniform list of Turing functionals gamma E, and once I have an oracle h, f e will be all the values of gamma e when h is the oracle. oracle so writing qs for gamma h a h e of s q zero zero and now well if alpha choose the leftmost string of length e so that i can find in this c set at stage h of s so really far out uh an x that's better than the current qs minus one greater Minus one greater if so I choose it least and let qs be x so what it says is ask h what's the leftmost extension where I can get another element and that finishes the definition of gamma and now if h is a dominating function then fe is actually s alpha up to finitely many arrows To finitely many arrows, where alpha is the leftmost string such that s alpha is infinite. And by the way, I define this tree and the sets, this will be an alter filter base. I needed eight to be sure it goes far enough here to get the, if this is infinite, to always get another element from it. Okay, yeah, this is a somewhat standard methods. And now we improve that construction and combine it with some more things to get a COSI altar filter base. So far, we've only one below every given high set, so certainly a delta two one, but how about C? Well, it's impossible because the maximum tower. Because the maximum tower cannot be CE. So, co-CE is the next thing to look at. And here we went back to 2001, like the Space Odyssey, which by then was 18 years back in the past. Early on as a postdoc, I had been in Madison and worked with Stefan Lamb and Reed Solomon. And back then, I was quite interested in R-maximal sets. And we were thinking whether co-finite. Thinking whether cofiniteness above an R-maximal set can still be sigma3 complete. Seems easier, but in fact, we built an R-maximal set A so that whether WE union A is co-finite is still sigma 3 complete. So we modified the construction that I've just given and combined it with the technique from that paper, which we called Which we called reserving numbers. And using that, we were able to construct a CoCE ultra filter base. Mark well, so all the columns are still computable, but the whole thing is now CoCE. All right, so that's it about ALTAFilter basis. That's it about alter filter basis. We also in the paper looked at maximally independent families, which also play an important role in cardinal characteristics. So what's an sorry what's a maximally independent family? First of all, independent means, well, any intersection of columns and their complements is possible, meaning non-empty. So if you define So if you define f sigma to be this here in the in the Boolean algebra really of subsets under star inclusion, f is independent if each f sigma is infinite and maximally independent of course means I cannot add another computable set to it and keep it independent meaning if I have an infinite well if I have a computable set R there's some sigma so that There are some sigma so that if sigma is star included in R, or if sigma is star included in R complement. Now, in set theory, people prove that I and U can be incomparable. It's consistent that they are incomparable. However, in computability, However, in computability, I is meant to add equivalent to DOM function and hence to U. Strangely, there's no direct natural proof to translate from maximum independent to ultrafilter basis and back. You have to go, it seems, via a DOM function. Okay, great. And the last piece section of the paper deals within algebras other than the computable sets, where all these mass problems also make sense. For instance, take the k-trivial sets, the Boolean algebra of k-trivial sets. We showed there's a delta 2 algebra filter base for the Boolean algebra of K-trivial sets. For the Boolean algebra of K-trivial sets. And just like for computable sets, this will be high. What we used here was a result by Cutera and Ted saying there's a delta two function H that dominates all functions, perhaps partial, that are partial computable in some k-trivial set. K-trivials are very close to computable, so that makes it possible to have one. So that makes it possible to have one delta two function above all the partial computable in some k-trivial functions. And this fact is used to modify the construction that I just had of DOM function is as above u to basically build an alter filter base for the k trivials from that h and h is delta. And h is delta 2, so the ultrafilter base will be delta 2. And now, going the opposite way in the primitive recursive sets, we show it in Oracle C computes an ultrafilter base just if C prime is of P A degree relative to 0 prime. This property had been looked at in the proof of Djokovic and Stefan, who built a non-high cohesive set. Non-high cohesive set. So we use some methodology from that old paper to make this one work. Not sure what you should call this. If C prime is zero double prime, this is certainly true. So it's sort of a bit of a bit of that. So that's what we get as a characterization of ultrafilter basis, interestingly, for the Basis interestingly for the primitive recursive sets, so subclass of recursive. So the proof is a page or so using that method. And that's it for the results here. Some references, mainly this paper here. And there's a bit on the logic blog also 2019 that's not in a paper. And this is the old. This is the older papers referring to the studying cardinal characteristics and computability in chronological order. Again, this is mostly binary characteristics, meaning based on relations. The latest one here is Monin, which is intimately related to Monin's solution of Solution of the gamma conjecture. So it has another proof of Monin's conference result in the conference paper relating to the gamma conjecture, which I think wouldn't have been possible without the connection to cardinal characteristics, which we worked on when Benoit came to New Zealand in 2018. Sorry, 16, 2016, yeah. Okay, that's the story. And the value of problems are mainly about these index-guessable oracles and how to place them in the hierarchy of other complexity properties I had. But there are also open problems like looking at yet and other cardinal characteristics and find out their reasonable analogs. out their reasonable analogs and computability and place them in the MedV lattice. Okay, thank you.