Okay, so our first start this morning will be Michael Japosi from the University of Toronto who will speak on computability and whatsoever Julia says. Okay, well thanks very much for inviting me. It's a pleasure to be banned again. Alright, so I was asked to ignore the dynamic in the audience, which I'll do gladly. I was also asked to talk about I was also asked to talk about results on computability of Julia sets. So most of this is not particularly new, although it might be new to some people in the audience. And, you know, I mean, it's not going to be a very serious talk. It's going to be a little late music. It's too early in the morning for serious talks. So, anyway, so computability. So, what do we actually compute? And why when we're dealing with dynamical systems? What's the modern paradigm of computing? Just in practical terms. Well, here is perhaps the most famous example of all. This is the Lorentz dynamical system that three-dimensional nonlinear, very mildly non-linear. Very, very mildly non-linear dynamical systems. System exhibits chaos. So, probably all of you have seen a picture of Lorenz Attractor. This is just an app that I stole somewhere online and it runs a point in, well, it's supposed to run a point in three-dimensional space, but my screen is two-dimensional, so you'll see a two-dimensional projection. So, it will appear that So it will appear that the trajectory, so it's a trajectory of this system for the specific choice of parameters that's written there. And it may appear that it intersects itself, but of course it shouldn't, because in 3D it doesn't. And then the shape will be the famous Lawrence butterfly attractor. And there is a feature of this. Um and there is a feature of this thing. So if you click on two nearby points and you watch what these things do well, I mean they stay closed for a while just because I clicked on bad nearby points and so my point will be maybe too slow to make. No, this is good enough already. This is good enough already. So you could see then that the two trajectories, even though they're tracing out the same shape, they are now doing something fairly different. And this is going to happen with more or less any two points that you randomly click. So the shape that you're going to see is the same, but the behavior of the actual trajectories as they trace it out is quite different. So that is, of course, what we know as kO. That is, of course, what we know as chaos or sensitivity to initial conditions. The behavior of trajectories for even very mildly complex dynamical system can vary dramatically if you change the initial conditions. Which tells you that it generally doesn't make sense to try to compute individual trajectories, at least to follow them for an extended period of time. But on the other hand, the limit and shape here, as you could see, is the same for the different trajectories. I mean, different colors are tracing out the same limit and shape. So if you like, in a nutshell, the modern paradigm of computing chaotic dynamical systems is don't compute individual trajectories. Don't compute individual trajectories, compute limit and behavior. So attractors in quotes. Right, so we're going, it's like, you know, everybody knows that it's hard to predict the weather a few days in advance, right? But it's not very difficult to predict weather patterns, even years in advance, right? So I can tell you, for instance, that Toronto is going to be warmer in July than... In July than in January. And this is still going to be true in 10 years, even though I can't really tell you what the weather is going to be 10 days from now. So that's it. Okay, so we are going to look at the questions of theoretical computability of the most famous attractor of them all, which is actually a Which is actually a repeller. It's a repeller. So, Julia sets. I'm only going to look at Julia sets of quadratic polynomials. Because everyone likes to draw pictures of Julius and quadratic polynomials. Julia sets of quadratic polynomials on the computer screen. So you have the following dynamical system. It's discrete rather than continuous. So you look at discrete orbits rather than trajectories. And well, it's a quadratic polynomial in the complex plane. Any quadratic polynomial by linear change of coordinates can be brought into the normal form f of z is equal to z squared plus is equal to z squared plus c. So you only have one complex parameter in this family. And this is truly the normal form. For different C's, these things are not linearly conjugate. And we're going to view this as a dynamical system in the plane. So we're going to take the point Z naught and then we're going to send it to Z one, by F C and then Z two and so on. And Z2, and so on. So it turns out, in fact, that in this case, on this particular problem, because the map is not invertible, it is when you talk about limit and dynamics, it's appropriate to look not at the forward orbit, but at the inverse orbit. So instead of doing this, I'm going to look at an inverse orbit, z naught, z minus one. Z minus 1, Z minus 2, and so on. And I'm going to ask what the limits of these are. Okay? So, of course, you're going to tell me that a point has generally two inverses, unless it's the point C, right? Under this map, there are two branches of the square root. There are two branches of the square root. So that's not a problem. You could either look at the tree of inverses or you could flip a third point every time and pick whichever one you prefer. The answer is going to be the same. So this sequence is going to converge to a set, and this set is the repeller. And it's the Julia set. There is one exception. The exception is The exception is the map F naught, which is Z squared. For that particular map, if you start with the point 0, then that orbit is not going to go anywhere. That's the only exception. Any other map or any other point for that map and this thing is going to converge to the same set. In any sense you like, like I said. In probabilistic sense, you know, you flip a point. Probabilistic sense, you know, you flip a point, you pick a pre-image. As a tree of pre-images, you're always going to see the same set. Okay, so what are you going to see? You mean the same set for even different C's? No, no, no. No. The C is fixed, so J C So this is the repeller for this dynamical system. So here is another app that I App that I stole. So there I actually quote the author of the app. So here is how it works. You have the C plane here. Please ignore this blood fractal shape here. It's of no importance. No, I'm just kidding. It's the Mandelbrot set. I could say a few things about it later. But so what you do So, what you do is you click in this picture somewhere, and that chooses the parameter C. So, notice. And then the picture that you get here is the full one. So, it turns out that there is another way of defining a Julia set, which is perhaps easier to explain, but less meaningful. The full one. You can define the filter. The following, you can define the filled Juliet set Kc as the set of points whose orbits, forward orbits, stay bounded. Okay? It's equivalent to saying that since our map is just Z squared near infinity, if as soon as the orbit gets sufficiently far out, it's gone. Right? So it's just a set of points for which the atrait's okay if For which the iterat's are you okay if I don't put a little circle here? Power will always mean gitread unless otherwise specified. It just doesn't go into anything. Okay, then JC is its boundary. So the set that you see here in black is K. The sort of this light gray region is what goes off to infinity, and the boundary between Off to infinity, and the boundary between the two is the Julia set. And just to illustrate that this is a repeller, let me pick an arbitrary point. I'm just going to mark it there, okay? And let me see what happens with its inverse images. They're in green. I keep clicking, and this thing keeps taking inverse images, so every time the number of inverses will Every time the number of inverses will double. For this, it doesn't matter where I pick the initial mark, right? You could see that very quickly the inverse images converge to the boundary. And you could see that, I mean, they are nicely distributed along the boundary in a certain sense, blah, blah, blah. I mean, I could say some. You get the circle. You get the circle. If C is zero, then K0 is the closed unit disk, right? Because for obvious reasons, and J0 is S1, and you will get this for trivial reasons, you know, this convergence, as long as you don't pick zero as your starting point. Your starting point. Okay? And as I said, that's the only exception. Okay, so we're good with this. You want to see another picture? I mean, the Julia set changes quite a bit if I put it in different places, right? So here, for instance, it's disconnected. So the Mandelberg set, by the way, this set in the picture, it's deeply meaningful in some ways, but you could think of this as just the set. Ways, but you could think of this as just the set of points C for which the Julia set is connected. Okay, disconnected, so it's just some dust here, which is a Cantor set in the plane, but that doesn't matter. The rule still applies. This is pretty ugly, but this is the mark. You start taking the pre-images. When you click in the metal rotator, you're choosing C. Correct. Yeah, so I don't really click. Yeah, so I don't really click in the Mandelgrad set, I just click in the play. That's the choice of C. Okay. Alright, yeah, so you're right. Let's stop with this multimedia thing and let's make, you know, let's do some math. Let's make some definitions. So how do... Okay, clip this off. So like for Z for it to now go to infinity, you want at least a temp. You want at least the absolute value of Z to be less than R, right? Sorry, I say it again. It depends on C. No, no, no. But this is, this is, this is, this is one way to define it. That's another way, the equivalent. Okay? They will give you the same set. This one is maybe easier to digest, but that one is the one that's dynamically meaningful, right? So it makes sense to try. Right? So it makes sense to try to compute this set. Okay, so for the left guy, you just visually collect all the limit points, and that's the set. All the limit point in the tree of three images. All the branches in the tree of three images? Yeah, so it doesn't matter in what sense you will do this. So every point except C has two pre-images. One way of doing this is just flip a fair point every Is just flip a fair coin every time and pick one. The other one is to look at the tree of pre-images. Okay? So the limit set is the same. It's the Julia set. So this is the repeller. So computing Julia sets, right? So what does it mean to compute the set in general? I imagine everybody here knows what the Turing machine is, right? Yeah, I don't either. I have to learn it at some point and promptly forgot. So, but it doesn't matter because probably, you know, any definition, well, I mean, probably computing with the Turing machine is the same as computing with the programming language written in the program written in your favorite programming language. So I'll talk about algorithms, programs, Turing machines, whatever you prefer. Turing machines, whatever you prefer. The only thing that's important is when we talk about computability rather than computational complexity, we don't put any bound on resources. So if your algorithm needs, you know, a spare hard drive to compute something, we give it. Okay? So what does it mean to compute a set? Well, what does it mean to compute a number? Actually, dynamicists in the audience, do all of you. Nemesis in the audience. Do all of you know what a computable wheel is? So, this definition. Sorry, I said I wouldn't pay any attention to you, but I lied. So, this definition goes back to the famous paper of Turin in 1936. So, X in R is computable. Is computable if there exists an algorithm. I'll use m because m for machine, okay? So the algorithm takes an input, m, which is a natural number, and it outputs well it outputs a number, and this number, well, you could think of this as a as a This is a binary rational, if you like, or just a rational. But it doesn't matter, you could teach your machine, you know, the symbol pi, and it could use it. So it outputs a number, call it dn, such that mod x minus dn is less than two to the minus n. Okay, so two to the minus n is pretty irrelevant here, just, you know, since we like to think of computations as done on binary. Computations is done on binary. This means it's true to the nth bit. But you could put 1 over n, it's an equivalent definition, doesn't matter anything if you want. So that's the definition. A number is computable if there is an effective Cauchy sequence. All the numbers we know and love, well, in dynamics, I don't mean the logicians, are computable, and notice that there are only countably many of them. Okay? Okay? Just because there are only countably many algorithms that you can write on Python. So computable elements of C and so on are defined in the same way. What does it mean to compute the set? So I'm going to give you a definition which mimics this, and then I'm going to give you a definition which is a bit more, you know, like what people do. By the way, Durin wrote the paper to uh in fact to give examples of non-computable reels, really. It is not that difficult to give an example of a non-computable reel if you put yourself in the right frame of mind. Does everyone know what the Halten problem is? Does everyone know what the Houghton problem is? Dynamesis. No? Okay. This is the practical problem you have if you write a bit of code after you get it to run. Okay, so it runs, then it runs and runs and runs and runs and runs. And at some point, you have to make an executive decision. You know, it's still doing something useful, you should kill it. Well, that's an unsolvable problem. So there does not exist This, an algorithm, M, which takes as an input, you know, the code, the text of another algorithm, and outputs 1 if M1 halts and 0 if not. So such a thing doesn't exist. So then what you could do, you could just line up all your algorithms in Python, just all strings that you can write in Python, you write You can write in Python. You write, line them up, say lexicographically, so M1, M2, etc. are all programs in Python. Of course, you know, these things mostly just won't run. But that's fine. Inputting N1 and an input for N1, for which it could be. For M1, for which it could decide whether it holds on its. Sorry, say that again? Input, like when you say it holds on which input? You have to also. The input is M1. The text of M1. M1 is the code, right? Correct. So doesn't it have an input? No. This already is an unsolvable problem. This, yes, M1 doesn't have to have an input. Oh, I see. Sorry. It just works. Yeah, I mean this is look this is this is uh the existence of such a thing is is would be a paradox. It's the usual thing the the barber who shaves everyone who doesn't shave himself, right? So yeah, but anyway, so you line up all Turing machines, then you write down the predicate, which is just one or zero, depending on whether it holds or not. So P of m is one if Is 1 if mn holds, 0 otherwise. And then you write, I don't know, alpha is equal to sum P of n 3 to the minus n. I want to write this in ternary rather than in binary because I'm estimating this up to 2 to the minus n and I don't want any ambiguity. So if you can compute this, you could solve the Halton problem. So this cannot be computed at all. Problem. So, this cannot be a computer. Okay? All right. So, you know, and if I told you all of this on 936, I would be a genius. So, computing pictures, computing images. Question to the logicians in the audience. Does everyone know what the Hausdorff distance between sets is? Everyone? Excellent. So we're saying that the set K, a compact set, in, well, let's do C, okay? We'll only talk this. You could do this in any metric space, you know, appropriately prepared, but we'll just do this in C. We'll just do this and see. So, is immutable if there exists an algorithm m which takes natural input n and which outputs well it outputs a set but a set that the program outputs will just be a finite collection of data rational. Finite collection of data rational points with the property this is less than 2 to the minus 2. So here is an equivalent. The parallel is clear. Here is an equivalent. Notice that the point with coordinates alpha 0 is not computable. Right? Most sets are not computable by this definition. They're only countable many computable. Definition. The only accountable remains is that it is. So here is an equivalent definition, which would be more to the liking of practitioners. If you imagine your computer screen as a square grid of pixels, that it is, you would like to visualize a set. So you assign a physical size to a pixel, say 2 to the minus n, you assign You assign the coordinates to the center of the screen, and then your set goes through this picture somehow. And what you would like to have is an algorithm which, given this n and the coordinates of the screen, will give you a one-pixel approximation of the set minimum. Pixel approximation of the set, meaning that it will color in the pixels whose distance to the set is at most the pixel size. It will not color in the pixels whose distance to the set is, say, two pixel size, at least two pixel size. And then in the middle, there is a fuzz because computers are bad for solving exact inequalities. So it can make a mistake. And that's what we do in practice, right? Okay, finally. Right? Okay, finally, what Julia says, it's kind of as with any dynamical system, it's kind of pointless to expect much if you don't tell your algorithm what the value of C is. Right? So in general, when you're computing in a tractor of a dynamical system, it's pretty good to know what the dynamical system is. Okay, so you have two options. Okay, so you have two options. You could either write C itself into the code, which means that C would have to be computable. There are countably many such C's, but that's a valid option. Option number two, you could input C externally, which is what I did when I was clicking on that screen. So then you just modify modify this. So Julia said it's computable if Is computable if, and this machine, well, logicians, I'm sorry. This is, yeah, as an instruction, read C. Okay, so in technical terms, this is known as an oracle for C. It's an instruction which just allows, it does exactly what it's supposed to do. It allows the algorithm to read C with any precision, whatever. See with any precision, whatever precision you want, finite precision, of course, but arbitrary. And in the thing that I showed you, in the app that I showed you, that click of the mouse is what specifies C, and the algorithm just reads off where I click. So when you set it up like this, so the technical term is an Oracle for seal, like I said, and I And I had tremendous struggles with this notation until I realized who the oracle is. So the oracle is me. Right? It's me who the algorithm is going to ask for, the digits of C. That's the oracle. So, okay, so good. So this is JC. This is the definition. Okay? It's exactly what I showed you on. What I showed you in that app realizes this paradigm. This is what people do. You click, you can see, this thing draws you a picture. You could zoom in, you could zoom out. It's good up to the screen resolution, because otherwise there's no point, right? But the resolution is whatever you set it. Everybody's good with this? Okay. So let's formulate some theories. Let's formulate some theories. I just am other things I want to convince you that first of all this is practically important, right? I mean not necessarily for Julia says, I mean they're practically important as a model, as a paradigm. They're the best studied example of a discrete dynamical system in many ways. So a lot of the intuition So, a lot of the intuition that we have comes from Julia sets, but it's not like you specifically build heavy machinery based on Julia sets, but you build heavy machinery based on other things. And the principles are the same. So, right, so okay, so I'm going to formulate two theorems that will prove with That would prove was jointly with Mark Braberman, who's now in Princeton, but back then he was a grad student in Toronto. And so there are going to be two theorems. If you like the good news or the bad news. Which do you want to hear first? Bad news. Okay, so bad news. So here's bad news for logicians. Casey, the Phil Julius, it is always concluded. Well, I should say, with an oracle for C, right? You also have to say if this is the badness or putting it on the basement. Is the bad news or for peace? I mean, this is bad news. I just told you. I mean, it depends who you ask, right? So for dynamicists, this is good news. But I'm ignoring dynamicists, right? So, with minor exception. So, this is bad news, okay? You want to hear good news? So, here's good news. You meant JC, right? No, I meant KC, the Phil Julius said. The Phil Julia set. JC is its boundary, right? So remember, JC is the boundary of Kc. Kc is easy to define, right? Sort of easy to draw because you just iterate points until, you know, you say, well, this is too large. It's gone off to infinity. And JC is its boundary. I don't want to bring that thing up again. That thing up again, but you remember the picture, right? So the set in black, that's Kc, and then JC would be the repeller, and it happens to coincide with its boundary. So this is always computable with an oracle for C. So as long as you can tell the algorithm what the value of C is, it can give you a true picture. It's not trivial, by the way. Sort of the natural reflux, which is just iterate points and Which is just iterate points and say, whoa, this is too large, I'm sure it has escaped, doesn't work because you don't know how long you have to wait. That would be the halting problem. So you have to come up with something more clever, but you can. So if you are outside of the Mandelbrot set, it gets simpler? Uh, if you are outside of the Mandelbrot set, then K C is equal to J C. So I just told you then that J C is computable outside of the Mandelbrot set. Outside of the mental growth steps. So, in that sense, it's simpler. Okay, so. Oh, yeah, so there was that set. It's too bad that multimedia presentation, right? I have to refer to the picture, but it's no longer there. If you remember at the plane where I was clicking to pick C, there was this picture there. And so on. This is the Mandelbrot set. A Mandelbrot set can be defined as the set of points for which the Julia set or the field Julia set, it's the same, is connected. Okay? So it happens, it so happens that outside of the Mandelbrot set, the Julia set is not just disconnected, it's totally disconnected. Totally disconnect, okay? So, and it's equal to Kc in this case, obviously. And then I just told you that outside of the Mandelberg set everything is computable with an oracle for C. Okay, so there exists C such that JC is not Kabu with an oracle for C, right? So that's good news. So that's good news. Ah, no. You'll say, come on, this is just cheating. I mean, this must be a very bad C, right? So there's this computable C. Nah, this is still not enough. There exists only time computer. And by exists, I mean that I And by exists, I mean that I can give you an explicit algorithm. Explicit algorithm. Explicit polytime algorithm to compute C such that J C is not computable. Okay? So this is your worst nightmare. Your worst nightmare if you want to actually do computations. It costs you nothing to do one iterate. But you can never compute the limits of the repeller. Okay, so any questions about the theorems? Just saying that you can know whether the point value is know whether the point go is in the sh field shudder set, but you cannot know whether the guy is going to the attractor? No, not really. Just for this set that's easier to give a one pixel approximation for the other one. Much easier. But the problem is that this one pixel approximation for the Phil Julia set me give you an example. I'm going to draw a boundary of the domain. Okay? So I'm going to take the unit circle. The domain is going to be inside the... It's simply connected. It's going to contain zero. Okay? And all I'm going to do, I'm going to take the unit circle. Going to do, I'm going to take the unit circle and I'm going to remove a set of spikes of length, radial spikes of length one half with their limit points. So this is compact, okay? So you can encode anything you like in this thing. You can encode the Halton problem. Computing this can be impossibly hard, depending how you position the spikes. But if you fill it, you get the unit. You get the unit disk. So the fact that you could compute the filled Julia set doesn't necessarily tell you anything about computing its boundary. This is, at least for me, telling me a lot about how bad is I should have said from outside versus how bad is from inside. I can actually say quite a bit about that, but I'm supposed to ignore dynamic skills, so I'm sorry. But I can tell you later. I'm sorry, but I can tell you later once I stop ignoring. So I can give you some idea on what these bad Julia sets are. But first, let me see if there are any questions. I don't know dynamic. I'm asking you. Gotcha, I'm not ignoring you. I'm asking his question. Sorry, I didn't hear his. Yeah, so, right, so intuitively, you want to say that someone's going to be able to do that you want to say that somehow the boundary, so somehow there's something like this, right? So the boundary oscillates in some way and it will. So I will actually show you how. It's a bit more subtle than that. So for instance, if you do this in the sense of measure, and you look at the Julius as the support of the harmonic measure at infinity. The harmonic measure at infinity, or the Brawler-Lubich measure. That measure is always computable. Okay, so that turns out to be true. It's a theorem of Mark, Christopher Ropas, I think, Ilya Bender, and yours truly. It requires rather different techniques. So it somehow tells you that the stuff that you can't draw is well hidden from infinity. So it is sort of a picture like this, right? Sort of a picture like this, right? So the stuff that you could see is not necessarily the stuff that you want to draw. It's like here, if you come in from infinity, you're just seeing the circle. So you lose all of the complexity of the circle. So right, so here is some idea. Right, so here's some idea. So I'm going i it it turns out actually we can completely characterize the the non-computable Julia sets. There is one thing that must happen and that's the presence of a rotation domain, but that's not enough, of course, but it's a requirement. So let me throw some definitions at you. So first of all, I would like to switch Would like to switch gears and look at a smaller family. I want to simplify things. I want to look at a family of quadratics which have a neutral fixed point at zero. So I know that all of you listen carefully to the dynamic here, so you know what what I'm talking about. So here's the family. E sub theta of z is e to the two pi theta z plus z squared. That's z plus z squared. So here 0 is fixed and the derivative at 0 is on the unit circle. So you could ask when is the dynamic. So the difficulty here is to understand the dynamics near this neutral. The dynamics near this neutral fixed point, and you can ask when this dynamics is just the dynamics of an irrational rotation. Well, yeah, so I will only look at this for the moment for irrational theta. When theta is rational, you know exactly what happens. It's not particularly complicated and very classical. So one thing is So, when theta is irrational, all sorts of difficulties can arise in describing the dynamics. So, definition. We say that is Siegl if there exists a conformal change of coordinates. Call it phi. Call it phi in a neighborhood of zero, which fixes zero and which makes the following diagram commute. So this is p theta. This is just the rigid rotation. I ran out of space. This is not good. Makes the following diagram to me. So phi phi I phi d theta rotation. Okay? Otherwise we call it Cramer. Typical points is Siegel. In fact, Siegel's theorem was that this is true for all the Fantan values of theta. I'm not going to tell you what the Fantan values are because I'm going to give you a great Because I'm going to give you a criterion, the exact characterization of such status, which is due to EOPOS. But before I do that, I would like to point out that because of some general nonsense, in this case, there exists a maximal linearization. So, a linearization with the maximal domain. So, there exists a maximal A maximal linearization domain. So if theta is signal, which I'll denote delta theta, and let's call this the signal disk. So just think of its boundary as some frame. Just think of its boundary as some fractal. The boundary lies in the Julia set. It's a disk, it's a topological disk. In fact, it's an analytic disk. So phi, there is a maximal linearization phi, which just turns this into the unit disk, zero to zero, and this thing to rotation. And inside here, everything is foliated by analytic circles. By analytic circles, right, and each of which you have a rational rotation by angle theta. The boundary, the dynamics on the boundary could be a mess, it's a subject of a lot of rather interesting papers. But the point is that this thing is maximal, okay? Doesn't follow from the definition, I'm just telling you. Okay, so there is a characterization. So there is a characterization. We have a photo. It's scheduled at eight fifty eight fifty five. We see it's a couple of minutes late, but um A couple minutes late, but um you can have to stop. I could stop right now. I'm not gonna take three or four minutes. Uh not going to tell you much in three or four minutes, but I could finish this in ten minutes. Who photos at 855 for online people, not for us? Uh you're gonna call? Well, I'm calling it. I'm calling it. Okay. You should go into late 55. Okay, so then we transition the technology. Okay. So then I can tell you privately if there is any interest on how one could try to do that. Too bad because you started late, but this is pretty sad with the people remotely. So why don't you go until 8:55? Could you have five minutes? I can't. I was. It's okay. We started a little late, so yeah, so that's alright. Okay, are there any questions for the speaker? Okay, so now this is this is a private question, so I don't have to stop for the photo. So, I don't have to stop for the photo. So, this I can answer. So, there's a theorem of Jokos which characterizes, it's a brilliant theorem, so which characterizes the Siegel parameters in this fan. It says the following. It's almost explicit. Theta is Siegel if and only if the follow-on series converges. So, I'm going to write this series. So, this is actually really there is There is the theorem is due to Bruno and Jokas, but Bruno's theorem says that this convergence, or in fact, slightly different convergence, which is equivalent to this, is a sufficient condition in general. Joker's theorem tells you that in this family it's also a requirement. So you look at the following sum. So here theta naught is theta, and theta i plus 1 is the fractional part of 1 over theta i. So all you're doing is you're shifting the continued fraction to the left, right? So if this thing converges. And in fact, there is a refinement of this by Bloof and Sherry Da, which tells you. Which tells you what the median of this function is. You could measure the size, the conformal size of this siegel disc in the following way. Remember I told you that there is a phi which turns this into a rotation? Let's normalize phi so that phi prime of zero is one. Then you lose control over the size of the disk that this is mapped on by phi. I mean, that's a trade-off. I mean, that's a trade-off, right? I could either normalize the derivative or normalize the size of the disk. Okay, so the size of this disk is known as the conformal radius of delta. So it turns out that log of the conformal radius plus phi extends to the To the reals as a one-periodic continuous function. So, of course, this is only defined on a dense set of points, for instance, not defined for rationals, right? Because you will get one over zero somewhere. So, but what it says that this extends as a continuous function. So, you should think that up to a continuous blah, this is like the exponential. Exponential Yeah, so ha, so what happens? What makes it difficult to compute these things? I wasn't kidding, I can actually tell you, but I couldn't tell you in four minutes, but I can tell you in nine. I think we can probably have another speaker at the time. Okay, so that's alright. I don't want to observe too much time. Maybe, yeah, maybe just one word. Yeah, that's okay. So hey, they're going to come out of the beers is going to come out.