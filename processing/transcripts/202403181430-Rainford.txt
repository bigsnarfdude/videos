I feel like there's a whole pile of things I felt I was going to have to explain that have just been explained. So this is absolutely brilliant. So TORK is an ongoing project that I'm part of along with and we are the computing branch of this project actually. So I'm from a non-standard computation group and I got into this stuff because Into this stuff because I just want to stop proving things that Tori incomplete, and I want to start proving that we can do different sorts of computation, and that Turing completeness is not actually that interesting. And if I want a biological computer, why do I want it to do the same thing that my computer does? Biology does some really cool stuff. Why don't we look at what biology wants to compute and how biology wants to compute it and use that instead? But we've got two other branches to this project. We've got two other branches to this project. So we're also working with Sarah Harris in Sheffield now, after her recent move, who is working with us on, who's doing atomistic or close to atomistic physics-based modelling for this project. And then we've got Charles Dorman and Pelson Crow's lab out in Dublin, at Trinity College Dublin, who are working on our lab bench stuff. Working on our lav inch stuff and actually trying to create all our little bacteria to see if any of us ever works. So, what are we actually doing? So, I think we've thoroughly established most organisms possess negatively super called DNA, and this aids in the packaging, allows access to information in our DNA, and I don't think I actually need to talk about that any further. About that, any further. What I will talk about is the fact that a lot of models hold currently for how we do computation or how we engineer behaviour in plasmid DNA is based on gene transcription. But interestingly, all of them sort of do this wonderful little dance to avoid supercording. Either they ignore it or they do a lot of different trial and error things until it stops messing them up. Up because transcription creates supercoiling. It creates localized supercoiling. So whenever you get transcription of a gene, you get positive supercoiling happening ahead of it, because as we unzip that gene in, it's all going to go somewhere. So ahead we get wound tighter and behind, we get wound looser. So we create these little local supercalling domains. Because also, while we're transcribing and while we've got hold of the DNA and we're ripping it apart and copying it. We're ripping it apart and copying it, we get some persistence of these super boiling being generated, and it sits around for a little bit until we let go and it all just relaxes and sorts itself out. Obviously, enzymes come in and about with that, but they don't happen instantly. Enzymes take time, and these things happen. So, I think we've also very much covered this. So, negative supercoding increases transcription. It helps us to open up the DNA. It makes it much, much easier for transcription to start and continue. Though, you know, up to a point, it turns out there is some evidence that if it spalls apart completely, then it's not very helpful for transcription, at least. So, currently, So, currently, a lot of sympathetic biology uses this transcription and transcription factors for gene regulation by circuits. One gene produces something that either activates or inhibits another gene, and so on and so forth, until we get an effect we like. Repressylators are a classic example of this. Each gene represses the next one, so you get a nice oscillating system as they turn on and turn each other off. But, as I say, these circuits often dance around supercooling because they get in a lot of trouble with it. Because too much positive supercooling in your system and it stalls out, because now you really can't get with that information. It's all just wound up too tight, and you're not getting in there, and everything sorts out. As I say, too many negative supercoils in the wrong place, and it destabilizes, and you can't do much. Because those melt points are great for getting that bit of DNA. They're not so helpful about getting the DNA 30-base pairs further. But the DNA 30 base pairs over a lot, because trying to get that set to open when the other lot's already opened is very tricky. So we've got a problem in this idea of building gene regulation circuits that super cooling is in our way. But I don't like this because this assumes that what we want to do is switch things on and off. And as I said, I don't like classic computing, and classic computing is all about switching things. In Council Computing is all about switching things on and off. So, why is it a problem? Why is supercoiling a problem? I've just told you, I can control things with supercoiling. Supercoiling controls transcription. So how about instead of using a transcription factor to turn one gene on, how about I just drive three genes with some supercolon, generate a load of supercoding, and turn all three of them all at once. Once. Because then there's an obvious thing for, okay, what about why I want to turn it off? I'll just create a topological bridge, close off the loop, loop and turn it all off again. Isolate the domain. Hey, wonderful idea. But, you know, can we do that? But it turns out the components are already out there. We already know what they are. We already know what they are. So we know that there are genes such as TET-A. So TET-A generates large negative super-cooled domains. It fixes to a membrane as it's transcribing, and it does enough transcription to stay fixed there most of the time, which prevents the DNA from just relaxing. And when you combine that with, we think, a barrier at the origin of replication, I'm taking the biologist's word on this. I'm taking the biologist's word on this. They keep telling me that something's going on with the origin of replication that's helping to also hold that from twisting around too much in the cell. So we can generate these, though I will say it does require us to be a little bit cheeky and knock out top A. Otherwise, top A does just kind of mess with us and get rid of all of our negative supercooling. So we've got the ability to generate regions of Regions of negatively superfluous DNA within a plasmid. Okay, so slightly familiar, as seen in the previous talk, black eye will grab onto your DNA, twist it up and create an isolated domain. That prevents supercoding transmission into the inner loop. Fantastic. I can now isolate a part of my circuit. And we can. And we can drive genes with this. So, the PLU500 promoter is a point mutation on a PLU promoter that increases the CG richness of it, making it require negative supercoiling to open. Makes it very, very much dependent on negative supercoiling to function. So, we've got our pieces. We can now turn on a gene. We can now turn on a gene with supercoding. We can isolate a domain and we can generate our supercoding. So I give you the hopeful eventual talk plasmid that we want to build featuring our TETA supercooling engine. We've got two lap points for our lap to fix that. That to crit. Fix at, at crypt, so we can isolate a reporter gene. So we've got two reporters, just so we can check that everything hasn't just broken. So we've got M Raspberry here and M Power, a red and a blue fluorescent gene, and we've got our two promoters, both of which should be super cooling sensitive. So all goes well. Without LAC, LAC. Supercooling should be generated by TESTA. Should be generated by tet A, A, turn on M Raspberry PG, and then turn on M Camela as well. And that's in the system, Mraspray still turns on. That comes in, isolates our McAmer gene, and it's no. Switched off. Starting simple. Well, in theory, in the long term, we want to stick loads of genes in there. We want to build multiple domains. Uh we want to build multiple domains, we want to mess around, and uh uh and we've got our eyes on some other mechanisms as well. But now this is what we're working with. Nice, is it? So we've got lab experiments, as I say, we've got some guys building these in the labs. Morgra is doing the vast majority of the work on this, he's doing this, he's doing a fantastic job with this. Every time I meet, I talk to him. Every time I talk to him, he seems to be building more things. So, we've got bacterial variants. So, we're actually doing this in both E. coli and salmonella. So, on the left, we've got our E. coli strains, and on the right, we've got our salmonella strains. As I said, this doesn't work. We let top A get rid of all our negative supercoiling. So, for each of those, Buricona and Salmonella, we've got a Top A knockout where we've got rid of blue blob in this little iconographic. Little iconographic. And then we also need two options: systems with black iron and systems without. So, any coli, this means we have to get rid of lack eye. And Samonada doesn't have lack eye natively, so we've had to add that in for our lab experiments. And then we've ended up with, then, because we wanted to control for everything under the sun, it seems, when we have these discussions, we've got Circuit variants. So we've got a partial circuit with just one reporter, auto gene in there. We've got, and then two versions with both our reporter genes in. So we've got them running divergent, so facing away from each other. And we've got them running in tandem, so both facing in the same direction. We wanted to see what would happen really, because they're also generating supercooling as well. Because they're also generating supercooling as well as TETE, and so we didn't want to discount that that was going to have an effect. So, those are our controls. And then we've also got all of these, we've also got each version done with the well-type loop promoter and our mutant 500 promoter. So, that's 56 variants already that we're working with. Plus, actually, at the moment, we're also looking into some variants of the tech. Into some variants of the Tech A promoter. So we've got about four of those. So we're having, so the lab's working hard and we're getting some results. We've definitely got a snag somewhere in there. And the more we look into it, the more interesting that snag's getting. Because they don't work. And we don't know exactly why. But everything we eliminate makes the possible reason more interesting. Hopefully, some good. Hopefully, some good news from there eventually. We've got a physics model, I'd say, and this is being developed by Victor Lesko Romas. And this is where we immediately wanted to look at moving away from this sort of thought process of DNA circuits where transcription factors act as switches. So here we're thinking in terms of transcription factors create topological domains. Through their transcription, they're creating Through their transcription, they're creating these local areas of supercoiling. Through that I, we're creating an entirely new domain, topological domain, by separating an entire part of our plasmid from our supercoiling generator. And this whole thing changes the paradigm. It changes the possible complexity of our circuits because one of the biggest problems from a computer science perspective. From a computer science perspective, computing perspective, biological computing is wiring. It is not easy to wire biology. It does not like to go where it's supposed to. It does not like to stay where it's supposed to. One thing does not like to only listen to one other thing. Transcription factors, lovely idea. You get the right transcription factor, it plugs in, thing turns on. Problem is, other things will also turn it on, and the thing you're using to turn it on will go and turn other things on as well. Go and turn other things on as well. It's all very messy. So, what if we stop thinking in those terms and start thinking more messy? Why not think messy? If we're turning on and off entire regions of our DNA, then I'm going to be a little bit, then I've got a lot more room for error in some ways. I'm not reliant on that one little segment of DNA. One little segment of DNA, and that one little segment of DNA on the transcription factor don't know what they're supposed to. Hopefully, by drawing us away from that need, we can make everything a little bit simpler. So, this is all being implemented through our talk physics, which is I was about to say a model that does something, but actually it's quite a few models. It's been really well put together. It's a individual-based model. Individual based model where we've got all our different effectors. So these are enzymes, their this is where the biology fails me and I lose the word. So we've got all sorts of things in here. Enzymes, RNA binding, polymerase, things like that, and these bind onto our DNA model, which has DNA, gene sites, and nap sites. And the nap sites are there because we've got other stuff we want to do later. Because we've got other stuff we want to do later that involve NAP sites that might be really interesting. But each of these effectors binds to the DNA, has an effect on the DNA, and unbinds. And each of those processes is modelled separately for each different effector. Obviously, some of them will have the same models, but they can all have their own unique models. And these models are being derived, at least to start with, but With but from the work of Sarah Harris's previous atomic models, Craig Benham's work with SIDS, quite a few bits we've got going there using Sam Meyer's work as well. If you ever get a chance to talk to Victor about this stuff, he's absolutely amazing and knows all about it. And I can't possibly remember everything he's using because it's a long, long list, but it's an impressive list of stuff that he's been adapting. Impressive list of stuff that he's been adapting and fitting into this computational model that's also really well implemented. So, if you want to add a new model in there, trivial. And then it just runs fast. I have no idea how he's getting the speed he does out of this. And then there's my model, which is TalkCon. So I say I'm a computer scientist. I have a background in mathematics that I'm told I'm very bad at putting down. So every time I come to a new project, Every time I come to a new project, my boss asks me, So, what algebra are we doing this time? And in this case, it ended up being high calculus. So, we wanted a very, very fast, abstract model of this system as components for computation. So, we wanted, and the problem here is there's two main processes happening: there's transcription and there's supercoil. And transcription's, relatively speaking, slow. Slow and transcript and supercooling is very, very fast in comparison. But also, it's biology, so everything is happening at all times and all at once. And that's not how a lot of computational models work. We often like to use things like event-driven modelling, where we just model the next thing that's going to happen. Except in biology, that's everything, that's right now. So instead, we went with Python. So instead, we went with PyCampus. So, PyCamptus was originally developed for things like mobile phone networks, but it's since become quite popular with biologists because it deals with concurrent systems where everything is happening at once. And it deals with multi-scale systems with vastly different time scales and vastly different size scales. Anybody else in the room probably going, yes, that sounds right. Like, everything happening all at once, at all levels, and in all directions. And in all directions. So we've got a transcription model, which is slow. Oh, so a bit like, you know, sale now. In our model, we just go with our promoter is going to determine the rate of output that we get from a gene. And that's going to be transcribed straight into an environment, and we're just going to ignore processes beyond that. It's a very, very simplistic model. It's very abstract, and the idea is it runs very, very fast. And our supercording model, which is also done by Model, which is also done by signaling with PyCapus. And that's very fast. But we decided not to try and model supercoiling at every point in our DNA. So in this model, the idea is we treat it as regions. We have more persistent potential barriers for supercoiling, such as in the current system, we've got that tet A gene, we've got the origin of replication, we've got those lakh points. So that breaks up plasmid up in two. So that breaks up plasmid up into supercooling regions. Genes that sit entirely inside of a region, likely they're positive and negative supercooling, are going to cancel each other out, out fairly often, and they're going to relax most of the time. So we're only looking for long-term build-ups in how these are, and more sustained supercoiling actions. But we did then have a bit of a hiccup with that when we realized, so we started with single-directional negative supercoiling plasmids, and then we wanted to actually make them accurate, so we added To actually make them accurate, so we added positive superconnecting, and then we realized it was going in both directions and that it doesn't cancel each other out when it encounters each other. So then we had to work that one out. And that's got a little fiddly. If you want to see the PyPaptus model that's been published, I won't go into it here because it's not that interesting. So, two models. We've got transcription models. So, we've got gene transcription. We started with a binary threshold for this. Which was a great start, useful. Turned primoser on, gene turns on, great. But he didn't like that, so we moved on to sigmoid. And then, because there's a reason we've got three different systems running here, the physics model started throwing back some interesting results, which said actually, when we were getting lots of supercoiling in the system, the promoter was transcribing less. So I went from So I went away and we talked about this, and I stared at his results for a while and went, okay, so I'll just add a normal curve in here and hopefully I'll never have to use it. Spoiler alert. I have since had to use it. Use it and I'm not sure I'll like it, but it's interesting at least. But we, but this all just, so this all just controls the rate at which our genes output, and that will go straight to an environment concept that Because try as I might, I can't get a straight answer from biologists on how we get from that transcription to something I can observe as a fluorescence of protein or an mRNA, reliably. So for now, we've just got an environment and we'll parameterize it as we go. A little supercoding. So we've got, we're mostly modelling twist here. We're kind of ignoring Rye. It's there, it's happening, but we're kind of not thinking too much about it until. We're not thinking too much about it until we have to. We'll add it in when we need to, which will probably end up being sooner than we'd like. So, twist, positive or negative, two directions of travel. And what we found is that you go one way around, the other way around. But we needed to work out if I'm M Raspberry sack here, what do I think the local super calling is? Well, it's the sum of everything in the region, region, and everything that's passed on from the neighbouring regions. Passed on from the neighbouring regions. So, in this case, we don't have LAC in this system, so transcription. So, supercoiling is transmitting between our regions. And it keeps going in the direction it started, and each region transmits everything it's got in that direction around. And nothing really annihilates, per se. So, we've got, so these free systems, why did we build free systems when they appeared to be? Build free systems when they appear to be not really doing much for each other other than getting in each other's way. So, the idea is that our physics system gets parameterized by a biological system. Because, well, all of the models we're currently using for it are fantastic. Most of them are not of dysplasmid in E. coli, in salmonella, in those very busy environments, in those very real environments. So, we actually wanted to get some parameters back from the biologists into our physics model. From the biologists into our physics model, see what the difference would be. A, because biology is never reliable in terms of scaling, scaling exactly. But also, the more we can feed back onto those models and improve our model, the better. And hopefully, the physics model is going to parameterize our computer science model up. It's going to give us some really nice numbers, some really nice, you know, in general, this will do that. Well, this will do that with this rate or that frequency. And obviously, it would be very nice if the computational model will also be able to feed off the biological model and check against that. And if all goes well, these will all match up nicely. But one of the goals in this project was that none of these systems should be feeding off each other and not giving anything back. We had three groups of people who were all interested in different things about this model. Different things about this model, but also all want productive outputs. So we also want our computational model to be really small and really fast because we want it to be able to run thousands and thousands of times with thousands and thousands of variations. So eventually we can start applying some machine learning and providing our physics models with potential new circuit designs. I don't know about anyone else here. If you've ever seen evolutionary algorithms in action, they can come up with some. Algorithms in action, they can come up with some really wacky solutions to things that we never think of. And given people designing plasmid circuits right now are still thinking in terms of switching things on and off, I really want to see what evolution does when you handle that problem. Problem. Obviously, not actual evolution, because that's going to take a long time. So let's do it on a computer. Computer, and then build it in real life. And we want the physics model to help us with biological. Model to help us with the biological models because while the physics model can't reflect the complexity of what we can get from a real cell, we also can't see all the complexity in a real cell. We just can't access things like that very local supercoiling that's happening in these systems. So being able to use the physics model to filter these circuit designs, check which of them are actually going to work, because Which of them are actually going to work? Because small fast models, not the most reliable. They're small, they're fast, you can do a lot of them, but you better check afterwards whether they were right. But it also, and we've already seen a couple of cases of this, can provide us with some ideas as to what might be going wrong with our actual bacteria. Why isn't it working? So, currently, what are we up to? So, we're currently trying to do some parameterization of the physical. Some parameterization of the physics of the biology. We've got mRNA protein or fluorescence levels coming out of our biological experiments. And we're comparing that with transcription events, hence at the minute. Unfortunately, at the minute, our physics model works and our biological model doesn't work, so trusting the parameterization is hard. Because probably something's not quite right there if one's working and the other's not. We are, however, starting to parameterize the computational model with the physical. To parameterize the computational model with the physics model. We're doing this using initially a parameter search. We're actually currently doing this at two levels. So the first one we're doing at is what we're calling a behavior-based parameterization. So we're literally limiting ourselves to only parameterize the computational model based on things in the physics model that would also be visible in the biological model. The idea here is we wanted to see how far wrong could we be. Could we be? How wrong could we be? We can see the internals of both of these models. What if we couldn't? What if we were just trying to set a parameter based on what we can see? How far wrong can that go? And then we've got a second one where we look a bit deeper and we actually sort of peek behind the current and go. So that should give us a comparison. And there we're comparing these environmental levels, which, because it's a computational model, they produce a number. They produce a number. Right now, we've decided one is one transcription of it in fault. So we're using that for our comparison. And yeah, that's going well, and that's in preparation as a paper, and the debugging is ongoing. But hopefully, more to come in the future. And as these models grow and become more refined, we can start engineering plasmids. Plasmids. We can start discovering what is the potential for computation of these systems, systems, beyond flicking some switches around. So big thanks to UKRI for funding and also Science Foundation Ireland and all the guys on the talk grant. Aunt Susan, Sarah, Charles, Carlson, Victor, and this was one of our recent meals where we realised we were all sat in a nice little circle. Sat in a nice little circle. Except for Charles, who wasn't able to be with us, so he got isolated. His nice little black loop there. Thank you very much.