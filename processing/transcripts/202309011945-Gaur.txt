I'm pretty sure for every possible basis state. And instead of writing a bunch of zeros, a single one, I've not a bunch of zeros, I'm just talking at number k. Decimal number k which varies from 0 to some happening. Right, so just imagine we were given a small vector and then we created a large vector out of it, very large vector. This is an exponentially large vector by applying only Applying only limited number of operations, linear number of operations. There is no classical analog of this. So there must be a catch. What is the catch? We cannot see it, right? We know it is there, we cannot touch it. And there are nice Thinking exercises, thought experiments which we can do. Let's skip all of that stuff, right? So let's take a qubit, convert all the complex numbers into the polar representation. What we will get is a nice graphic. So this is the general state. Of course, the constraint is that the magnitude squared should sum up to 1. I can write this as the length multiple times. Write this as the length multiplied by the angle. So the angle depends on which thing we are talking about. So either app or radar. Not only that, quantum physics tells us that clobal phase is not important, so we can take it out. Once we do that, we are left with really three quantities: the length of this vector, the length of this vector, and the relate between these two. Complex numbers. Now the constraint simplifies. There are three variables, but there is a constraint, so we only get the variable that we can describe the state of the qubit using two angles. There's a little bit of trick happening over here in the sense it's a visualization trick so that we can put everything nicely on the square. So, qubit lives on this three-dimensional sphere. It could be anywhere, infinitely many possibilities. Not only that, if I apply some operation, it will change its position. It might be here, and I applied x-cape to it. It came. Or rather, yeah, so this is the only way we can. This is the only way we can interact with qubit. We can rotate a vector and so on. So what does this rotation look like? Well, it has to be a matrix multiplication, but not all matrix multiplications will do the job. It has to be a matrix which preserves the length. And those matrices are called unitary matrices. They have complex numbers as the entries and the condition, technical conditions. So, one more time: the only way we can manipulate a system of quantum qubits is by rotating them on the sphere. In computer science, we talk about rotate, compute, rotate. So, I have covered the rotate part at this point. Now, I am going to talk about the compute part. How many of us have heard this phrase? Rotate, compute, rotate? Of course, you can. Maybe in a different danger, but I have a key. So, before I talk about the compute part, it's great that we have created this nice superposition which captures the properties that we want. But how do we get information out of the system? This is the only way we can get information out of the system. System. So, here is a little circuit. This is where we start. We apply this operator and then we do a measurement. So, measurement says that whatever is the amplitude squared of that would be the probability of observing the state. In this case, we would see zero state or one state with the same probability. They correspond to some physical. They correspond to some physical things in the system which I know nothing about. The catch is that once a measurement has been made, there is no going back. If the outcome is zero, then this thing is lost. This overholes lost. You'll only have a new state. There is no way of knowing what we came where we came from. So, here is a qubit in this particular state. If I remember my complex numbers right, then square of this quantity would not change the probability of observing this. So, if I perform the measurement in so-called computational basis, if I'm talking in terms of zeros and ones, I really get no information about this angle phi. Right? So, there is a way of measuring so that we know something about the relatives. That we know something about the relative phase. That is what the point of this slide is. If I want to know the relative phase, I can perform a measurement in a different basis, maybe plus minus basis over here. And what happens? Well, this is the state. If I want to describe 0 in terms of plus and minus, it's plus, plus, minus. I'm not really focusing on these alphabets. And this state is ket plus, minus, ket minus. And if we rewrite things the way we want them to be, then the probability of observing ket plus would be 1 plus e to the power i phi, whereas over here it is 1 minus e to the power i phi. I think this is correct. We will see two different outcomes with different probabilities, right? So it's not half an hour, which means we extract some information about the relative phase. It's a very, very important. The relative phase. It's a very, very important trick that we use in the sense all the time. So measurements can be done on a system of lot of qubits. We don't have to measure one. We can measure them all. We can measure any subset. Only catches that once we have a new state, the state should be. State, the state should be consistent with whatever the previous state was, and the amplitudes will have to be normalized. So suppose this is the state that we start in. The amplitudes I'm just indexing based on the decimal value of the state, right? So 1, 2, 7, and 4, the least significant bit is on the right, which might be different from any layer error from the right bit. So the condition is that the square of these amplitudes has to sum up to 1. Let's say that we made a measurement and 0 is observed. We made a measurement on the first amplitude from the left. And we were it has to be something of this type because other things are not consistent with the observation. The question now is what are these new amplitudes? These new applications are given by. Can we obtain by By maybe obtained by normalizing it, right? So all this happens automatically. So I talked about control mortgage which was over 2 qubits. We can define an avoxy. A control mortgage over 3 qubits. What it does is there are 2 controls. If both of them are on, only then this particular This particular qubit flips its state. So the output of this particular operation is given over here. It would be ZXR within bracket X and Y. It's okay, it's enough to describe these things for computational basis. If I wanted to control the flipping of this, Flipping of this state by 3 qubits, I can do that. How do I show it? 3 dots. There are 3 controls. So really this is a way of implementing AND operation in Boolean logic, computing AND of the computing. If this is why is this interesting, why is this important? This is the computer part. Take any Boolean function. Take any Boolean function. It has a representation in Z basis. I cannot spell the name out. It's also known as algebraic normal form. Where any Boolean function can be written down as an XOR of min terms. Each of these min terms can be implemented by one of the gates that we have seen. What is the type of the gate? It's a control. What is the type of the gate? It's a control, not gate. Simple as that. There are a lot of controls. Every Boolean function has that representation. So here is an illustration. It's a majority of 2. Majority of 3 functions. So if any 2 are 1, then the output should be 1, otherwise it should be 0. Let's not worry about how we translate it with this. Translated the description of the function to this algebraic number form, that itself is a hard computational problem. But suppose someone gave us this, then I can compute a circuit, I can compute a quantity, which will evaluate this function in parallel to all the possible inputs. This cannot be done classically. I cannot apply a Boolean function to all the inputs. A boolean function to all the inputs simultaneously in the class byport. But we can do it here. So take a Boolean function f, convert it to a geopolitical normal form, construct the quantum circuit using the C naught gates that we just talked about, and call that circuit U. That is the unitary that we obtained for a For applying computing Boolean function. So that function could have n inputs and a single output. We can generalize this to multiple outputs also. But the idea is simple. There is a quantum circuit which will compute in parallel answer to every possible query that we can provide as input. Input. If one specific x is provided, then this circuit tells me what the output is on this line. The state will reflect what f returns on that input x. This is the quantum parallelism part. We want to apply this to all the inputs, which means Inputs, which means we create a superposition using n, little n Adamat gates. This is our state, equal superposition of all the computational basis states. On each of these inputs, we will know what F produces as output, whether the output is 0 or not. This can be done, right? Just that you cannot ask the machine, can you tell me what the answer on X is? Because how do we extract information by making a measurement? It will say, oh, I'll give you an answer with this probability. It might be something, but I'm not interested in that, right? I'm really interested in F 0 0 0. But when I do a measurement, I get 1 1 1. Get 111. So that's the catch. We will deal with it later. But there is no classical analog of this. So there are a lot of other interesting pictures, circuits that I want to show, maybe three or four. One of these I will use in the last section. I think I'm doing time, right? I think I'm doing time, right? So here is a very simple circuit which will create an APR pair. This is very very very important for one-time path creation. So the initial state of the two qubits is here. After application of this Hadamard over here, the new state for the top qubit is here and bottom qubit isn't the same state. Qubit when we apply the x operator, it does nothing to the second qubit because the control is 0, but over here, the control is 1, therefore the state flips. 1, 0 becomes 0, 1, 1. So we can create two such things in a lab. One we can keep in the lab and the other one we can send to the moon. So Chandrayaan can transmit information. Information very secure defect. Here is another interesting circuit. This is where this comes from: simulation of analytics. If I have two unitaries, two matrices which preserve the lengths, then I want to compute this quantity applied to this state. And what can happen in general is that this. And what can happen in general is that this matrix addition A minus B might not be a unitary. So I cannot just apply it. Vodcom lets me only rotate things, right? If A minus B is not a unitary, we cannot apply it. But I'm interested in that. I'll show you why later. So how do I do that? This circuit will do the job. So of course A and B have to be given to me. These are unitaries. And they could be large complex unitaries. And they could be large complex unitaries, I am not writing the number of qubits, but that does not matter for this illustration. Only additional thing that I need is this definition of the kit is this. Still no complex numbers over here. Forgot to mention it. Complex numbers show up very little only in a few selected places. We can do a lot without using complex numbers. So let's see what really happens when the cell What really happens when the circuit is applied to this particular state? So this B operator changes the state 0 phi to an equal superposition of 0 psi and 1 psi. After which we will apply A, then B, then we will apply B again. Now this circle has a hole in it, whereas this one is a completely different. Has a hole in it, whereas this one is a completely occluded circle, right? So it's a control operator, but the definition is reversed. If the control is 0, only then this A is applied, otherwise not. So, because the control is 0, A is applied at this point, this point doesn't change. Over here, B is applied only if the control is 1, so B is applied. Control is one, so V is the point. State that I have. All good so far. Let's apply V again. So, applying V again gives me this state which looks like this. I am interested in the blue part. I am interested in this. What does it mean? If I measure and the outcome of the measurement is zero, then I am happy. The state of the second qubit is what I want. Q-bit is what I want, otherwise, I have to repeat my experiment. And of course, that happens with high probability with constant probability. So, we could so we will use the circuit later or something else. One more important quantum circuit, which is the basis of a lot of algorithms, the famous ones. So, So this section applies Fourier transform and the definition of Fourier transform is multiplication by this matrix where omega is the nth root of unity n happens to be this quantity. So if I give it a column vector with a single 1 in 0 in jth position and 0 everywhere else, then multiplication by this matrix will give me an equal By this matrix will give me equals over k. State in which the amplitudes are omega summed over all k. So we want to do this quantumly. Why do we want to do it quantumly? Because we save time and we save a lot of time in fact. If we perform this matrix multiplication on a classical computer, best in some sense. In some sense, we can optimize this a little bit more, but in some sense, this is what we are stuck with. This matrix has nice structure, so we can decompose it into parts and we can have login stages, we can define a recursive algorithm, in each state we need to go on and work. The total work done would be big go off and work in, right? So we want to get around this problem, we want to do it faster. Around this problem, we want to do it faster. Here is this quantum circuit, which does implement Fourier transform on four qubits. I don't want to get into the derivation, it's very easy. The important point I want to make is there is a repeating structure to this, right? So there is a edge here, there is a edge here. Here we have our two here. Here we have R2, here we have R2, here we have R2. Here we have R3, here V R3 and V R4, right? So if I kind of generalize this to n qubits, then the first row will contain H and N minus 1 things. Second row will contain H and N minus 2 things and so on. Number of gates that I need is little of little n squared at most. Not only that, all these gates operate on two. These gates operate on two qubits each. They are very easy to construct, at least theoretically. So, that is what we gain. What are these individual unitaries? Well, they can perform some kind of a rotation. If I give this index as 2, then the rotation would correspond to 2 over 2 if this index is 3. Right? So we have a quantum circuit which will follow. We have a quantum circuit which will perform this matrix multiplication and it looks a lot of savings, right? Little N compared to capital N. It's exponential amount of savings. What is the catch again? The catch is we know that we have done the multiplication, but if you ask for an actual amplitude for a corresponding computational basis state, we cannot get. Computational basis state, we cannot get that. But if the original function that we started with was periodic, then we can discover the period. We can find the period efficiently. And this period finding is the basis of several algorithms. So let me take five minutes to talk about only one thing. I'm at 35 and then I'll leave the remaining time for questions. So all of us have heard about kernel support vector machines. Support vector machines are, we are given data points, red and blue. We want to classify them by finding this plane. This plane should have some nice properties. The properties are that it should have a separation margin that is large as possible. Support vector machines, if such a separation is possible by having If such a separation is possible by a linear hyperplane, then it can be discovered very easily by using a simple update rule. For example, the person from the original days will give us this idea. In fact, the complexity depends on how quiet this time is. So, in some sense, support vector machines form the basis of the system. Support vector machines form the basis of theoretical basis of models, machine learning algorithms. So it's a fundamental problem. What is the catch? The catch is data doesn't have to be linearly separable from the picture. There is no way I can separate out red from the blue by drawing a hyperplane. It's a non-linear surface that is needed. But the kernel grid tells us that maybe some. us that maybe someone told us that don't work with this data, just project every point x to a two-dimensional point x, x squared, then we'll be able to draw a line, a hyperplane of this identity. So that is what the kernel trick is. Sometimes we get lucky, sometimes we don't get lucky, right? Most of the times we get lucky, let's put it this way. So we want to use these ideas. Use these ideas of quantum circuits, quantum computation to create a quantum kernel. What is a quantum kernel? I will define how it is presented in the tutorial on Mendelane and then we will come up with a new definition. So, this is my feature vector, and I want to encode it in some superprovision, I will superprovision state. So, from vector x I want to create a superposition vector of x, the wave is more than important, right. So, 0.3 divided by 2 gets equal minus sign, 0.3 divided by 2 gets 1. Similarly, for the second qubit, the rotations depend on this component. So, if I have a feature vector of length n, A feature vector of length n, then I need n qubits, right? And a quantum kernel, as described over here, would tell me the distance between these two vectors. Because that is enough to determine whether there is a separating multidimensional space. So we projected this little n size vector into 2 to the power little n size vector, and we are hoping that in that space there is separation, right? Data separation, right? This is nothing but the end of superposition and so on. The classical setting, the most successful kernel according to my students, is this radio basis functions. And it seems to work well on all the data sets that they have tried. What does it look like? It looks like minus gamma mod. like minus gamma norm of x minus y whole squared divided by some 2 sigma I'm ignoring that part I'm assuming gamma 2 is 1. Alright, so how do we create a quantum kernel which computes distance according to this definition? Well you load x into a superposition which is done with inside unitary shown on the previous slide. Star stable 0. Similarly for y we create k y. For y, we create kit y using a unitary that depends specifically on y. And then this quantum kernel that we want should give me this quantity, I'm assuming gamma to be 1. If we do a little bit of simplification, then this is nothing but the expected value of something where this expected value is exactly what you would hear, and if I write this nicely. over here and if I write this nicely out can correspond to the unitary for x the transpose the u dagger of x times u y plus u dagger of u y times the u dagger of x right. So unitary multiplied by unitary is a unitary and I would just say the sum of the two unitaries. Luckily we already know how to solve that. This was the circuit that would compute A minus B, right? So the state that we want to start with is not an arbitrary state startup. So minus the details, if we run this circuit and we make a measurement at this point, if the outcome is 0, then we will have the quantity that we want. That we want. So the quantity that we want would be the distance between ketx and kety in this particular space. So how good is this idea? So again, my students looked around and they said that this is a hard to deal with data set. It's notoriously hard, mainly because data is incomplete and there are some. There are some properties intrinsic to the data set. So there are a bunch of features, and the goal is to predict whether the individual has that contract. So we can do this business of feature selection and for creating get X as those states we use angle image. We use angle a little bit. There are a lot of options over here and I can go into the details but this one will let's don't um and compare the accuracy of the classical regular basis function kernel with the quantum RB kernel. The numbers are over here. These numbers are not bad, they're actually good. The data set is so hard. And it's a tenfold accuracy test or something like this called standard. Once we evaluate There is a clear-cut improvement, right? Improvement is small, but it does do better. Not only that, the number of features that are needed is not small, but resources are not. But the work was done by the Mitex intern this particular summer, and he's in the process. This summer, and he's in the process of writing it. I'm just putting one slide up. He has tried a bunch of other data sets. The idea seems to work well. Okay, let me stop at this point. I have a few more slides, but we'll stop. Thank you.