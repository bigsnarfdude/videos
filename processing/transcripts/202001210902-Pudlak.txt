So as usual, why just start by thanking the organizers and thanking your organizers to let me speak because although I am an organizer, the other organizers asked me to do this talk. So I want to talk about that one frame. Uh that one trade and resolution, uh I'll explain why uh this is uh uh why I'm interested in this particular case. Of course we are interested in the Freaka system for every fixed step, but this seems to be the case where we can where we might be able to understand better what was. What's going on? So you don't record the sending seat first? So it should be recording and process. So here is a brief overview. I will denote by F sub D the W D Frega systems. Depth the Fraga systems, which means that targeters have depth 0, conjunctions have depth 1, and so on. So one pregnancy system can be viewed as a resolution where instead of literals you have also conjunctions. And in particular resolution can be also as F0 system. System and this is usually referred to as frequency stance, but it should be called more precisely sequence systems because it's almost always formalized using sequence systems. I'll start with the concepts of canonical and interpolation. And interpolation pairs. So these are Eastern NP pairs that are associated with proof systems. The first one was introduced by Sasha in 1994 and it's a pair of sets where one set essentially are satisfiable. Let's assume just C and X. In general we can define it for In general we can define it for any formula, but for this purpose we only consider CNS. And B is essentially a set of CNFs that have shown replication to but it's more uh precise to formalize it using padding as it is uh done here and this is how uh Seychelles uh define it. Shall define it, but intuitively, you should view it as satisfiable formulas and formulas that have short refutations in the system. A related concept is the interpolation pair of a proof system P. This consists of Each set consists of a triple, where the first two elements are say CNFs and the third element is a refutation of a conjunction of these CNNs and they They differ in which of these is satisfiable. So it's possible that none of these is satisfiable, and the pair is disjoint because there is a refutation, so that they cannot be in both formulas phi and psi satisfiable. So this is there, and this is called interpolation there because it's because it's uh uh essentially uh connected with uh interpolation in two systems. Now the first concept uh polynomial separability means that the canonical of the canonical pair means that the proof system is automatic. That uh sorry uh uh weekly automatical. Uh I I I will keep forgetting this weekly, so this is the first place and so this should be weekly. And the other is if the interpolation pair is polynomially separable, then it means that the proof system has feasible interpolation. I think this is I think this is well known that the automatic automatic of proof system is equivalent to the separation because if you have this algorithm that separates it, you can view it as a kind of proof system that you have. Or you can start with some proof system and add this algorithm as additional means to prove some. Means to prove some refute some CNS. So, Pavel, just to remind us, a weakly automatizable would mean that if there is a short proof in the proof system, some stronger proof systems. So, the official definition of weakly automatable is that there is a possibly stronger proof system which is automatable. And Automatable. And as I said, this separability means that you can use this separating algorithm to define this stronger fixed state in which you can argue set or a stronger core system that is automatable or it's probably a reality, right? Every proof in the weaker core system can be converted into the stronger core system. You don't require that the stronger core system is automatizable. The stronger process to this automatizable. But this is the definition. Thank you. We know that resolution has feasible interpolation. It was proved by Krajƒçek and independent. By Krajiczik and independent by Pitasi and others beside everybody. And also we know that the canonical pair of a proof system Fd is equivalent to the interpolation pair of F D plus 1. Equivalent in the sense that there are Equivalent in the sense that that there are polynomial reductions between the pairs. Uh I'm not going to define these reductions because since they they are obvious uh of course you you may have two kinds but uh basically this is a kind of uh many-one production between the pairs. So it suffices to focus on one kind of these. I will focus main on the interpolation pair of F1. And the problem is is this interpolation pair of one polynomial separable? And the same question is if this canonical pair of x0 polynomial is separable. In light of new progress in finding algorithms for everything, now it seems that it's not. Now it seems that it's not uh so much uh uh excluded that uh it it could be, so it was a polynomial separator. But uh we'll see more I will talk about uh the games and relation to uh to this uh NP pairs. Uh if we have a combinator We have a combinatorial two-player game. We will suppose that uh not only the game is defined, but also that there is a concept of a positional strategy and of positional strategy, and such that if that one can decide in polynomial time whether the strategy. Whether the strategy is winning or at least in NP. So if you know that it's in NP to decide whether there is a positional winning strategy, then we can define a pair which we will call a canonical pair of the game, which consists of the set A where Of the set A, where the first player has a positional winning strategy, and B, where the second player has a positional winning strategy. Now, why are we interested in positional strategies? So, this will somehow follow from the simulation that I will talk about. But a general reason is that if you have a combinatorial game, then If you have a combinatorial game, then very often again uh i the decision problem the decision problem who has a winning strategy is uh P space complete. But if you have uh positional strategies then they often have this property so you you get a concept which is of lower complexity. We can uh characterize uh the canonical, which is the same as interpolation pairs for F D for every D by certain games. So this is something I already talked about uh some time ago, but I I just had a sketch of this uh proof and now I was able to to finish this proof. To finish this proof. And as I wrote the proof, I realized that in fact it may be possible to extend this characterization to the fragment systems. So we'll have also, if this is true, then we will also have a characterization of canonical tires which are equal to interpolation pair of. Interpolation there of Frege systems. So this is one way to characterize this. These are certain games which are just called F D games. And D is shifted by one. So for every F D, every game has f D plus one. But this was preceded by a characterization of A characterization of the canonical pair, which is uh the interpolation pair of uh F1 uh by uh the so-called uh point line game which we did in our joint paper. Now I want to pass from uh decion and p pairs to uh monotone Boolean functions. uh monotone Boolean functions. Uh because we want to have uh something l like uh a generalized concept or of a circuit. Uh these pairs are uh if you consider NP pairs then uh this is something that we can hardly view as concept of uh circuits and if we especially if we want to prove some lower bounds then you we would like to have something that is monotone. Something that is monotone and possibly works for wave functions. So what we can do is the following. Suppose that you have a certain definition of a game, a class of games, and the definition is such that there is some parameter in the game, which is a string of zeros. Which is a string of zeros and ones. Of course, you can every finite structure you can represent as a string of zeros and ones. So, in principle, in every game there can be something like that, but we want to have something that is more natural. For instance, we have a game where we have certain structures, say the graph. Structure, I say the graph is fixed, but there is an initial position where there are some pebbles or something, and the position of these pebbles can be represented as a 0, 1 back curve. Or we have different concepts, some game which ends in some position, and then we can decide which positions are. We can decide which positions are winning and which are not winning. So, this also gives us a vector of zeros and one by which we determine which positions are winning and which are not. So, then what we can do is we can say let's take one of these games and forget what is the state initial position or what the initial position or what is the the set in position and take it uh as uh as three variables. And then we can uh define a Boolean function by uh in the following way that um we say that f is one if uh player has a winning positional strategy we substitute some zeros and ones for for these uh For these parameters, and FA is zero, if player two has a winning strategy for these parameters. But as I said, I will focus on positional winning strategies. So this may be the partial function because there are games where we do have this concept of positional winning strategy, but not every game. gain has a positional win strategy again some win strategy by the well-known theorem but for positional strategies this is not not the case. So this defines in general only a partial Boolean function. What we also want is to obtain a monotone Boolean function. Obtain a monotone Boolean function. And this is indeed the case if the string determines the winning positions of one player. So suppose that once will be winning positions for player one, then this clearly will be monotone function because if there are more winning positions, then clearly Then clearly player one wins in four cases. For the point line game, this will be different because this game is a game with pebbles that are moved on kind of a board and each player has one player has a say black tubbles, the other has wha white tables. white doubles and we will see that also in this case we get a monotone function. You're going to explain the point line A? Yes. And also these also length to P now the last thing to observe is that this concept of Of game scheme defined in this way enables us also to compare the game schemes. And if we want to only have monotone concepts, we will consider only monotone projections between the games. So we will we can compare uh uh these uh These computational devices by projection in the natural way. So let's start with the, before I define the case for that one, I guess it's then let's start with a simple example which is this uh uh a monoton Boolean circuit. Uh we usually view uh the monotone circuits were defined as something that computes. You take some input and then compute values and your output. But you can also view it as a game. But then instead of going Then uh instead of going from inputs to the output, we should go from output to the inputs. And as again, monotone Boolean circuit, of course we can do it also for non-monotone, but let's just use monotone. It's a game where you have two players, one player denoted by OR, the other by and by and uh or wants to reach an input which is later one uh and uh he decides where we go in the graph of the in the back of the 30 on nodes which are labeled by the junction and the other player decides where to go on nodes labeled by each conjunction uh and uh And uh uh the goal of or player is to reach an input with one and the goal of uh end player is to reach an input zero. So this is uh this is clear but it's it's good to have it in mind and if we uh remove uh uh well what we what we actually do that we What we actually do, that we consider a circuit without a particle input, then this game is transformed into a game schema, and this is the Boolean circuit. So this may look like a very special thing, but most of the games, if you define games in a easy way, then then they are equivalent to this concept. To this concept. One thing to observe here is that we don't have to care about the positional strategies in this case. That if you view a Boolean circuit in this way, then it has the property that if somebody has a winning strategy, then he or she also has a position or winning strategy. And if you just think about it About it, the player decides, how does the player decide in a particular node? So he looks what is the value in this node, say the or player. The value is zero, then this is not a main position, so it doesn't matter if the value is one, then uh he computes the values of the predecessor uh and goes to the vertex whose value is uh one. So he doesn't need to know how he got to this particular node. He just knows where to go from this note on. Just to have some exercise about positional strategies. Now, so here is something that looks a bit more complicated, but what what it says is What what it says is uh basically that uh we can uh transform uh this characterization of uh interpolation pairs into a sort of uh monotone interpolation theorem founded at Frege, where the gadget that is used for interpolation is not a monotone circuit but uh are monotone are are uh uh depth uh uh uh D plus one uh uh game schemes. So was it that D plus one game scheme? I will not define it. I will define only depth two game. And then it will be clear how to how to define. So I state this generally but I want to focus on depth one because then it's uh much easier to explain. It's uh much easier to explain it, and uh it's easy to internalize. So, the situation is the standard situation for interpolation, that we have uh two formulas that have common variables. So, what is maybe what may be confusing is that the common variables are the second string of variables uh which uh usually write as the first string, but anyway, so As the first string, but anyway, so they have common variables z, and x and y are disjoint set of variables. And we have a refutation of such a CNF. And then it's possible to construct a polynomial time that the game scheme such that for every assignment if phi xA is satisfied other than Is unsatisfiable, then player one has a positional winning strategy and and so on. So in in terms of this function associated with this game scheme, then this function, this partial function interpolates. And this is in polynomial time, so this implicitly means that the size of means that the size of this game scheme is polynomial in the size of the proof. So one can of course prove something like that, but is it useful? It's not clear. So let's look at a special case of Dep2 games. Let's define what a Depth II game is. There are two players that alternate That alternate by filling two times m matrix. So we have two strings, u1 up to um, v1 up to vm, that are constructed by the players. So say the first player start with u, then second with u2 and so on. But the point is that when they get to UM, they pass to VM and go. they pass to VM and and go backwards. Of course there there are some rules what the they can play and the rules are supposed to be local. So in the first row what a player can play depends only on I and on the previously played symbol. In the second row it is slightly different It is uh slightly uh more complicated because it uh uh EI uh goes after Pi plus one because we go backwards and uh legal move is determined not only by Bi plus one but also by Ui that is the symbol which is in the matrix of Bi but it's it's local But it's it's local, it does not depend on larger context, on this small context. And there is a set of winning positions, W which are winning positions for player one and this is what player one wants to get. And play player two wants to avoid W. Now W. Now here it is also added positional strategies, which means that what is a positional strategy is defined in the same way that a positional strategy should also be defined locally. And localization is exactly the same as the localizations of legal moves. So we can say that a positional strategy just just reduces possible little moves to something that enables the player to win. A is a parameter, capital A is a parameter of the game? Okay, A is uh a set of uh symbols and uh uh it's a it's a parameter uh in the sense that uh the size of A That the size of A also determines the size of the king. But we can also view it in such a way that the parameter is m and a is polynomial size in m. So A is not a finite constant size set. If you you should think it is a polynomial size set in M. What values they are writing? Sorry. What values they apply to this matrix? I mean, just simply. Sometimes it doesn't matter. It doesn't matter. Why here we don't have positional strategies meaning in the ordinary sense without UI in the second item? It's just a positional game, right? Forget about your interpretation, it's just take. Interpretation just take longer or something. Yes, this would be positional in a very strong sense. But we need this in order to get the connection with Fregas proof. So, but it will be perfect. Yes, so this is an ad hoc definition uh intended for okay, the one Fergus system is not uh not intended to to be. the most pleasing or most satisfying. But it will be clear that it's natural. So this is one way, well, I mean the main way how to define the game and so I proceed this time. So I proceed uh this this W is the uh uh that the thing that that we can uh view as a parameter and if you want to get a gain schema then uh then we uh think uh this boundary as a string of zeros and ones uh which then determine what uh we'll have uh uh Have winning strategies. Now, here's maybe a more attractive definition which is equivalent, but state it only vaguely so far. Suppose what what the player do is do something. Do is something different. They also have two rounds. In the first round, they alternate constructing a monotonous Boolean circuit. Each of the players constructs a piece of the circuit, and then another player constructs a piece of the circuit, and so on. And after they finish constructing the circuit, then the second round will be playing the game of this. Playing the game of this circuit. So, of course, if the game is just a circuit, they don't have to play because they can just evaluate the winning strategy in the circuit. But formally, the second round will be playing this this circuit. What does the legality correspond to when you're constructing the circuit? So the legality will be used. I go with more detail how this is constructed. So to state it precisely, we should think of a circuit as a straight line program. A straight-line program is given by a string of instructions. These instructions are of the form a variable at the white k is the interjunction of say conjunction of itself and YP or this junction. And now what the legal moves will be sets of these instructions, say just without lots of generality, just a pair of these instructions. So if if this is at this step, say the first player is playing, then he will decide whether And then you will decide whether you will add this instruction or on this instruction. So UI is an instruction. UI from the previous definition will be a very good thing. And so the there is a fixed set, but not a constant size set, because it involves So the set of all the principle extractions polymer size. And at every step we have a choice. But in every step we can assume that there is only finite number of possible instructions. But we don't have to. It may also be just It may also be just uh larger. So this uh it's not uh not really important. But let's just uh first tell us the think of the situation when there are two two possible instructions between which the player chooses. Then it will be not an arbitrary. Not an arbitration. This is fixed uh uh the uh the game is uh given by these sets i sub i, which are sets of uh instructions that the player can actually play. How does the like depth parameter play with this? I assume this is the depth version for depth. Yes, so to take the uh let me just finish this and come back. Let me just finish this and come back to your question after that. So I I just want to say that uh they they should construct the oh sorry they shouldn't be in a circuit not program. They should construct the circuit in the reverse order not starting from the input of the circuit but from the output. Outputs. Because if they did it in the natural order, then this concept would end up to be equivalent of circuits, which may be something like that, but the problem would be that it wouldn't be useful for us if we were connected with the point like the yeah, so there was a question what to do in in in general. Maybe a weak question. Uh let me just answer. Let me just answer question even. So in in general the metric is not not two by two. It's uh a metrics uh D by M and they go back and forth. And the locality is the same in the sense that it depends on the previous but it will depend on the on the entire column above So, in terms of this characterization of circuits, it would be like the first round constructing game of dev two and then playing the the game of the That was bit queer question, but like if they know I, why the last player to move? I mean, the one who is deciding V1? The player that decides V1 always wins, right? Essentially, because his or her strategy depends on I and so this player knows that it's going to set V1. In this definition seems that the you can determine who is winning by a You could determine who we did by adding just very simply just is it odd or even that was also a missing moves means which is intervals of the game there are rules which I'm possible with. There are rules or currents always to rules in this that the big almost are determined, so this is like even in the determined. Oh, so it's not so player should make a decision, but there is like some function it's really functioning, yeah. Yeah, yeah, it's not difficult. There are many games of this kind. One is not just and not just W. But these rules that they have to follow. So when they build a straight line program, they can only choose an instruction that depends on the previous instruction? Yes. And how about the input? What input do they evaluate the circuit on? So they build a circuit and then they have to evaluate it on some input. So how is that input chosen? Yes, so this input is the parameter. I see. So that how do you do? Parameter. So the W. This W. And depending what it is, we get this width function. Okay. So now, so let me just mention which I will need later on. So here the player just decides between this instruction and this. Instruction and this instruction. But of course, everything can be generalized, so we can allow situations where the player will have not just choice between which instructions he would play, but between a string of instructions. So uh either he would play several instructions of this kind or several instructions of that kind. So this is something that we will need later. Is something that we will need later now to the definition of the point line game. So this is also at first complicated, but I have an animation which I will demonstrate. A puddling game is given by a deck which has nodes and arrows. And nodes again belong to belong to one of the players. In this game we will have a player black and a player white and they and moreover a node has an internal structure which is just a set of points denoted by PA. If we have a possible transition from A to B in an arrow, And arrow from P to B, then there is also a partial matching given between P A and P B. There's some matching that is a priority given. We suppose one source where they start and we suppose that uh each thing has exactly one point. Uh velocity of generative we we may assume that there is just just one thing but uh Just wanted to look at the animation several things. The game starts with some black and white pebbles on the points of the source. And then what players do, they only decide which arrow to follow. If the node belongs to black, then black decides which arrow to use, and otherwise white. And otherwise, white. And the pebbles then are moved along the lines in a determined way, so they don't decide how to move. Apparently determined by what tablets are on the A and what are what is this partial matching. So let's have this example. So now I uh I So now I uh I uh recycled some uh previous uh slides uh which uh have efficiency that I didn't write arrows between uh between nodes. So nodes are rectangles here circ these circles are uh points and And when I drew lines between points, it is assumed that there is an arrow between the notes. Also, I don't have black and white, but I have blue and red. This is of course not essential. So the the game starts like this. The game starts like this. Now many things can be simplified, but in this case the situation is that sometimes there is a point which is not connected to anything in the node which is connected by an arrow. Connected by an arrow. So in this case, here the blue player starts, and if he goes here, then the red player will get this. So this is an additional rule to fill in all the all the points. That if we have a That if we have an arrow, an arrow from this node to this node, and now if they decide to go here, the red one is to go here, but we should also say what will be the color of this. And we say that this color will be something that the other player can claim. So if the blue player decided to go here, then the red player can claim this. What's going to happen? What's gonna happen with the pebble that stayed on the first knot? Like this blue pebble, what's gonna happen with this? Uh nothing. So it will be removed. But in this animation it will stay there. Okay. So now the blue player thinks, okay, if I if I go here then I will have a And I will have a blue purple here, because here we just move blue here and red here, which like this. But if I went here, then this will be red and this will be also red. So it's better for me to go there because I want to keep blue. But then um and then red red player decides. So red player decides to go here and now uh red player wins because the there are only l lines from red to go uh to the uh to the sinks. The sinks. So, in spite of using this greedy strategy, that player wants a greedy strategy is not the best strategy. So, what is so in this I I don't don't have an animation for for uh the good strategy, the the the the the winning strateg actually here uh Winning strategy here, one has a positional winning strategy, which is actually to go here. And then he will definitely, if he goes here, he will definitely get these points. And then he can... Alright, but let's time is passing, so let's consider a different way of playing the point line game. So now So now the player what the player does, they just decide where to go in the crowd. They don't move pebbles, they charge automatically. So they decide where to go. And suppose they will start with certain pebbles and the initial and they they would not move these these pebbles. They they will set aside and construct some path through a slice of path to through the uh to to some sink. And after they reach the sink, only then they they would check which pebble actually would get there if they moved. And how did they decide? They would go backwards from that node along the path and see where they end up, in which what would be the colour of all the pental data. colour of the penalties. And this is what we can use to show this proposition that point line games and depth schemes and depth two game schemes are reducible to each other. Because let's we would Let's uh we will use this uh characterization of depth two gains by uh by construction of circuits. So uh what we will do will be uh we take the point line gain and um fix uh Yes, nice. Uh introduce the initial configuration. The test two the parameters are going to set up. So now this way of going in the point line game in one direction and then going back, we can view the construction of the path we And the construction of the path we can do as a construction. Let me just just finish this. So then let's go through the pl so the the actual uh So the actual certity that we will construct from the point line game will be surprisingly simple. The players would not use instructions other than substitutions. And these substitutions will correspond to these matchings. And then going back in the online game, finding Finding out what is the color that should have ended up will be evaluation of these instructions. So this shows that while the definition of the Deptuian seems to be kind of strong, that you construct an arbitrary circuit, and it's difficult to construct a circuit and guess what is the Deptuan. The circuit and guess what is the right thing. So, here we construct a very simple circuit, just a circuit that needs a variation of some substitutions. So, this shows that it may be after all not so strong. But of course, we have also the opposite simulation. So, in spite of the fact that uh point line in this uh way the Well, this is such a simple section. It can might be the form of that thing. I had to skip this uh concept of generalized circuits and uh  Which means also the interpolation pair of the one fragment. So let me let me show this slide here. So if you take depth one, get one fragment, then you get this sort of marginal interpolation either by depth two games or by but the converse is also true, is it you can reduce depth two games to yes. And are all these games P space complete if you don't um impose positionality constraints or Imposed positionality constraints or point line games in this model as well. Could you say some words about what part of the proof in the depth to gain correspond to the matching in the point wise game? So where that matching is coming from? Well essentially uh what you what you have uh are uh are are formulas with which it uh which are disjunctions of conjunctions. Of conjunctions, and somehow you like in resolution, you follow kind of logical dependence. So this infrastructure corresponds to which conjunctions goes to which conjunction in the previous step. But uh very roughly and uh Do you have restricted versions of the games that actually solve efficiently? One uh trader case is uh if the four-line game is uh tree-like then uh actually uh we get uh more uh more formula. No more questions? Could I stand playing to turn off or anything? Oh, it's stopped. You wanna hit the other button on the right? You wanna yeah, hit that one. Yeah, hit that one. Yeah, the middle. Yeah, and now you probably want to put the projector on unless.