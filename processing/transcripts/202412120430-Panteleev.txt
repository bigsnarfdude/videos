Okay, okay. So the title, the title is shift codes, and so I'll try to explain to the best of my ability what are shift codes. And so actually this project was so when after we discovered this asymptotically good QDPC code, so there was a question. So, there was a question how we can understand them from the topological point of view. So, usually the standard way how we obtain LDPC code, as I already mentioned, so we have some topological space, we have a finite cylinder, and we produce LDPC code. And we already saw that we can do this for. We already saw that we can do this, for example, with Tori code. Yes, and in this case, so we have a Taurus fine installation of a Taurus, and we get this QODPC code with this standard graph. And so the question is, okay, so for Toric code, it's quite easy to understand what was the topological space. It was a Taurus. It was a torus. But the natural question is: what was the topological space behind this, all these goodQDPC codes? And this is a little bit tricky because, so they, of course, they are defined on some special square complex, which is kind of a topological space. But these codes, they also involve some local codes. If you remember my Calls, if you remember my previous talk, and this complete significantly complicates all this. And so, in order to do this, in order to work with these new codes using standard topological methods that were already applied to codes like surface codes, so we need to understand them better from this point of view. So, and the shifts that was in the in my title, it's a standard notion from algebraic topology that, in my view, completely answers this question. So, the answer to my previous question is that these codes can be considered as if if you want to interpret them topologically, so we we can consider them as shifts on some finite posets. Some finite posets, and you should take into account that finite posets are almost exactly the same as finite topological spaces. So it's almost exactly the same notion. So it's a topological space with finite number of elements. And shifts on these topological spaces are exactly the topological spaces that we are looking for. And by the way, so shifts. And by the way, so shifts, it was well known that they are also topological spaces. So, in some sense, shifts are generalizations of coverings. So, we can view them as some generalizations of coverings. I don't think I have a lot of time to describe in detail what are these shifts in algebraic topology. So, maybe first I give some ideas. So, first, I give some idea about the interpretation of quantum LDPC codes as topological space. So, as I previously mentioned, so we can convert, for example, some topological space to Q of DPC codes. But it is also natural to ask whether if we have some quantum or DPC code, can we convert it? DPC code, can we convert it in some kind of topological space? And in fact, it is possible. And so the answer is yes, so you can do it. And the answer to this also related to POSETs, partially audit sets. So the approach is here is very simple. So we just interpret this quantum or DPC. This quantum LDPC code as a posset with three levels. So, this is the lowest level, this is the middle level, this is the highest level. And we say that, for example, Z is below then this qubit, and this qubit is below then this X. And of course, this Z is below than this X because we have a path here. So, this is a perfectly defined poset. And in theory, In theory of posets, there is a standard notion. So, since every poset is a topological space, then it is also known how to construct some kind of topological space that represents it. And the standard construction is what is called order complex. So, order complex is a simply show complex. Complex is a simplicial complex that is constructed in a very simple way. So we just consider all possible chains and we say, so our simplexes are all these possible chains. So for example, in this case, what chains we have? So the maximum length of the chain here is three, yes. So we have simplexes that corresponds to this path. And so we also have simplexes that correspond. Have simplexes that correspond to such paths, yes, or such paths, or we have simplexes, so vertices that correspond just individual vertices of this graph. So and so we can apply this procedure to every QODPC code, and you obtain a simplicial complex, a topological space that you can work with. And you can ask, for example, a question if you have. Question: If you have some quantum LDPC code, if we interpret it as a topological space, what is its fundamental group, or was it some other characteristics? Yes, and in fact, you can answer to this question. So, if you convert them into other complex, so you can answer all these questions. And this kind of different approach from the Approach from the one that was proposed in the paper by Friedman and Hassen. They also proposed some methods how to construct manifolds from quantum codes. But here in this project, I describe here, so we do not construct manifold, but we construct two-dimensional simplicial complex. And what is also very interesting is that we can reverse this process, and maybe this is. Process and maybe this is even more interesting. So, we can start with the poset, yes, and we can convert this poset into a topological space, yes, into this simplicial complex. And then we can interpret this simplicial complex, since it's a final simplicial complex that has homologies, and we can interpret is as a QDPC code. So, we can do, so we can also work in a reverse. Also, work in a reverse direction, and why it is interesting because we can construct quite easily random posets. Yes, because possets are usually just defined by some graphs. And so this gives us a very general way how we can construct QLDPC codes. Because if the graph of this poset is sufficiently sparse, then we always get here sparse. Get here sparse code. Yes, so we'll also have this quantum LDPC code. And the open problem, of course, can we also get, for example, asymptotically good QLDPC code just by considering random posets? And I actually don't know the answer to this question. But now let us return to the shift codes. So what is the shift? Yeah, yeah. Yeah, yeah. Yeah, so there in the previous slide, so you have to look at rank two posits only? Oh, no, no, no, no. In fact, you can look at any post-so you can just in this positive, so when you construct simplicial complex, you can use whatever homology you want from it. So it may be, yes, it may be, so it can be any process. So it's absolutely. Thanks. Absolutely. Thanks. Okay. And so, what are the shift codes? So, I don't want to spend a lot of time to define what is a shift, and I'll try to explain what I mean by shift code. So, a shift code, in fact, it's a very simple idea. So, it's just some kind of tanner code with, and we know that what is tanner code? Stan Tanner code is just a code where we have. Just a code where we have some local checks. Yes. So we have, so we define this shift code by a set of local checks. And these local checks, they are parameterized by some set X. And this set X, it's not only set, it is, in fact, it is a POSET. Yes, so the indices of these checks, of these local codes, they are elements of this POSE. This poset. And so we, since it's a posset, so we have some hierarchical collection of constraints. And we also have this special restriction, special properties that we require that whenever we have some code word that satisfies some local check, this one, it also satisfies all the local checks. satisfies all the local checks that corresponds to the elements that are higher than this one. So in some sense, the higher element, the smaller the constraint here. So this is the idea. And the maximal elements, they correspond to the trivial constraints where we just do not constrain. So it just Just do not constrain so it it just involves one bit and we do not constrain it at all. So it's just um for the sake of uh so so it's so I just need it so because the theory with this kind of trivial constraints is much is much better. And so here we have some uh kind of co-dimension. So this is the smallest constraint. They have co-dimension zero. These constraints from Constraints from this second level. Yes, they have codimension one and etc. And here we are using these local constraints, so we can define what is called section. So in the theory of shifts, it is called section. So when you have some set of constraints, so u is the set, is a subset of x, and x is the index set of constraints. Yes? Constraints, yes, so it means just we choose some number of constraints, and so we look at these constraints and we just look at all the bits involved in these constraints and we apply these constraints. That's all. So it's just some subcode, yes, that satisfies all the constraints from this set U. So it's a very simple notion. Notion. And so let me give you some simple examples. So, for example, if we have a Tanner graph code that I describe today, so when we have constraints in vertices and we have bits on edges, so in this case, so we have one level trivial constraints that d yes, that corresponds to individual bits, and we have an another level that corresponds to these vertices. To these vertices. And as you can see, so the co-dimension of these smallest constraints is equal to zero, and co-dimension of this is equal to one, which exactly corresponds to this case. Yes, because here the maximum dimension is on edges, and then we have vertices. So, vertices have co-dimension one and And edges have co-dimension zero because they have the highest dimension. Yes? Okay, but we can also do this with other kind of codes. For example, if we consider product code that we described previously and talk about it. So we can also describe it with a collection of local constraints. But here we have more levels. So here we have individual. So here we have individual bits levels. So here we have these lines levels and here we have also the whole code level. So sometimes we also add this level too. But so in simplest cases, so we just consider this as a special case of the Tanner graph. So it really depends on so sometimes we use it in this way, sometimes we use it in in in in other way. In other ways. Okay, but why these shift codes? They are classical codes, and why are we interested in them? And first of all, we are interested in them because using these hierarchical, classical codes, these hierarchical constraints, we can construct quantum codes. And the idea is very simple because in shift theory, when we have a shift, since it's a topological space, we can study its. We can study its homology. And so we can define the homology groups for every shift, which means that we can define a quantum code for each shift. And what is interesting that, so we can also consider the special case when all the constraints, these local constraints, are repetition codes. And if they are repetition codes, then in fact, this definition. This definition corresponds to the standard notion of homology. So, if X is, for example, some post set that corresponds to some cellulation, for example, of a torus, yes, then if we consider if all local codes are repetition codes, then this shift cohomology is exactly the cohomology of this cellulation of Taurus. So it gives exactly. Torres. So it gives exactly Tauric code if we interpret it in this sense. So here we can see how we can get this. So we have a torus and we have bits on these squares. And so we have local constraints here. So our smallest constraint, yes, then we have constraints that involves two consecutive bits. And here we have a constraint that And here we have a constraint that involves four related bits. And if we consider this hierarchical collection, yes, with three levels, and we construct this shift homology of this. And so here I give a formal definition how we define this boundary, a co-boundary. Boundary and co-boundary operators. And so if we apply this, so we obtain exactly the Toric code. And why, but my talk wasn't about Toric code, my talk was about asymptotically good QDPC code, why we are interested in this. And this is because recently we found some interesting. Recently, we found some interesting property of this shift code that seems to be related with the local properties that we need in order to construct good quantum LDPC codes. And so we call this property extendability. And so let me explain it. So suppose you have these shift codes, yes? So hierarchical collection of local codes. And suppose you choose. And suppose you choose some subset of these constraints. So they are shown in red here. So you look at the bits that are involved in these constraints. And for example, you can find a code word that satisfies this partial code word that satisfies this subset of constraints. Yes, and so we say that this. So, we say that this set of constraints is extendable if we can extend every local code word. So, we call this a local code word when it satisfies only local constraints. So, if it satisfies all the local constraints, we call it local code word. And if we can extend every local code word to a global local code word, then we call this set of constraints extendable. And let me explain it. And let me explain it a little bit more geometrically. So, for example, here, so we have some picture of some object that kind of satisfy our local constraints of a normal object. Yes, that can exist in physical reality. And here is another picture of the same object. And again, it satisfies all the local constraints that we show here. And here, and the same here, but Same here. But when we consider the global code, yes, so we see that, so we cannot extend all these local constraints to a global constraint. So they cannot be all simultaneously satisfiable. So which means that it's not always possible to extend every subset of constraints. And so we call this shift code. We call this shift code maximally extendable in some class of shift codes. If, whenever some subset of constraints is extendable in some code from this class, it is also extendable in F. So in some sense, it's maximally extendable shift code in this class. So it extends every subset of constraints that you can extend somewhere in this class. And so an easy observation is that that subset of constraints is extendable. So here I take the subset of trivial constraints, the smallest constraints, yes, that corresponds to individual bits. So a subset of constraints is extendable if and only if it is an information set for the code. Yes, an information set, it means that we can put any bits we want. Yes. bits we want yes and we after that so we can extend it and so information set so you you can easily check that this corresponds to information sets so what what does it what what what it means so what it means that maximally extendable codes uh implies that they also maximally recover That they also maximally recoverable. By maximally recoverable, I mean that if we have some information set in this code, in some class, then we can always, if it is an information set in some other code, then we can always that it is also an information set in this code. And such codes are called maximally recoverable because they can recover irrelevant. Because they can recover erasers. So, all the erasures that you can recover in the code in this class. And so, and the particular example that we consider here, so for example, if we consider all the codes, all the product codes with some fixed parameters, like we multiply, so we have a tensor product code and we fix the dimension and the lengths. Lengths of the component codes. Yes, we have some quite large class of codes, and we can say that an element of this class is maximally recoverable. Yes, if it can recover from the erasers, from all the erasers that any other code from this family can recover. And such codes are very popular in storage applications, and it looks like that. And it looks like that these two notions are very well related. And in fact, so right now we don't know, maybe they are even equivalent. So right now we don't have any counterexample that says that maximally recoverable code, it's a very well-known notion, it's different from maximally extendable code in the case of product codes. And so let me maybe I'm a bit of time, so let me Let me go a little bit faster. So, this property, as I said, is very well related to our problem that we are trying to solve. So, we are trying to construct quantum locally testable codes. And here, I give you the definition. If we have a parity check matrix, what we mean by locally testable codes. So, if it's ODPC. Testable code. So if it's LDPC code, then the definition is very simple. It means that the syndrome grows with the error that happened to the code word at least linearly. So which means that if we have small syndrome, a small number of unsatisfied checks, this implies that the error that we have very small error. And not every call have this property. So when very well-known example that has this. Well-known example that has this property is a Hadermart code. Okay, but let me go further. So, here, so the natural question, for example, if we have some, for example, repetition codes, so we can ask whether it is locally testable or not. And the answer to this question is not very obvious one. So, from and the actual answer, it depends. Actually, answer it depends because if we represent this code by this standard parity check matrix, then you can easily see that it is not locally testable because we can find error, very large error that has a very small syndrome. Yes, you and you cannot find any other error that produces this syndrome. So, here I showed you. So, checks are on the edges and Are on the edges and bits are on the vertices. Yes, and so here, so this is just an interpretation of this perity check matrix. And you can see that this soundness parameters, it kind of corresponds to the size of this cut. Yes, the syndrome is just the size of this cut. And this is exactly how this problem is related. Related, so it shows that this problem of soundness, yes, find a good soundness, it is directly related with what is called Kaboundary expansion. And so, particularly here, we can consider Kaboundary operator, and so we can see that it exactly corresponds to the problem of finding a graph with With very large sparse graph, with very large cuts, so that produce very large cuts. So, whenever we divide this graph into parts, so we have very large cards. And so, this soundness parameter, it exactly corresponds to what is known as the Tiger constant, yes, related with the expander graph. So, let me. So let me okay. So this is I already said this. So you can formally verify that this Tiger constant, yes, is exactly this soundness parameter. And in fact, if we can, so the answer to my previous question, yes, whether repetition code is LTC or not. So it is LTC if we use appropriate. Use appropriate parity check metrics that comes from the expander. So if we use expander, then this code is, of course, locally testable. And so here I want to show you some generalization of this idea of this boundary expansion. So in fact, it works not only with graphs, it also works with other high-dimensional structures like simplicial complexes and even cubical complexes. Complexes and even cubical complexes. So here I show you a simplicial complex, yes. And for simplicial complex, we can also consider the boundary maps. And we can easily define this boundary expansion at each level of this complex. And we can also define some small set version of it. And what is known is that this boundary expansion is directly directly. Is directly related with the soundness of the court. And I hope you already understand that there is this relation. And to the best of my knowledge, this was first noticed by this paper in 2014. And there was also another paper by almost the same author that also connected this small set expansion. They didn't use small sets. They didn't use small sets, they represented it in some equivalent way, but so actually it was essentially the same. So they also showed that this boundary expansion implies large x distance. If we try to construct homology from this code, yes, if we construct homology from this simplicial complex, we obtain some QLDPC code. And it turns out that its existence. It turns out that its distance, yes, if we had good small set expansion, then the minimum distance of this code is large. And in fact, it can be even linear. So, which means that we have also a very good way how to prove the minimum distance bounds. And in fact, and the method that we use in our paper on good QDPC codes, and actually the idea of the construction, it The idea of the construction directly comes from these two very old papers. So, let me also briefly discuss some generalization of our construction. So, here, I show some good QDPC code, and I also try to find some good QDPC codes. So, the one that sits here that also. That sits here that also has this additional property that these matrices, yes, they are LTCs. So these matrices give you locally testable codes. And it turns out, so that let me skip this. So it turns out that this boundary expansion that I described to you before is exactly. You before is exactly the thing that you need to look at and when you consider this local product code. So in our case, in our construction, so we have a product, tensor product of two codes. But if we want to generalize them, so we have to consider tensor product of more than two codes. And it turns out that the quantity that we need to look at. Quantity that we need to look at, so we usually call it either product expansion or boundary expansion of product codes, or just general some kind of high-dimensional distance. Yes, so because it works like high-dimensional distance. And this property is directly responsible to the minimal distance of the produced codes, and so we need some way to find. We need some way to find the code that has this large value of this D. And as it turns out, so it is possible to use this maximally extendable product code that I already mentioned. So if your code is, so what we were able to prove is that if your Tensor product code is maximally extendable, then Then it has large value. And in fact, you can easily obtain a collection of codes that simultaneously have large, so a collection of codes such that these codes and the duals to these codes, they are all simultaneously have large values of D. And this gives us some hope that maybe so it could be possible. So it could be possible also to construct asymptotically a good quantum locally testable code. And I think I should finish because I already exhausted my time.