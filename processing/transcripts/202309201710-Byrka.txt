I will spend some attention to advertise the problem itself. I will not talk about too many details. If you like to hear some details, please interrupt me. So it will be facility location. You can think in the standard setting there are these possible facilities and there are clients. Possible facilities and there are clients, and you need to choose a subset of facilities and connect all clients. So that's a good standard problem. But we will consider submodel cost function that would be cost of handling a group of clients at a single facility. So you define some of the functions either more mathematically or genomically, but guess you know. Guess you know, that's medium functions. So, so modula facility location is a problem to select a subset of facilities and assign clients for these facilities. And we minimize the function, there is facility cost and connection cost. And here the connection cost is just we pay distances of clients to facilities kind of thing, and we pay And uh we pay uh for each location uh the the cost of uh this this modular function of the set of clients assigned to location. We assume that the connection costs are metric as usual. So what's known is of course the Hitig's card problem, it's more generally standard for simplification. Uh but the most relevant uh reference work is uh work of CPU. Work is the work of Svitkin Atartos, who considered the most general version of the problem, which will be less interesting for us. That is, if you could have arbitrary simula functions individual for different locations, then the problem is set cover hard, even if the metric is not complicated, even if it's just a single point, just a collection of the. Just a single point, just a collection of these different submodular functions make it complicated, so that's not interesting for us. But they also consider a setting where there's just a single submodular function, but they also consider this function to be not general submodular, but it was generated by some hierarchical structure described by a tree. So our work will be to focus on something in the middle. To focus on something in the middle. So we want a single function, but general model function. And okay, so our contribution here will be better than logarithm. So we will get, we don't get a constant, we get a log-log in approximation algorithm for the problem. And also we can get similar approximation for slightly more general setting where you could have occasion-specific additive code. Location-specific additive cost, or you could have location-specific multiplicative factor. We don't know how to have both of them. And the last point I want to emphasize, so actually I'm grateful to David and Jens for discussing a pure ETSP before, because there's something very analogous to facility location. So you could imagine you don't know what set of You don't know what set of clients will arrive, but you want to plan the assignment of these clients to facilities up front. And just like with DSP, there are two different settings. So there's this independent activation model in which these clients stochastically but independently arrive. And in this setting, the constant factor approximation is known, just like with USB. There is also a polynomial scenario. There is also a polynomial scenario model for which so far only logarithmic approximation was known. And our work is related to that. So this universal stohastic facility location in the scenario model, in almost full generality, reduces to some model of facilitation. The way to see this, so you could think like what's the probability that you will actually be using facility. The probability that we will actually be using FaSilic. And it happens to be a similar function of the set of clients that were pre-assigned. Okay. But I will use the language of similar facilitation too. Can you just take a note of both this and this? These two versions. Okay, so in the basic problem, we just pay this. Just pay distances plus the cost of this set of clients at each facility, but it's location independent. It's the same thing. So here in the multiplicative thing, we could have the cost of saving this set of clients is this function multiplied by a constant that's rotation specific. We can have additive rotation specific constant, but we cannot have both that. But we cannot have both types. We don't know how to do it. Okay. So I'll try to briefly sketch what we do. So we start from a configuration LP, standard thing. So the variables here are like what set of clients is served by a particular facility. It it helps to explicitly uh describe the the objective function, but The objective function, but also it's a standard thing. It can be approximately solved despite the fact of exponential number of variables. Let me discuss it. That's standard. And here's an overview of what we do with this fractional solution. So we will be first sampling some configurations and then embedding the remaining. Embedding the remaining instance into a tree metric, we think of these two steps together, sampling together with embedding, doing something good for us. We will reduce our problem to the problem on a tree, but a combination of these two will help us not to lose a logarithm, but rather a log log, which is somewhat unusual. You typically lose logarithm. logarithm by embedding the trees. And then we will do some processing on a tree, which is kind of standard for facilitation literature, get some structure. And in the end we will do rounding on a tree which will be we'll use some technique from an early work. Okay, so let's Okay, so let me tell you how these first two steps together work, why they are specifically good for our problem. So you could think that when we are assembling these configurations and deciding to open these facilities inside a subset of clients, the effect for us is that these clients disappear. So we kind of pay for them, but they disappear from the remaining instance. And the observation is that if we sample these. That if we sample these configurations with this scaling factor, logo gap, that the probability that the client survives this sampling process, not being covered, is roughly one of a logarithm. And this we combine with tree embedding, and the tree embedding. And the tree embedding in expectation blows up distances by logarithmic factor, and it cancels with this probability of client disappearing. So in expectation, we get the same connection cost as we had before these two steps. We of course paid already the log log n in terms of facility opening. I mean we paid for those configurations that we sent. But what remains is But what remains is the original problem on the tree metric, which is hopefully simpler. Okay, so that's quickly done. Now let me tell you about filtering, so what we do after we have a tree. So when you think of a fractional solution for this tree problem, you could focus on a single client, and this client is fractionally connected to This client is fractionally connected to facilities and thinking the original points of the metric are leaves of the new tree. So you can think now there's some kind of a flow that assigns this client to different facilities. And when you think of this flow, what we will do, we will find such a sub-tree that corresponds to You walk up with this client as long as there's half of his flow flowing up. And when on the next stage there's less than half, then we kind of ignore the top part. And we just tell him, you will be served at the bottom tree. So we're kind of losing half of the flow. So we will need to later scale up the flow by a factor of two or two to be still feasible. But we are fine to lose some constants. Find to lose some constants. So by losing constant, we forget the flow outside of the tree. But then all these distances inside the tree, they're kind of comparable. So we are ignoring where exactly will this client be served as long as it is served within the subtree. All this operation is to remove the connection cost from the project. Connection cost from the problem, we will instead have a constraint that the client must be served from the business language. Are you using the configuration LP anymore? Not really. Okay, so this fractional solution I still have, I will be modifying it. But okay, I'm I'm still keeping the configurations, why not? But I'm I'm not using the specific properties of that. Okay, and after I reduce my problem to some kind of feasibility problem that I need my clients from within these sub-trees, I just need to plan opening facilities. I will now uh use a method from from paper by by Neil and Clint his students uh And he students. They consider it a different problem. Okay, let me not talk about their paper, rather tell you what we are doing here. So the idea is to do rounding of these problems. I need to produce integral solutions. We need to decide where these facilities are open and how kinds are assigned. And the idea is we'll be rounding bottom up. Bottom up, and on each level down the tree, I need to make some decisions. And you can imagine when you have a client with such a big tree, he doesn't have to necessarily be served at a particular leaf. He could maybe wait a little bit. But when you have a client with a smaller tree, maybe he insists on being served down the tree. And to this end, we will analyze how this fractional solution looks like. This fractional solution looks like at a particular leaf of the current tree. And this is actually a little lemma from the newspaper, exactly. Pictures. It's a very good picture. So maybe you can correct me if I misinterpret the picture, no? Okay, it's a point. So my understanding. So my understanding of the picture is that we consider some level sets. So you see how much a client in our language, how much a client is served at a particular node. And in a fractional solution, you could have some clients serve like almost fully and some of them only epsilon. So you can think of playing with the threshold, of including only clients that are served only clients that are served more than some threshold and so I think this axis is this is the threshold and okay and we not care just about the the the number of these clients, but what we actually care about this the the the cost of of this set of clients Of clients defined by different thresholds, how this cost changes when you change the threshold. So the idea here is that we analyze how the cost of serving these How the cost of serving these clients changes if we play the threshold. And this function could have like two different shapes. So either playing some particular value of the threshold has the impact that you select a set of clients whose removal from the instance would give you substantial gain in the cost of the fractional. Gain in the cost of the fractional solution. That's supposed to be the left picture here. Or the opposite case is that if there is no such value of the threshold, so that always the clients would be removed would save you very little for the fractional solution. But in the second case, it turns out that the cost of That the cost of serving just the clients who insist on being served in this single vertex, those who are integrally served by the solution, then this cost would be small compared to the fractional solution of this node. And the algorithm does different things depending on the Depending on the two cases. So, in the first case, it would serve the set that gives you saving for the fractional solution, and you analyze it like an iterative running algorithm. So, you measure the progress by the fractional solution getting cheaper as a result of saving some set of clients. In the second case, you cannot do that, but you benefit from the fact that you will only From the fact that you will only do it the logarithmic number of times for a single client, so that that will be for different levels of the tree. And if we know this cost-letic current level is small enough, so I can repeat it logarithmic number of times, so that when I sum it over all the levels, that's still bounded. Okay, so that's the sketch of the. The sketch of the idea that we borrowed from Neil's work. And it turns out to be perfectly suitable to round our remaining three-embedded instance. It's very similar to what Neil did. So they were considering similar tree. Similar tree but over time intervals. So we constructed three out of space by tree embedding and they constructed it three out of laminar time intervals. But the rounding process is very similar. Okay, so just to summarize, so we start by this partial assignment from Start by this partial assignment from sampling, embed the tree, embed the residual instance on the tree, and you run it on the tree, and you can view it as like two solutions, and you just put both of them together at some day of cost, and that's the feasible solution for putting that problem. Yes, so that's it for the sketch. I'm happy to. That's it for the sketch. I'm happy to discuss some details, but maybe we don't want to do that at the moment. But let me mention some open problems. So of course the constant factor is open for this problem. Interestingly, we also don't know how to do constant factor for just three instances. And maybe this you find interesting as an open problem. So just some model of a sale delegation assuming the answer. Location assuming the underlying metric is a trig metric. Currently, we don't know how to do it. It would not imply by our result the constant factor for general problem because we lose the log log n in both steps. But it's interesting to see by the tree. It would be interesting to try to slightly generalize it into this affine version where you would have both additive and modify. Of additive and multiplicative facts that would be location-specific. Currently, we cannot do it. The reason is when we do this rounding, like when the leaves are merged in a higher level, you kind of decide in which location you would put the facility that in the rounding process kind of ignores the location. And when you have both these. When you have both these costs, then both these factors we wouldn't know how to compare. Okay, so that would be just like minimal. Okay, so that was the questions. And just to conclude, I just want to repeat our advertisement for IBCO. I will be happy to see many of you there. But just to add uh some more information, we have a fantastic set of speakers for the summer school. Speakers for the summer school, Sophie, Neil, and Vera. So if you're considering to send your students somewhere for the summer school, please. So, are there some special cases of submarine functions for each construct as well, like by the ending functions? Um so maybe there are there are more but but but the the the reference work that I know is this fifty notler and they uh they they consider some some some tree. So there's some underlying tree and then the clients are sitting there and when when you're when you're asking for a subset like what's the cost of setting this and that client together then They're flag together, then they they they collect the costs on the edges as well. So sorry, follow up to like is there any non-trivial subordinates from which like LP you can get constant using the LP? Like I think there is using local search. Yeah. Is there anything for which the LP user calls? Not the ten hours, no. Not that I know of, no. Even the integrality gap of this LPs is a good question. It could be constant. We don't know anything to be able to publish. You already sent around the announcement, or can students already register for something? We don't have the registration for the conference open yet. The web page is there. I didn't yet put the names of the speakers. This will be fixed next week. But the submission server is open. The submission server is open, yes. Please submit your first papers to get any questions about facility locating or the coast or  