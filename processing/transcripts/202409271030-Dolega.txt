Yes, I'm gonna talk about B Hurwitz numbers. So I will first start with a classical Hurwitz theory, and then I will explain what this B stands for here. So you will see that this is some sort of one parameter deformation of a classical Hurvitz theory. And then I will try to explain how we can enumerate them using W. them using W constraints. So let me start from the classical Hurwitz theory. So we have already seen some examples of Hurwitz numbers during this workshop. So in Hurwitz theory what we would like to do, we would like to enumerate branched coverings of the sphere. Branched coverings of the sphere, and we would like to control some statistics related to these branched coverings. So, the most famous example is that we are looking at the coverings that has all ramification points of a simple type, but you can do something much more general. So, let me make a picture. I don't know if this will be actually more general than maybe that's let me make it like that. Okay, sorry for that. Okay, so. Okay, so this is some genus G curve. We are trying to cover DP1, and we have some points here. So here, and then the next one would be here. And here I will again have a non-simple one. So, okay, it's not very far from the simple case, but it is slightly more general. So, okay, so what I would like to do, I would like to count. To do, I would like to count these objects, I would like to count them, and I would like to also control somehow this what is happening over these ramification points. So I will have one point which is special. Let's say that this one is special, x infinity. And for this one, I would like to keep remembering what is the degree for each point. So I will do this by marking these points. Marking these points with some variables such that the index of this variable is precisely the degree. So, for instance, for this one, I will mark it with P3, this one I will mark with P2, and all the other points I will just mark with one variable. So let's say that this is X1, X2, and here I have some Xn. And each And each of them I will have one more point here that I forgot to mark. Okay. And now I will just mark each point by one variable. So what does it mean? It means that I do not remember exactly what is the degree here, but I can still count what is the number of points in the pre-image. So for instance, here I will just mark it by one. U1, U1, U1, U1. For the other one, I will mark it by U2, U2, U2, U2, and so on. Okay, I'll do it with all the points. And once I do this, I can write a generating function. So this will be a generating function which involves one infinite family of variables, p1, p2, p3, and so on. And then I will have some n extra. And then I will have some n extra variables, u1, u2, u3. And if I write this generating function, this generating function keeps track of enumerating genus G branched covering such that I control fully a ramification profile over one point. And then I also control the number of pre-image for each other ramification points. So my generating function will look like So my generating function will look like that. If G is equal to a sum over n greater than one h bar to the power n fgn and this is by definition our sum over all d so d corresponds to the degree of my uh of my branched covering and there i'm summing over all I'm summing over all branched coverings of CP1 by a genus G surface such that the degree of F is equal to D. And I will, this is a standard thing to do that I want to count it with the weight, which tells me what is the number of automorphisms of my branch covering. And then I will have a part which is controlling all these steps. Controlling all these statistics that I would like to know. So in this case, h bar pi to the number of the points which are locally of degree one over x infinity times Ui to the number of the prey prey images of Xi. So this is a standard thing to do if you want to count. You usually work with generating function. So you would like to write down a generating function for the objects that we are trying to count, and you want to do something with this generating function. So we saw during this. We saw during this week that for many, many interesting enumerative problems, what we do, we will try to understand such a generating function. And in many cases, we can do it by figuring out what is the spectral curve associated with your enumerative problem and proving that the topological recursion actually can recover these numbers here. And one more comment. So, usually, as I said, So usually, as I said, the classical objects are simple Hurwitz numbers. This is more general because you can very easily read where the simple Hurwitz numbers appear in this generating function because if all the ramification points are simple, if you want to count only those branched coverings that have simple poles, then you know that the degree of each variable ui should be simply d minus one. So if you have a degree d, So if you have a degree D cover, simplicity means that the image has precisely d minus one points. So this is a more general generating function than a generating function for simple single Hurwitz numbers. And it turns out that there is a very beautiful theory which connects this generating function with symmetric functions. So I think it was already Functions. So I think it was already mentioned probably by Maxime that there is a way to rewrite this function using symmetric functions. So let me do this. So the theorem is that if you look at the exponential of the sum of so I want to sum everything. So I want to take all the possible genuses and all the possible number of. Number of the boundaries. I do the standard thing. So I mark it with the H-bar to the Euler characteristic Fgn. It turns out that this function is equal to the sum over D greater than zero. Then we sum over partitions of size D and then D and then we have a sure symmetric function, which is this hat, it means that I don't want to worry about the normalization factor, so I normalize it appropriately. And then I take a product over all boxes in my Young diagram lambda, and I have g evaluated in h bar times I minus. h bar times i minus j where this g is is a function so g of z is simply equal to u1 plus z times u n plus z. So where does it come from, this formula? This formula comes from the fact that one way to enumerate this branch covering is to This branch covering is to switch from geometric problem to more to a representation theoretic problem and understand the enumeration using monodromy groups. Once you do this, you actually end up with a quite easy combinatorial restatement of this enumerative problem. Namely, if you want to count branched coverings and you want to control what is happening over these points, this is equivalent to counting some factorization. Some factorizations of an identity in the permutation group. So, in particular, for this case, in fact, I can even keep track of a full ramification profile over every point. And if I want to count the number of branched coverings with a fixed ramification profile, that would correspond to enumerating factorizations of an identity as a product of n plus one permutation. Plus one permutations such that the cycle type of each permutation is given precisely by this ramification profile. So for instance, for the example here, I would like to have a product of permutations such that the first permutation has cycle type 3, 2, which means I will have a cycle of length 3 and one transposition, and so on for each permutation. So this is like the first step to see how this formula works. So once you rewrite So, once you rewrite your problem into a problem of enumerating some permutations, then there is a standard trick to do this: namely, you can use representation theory. So in order to count such factorizations, you can rewrite it by using irreducible characters of your representation. And then this formula follows basically almost from the definition of the short polynomial, because sure polynomial is Because Schuyler polynomial, if I expand it into power-sum basis, the coefficients that appear are precisely irreducible characters of representations of the symmetric group. So this is how you can see, how you can go from this formula to this formula. But it turns out that this is a very good idea to switch from here to here, because you can use many, many new tools to handle this kind of enumerative problems. Handle these kind of enumerative problems. These tools are coming from symmetric functions, from representation theory, and from integrability. So this formula is absolutely beautiful because it somehow connects two different stories in a very nice way. And I wrote it like that with this general G because you can ask yourself, okay, so here we have this very particular polynomial. This very particular polynomial, but maybe you can replace it. Maybe you can replace this g by a more general function, and some interesting enumerative story will appear. So this was the idea of Paquet and Harnat, and they introduced the so-called G-weighted Hurwitz numbers. So maybe let me comment on this. So if you don't think about the enumerative story, if you only think about this. If you only think about this sort of function, these functions were studied before, and they were called the hypergeometric type tau functions. And they are related to integrability, to the KP hierarchy. But due to this link that I just explained, it actually is interesting to understand what kind of enumerative story will appear when you work with allergies. And this approach will. With other Gs. And this approach was used by Mathieu Guy Paquin and John Harnot, and they introduced the so-called G-weighted Hurbitz numbers. So G, so this is a generalization. So let's say that g of z is a rational function. In fact, it can be. In fact, it can be any formal power series. But for this talk, I will mostly care about the rational case. So these are called G weighted Urbits numbers. And let's look at some examples. So maybe the simplest example is when g of z is equal to u plus z inverse. So the simplest rational function you can imagine. And it turns out that once you put g equal to that, and you would like to understand Equal to that, and you would like to understand this enumerative story, then you end up with the so-called monotone who reads numbers. Which were introduced by, first they were introduced by Novak, and then they were studied by Novak Matsumoto and then Goulden Guypake and Novak. This monotone Hurvy's number. These monotonous Hurwitz numbers, they naturally appeared in matrix models. So if you want to understand the H C I Z integral and you want to expand, you want to make a topological expansion, it turns out that precisely monoton Hurwitz numbers are the coefficients that you will encounter. So you can see that this idea of just working with the generating function. Working with the generating function, which is defined by a symmetric function and some quite general g, is very successful because it can cover many, many different cases that people were looking at independently, case by case. Let me just mention two other cases. Sorry, just one other cases. So, if we generalize it and we write u plus z to the power k to the minus one, we will obtain something which is. We will obtain something which is called a orbifold monotone. Orbits numbers. And these were studied, for instance, by Norman and maybe Max too. I don't remember, so sorry for that. But just these are just examples to show you that you can choose G to be something different than polynomial and you often Than polynomial, and you often end up with some theory that was studied before. So, that was a very successful idea to work with this generating function. And perhaps, I mean, one very strong property is that this is always a tau function of the Kp hierarchy. The radiation is very small in the middle. Yes, but the so I agree, definitely. But this is also in a certain way, working with a polynomial weight recovers simple Hurwitz numbers. But of course, it's a different example. So this is, of course, true. So if you work with g, which is an exponential, this is just the classical generating function for the C. Generating function for the simple single Hurwitz numbers. This is indeed correct. But if you keep in mind that the polynomial gives you something more general, because you can easily extract the contribution which goes to the simple Hurwitz numbers. Then sometimes it's, I mean, you can obtain similar results by working with the polynomials. And for my talk specifically, I want to work with. Specifically, I want to work with rational functions. So that's another reason why I didn't put it here as an example. But this is a very good remark. But yeah, so here if we have G, actually, G can be pretty much anything, any formal power series, it will still be a tau function of the K-peak hierarchy. So this is a very strong result, and this strong result really helps you to work with enumerative problems. And going back to one of the And going back to the one of the main subjects of this conference, namely topological recursion, we already heard that in general it is kind of hard to have this universal like universal idea why topological recursion appears. So Maxim was emphasizing it that I mean, usually you just look at your problem, which is quite specific. You're trying to figure out the spectral curve and you're proving topological. Spectral curve, and you're proving topological recursion, but you're doing it case by case. And in a Hurwitz theory, this is exactly what was happening in the past. So, people were looking on different examples. So, first they were looking at the simple single Hurwitz numbers, and the topological recursion was conjectured, and it was proven, then for the monotony, and so on. And for each case, it was kind of a big deal to work with them. But very recently, Maxim and Sergei and Petra and other people, they proved this quite general theorem. So that's really beautiful because at least in the Hurwitz theory, we have this kind of universal explanation why topological recursion appears. And they prove that these G-weighted Hurwitz numbers, they are always governed by the topological recursion. By the topological recursion. So let me state this theorem. So, if you start with the following experience, If you start with the following spectral curve, so x of z is equal to z divided by g of z, y of z is equal to g of z. Then, and you apply the topological recursion to this spectral curve, then you can compute all the g weighted Hurwitz numbers. Numbers. So, this is a very nice result because, as I said, there is at least some class of enumerative problems where we have this one universal explanation of topological recursion. Yes, that's why I, as I said, like there are many, many intermediate results. So, all the case. So, all the cases that were somehow governed during time, they were kind of worked out by many people. So, yeah, the first kind of universal thing was the theorem of Sacha and Guillaume-Chapuis, Bertrand and John Harnat, where they were working with the polynomial weight. But recently, it was generalized to this rational. In fact, it was generalized to much, much more general cases. Much more general case, but again, here I want to focus on the rational case. Okay, so that's great. Any questions so far? Sure. Sorry, say it again. Yeah, this. Yeah, so this is related with, so this check, this is related with the dimension of lambda. Yeah, so there will be some kind of hook factor that I don't want to introduce. But there is a way to normalize so that it works. Okay. The cross-off factor. Necros of factor I don't know I don't know we can we we can talk later uh yeah uh okay so so now let me pass to to this one parameter deformation so I will introduce uh this these Bhurwitz numbers and this is something that comes very very naturally from the symmetric function symmetric functions point of view but it doesn't come naturally naturally at all from like a numerative point of view so Numerative point of view. So in the symmetric, in the theory of symmetric functions, there is a one parameter, there is one very famous one parameter deformation of Schur polynomial, and these polynomials are called Jack polynomials. So we have some kind of deformation and we have Jack polynomials. We have Jack polynomials, and I will have some parameter b, and I will just write it here that for me, b is square root of alpha minus square root of alpha inverse. So it looks precisely the same as a parameter that appeared in Omar's talk, where alpha is a classical parameter that appears in the Jack story in the literature. But for me, actually, this parameter will be way. Actually, this parameter will be way more important than just alpha. So these functions, I mean, where do they come from? For instance, they are specialization of the famous McDonald polynomial. They appear also in a They appear also in the theory of Selberg integrals. And maybe the most important for us is that they are strictly related with beta matrix models. So before I explain in detail what is the definition of this Jack polynomial, let me just introduce one x. Introduce one extra quantity that will appear, namely, this is a B deformed, B-deformed content. So this quantity I minus J, we call it a content of the box. In the story with Jack polynomials, we would like to work with the following deformation. And you can see that if alpha is equal to one, this is precisely the content that we had before. But when you're working with this perturbed function, this is the quantity that appears all over the place. Okay, so now I can define what are these jack polynomials. So I will define them in the following way. So Jack polynomials, this is the unique family of symmetric polynomials, which satisfy Polynomials which satisfy the following properties. So, first of all, these polynomials are eigenfunctions of a certain operator. And again, you will see that this operator appeared in Maxim's talk, but without this deformed part. So if you don't have this part, what is this operator? This operator, it looks like you sum over i plus j and you have h i a j, sorry, h minus i, h minus j, h i plus j plus and plus and then you have the other way around so h i plus j h h minus i minus j h i h j so this is this cut and join operator that appeared in in maximum talks i think that in his talk it was denoted by q if i remember correctly but in this jack story there is this extra part here and and by definition so i will call this operator d b and by by definition jack polynomial is defined By definition, Jag-Jack polynomial is defined by the fact that there are eigenfunctions of these operators. So dB is acting on charge polynomials such that this is two times we sum over all the boxes. We sum over all the boxes in Lambda, and we have this deformed content times J lambda p. So this is the first property. So there are eigenfunctions of these cut and join operators. And the second property is the triangularity property, namely, if you want to expand them in a so-called monomial basis. Basis, then this expansion is going to be always upper triangular. So, this is a monomial basis. And the only thing that is not defined here is the normalization factor. So, you will have to choose which normalization do you want to work with. Do you want to work with? People are working with different normalizations. But these two properties, up to a normalization, they uniquely define these symmetric functions. So, again, when alpha is equal to one, and that corresponds to b equal to zero, these are precisely Sure functions. When alpha is generic, you have like one parameter deformation of sure polynomials. And you can play again exactly the same game. So, I mean, this is. So, I mean, this is very natural to define the following function. So, I will define a tau gb as a sum over d. Then I will have some normalization factor that I have to put here so that everything is nice. But basically, the rest is identical. So, I now instead of sure, I will have jack. will have check divided by the norm. So there's some kind of canonical scalar product on the space of symmetric functions which makes this jack polynomial orthogonal. So I don't want to go into detail, but just think that there's some normalization factor. And then here we have exactly the same thing as before. So we have this. Same thing as before. So we have this G thing H bar times the content. So, I mean, what I did, I basically just wrote precisely the same thing as before, except that now I replaced the sure function by some one parameter deformation. And as I said before, from a numerative point of view, maybe it doesn't make sense to work with such a function. Sense to work with such a function, but there are many reasons to do this. So, the first reason is that very special examples of this function did appear in theory of beta ensembles. And it turned out that this is a partition function for different models of beta-deformed matrix models. So, for instance, for Gaussian beta ensembles, for Laguerre, for Jacobi, you can prove that this. You can prove that this is a partition function of these models. It also appeared in different contexts. For instance, if you take g, which is an inverse of a linear polynomial, that would be a partition function that appears in the AGT conjecture with n equal to 2. So actually, this object appeared already in different contexts, but it didn't appear in this kind of enumerative context. So this is a very nice. So, this is a very natural question. Is there any sort of enumerative theory such that this function is a generating function of some objects? And the answer is yes. So, this is a theorem that I proved with Hyung Chapui. And this theorem actually works for double B Hurvey's numbers. So, in this talk, everything is simple, single. I have only one jack here, but in fact, you can have one jack times some other jack in another infinite family of variables, which are independent. And in this context, we proved the enumerative interpretation. So, here's a theorem. Theorem So, actually, it held in the case of double G-weighted And the theorem, I'm not going to be very precise, because I need to move on, but basically, we prove that there exists some kind of topological combinatorial theory such that this function is precisely generating functions for the subjects. So this is a generating series of G-weighted Non-orientable branched coverings of the sphere counted with multiplicity. B to some power, where this power, this is an abbreviation of measure of non-orientability. So this is some kind of statistic that is supposed to measure if your branched covering is orientable, like classical one, or is it something new? So this quantity is equal to zero if and only if f is a classical. If a classical branch covering Okay, so maybe later if you will have some questions about the precise meaning I can I can go back but let me let me move on. So what is the natural problem now? The natural problem is I think it's obvious. So is it true that this new tau function Tau function can be still governed by some sort of topological recursion. So that's a very natural question. And then when we go back to a theorem that I mentioned, a theorem for the classical case, you can see that the fact that this is a tau function of the Kp hierarchy, it's a very, very important ingredient to prove this kind of general theories. But this is not the case here. I mean, this is. Not the case here. I mean, this is not a tau function of the Kp hierarchy. So this is a big problem. I mean, at least we cannot just try to mimic the proof in the classical case. And one way to somehow move on is to try to think about different notions of the topological recursion or different approaches to the topological recursion. And in this case, the algebraic one seems to be the best one. The algebraic one seems to be the best one. So, Kontevich and Seugelman had this more algebraic approach to topological recursion, so they defined something which is called an error structure. And they proved that whenever you have an error structure, there is a unique solution to certain differential equations. And in many, many cases, this solution is governed by the topological recursion that you can somehow understand from this airy structure. So, then a very good So then, a very good question is: but where does this array structure come from? I mean, what is the classical source of the array structure? Yes? We have no, no, no. So, so there are branched coverings of the sphere. So, this means that the source is the. means that the source is the sphere the the target is the sphere so like in classical theory like you have a genus g genus g surface and you you cover the sphere okay you you actually you can you can work with coverings of higher genus surfaces that's totally fine but in the classical case that's not what we do we are we are usually counting branch coverings of the sphere okay what is Yeah, so this is some kind of statistic that I didn't define. So, what I said is that there is a way. So, first of all, you need to know what is this non-orientable branched covering. But imagine that there is a notion of non-orientable branched covering. And then there is a way to compute some kind of statistic, which is an integer, positive, non-negative integer, which has the property that this integer is zero if and only if your And only if your covering is actually orientable, so it's a classical branched covering. But I didn't explain how to compute it. There is some kind of combinatorial algorithm. Yes. In fact, we even, so if you take a logarithm, all the coefficients are just like up to multiplication by d, where d is the degree, they are just positive integers. Degree, they are just positive integer coefficients. So, this is really an enumerative, like we're really counting things with weight simply b to something. So, the only like non-rational non-rationality in the coefficients comes from the number of the automorphism of the brand correct. Yes. So maybe, yeah, maybe let's go back to this question later because I'm not sure if I will have enough time. But I can be more precise. Yes, I can be very precise if I will have enough time. Sorry for that. Okay, so let me just go back to the main question. So can we prove some sort of topological recursion or some maybe version of topological recursion? So we had in mind this error structure. So we had in mind this errost structure of Konsevich and Seubellman. And then there is a work of Nietin and Gaietan Borot and Vancouver Bouchard and Kroitik, where they proved that a very good source of the area structure are W constraints. So whenever you can find some W constraints that are satisfied by your tau function, then there is a very, very big chance that you will have a higher error structure. So that was our idea. And what we wanted to do, we wanted Our idea, and what we wanted to do, we wanted to find these W constraints in this case. So let me pass to our main theorem. But before I do this, let me make some small drawing because it's going to be very helpful to think how I think about this cut and join operator graphically. So there's a very simple way to remember this operator. So what I do, I will draw paths. There are lattice paths, which starts in a point 0, 0, they finish in a point 3, 0, they stay in the positive quadrant. In the positive quadrant, and I can go up or down or flat by any increment. So, increment can be anything. And whenever I have an upstep, I will associate an operator h minus k, where k is the increment of this thing. So, let's say that here I have h minus k, and here I have h k minus l. So, this is of size l minus k, this is of size k. And whenever I go down, And whenever I go down, I have a H indexed by a positive number, which is an increment. So, here, for instance, this is an increment k. So, this is h k. And sorry, L L L, this is L. Yes, yes. But I don't want to use J because Jack polynomials are already J. Exactly, exactly, exactly. Exactly, exactly. So, so, so, ah, because I forgot. I sorry, I forgot to write what are they? Yeah, I'm really sorry for that. So, hk, sure, I should write it. So, whenever k is positive, this is simply k d d p k. When k is equal to zero, this is just zero. And when k is negative, this is p minus k. Okay, yeah. Sorry. In general, we will think that this. In general, we will think that these are some Heisenberg operators, but we're using this representation that is acting on the symmetric functions with this specific representation. So, okay, so what I want to do, I want to draw all the paths of length three. So maybe this path looks like I go up, up, down. Maybe I go first up and then down, down. So then you will see that you will have like H minus L, H, L minus K, H K. But there is also this spurred case where I can go, I can have a flat step. And whenever I have a flat step, then this flat step is at some level k minus one, sorry, it's at level k. So here I will have h minus k, here I will have hk. But for the flat step, I will associate this color. So this colour is minus. color is minus k minus one h times b so now i have a way to associate some operators to these paths and whenever i will have a path i can associate some weights this this defines me an operator so what i'm saying is that db combinatorially i can think of it as a sum over all paths of length three okay and for each such a path i will associate each such a path I will associate I will associate a certain weight. But now you can so let me just write it. So db is equal to a sum over all gammas from 0, 0 to 30 greater equal to 0 weight of gamma. Okay, so this weight of gamma is Okay, so this weight of gamma is this weight that I just described here. And we would like to do exactly we would like to play exactly the same game, but now, yes? No, no, that's important. No, we really read them from left to right, the way it is written. And that's actually important because we will work with longer paths. And in longer paths, you can imagine that you will have up, down, up, down, up, down steps. Up, down, up, down, up, down steps. So, the up the operator that we associate is the operator written the way it is, the path looks like. So, more generally, so more generally, whenever I have some set of variables, so let's x be some set of variables from x1 to xn, I'm going to look at I'm gonna look at some paths. So, okay, a generic path will look like that, finishes somewhere. And whenever I will have a flat step, which is at height k, I will associate almost exactly the same weight as here, but I will also add this variable that I have here. So now for this flat step, the weight will be xj minus. XJ minus H bar times B times K. So sorry, actually, there is a small difference because here it was K minus one, but now I will change it. So it will be precisely the height. And I will have the shift by some variable, okay? And this weight, I will define weight of gamma with this extra decoration X. So you can think that this X is somehow decorating. That this x is somehow decorating some flat steps. Whenever you have a flat step, you will decorate it with some extra variables. So, okay, so here is the main theorem. So, the main theorem is that our tau function of rationally weighted b-deformed Hurwitz numbers satisfies certain explicit. Satisfies certain explicit constraints that now are going to be very easy to write down using this combinatorial language. This is a theorem GDAM with Nitin and Kento. So here is the equation: T times Times gamma, which starts at the height k minus one, it finishes at n plus one, zero, and stays in the first quadrant. Weight gamma times u one up to u m M plus minus one to the power m sum over gammas from zero a minus one to m plus one minus one weight of the gamma zero minus v one up to minus v m is active. Vm is acting on our is killing our tau function. So, what are these parameters here? I'm working with the rational function, which is a product of ui plus z divided by vi minus z. So the theorems. So, the theorem says that this operator, this is a quite big operator, but as I said, there is a very easy way to remember. I mean, if you think about it, what is happening here, I'm looking at the degree of my numerator and denominator. So it's n and m. And the first part is just a sum over all paths of length n plus one. The decoration is given by my variables u1, u2, and so on. Variables u1, u2, and so on. And the second part is given by all the paths of length m plus one. And the decoration is given by the parameters v1, v2, and so on. And that's it. So actually, this is a very simple combinatorial formula, which gives you the constraints which are satisfied by this tau function. So how much time do I have? 12 minutes. Okay. So, and that's a very good point. So, what is happening here? Actually, that's a very good point. So, what is happening here? So, actually, the contribution from all the steps is becoming trivial because the only thing that appears here, there are just these variables, u1, u2 for the first part, and v1, v2 for the second part. So, actually, if you think combinatorially about it, you can kind of forget about. About it, you can kind of forget about this flat step, and you can put some elementary symmetric polynomial in front of everything, and then you will sum over all paths which are of the length at most n plus one. Because you have a bijection. I mean, whenever I have a path of length n plus one with some flat steps, I can remove them. I will have a shorter path, and I can insert these flat steps in all possible ways. This is controlled by elementary symmetric polynomials. This is controlled by elementary symmetric polynomial. So the formula is becoming much, much simpler. But in the B case, this is really, really crucial that we have these flat steps. And they give you a very non-trivial contribution because it really depends on which height we are. But yeah, so maybe let's look at a simple example. Ah, sorry, of course, yeah. Thank you. That's why we say constraint. So actually, that's a very good question because then maybe if you were working with Hurwitz numbers, you know that sometimes you have cut and joint equation and Join equation and Virasoro constraints. One way to think about Virasoro constraints is that if you sum over all integers, your cut and join equation very often looks like Pi times something. And this something is the Virasoro operator. And this is exactly what is happening here. So I don't know if I will have time to tell you about the proof, but in fact, the first step to prove this was to hook up cut and join equations for all Hurvy. For all Hurwitz numbers. And this actually we can do not just for rational, we can do it for any G. And then a non-trivial part is that actually if you have your cut and join equation and you think again about this cut and join equation in this language of paths, so now you will always start from 0, 0. You will have the first path has to go up. I mean, it has to because it has to stay in the first quadrant. And then you will have the rest of your path. And in the cut and joint, And in the cut and join equation, you have to sum all of them. So, this is non-trivial that actually for any height, this other part is completely killing your tau function. So, this is why usually cut and join equation is much easier than Virasoro constraints. And Virasoro constraints are refining cut and join equation. This is exactly the same thing is happening here. So, we first start with the cut and join equation, but then we can actually prove that we have constraints. Which operators? Ah, the whole for different case? I don't think so. I mean, no, no, no, of course they do not, because they, I mean, they're coming from W algebra. So actually, if you think about the simplest case, which is Virasoro, so these operators are actually Virasoro, they're Virasoro operators. Okay, but so these operators that are secretly coming. So, these operators are secretly coming from W algebras, but that's a bit technical, so I won't go into details. Yeah, it is the highest-wheel representation, yes. Yeah, yeah, yeah. They're all coming from finite rank W algebras. And in fact, in fact, this is a very so. Maybe I will not write an example because I might not have time for this, but you can. For this, but you can check yourself. This is a very nice combinatorial exercise. That if you write this operator in a case, let's say in the monotone case, you will see that these are the Virasoro constraints that were worked out by different people for the monotone case. And for this monotone case, we will also see that these are the constraints that appear in the AGT conjecture with this general B. So this is one way to see that for general B, the monotone case here corresponds precisely to Monotone case here corresponds precisely to the Whittaker vector in the AGP. But let me just conclude with the last theorem. So I told you that our, I mean, what we would like to do at the very end of the day, we would like to prove some sort of topological recursion for these B Hurwitz numbers. In general, we cannot do this, but for the case B equal to zero, actually, this theorem implies the theorem that was here. The theorem that was here, namely the topological recursion for the classical case. So, this gives a completely new proof for the rationally weighted single Hurwitz numbers, which is independent of your proof. And this is the proof which basically uses the fact that these constraints, they're coming from W algebras. And Knittin, Gaia, and Vincent, and Thomas Kreitzig, they basically figure out that this is a very good source of the higher area structure. Source of the higher area structure, so whenever you have some nice representation of W algebras, you can prove topological recursion. Yes, yes, exactly. So, this is the corollary of this theorem. So, let me just finish with this corollary. So the corollary is the new proof of TR for for the rational case, so for the case for this case. For this case, that I wrote there. For B for B for B, yeah, yeah, yeah, sure. For B equal to zero. For B equal to zero. And this is based on the theory. On the theory developed by Gaia Tan, Vanson, Nitin, and Thomas Gretik. Okay, so what is next? The next thing that we would like to do, like eventually, as I said, we would like to prove some sort of topological recursion for these numbers. From combinatorial point of view, we always From a combinatorial point of view, we strongly believe that there must be, I mean, the behavior is really, really similar. And in fact, we strongly believe that the refined topological recursion that Omar was talking about is the right topological recursion to work with. Of course, the problem is, as you already saw, that this theory doesn't work very well if your curve is not a genus zero curve or maybe hyperelliptic curve, but at least But at least for these cases, we can prove, and this is an ongoing project, we can prove topological recursion whenever our weight is essentially of this form. So, this is an ongoing project with the same outers. This is not finished yet, but for this weight, we believe that we can prove that this curve is now. That these curved numbers are governed by the refined topological recursion, and we can also do the case with the internal phases. So, thank you very much. That's all.