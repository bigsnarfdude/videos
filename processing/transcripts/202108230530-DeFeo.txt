This project has a more theoretical crypto flavor than the other ones, I guess. Although don't be put off by that, because I think there's lots of interesting number theoretic questions that we have to explore here. So, the title of the project is Non-Interactive Zero-Knowledge Proofs of Isogeny Knowledge, which makes Nitsk Poix. Nitsk poix just because cryptographers like to have acronyms. The general question, this is unlike some of the other projects, this is, I would say, an open-ended project in the sense that I don't know what I want to achieve in the end. There's more than one question which can be asked, should be asked, and the arrow. And they are all perfectly valid, and so it depends, I guess, on which question people have ideas on. The general idea is that in the usual crypto spirit, you know some secret isogeny and you want to prove to someone that you really do know this isogeny without revealing the secret, of course. So this is a vague statement because This is a vague statement because there's many different kinds of isogenies you may know. There's many different statements you may want to prove. So one example is that you know the secret key to some public key. And so this could be the secret key to SIDH to SIDH or the secret key to C-side. And so these already is two very different. And so, these already is two very different kinds of isogenies because, here in SIDH, well, as we just said, your public key is something of the form E and then phi of P and phi of Q for some basis torsion points P and Q. Whereas in C side, the public key is only some curve, E. Some curve e, and in C side, of course, secrets are essentially elements of a class group, and then there is more than one way to represent these elements of the class group. There is, so for those who know, there is the C sign way or the C fish way and these are And these are essentially the same kind of interactive proof structure, but the actual way in which elements of class groups are represented changes a lot the way you end up doing the proof and changes a lot the efficiency of these schemes. Then there's other questions you may want, there's other kinds of isogenies you may want to consider. Isogenies, you may want to consider going beyond the two main key exchange encryption schemes. There is, of course, the SkiSign flavor, where here you may, in this case, KeySign, we're very close to the generic isogeny problem between two supersimilar curves. So we're talking about. Curves. So we're talking about supersingular curves over Fp square, and you can see ski sign as a proof of knowledge of an endomorphism ring, or equivalently, a proof of knowledge of a walk, an isogeny walk from some well-known curve E0 to this public key. And so here. And so here the waski sign ends up proving things is not proving exactly the knowledge of a specific isogeny, it's more proving knowledge of any isogeny from the starting curve E0 to the public key. So it's again a slightly different flavor. And then another flavor that you can find in the regional in the recent literature, and this is not about quantum safe cryptography. Quantum safe cryptography would be the thing that's used in verifiable delay functions. Where here, the interesting thing is that we're talking about first of all, this is about pairing-friendly curves. So, we want some ellitic curve E, which is defined over F. Which is defined over FP, which is supersingular. But we're also exploiting some pairing group with n, a large prime. And we're using discrete logarithms in this group. So this is definitely not something that is post-quantum, but it has its uses. And the interesting thing here is that we do have isogeny. We do have isogeny walks again, and we want to prove statements about these isogeny walks. And the very special things about these isogeny walks is that they are very long. So this is a pretty vague way of saying things, very long, but just to make an example, when we think about isogeny walks in ski sign or sea fish, we're talking about Seafish, we're talking about walks in esogeny graphs which have length around a few hundreds of steps. In Ski Sign, in SADH, the length would be exactly 200 something steps. That's not exact, but that's we have an idea. Whereas in verifiable delay functions, we have isogeny works of length that is in the thousands. Is in the thousands or even in the millions of steps. It's more in the millions than in the thousands, to be honest. And so this is a quite different problem because you want to prove knowledge of anisogeny, which is very long. So you expect the proof to be very long as well. But then you have all these new crypto techniques on succinct proofs, which tell you that you can have sub. Which tells you that you can have sub-linear length proofs. We don't have anything like that for isogenies unless we borrow techniques from crypto which work generically. So these are the four kind of isogenies which have appeared so far in the literature and which we may want to be able to prove. Now, how do you prove a secret? Now, how do you prove a secret knowledge of a secret SRG? The usual technique is that of the Sigma protocol. I can't write a Sigma Sigma protocol where this is an interactive protocol between a prover and a verifier. The prover, of course, knows the secret. And the verifier knows the public data. So I'll write it here, public key. And the goal of the prover is to prove that he knows the secret which leads to the public key without revealing the secret. So it usually starts with a message from the prover to the verifier, something that is called a commit. The verifier, something that is called the commitment. This is a random message, usually, which essentially bins the prover to then reveal something, but this revealing will not give information on the secret. Then, to the commitment response, the verifier responds with a challenge. This is also. This is also random, although the verifier can really choose whatever he wants, doesn't need to cost a toy. A typical example of a challenge would be a bit, for example, this is what we do in SIDH kind of isogeny proofs. And to the challenge, the prover responds with a response. Which in this case depends, of course, on the commit. Which in this case depends, of course, on the commit and on the challenge. And the verifier then just checks some equation. This is the generic structure of a Sigma protocol. Of course, in general, you're not bound to having only three messages. An interactive proof is something that can have as many messages as you want. As many messages as you want, but usually three messages are enough, and they are very practical to make interesting protocols. All the protocols we know for isogenies are based on a Sigma protocol, so on this three-message structure. And now here is about non-interactive proofs. So there is a standard technique which you may have heard of, which is the Fiat Shamir. Shamir technique, which takes an interactive proof and transforms it into a non-interactive interactive zero-knowledge proof and transforms it into a non-interactive zero-knowledge proof in the random oracle model. You need this essentially, you need to use hash functions and you need to make quite strong assumptions on the hash functions, but they are certainly strong assumptions. They are certainly strong assumptions, but they're also quite reasonable and quite common in cryptography. And when you combine the thing, then you can transform your sigma protocol in something that is non-interactive, which is more useful. Typically, you are happier with non-interactive proofs. Fiatramir is not the only technique to make non-interactive zero-knowledge proofs in general. One thing that it's important to keep in mind is that. That it's important to keep in mind is that the theory of zero-knowledge proof is extremely well developed. There's tons of literature, I guess there's 10 times as many literature on zero-knowledge proofs than there is on isogeny-based crypto. And there are theorems that tell us that we can prove any statement in NP in zero-knowledge. So NP, the complexity class NP. The complexity class NP, for example. And there's other many other statements of this sort. So the question is never whether you can prove knowledge of anisogeny. Of course, knowledge of anisogeny is typically going to be a problem in MP. So there is no doubt that the protocol exists. And even more than one protocol does exist for this. The question is rather how efficiently you can prove it and based on what assumptions. Because typically, if you use generic zero-knowledge. If you use generic zero-knowledge tools, like for example, you may have heard of NARCs or STARKS. These are very popular right now because they are very efficient as far as efficiency goes in the zero-knowledge space. They're very efficient techniques to prove generic statements, and they even have. Statements, and they even have some interesting succinas. This is what the S stands for: some very interesting succinas properties in the sense that the size of the proofs grows less than linearly in the size of the statements being proven, which is amazing. Of course, there are some limitations. For example, SNARKs are not post-quantum. Starks are, but Starks are not succinct, if I'm not wrong. If I'm not wrong, so the result is literature, but of course, these are still quite heavy techniques which are less efficient than, say, I don't know, ECDSA, for example, which is also a proof of knowledge of something. And so anytime you want to think about these protocols, about these proofs of knowledge, you need to have in mind that there may be alternatives which are generic and which Alternatives which are generic and which to which you are forced to compare yourself. So now, just I've been talking about what we want to do, but I haven't said why. So the question is, why do you want to do this? What are proofs of isogeny knowledge good for? In the notes, which I guess I will put also on the overleaf, for the moment they are just in Zulip, I give four, I think I remember. Give four, I think I remember, yeah, it's four interesting applications. The four that in my mind are the most interesting ones. The first one, of course, is signatures. Any non-interactive zero-knowledge proof is almost automatically a signature scheme. The only thing you need is to essentially tie the proof to the message you want to assign. And so, this has been the first and main motivation to make POIC's proofs of exogenous. POICS proofs of exogeny knowledge. The first one was the SIDH signature scheme. And this is an interesting thing because this is quite old, come on, it's formed 10 years ago, but for 10 years it has been wrong. We just recently figured out that there was a mistake in the security proof of these SIDH signatures, and the mistake. And the mistake was not just a mistake in the proof. I mean, the protocol is insecure. So it's a small mistake somehow. You can patch it. There's more than one way to fix it. But I mean, this is really happening right now. There's been two papers that appeared only print recently. One by Stephen, Sam, Lucas, and myself. And another one by Wisam. Another one by Wissam, Matia, and Federico. The references must be somewhere in these notes. And they actually are quite orthogonal in the way. So the problem, of course, is the same problem in the security proof, but they are orthogonal in the way they exploit the bug in the proof. And also, there's different suggestions on how to fix things. So this is a So this is a quite open problem right now because I don't think we have said the last word. There's still quite a number of questions which are open around these SIDH signatures. Then I already mentioned CSIGEN and CFISH, which are both based on C-Side. And then of course SkiSign, which I mentioned too. And not mentioned here, there is also GPS. Also, a GPS, which is essentially the ancestor of SkiSign. So, Galbraid, Petty, and Silva. So, all these schemes are signature schemes. And here, usually you don't care about generic zero-knowledge proofs because these tend to be not competitive as far as signatures go. But if we want to talk about competitiveness for the moment, well, as I DH signatures, you can't really. Signatures, you can't really say they're competitive as far as signatures go. C-Sign definitely is not going to be competitive. So, the only interesting protocols we have run out are CFISH and SkiSign, which are interesting, but for different reasons. SkiSign is really interesting because it's very compact as far as signatures and public keys go. Seafish is interesting more because of its kind of homomorphic properties, which enable Which enable several advanced signature schemes like group signatures, string signatures, threshold signatures, and other interesting crypto protocols. But maybe signatures is not the first thing we're going to focus here because unless someone has a crazy and wonderful idea that leads to even better signatures, I'd say right now the focus for signatures would be on improving skills. Would be on improving ski sign, and that's a whole topic in itself. But I was more interested in working on the other flavors of proofs of knowledge, which I think are more easily approachable. It would take the whole week to dive into ski sign, and in the end, we probably wouldn't have anything to work with. The other obvious reason to want to have a zero-knowledge. Zero knowledge proofs of knowledge of a secret isogeny is for non-interactive case change. So you may have heard that SIDH psych are not secure against active attackers. That's why they need to use something that's called the Fuji Zakiokamoto Transform to obtain an NCCA secure encryption scheme. This is exactly what Psych does: it integrates the Fujisaki. It integrates the Fuji Zakiyokam alto transform with the basic SIDH keys change. But this is not the only way you can imagine all the things. In the end, the reason the attack, the Galbre Petit Shanika NT attack works is that when you see an SADH public key, it's very hard to decide whether this really is an SADH public key or not. Really, is an SIDH public key or not? It's actually assumed to be a hard problem to distinguish an SIDH public key from a random triplet of curve, random point, random point. Is this the same thing as E phi of P and phi of Q? So distinguishing these two kinds of triplets, just the random triplets of curve to... Random triplets of curve-to-points and curve images of some torsion points. Of course, with constraints on what the points R and S look like, so that they really do look like images of some torsion points. This is supposed to be a difficult problem. But if you can prove in zero-knowledge that you really do know the isogeny phi, which leads to the triplet, then I can be convinced by the zero-knowledge proof that an SIDH key is honest. An SIDH key is honest. And so, this is a way to a different way to patch SIDH psych against the active attack. And it is also in some sense more powerful than Fujisaki Okamoto because Fujizaki Okamoto only works for one of the two participants. Only one of the two participants can use the Fujizaki Okamoto transform to prove that it's behaving honestly. Whereas zero-knowledge proofs could be used to Could be used for both participants to prove that they are honest. And so this would lead to a non-interactive case change, which is an interesting primitive in some contexts, not something that NIST is calling for and out, but something that definitely has many applications. And so this is mostly for SIDH as a problem because CSIDE doesn't need these kinds of techniques. Kind of techniques. For CSIDE, we have very efficient and simple algorithms to verify that some public key is a valid Seaside public key. So this is really a problem for SIDH, where in the paper, I think this is number nine, in the paper with Sam, Stephen, and Lucas, we give one possible way to Way to one possible zero-knowledge protocol to prove knowledge of the nice IDH secret. There may be improvements here. This is still something which I believe has not been pushed to the end. So there may be some interesting things to say. So I hope, I'm sure we will have some time to present what's happened to SIDH in more detail. To SIDH in more details in the next sessions, so that we can really think together. There's a couple of things which are really stated in these preprints as open questions. Like, we leave this for future work because it really feels like there is something more that can be done. But we haven't been able to do it in the small time we had until now. The third application is trusted setups. Is trusted setups. So, this is an interesting thing. There are some protocols where, so this topic is coming for the third time during this morning. So, we said that we want to hash to the super senior set. This is one we want to hash to the super senior set. This has many applications. Singular set, this has many applications, although I don't think we've said what the applications are, really. The second time this comes out is in the torsion point attacks. And yet again, this trusted setup, which relates to these two topics. So, what's the problem here? The problem is that The problem is that we know that if you have an analytic curve and you know it's an endomorphism ring, then you have much more information than just knowing. So this is about supersing your curves, of course. The endomorphism ring is a lot of information to give on a supersinger curve. So this is information that enables the torsion point attacks. And there are some cases, some protocols, such as the verifiable. Protocols, such as the verifiable delay function protocols, where this information completely breaks the security of the system. So there's more than one scenario where we would like to have elliptic curves, supersenior elliptic curves taken at random from the supersenior class, such that we can be confident that no one knows the endomorphism rig. And so this is the topic of the hashing to the supersenior set group. Now, as far as we don't have a As far as we don't have a decent solution to this hashing to the supersingular set problem, we are left with the only option, especially in the VDF case, we are left with the only option being a trusted setup. So what's a trusted setup is something very simple, is something generates a supersenior curve at random for you. So this person who's generated the supersinger curve definitely knows the endomorphism ring of the curve, because the only technique we have at the moment is random walks in the super singer. Is random walks in the space in your graph. But then you just trust this person to be honest and to never use this information, possibly to throw it away, to throw away the information. This is not extremely satisfactory, but in some cases, it's the only thing we can do. The interesting thing is that we can reduce the amount of trust needed by using a multi-party protocol, where instead of just having one trusted person generate the random curve, you can have many trusted persons. Trusted persons do each, at its own turn, a round of random walk in the supersenior graph. And then the interesting thing of this trusted setup is that you need just one participant to be honest among the whole the many participants, and this is enough to guarantee security. And so, this needs proofs of knowledge of secret isogenies, which are going to be different depending on whether you are in the SID. Depending on whether you are in the SIDH case or in the verifiable delay function case, because you are going to have different elliptic curves, different tools to work with. For example, in the VDF case, you can definitely use non-post quantum tools, whereas it doesn't make much sense in the SIDH case. So this is one other interesting application. And here we are entering the domain of things where to be serious about To be serious about this, we really need to compare with generic techniques, with SNARKs and STARKs, because maybe these may be more efficient. For the moment, we don't really have satisfactory solutions except for the VDF case. The verifiable delay function case is the only one where we have some decent way to prove knowledge of secret hesogenies, although it's based on like the soundness of the protocol is based on a heuristic assumption, essentially. On a heuristic assumption, essentially. And the other, the last topic, the last application of these proofs of knowledge is the setup of these verifiable delay functions, where I told you that you have this very, very long isogeny, which to be fair is not even secret. Everyone knows this very long isogeny. This very long isogeny. The problem is not as much as proving that this isogeny exists, because everyone can just take the description of the isogeny and verify that it's correct. But the question is really that it takes time to do this verification because the isogeny is very, very long. And it takes space to store this isogeny, like in the order of the terabytes we're talking here. So this is something that if we are thinking about distributed protocols like blockchains, this is just something that people do not want to do. Something that people do not want to do, you don't want to spend time doing this verification if someone can make a succinct proof of the existence and the degree of this isogen. This is the really important question, like proving knowledge of an isogeny from E to E prime together with proving that the degree of phi is equal to something. This is something that we don't really know how to do. If we knew how to do it, Really know how to do it. If we knew how to do it, we could really make the setup of these verifiable delay functions easier, essentially. There's other applications that may come from these proofs of knowledge, which I have some half-asked ideas about what one could do with these proofs of knowledge. There is also, it was mentioned in Zulip today, there is. Was mentioned in Zulip today. There is also a paper by Antona which also studies verifiable random functions, which is something very similar to signatures. It's like deterministic signatures and is also related to all these questions on proving knowledge of secret isogenies. This is a rich topic and a complex matter. A rich topic and a complex matter, and I think we will have time to say more about this during the group sessions. I hope Antonan will tell us something about these ideas. I don't want to say more here because it gets quite complicated, I'll say. So in all these problems, there's essentially all the techniques that have been developed for esogeny. That have been developed for esogeny-based crypto can be useful here. There is certainly questions about quaternion algebras and proofs of knowledge based on Eischlet orders, like what has been done for ski-sign. They may turn out to also be useful in the SIDH setting, although so far the little attempts Antonai and I have made haven't gone very far. Very far or have proven to not work. There's certainly lots of different questions to explore here. And so it's really a mixture of some strange and difficult questions, which at first may seem artificial, but which really come from these sigma protocols and where you want to prove knowledge of these witnesses, these secrets for some public keys, and these quite artificial problems like. These quite artificial problems, like the SADH problem, and using all the things we know about endomorphism rings and about not knowing endomorphism rings in some cases, which enter into play. And so yeah, my hope is that by just exchanging ideas on what the state of the art is at the moment and where we want to go, we may come up with one. Up with one or two interesting directions, which may lead to some good results. If all goes wrong, at least we will have an interesting overleaf which surveys these questions more in details and which may serve as a jumpstart for more work in the future. So, yeah, I guess I'll stop here and I'll take questions. 