All right, so thanks everybody for being here. So I'm going to talk about viewing the thousand geometries on the inside. And this is joint work with Remy Coulon, Sibero Matsumero, who's over here, and Steve Tradle. And there's a couple of, well, okay, first of all, let me apologize up front for the fact that the frame rate is not going to be amazing. So first of all, you can go to, there's a couple of You first of all, you can go to, there's a couple of links here. Three hyphen dimensional space. Let me just show you what that is. This is the website that goes with the project. And you can kind of, it takes a while to load because there's lots of videos and so on. But then you can see in much better frame rate some of the videos that I'll be showing you. And you can also sort of interact with things. You can like, you know, click on the fly button for H3, say, and then use the keyboard controls to actually fly around these things yourself. Things yourself. Okay, so if you get bored talking to me or listening to me talk, then you can go to there. There's also the papers down here. So let me just start with a couple of videos of some of our previous work in this sort of stuff. So this is walking around inside a three-dimensional hyperbolic space in VR. We're currently in the process of developing the Currently, in the process of developing the VR component of our current work, although, you know, COVID being what it is, it might be a while before you want to put your face inside of a VR helmet. So this one you'll notice is sort of made out of polygons. This one is the graphics is a lot sort of shinier and higher detail. And this is sort of using the process that we're sort of using now. And I'll talk more about these different things. Now, and I'll talk more about these different things. But okay, so we're trying to visualize these Thurston geometries. Let's take a step back and talk about the two-dimensional geometries. So there's this famous uniformization theorem that says that every closed two-dimensional manifold admits either the two-sphere Euclidean or hyperbolic geometry. And these are sort of illustrations of tilings with. Illustrations of tilings with those different geometries. And the story is a bit more complicated in three dimensions. The analogous sort of way to classify this was conjectured by Thurston and fully proved by Perlman. It says that every closed three-dimensional manifold, you don't necessarily just get to assign a geometry, but you can cut it up into some finite collection of pieces so that each piece admits one of eight different geometries. Eight different geometries, and so the point of this talk is to sort of say, okay, on the previous slide, I had three Escher prints down here. What are the pictures that go down here? And so, I'm going to sort of go through quickly and just sort of show you just a little video from inside of each of these things and say maybe a word or two about what they are. And then I'll say something about how we generate the images. So, first of all, what do I mean by a geometry? This will What do I mean by a geometry? This will be a little bit important later. A geometry is a pair consisting of some smooth manifold x, some space, together with a group of isometries. So for ordinary three-dimensional Euclidean spaces, what we're seeing here, the manifold is R3, and the set of isometries is the usual set of isometries of E3. So rotations, translations, that kind of thing. So next, there's the three-sphere. I'm just going to sort of show you some. I'm just going to sort of show you some videos and again, hope that the frame rate isn't too terrible of what it looks like from the inside. And, well, what do I mean by looking from the inside? The idea here, the principle is that light rays should travel along geodesics. So you look at how geodesics work in that space and you send out light rays and you see, you sort of put a camera inside of your space and you see what the result is. So that was the three-sphere. So that was the three-sphere. This is the three-dimensional hyperbolic space. So, Henry, just to ask a question: so, like, you're always going to be seeing the back of your own head, yes, as you walk around the three-sphere? In the three-sphere, yes. Your head is not rendered in these pictures, but yes. Okay. And just another question. In the three-sphere one, I recognized that sort of small blue dot. That seemed pretty familiar. But what was the kind of the other stuff, this kind of The other stuff, this kind of polygonal. Oh, yeah. So, what am I showing? So, this is sort of a stylized version of the edges of the hypercube. So, if you take a four-dimensional hypercube, say, and then you really project it onto the three-sphere inside of R4, then you've got points and edges inside of the three-sphere, and you can draw them. So, it's Earth, Moon, surrounded by a hypercube. A reflective, yeah. A reflective, yeah, that the edge. So, all this, okay. So, getting into this a little bit more, it turns out with our system, it's very easy to do things like spheres, and it's easy to do Boolean operations on spheres. So, take the hypercube, delete a large sphere from a large ball from the center of each of the eight cubes of the hypercube, and a smaller ball from the center of each of the vertices. And I think this is what you get. Okay, okay, brilliant, thank you. Um uh this one is uh I think Seifert-Weber dodecahedral space, so deleting a dodecahedron from uh from hyperbolic space, hyperbolic manifold. Um, the two-sphere cross-Euclidean space, so so we had the sort of constant curvature examples, S3, E3, and H3, and this is two dimensions of spherical space and one dimension of Euclidean space. So if you sort of look down in this direction, you see that the perspective kind of falls off in a kind of Euclidean space. Perspective kind of falls off in a kind of Euclidean way. It's sort of understandable. But then there's some sort of strange things going off here. So this is sort of like looking more towards this S2 direction and the geodesics of your site start wrapping around the two sphere and then you get this sort of distortion. That's another view of S2. So again, the Euclidean direction is down that way. And then over here, this is the pure S2 direction in that direction. In that direction, and this one is two-dimensional hyperbolic plane going off in that this direction is the hyperbolic direction, going off down here is the Euclidean direction. You can see that things are getting very skinny off here. You've got some sort of tiling in H2. Things are going to get very close to each other over there. And then there are the three weird ones. Nil is a sort of twisted version of the Euclidean, three-dimensional Euclidean space. And let me not say And let me not say much more about this. I'll say something about what's going on in the background later on. This is some sort of analogous to gravitational lensing or something like that. SL2R tilde, the universal cover of SL2R, is sort of a twisted version of H3, sort of even worse than nil. And the last one, Sol, is just sort of different from everything else. It's a very strange space. Strange space. So, okay, so those are some little postcards from these different things. I guess I should also mention: here we are back in Euclidean space, but now I'm changing the lattice in real time as we're viewing it. So this is sort of applying a Dane twist to the three Taurus whilst we're inside of it. So let me say something about the different graphical techniques and sort of different ways to approach. And sort of different ways to approach the problem of making 3D graphics and how to apply it to these spaces. So, there's sort of two, actually just back up a step, sort of two big ways of doing things, polygons and sort of ray-based methods. So, if you like most video games or like 3D software is using polygons, things like Pixar movies, those are using ray tracing or ray-based methods. And so, let me say a little bit about what these are. Bit about what these are. So, this first, the first, the earlier work here, this is using polygons. And so, the idea here is that you have your world, and objects in the world are made up of lots of little triangles. And you've got the screen of your computer, and you need to get these triangles to go onto this screen. And so you have some sort of projection matrix. Maybe the easiest thing to do is just sort of orthogonal projection. You just project this triangle onto your screen. This triangle onto your screen just by sort of forgetting the z-coordinate. Or you can get a bit fancier with projection matrices, projection, sorry, perspective matrices. But essentially, what you need to do is for each of the vertices over here, you need to decide where they go over here. And then you get lots of little triangles and you deal with overlaps between the triangles with ordering and so on and so forth. Now, the reason that this is used in most sort of real Used in most sort of real-time computer things like computer games or computer-aided design programs is that it tends to be pretty fast. The disadvantage for our case is that this map from stuff in the world to your screen may not be very easy to compute. And as things get sort of more complicated, you may find that a single point, there may be multiple paths from that point. Multiple paths from that point onto your screen. Well, and they don't have to necessarily go to the same place, even. And so this map backwards gets complicated and becomes multivalued and so on. So the ray-based methods sort of get around this problem by sending the information the other direction. So for each pixel on the screen, you say, okay, that goes out into the world, or I send a ray out into the world, and I decide what I hit. And I decide what I hit. And so you sort of don't need to pull back instead of this, you're pushing forwards. And it's easier to trace geodesics forwards for each point, knowing you're going to get a single answer, rather than to ask, for this object, what are the different ways that it can hit me? So I've got these two different things here, ray tracing and ray marching. Let me tell you the difference between those two. So these are two different. So, these are two different things within the ray-based paradigm. So, in ray tracing, well, so you're always sort of tracing a ray out. And then what you're doing is you're sort of saying, okay, you're solving some equation to decide, does this ray intersect this triangle? And so, you know, you figure out the point of intersection between the plane of the triangle and the ray, and then you have some inequalities to decide if you're inside of this triangle or not. Or maybe you're going to. Triangle or not, or maybe you're going to ray trace against a sphere, and then you're going to get some sort of quadratic equation to decide: you know, does my ray hit my sphere? And again, this could get sort of complicated when your rays start getting complicated, when the geodesics in your space start getting squirrely. And so, ray marching is sort of an attractive alternative. So, let me describe what this is, and this is what we actually use. So, rather than describing a So, rather than describing a shape by saying, you know, there's a sphere over here or there's a triangle over here, what we have is we describe our objects with something called a sine distance function. And what this does is it says for each point in the space, say here, I've got a point. It tells me what is the distance to the closest solid object from that point. So, for example, here, I've got this ball over here. And so, given a point x, And so given a point x, the distance, the closest approach between my point x, and let's suppose this is the origin. So the closest approach between this point x and my object is, well, it's this distance here, which I can get by getting the size of x, that's the length of this vector, and then subtracting the radius r. So you can come up with this function pretty easily in Euclidean space, and in many cases, it's sort of And in many cases, it's sort of nice to do in these other geometries. So, given this sine distance function, we still need to solve this problem where you're looking in some direction, you're casting a ray out, and you need to decide where do I stop? Where does this ray hit? What kind of object did it hit? And so here's how it works. So, you say, okay, so I start here and I ask the sign distance function, how far can I safely move along my array? Move along my ray knowing that I won't hit anything. And so, this sine distance function will tell me that. Nothing is closer than that distance to where you are. And so, you march along the ray and you say, okay, this is my new point that I'm going to look at. And then I ask again and I ask again and I ask again. And now I've started saying that actually the closest object is the floor down here rather than this ball. But eventually you converge, right? The distance that you move gets very small. Move gets very small. And so it's an iterative procedure. For each pixel, you have to ask the sign-distance function for each pixel, however many times it takes in order before you converge. So I mean, there's a lot of calculation here, but conceptually, it's pretty simple what's going on. So what do you need for an implementation of a ray marching algorithm? So far, the things that I've shown you, this sort of ray marching business. Shown you this sort of ray marching business. Well, so first of all, you've got x is the like for x was the r3 in the Euclidean case, the model for your space. So I need some way to talk about points in space with vectors. And I need a group of isometries. So this is probably going to be four-dimensional vectors and four-dimensional matrices, although there's some variance in how we do things. You need to know what your geodesics are, and they have to be arc length parameterized, because anytime you want to step along the array by Anytime you want to step along the ray by some distance, you need to be able to, well, you need to have had a parameterized geodesic to do that. And then you need sine distance functions for objects to draw. So for example, the ball that we showed before or the oh, and the Boolean operations, if you've got two sine distance functions, then the sine distance function for the union of those objects is just the minimum of those two functions, or the sine distance function for The sine distance function for the inverse object is just the negative. So it's pretty easy to sort of combine these functions together to make larger seams. So, okay, so this is the sort of bare minimum. You know, you send out a ray and you find out that you hit something, but then you need to do a bunch of other work to get sort of, you know, nice visuals. So lighting and reflections and so on. So let's talk about some of those things. Well, okay, so even before that, if you're inside of a manifold equation, Of a manifold, a quotient manifold. So, like the torus is a quotient manifold of two-dimensional Euclidean space, you need to be able to detect when your ray is leaving the, say, a fundamental domain for the torus. And you need to sort of say, okay, you think you're here, but actually I'm going to put you back in here, and then you're going to continue onwards through this central square. And then, so you're going to wrap around the torus some number of times. So, in order to do quotient manifolds, Manifolds, what else do we need? We need some sort of way to describe a phonomile domain, and we need face pairings in this group of isometries. So we need to be able to say, as you're leaving this face, go back over here. And let's see. Maybe I won't spend much time. I'm just looking at the time I've been talking 15 minutes, and there's a few other things I want to show you. But let me just say something about some of the light. Say something about some of the lighting information. So there's this standard model in computer graphics, very early computer graphics, called Fong Lighting, which says, you know, if you're here and you're looking at some object here, which is lit by a light source over here, how do you deal with the, how do you calculate a color? And so there's a few different things here. There's sort of an ambient term for like if your object just has some ambient glow. Has some ambient glow. And then the light coming in, there's sort of a diffuse lighting, which depends on the angle between the light coming in and the normal vector. If the light is sort of coming in straight, then it's brighter than if the light is coming in at a very glancing angle. And then there's a kind of specular term. This is kind of a reflection term. So is the light bouncing off the surface and shining in your eye? So here you need the reflection. And so most of the terms. And so, most of the terms here, many of the terms at least, are easy to calculate for these Riemannian manifolds, right? Everything's sort of local here. The things that aren't local are things like what is the distance from the light source to the point on the surface. There may be multiple vectors between the light source and the point on the surface. What direction do you head off from the surface to hit the light? Those things are a little bit more complicated. Complicated. And so just to sort of put these different terms together, this is the diffuse lighting of some scene. This is the specular lighting. There's a sort of shine on things you can see. And then putting them together, you get something that looks a little bit better. So that's the lighting. The extra thing that you need beyond sort of what you have for free is the set of geodesics pointing from a point on a surface to a light source. Surface to a light source. And whoops. And then, sort of one final ingredient that you need is if you want to be able to move around in the space, you're going to carry a frame with you, which is going to tell you what the pixels on your screen, how to convert those into tangent directions that you're going to sort of send out into the world. And so maybe you're facing forwards, you're facing this direction, and so you have an option. Direction. And so you have an up direct direction and a right direction here. And so for each pixel of your screen here, those are going to determine what the initial direction of the light ray is going to be out into the world. And so in order to take care of this, you have to understand parallel transport inside of your three-dimensional geometry. And I guess just one other thing to mention here: some of the motions that you're Some of the motions that you want your camera to be able to do. So, you know, somebody is inside of a headset, they want to be able to say, look up, look down, look any direction they want. There may not be an isometry of the geometry that does that. So, for example, if you have two-dimensional hyperbolic space cross one-dimensional Euclidean space, there's no isometry of that space that will rotate the hyperbolic plane up into a Euclidean direction. But your user in a VR headset still wants to be able to look up, and so you need to. set still wants to be able to look up. And so you need to sort of decouple the possible frames slightly from the isometries of the space. You don't have to do that in the constant curvature spaces, but in the other ones you have to do this kind of thing. So those are the six things that you need. Next I'm just going to show you some postcards from different scenes within different geometries. Here are a bunch of still Are a bunch of still images from Euclidean space. These are all the three Taurus with various kinds of steam within them. Here you've got, again, sort of positive spheres, negative spheres, and then this is using cylinders. Here's three postcards from the three-sphere. This is similar to the one that I showed you at the start. This is the ages of the hypercube. The manifold here is actually the three-sphere quotient. The three-sphere quotiented out by an eight-element quaternion group. This one in the middle is Poincar√© dodahedral space, and this is sort of some sort of image of the hop vibration, just some sort of random fibers from hop vibration reflecting off of a ball inside of S3. Some postcards from H3. This is the Seifert-Weber dodahedral space again. This is an interesting one here in the middle. Is an interesting one here in the middle. This is if you take this sort of a cubicle lattice where you fit six cubes around each edge, and it turns out that the vertices of those cubes actually make it out to the boundary of H3. And so inside of these holes, you can actually get in there and fly around. And it goes on forever. And well, it goes on until your graphics card gives out. This one is, so this is this sort of ideal cubes. This is. Ideal cubes. This is hyper-ideal cubes where these big open holes are sort of the corners of the cube. And you get these pictures of Kleinian limit sets out of this. S2 cross E, so this was the video from the start. This is, I think this is just a, there's a ball at each vertex of a dodecahedron on the two-sphere. And then you just repeat that going down in the Euclidean direction. This is looking down the Euclidean direction. This is looking off in the... Direction. This is looking off in the S2 direction. This one's an interesting one. This is the Earth is taking up the entire S2 factor of the space. And so this is looking, we're looking, we're directly above the North Pole looking down on it. And as we look off to the side, this is actually looking off to the side far enough that our light rays are wrapping around the sphere to hit the South Pole. And so here we're hitting, this ring is all Antarctica. This ring is all Antarctica. And then, even further along, this is back to the North Pole. And you'll notice there's a very sort of bright ring around the North Pole. That's because the light source is also directly above the North Pole. And so there's this sort of like, well, physically inaccurate, but this sort of infinite brightness on this very thin ring around the North Pole. And then it repeats and repeats. Let me see. Let me maybe sort of skip through because I. Maybe sort of skip through because I'm aware of the time. But H2 Grossi looks like something from the alien movies. Nil is difficult to describe, and I guess I'm not really going to get into it for the experts. All three of these are the manifold is the Taurus bundle with monodrome E1101. Oh, here's a video in nil moving. So there's nothing in nil other than one copy. So, there's nothing in nil other than one copy of the earth, and we're just moving away from it. It looks right like we're getting closer, we're actually moving further away, and it sort of breaks apart into these rings. This is a very strange feature of when you move vertically in nil. This is a video sort of showing what the light rays are doing. So, looking down the z-axis, this is the z-axis here. So, looking straight ahead, you still see the earth. At a very wide angle, you're following the yellow. Wide angle, you're following the yellow path that also hits the earth, but at a medium angle, it somehow dodges the earth, and that's how you're seeing these sort of rings. Let me skip through these pictures. This is different sort of lighting, different geodesics from the light source to a scene will change the brightness of objects in the scene. This is a crazy movie inside of Nil that I think I'll just skip past, but Nil is. Have passed, but nil is sort of the. We spent a lot of time looking at nil because it's the least weird of the last three, but it's still very weird. Um, this is, I okay, I'm going to leave this in because it turns out that the the here's an isometry of nil being applied to a sheep, and you will see that we are shearing the sheep. Um, so uh, so that's good. Be honest. Be honest. You set this whole thing up just for that joke. I mean, uh, actually, no. Uh, actually, no, but there's no way that I couldn't leave it in. Um, uh, SL2R tilde is yeah, crazier than nil. Um, here's some pictures of Seoul. Um, let me let me stop now. I think I'm probably over time. So this video, I'm quite sure, will just be a slideshow over Zoom, but it's very pretty on my screen. So thanks. Thank you so much, Henry. That was awesome. I think we do have some questions from Joseph, if you want to go ahead. Thank you. Is the classification of manifolds in five dimensions and higher becomes simpler or more difficult or unknown? Oh, I think. I think that people just sort of give up after dimension four with the geometric approach. So, I mean, I don't know, maybe Jayadev has an opinion on this. I mean, so the sort of attempt to classify by geometry, well, so you, I mean, the usual way it works in three dimensions is you, you know, the first thing you look at is the fundamental group, and that starts breaking down in four dimensions because you get into undecidability. dimensions because you get into undecidability problems so um so yeah i don't i the the the you you can look at the the same sort of question of like how many geometries with these properties are there in four dimensions and five dimensions and so on and i think that's done i'm trying to remember steve tradle look one of our one of the collaborators looked this up there's something like 58 of the same kind of uh classification of geometries in dimension four um so i don't think it gets easier Um, so I don't think it gets easier, um, and you know, there's more things you can do. Uh, I'm not sure how useful it is. I mean, you don't have a geometrization conjecture in four dimensions or higher. So, yeah, I guess I don't really know. I know a few things around there, but um, it gets easier in any sense. Okay, thank you. Yeah, I mean, just to add to that, I think what Henry said is completely, I mean, I think already even making a list of what are the possible Even making a list of what are the possible, say, constant curvature geometries on simply connected spaces is also not entirely trivial. And then after that, you'd need a geometrization. You need to say that everything can be made in one of these. Neither of those seem particularly easy to me. David, now I can see you have a hand up because I couldn't. Thank you. That's very interesting. Very interesting graphics. Very interesting graphics. The question I had: well, so this, this, these graphics remind me of these views of the black hole that we had of what, a year and a half ago, something like that. And I guess I'm wondering if you've used any of this to, does it make any sense to use this to visualize or to make a sort of visual model of what a black hole looks like? Oh, well, I know if you want to answer that, Savata. I don't know if you want to answer that, Saveta. I can, or you can. So, this is in a lot of ways very similar. So, the idea behind what you're seeing in a black hole is that you have sort of a place where space is very highly positively curved. So, we're seeing, so when you look at that picture of, oh, I'm forgetting the name of the supermassive black hole off the top. Of the supermassive black hole off the top of my head. But when you saw that picture, you'll see a lot of things that are really reminiscent of looking at objects in either the S3 or the S2 cross E spaces because those do have this sort of same positively curved bit. There's a little bit of a technical detail that here these are like Ramanian manifolds and there they're Lorentzian manifolds. So we're looking at geodesics in space-time. In space-time for the black hole. And here it's just space. And we imagine that the speed of light is infinite. So there's a little bit of stuff going on there. But for these sort of like static images, you can pretty much imagine they're the same. And did Steve already do it? Yeah, so Steve's done basically put the solution to the Schwarzschild black hole, which is pretty much the sort of Pretty much the sort of simplest, it's spherically symmetric singularity with nothing else in all of space. So he put that at the center and then sort of basically put a skybot. So at the place where the curvature sort of asymptotically flattens out, he put sort of a picture on an infinite Picture on an infinite sphere there, and that looks just like the images that you saw coming out of that the big collaboration. Very interesting. Thank you. We have any more questions? Any other questions? I have one. Yeah. Have you thought of, I mean, how hard would it be for to program so that you would see another human? So we would see what another human a certain distance from us would look like in those geometries. I guess it depends how what is the fidelity of the humanness of the thing you want to see. So it's the physicist take. Humans are all spheres. If a human is a Humans are all spheres. If a human is a sphere, then sure, we're already there. So there's right. So the advantage of doing this ray marching thing is that we very quickly get up and running. The disadvantage is you need a sign distance function. And if you want like a model of a human, that's going to be not so easy. It's going to be pretty slow to generate. So I should mention that, and there's some other people working in this sort of, you know, Working in the sort of you know visualization of these geometries. Um, uh, so Eric and Dorota, I'm going to have trouble pronouncing their last name, it's a complicated Polish name, Kopinski, something like that. Kopinskaya. Kopinskaya. Yeah, so they have a project where they're doing everything in the polygon-based system and sort of dealing with the fact of the multiple geodesics by sort of there's areas that they don't render, but but it's They don't render, but it's much easier for them to do something like: you know, there are lots of models of humans or human figures that you can easily put into these spaces. So it would be more difficult for us to do something like that. There aren't efficient models of humans made out of sine distance functions. But yeah, I mean, you know, for the moment, For the moment, right, the the I mean, right, it would be great to have some, some, somebody else in there with you that you can then, you know, throw snowballs at and discover that it's very difficult to hit anybody with snowballs in hyperbolic space, for example, because the geodesics diverge and so on. Um, but uh, I think for performance reasons, we'll probably just go with um we were talking about this earlier today, we'll go everybody is sort of a plan. Today. We'll go. Everybody is sort of a planet with googly eyes, and then you know, then you just have to do spheres. And so that's pretty easy for us to do. I mean, it's also worth pointing out that even spheres are not super easy to do in some of these spaces, since measuring the distance along a geodesic, I guess, and solve is a particularly difficult thing. Difficult things. So there's a couple of things that we will do to cheat where the we'll always have, we can have a distance underestimator, but it still converges to the right function. So that's saying like, okay, so remarching says it measures the distance you have to go, you can go safely and then you take a step and then does the next distance. So as long as you're always underestimating the distance, you're never going to crash into your object, but you need to make sure that they both converge at the same point. That they both converge at the same place. So that's something that we do use to speed up calculations. And there's some cheats, there's some wire. We can't quite do a sphere, but if it's small, it's going to look like a ball. It will be fine. Joseph, did you have any questions? This relates to what you were just saying. Do you try to make use of computations in the graphics card? Oh, yeah, everything is running on the GPU. There's no way you'd get any of this stuff. I see. You'd get any of this stuff at. Yeah, is it difficult for you to arrange? I mean, it's harder to code on the GPU than it is on the CPU, right? Yes. The error messages you get are it's a black screen or you know or it looks weird and then you start debugging by saying okay if this happens make the pixel purple. I mean in that sense it's hard and that there are you know that sometimes And that there are, you know, that sometimes the instruction, you know, there was an early version of the WebGL stuff that didn't let you do for loops in a very sensible way. And, you know, getting data in and out is sort of tricky. It's a different sort of stuff. It's also worthwhile to point out that there's this web project called Shader Toy, which is, it's, I mean, maybe not quite as Complicated as some of ours are because we're working both in JavaScript and on the GLSL, which is the coding language for the graphics card that we use. But it just deals with the GLSL side. So basically, it's a way of saying, like, here's my screen. I have all of these pixels. How do I assign a color value to each pixel? So there are people who have done just really amazing things. So I would recommend going to shadertoy.com and playing with that. ShaderToy.com and playing with that. That's a really easy way to kind of jump into the graphics card programming side in a visual way. Yeah. Thank you. Miriam? Marion? Yeah. I was wondering how accurate are these visualizations of these geometries? It's a good question because, I mean, you make the thing and you look at it and say, I mean, it looks weird. Is it right? Looks weird. Is it right, or did we make a mistake somewhere? Um, uh, we did spend uh quite some time, Remy, in particular, looking at um convergence of, well, so right, so first of all, we, as as as often as possible, we're doing closed form solutions for our client parameterized geodesics. So, um, you know, as long as you believe the implementation of um Of the functions that you're using, that GLSL is doing, then it should be pretty good. There are some places where we have to switch to sort of more directly numerical methods because of sort of singularity behavior. But I mean, we got pretty far into an analysis of this. We compared different Difference, you know, compared a numerical. What's the Runga Kutta four? Yes, we compared different iteration methods for integrating along the geodesics to see how accurate our implementation is versus some of the implementations that are used in things like the polygon methods. Since you don't Since you don't really have the luxury of getting to use geodesic flow there, you really have to work kind of brute force in this space. So, a lot of people will use different integration methods there. But yeah, I mean, you know, if we compare the closed form solution with Rungakota 4 and they're the same to six decimal places, then it's at least evidence that we're doing the right thing because two very different methods got the same answer. Thank you. Answer. Thank you. Great. I just wanted to follow up on Joe's question. The latest generation of GPUs support ray tracing natively. I wonder if you've looked into that. I assume that apart from just the extra horsepower these cards have, the ray tracing extensions are basically useless in this context because just Context because just yeah, right, they they bake in E3 is built in, right? Like, I think, did we was it Matthias Gurner that we asked about this? I think it might have been. Yeah, so so I don't know if you know Matthias Gurner, he's um he works at Pixar and he's also still publishing lots of papers in geometric topology because he has too much time or something. Um, but so so we've worked with him on. Worked with him on related projects. And yeah, so he knows what's going on with that. And yeah, it's not going to be any use. It's a miracle that the things that are in graphics cards are useful to us, but the new stuff doesn't look like it will be. Thanks. I mean, that being said, they're going to have more DDR5 RAM or whatever the GPU RAM is, that'll help us out a little bit. Ram is that'll help us out. Get the biggest card, and it'll probably help, right? And these things do need. Oh, so, so, yeah, Steve has also been doing, what is it? I keep path tracing. Steve has been doing a lot of path tracing recently. And that just, you know, leave it on overnight. We'll take as many graphics cards as you've got, and you get really pretty results. But yeah, did you share more funding than you needed? Yeah, so. Sorry, did you check with Mathematica if they have something? Mathematica? Does Mathematica use the GPU? I'm not sure exactly, but it does like lots of visualization for motion. I think they're mostly polygon-based, aren't they? You can barely draw nice triangle meshes. Yeah, there's a graphic thing, which is all mobile meshes. Multiple meshes. And it used to be the case that all Mathematica graphics plugins were written in Mathematica graphics, and then they broke that. And I'm very sad and will not update Mathematica until they get better. Yeah. Yeah, it's difficult to switch graphical systems for a large project. You couldn't really take something that was written. You couldn't really take something that was written in a polygon-based method and easily just change things and plug it into something that's based that's an array marching method. It's a very different way to do things. Yeah. Yes, so we do have our second part two of our second mini course starting in about a couple of minutes. So if people want to make care, we'll wave. Let's head over there. Way over there. Thank you once again. Very nice. Thanks.