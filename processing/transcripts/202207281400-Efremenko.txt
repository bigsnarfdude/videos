Okay, so today I'm going to talk about coding for interactive communication. I actually was surprised that no one talked before me on this. And I'm going to show you a really surprising result in this field, which is okay, so which is the following. Is the following? So, what is like the most basic question we ask about error correction codes? The most basic question we would like to ask: I just have some message error and there is some noise and you want to send this message to the bob, but there is some noise in the media. This is like the classic of classics of error correcting codes. And what is our solution? And what is our solution? We take our message, we encode this error protocol and send it out to the bottom. Now, what we know about, let's ask the first question, like probably the first question we would like to ask, what's the maximum amount of errors you can handle? And here today we're going to talk about adversarial noise. Okay, so like all noise that I'm going to talk with is adversarial. So in question, what's the maximum amount of noise we can conduct? Amount of networking candle, and we actually know the answer, like from the 50-50 from forever, which calls not impounded, which states that maximum amount of noise with the candle is one quarter. Okay, so it has a little bit asterisk. So people probably know this result. And the asterisk it has, it's if the size of your number of your passable code was goes to infinity, then Code was goes to infinity, when this goes the amount of significant cutoff is one quarter. So everyone knows what I'm talking about. So why is one quarter? Because like it in the regional version, it says that the distance of the code is one half, and we know that amount of errors we can handle is one half of a game. So it means that the amount of errors we can handle is one quarter. Now, here is the equation. What happens if I What happens if Alice still wants to send a message to Bob, but we allow to talk with each other? So Alice can say something to Bob. Bob can reply something to Alice. What will happen? For me, it's really surprising, but here communication helps. Because you would say, oh, but why would Bob eventually want to talk? He has nothing to say. He has no metrics. Alice is not interested in anything. Alice is not interested in anything that Bob may say, so why would he like will be interested in the talking at all? Okay, and it turns out that it's actually helpful to talk. And this results, like I'm really surprised that it's true because we started with proving that this is impossible, but like actually But, like, actually allowing Bob to talk will not help us for our resilience. But we are able actually to show that it actually helped. So, if I just want to send message to both and we are allowed communication, we can actually handle some fraction which is more than one quarter. Here is some content, it's not dyed, it's a small content, but it's just. Content, but it's uh it just shows the separation. I think it's uh that's important. Okay, so questions about so like I feel it's yeah when you say this amount of quality fraction errors of each method that the most quality fraction does so okay so here I assume that it's not adaptive model okay so it's means it's actually will be like three-round model and adversary can corrupt You can corrupt one plus this fraction of Earth from total communication and kicking this aside if you want to corrupt maybe only IS and the dozen and let all the both like it's a very like most generic types of errors can you expect the conversation more yes like like there is no like I'm not trying to cheat here so there is no I'm not trying to cheat here. So, there is like we are fixing lengths of communication, and we are actually saying, like, what's so expirant protocols? I'm saying what's the length of Alice's message, what's the length of the boss message, and what's the length of the Alice's message. So, it will be free around protocol in this case. I found this extremely super before this, I want to say, before going into this term, I want to talk about. Into this term, I want to say like there are three tasks we are going to talk about today in this lecture. One task is message transfer. What happens if Alice just wants to send a message? Another task is the message exchange. Alice and Bob want to exchange messages. This task is quickly harder than this task. And the third thing that we want to talk about is interactive communication. Alice and Bob want to execute. To execute some protocol and they want to compute some function f of x y. So, in fact, this task is like more generic than this task. But and it's equivalent up to exponential blow-up. So, like here when we are talking about interactive communication, usually like also assuming that you want blow-up to be linear. Okay, so it's just I just wanted to say. So it's just I just wanted to say this because like otherwise it's people get confused. So what will be our plan? Our plan will show like how like I'm not going to dive deep into the solution but first we will show like solution for message exchange and based on this solution we will show how we can get a protocol for message transfer. I just want to I just want to say here that message transfer is in general an easier task. Right? So if I want to send you a message, it's much easier when you want to exchange message. The whole thing here is like we want something which is optimal. Questions about what's our error resilience. So this is the question. So I want just to talk like a little bit more about interactive communication and what is known. Interactive communication and what is known. And so, because I feel like it's a very exciting field, and just people are not enough aware about the results that happened in this field. Okay, so what would be like your question, like binary interactive? So I think that we want to ask a question about magic trans. To ask a question about message transfer. Alice and both have messages and they only exchange their messages. Okay, and what's the maximum amount of noise will be able to come out? So what would be a trivial solution? So if Alice just encodes your message error correction code, sends to Bob, Bob encodes his error correcting his message error correct. It will be this will be resilient. The solution will be resilient to one eight of errors. Why will it be resilient to one eight of errors? Because for adversary to corrupt per communication, it's enough. We know that each error of encode is adjusted to one quarter of errors. So it's enough for advertising to corrupt one of the messages. So this is the trivial solution. So this is a trivial solution. If instead of like just exchanging two messages, we want to implement some interactive communication, you also can get this one eight result. It was shown by Brother Vanindrau in 11. And this is like, we can actually. This is like we can actually implement any interactive protocol with only control. Okay. And like it since like Robert Monroe, I think the question was asked, like whatever this one eight is optimal. And like recently we showed that it's actually showed that it's actually it's actually not optimal like that you can actually do chuckle which is better than one eight so I'm going to show you this result because it's a simpler and it like shows like a very nice feature which called feedback and why it's important and how it can be used but I want to say that since then since then this was like also a really nice paper I really recommend Really nice paper. I really recommend to read this paper by Gupta and Zank, right? So they showed that actually we can get one six and this is optimal. So we can actually have a one six error. I say it's like really surprising itself for me. So maybe I'll explain later why it's so surprising. Okay, so questions so far about message. So like at the beginning I talked about message transfer, now I'm talking about message exchange and this also works for like interactive protocols as well. Okay. I just want to talk, I just want like it's a little bit detour, I just feel like people will like to share a little bit. So what Like to show you a little bit. So, what happens if you are talking about a large alphabet? Like, it's usually over a large alphabet thing, it becomes simpler. And I want to say that if you say, if you want to have a solution for, like, say, message exchange, one quarter is tight and optimal. It's a trivial solution, like, I'm taking my message and code with distance. With a distance close to one, send it to you, you send it back to me. And this is tight and optimal. It's like why it's optimal, because adversary can concentrate only on one party, it means that he can corrupt one half of one party. And if adversary is speaking more than me, there is no way you can distinguish between me and adversary. So we don't know whose message is right. The message is right. So this looks like it solves everything, but it's not. Okay, this is a lower bound. And there was a suggestion by Grafari Kafka Suda. They suggested that what would happen if what was the problem with the attack? At best, if you are concentrated on the particles. You are concentrated on the party who speaks less. Okay, but what happens if you'll if we'll allow parties to adapt? What does it mean to adapt? It means that what will happen if parties can decide each point of time who is going to speak. It's a good question, like how we define, we decide, because like Because, like, uh, we are not very to decide with speaking, we need communication. So, here we are each party decide to want to talk or to listen independently of another party. And in case they both decide to listen, adversary gets a free budget, he can like send it down to get his error budgets, what messages he's going to send and like in. And like in this case, if you are allowed parties to adapt and decide that who is going to speak well, it's possible to get a resilience of two sevens. Later on, you showed that you can actually get something better than two self. And I have to say, this result is very, very surprising. Why it's very surprising? Because this result in this result will show that it's not. It looks like, okay, message exchanges looks like very symmetric tasks, right? Aris wants to send message, want to send messages to Aris. So it's very symmetric. So we would expect that protocols also will be symmetric. But it turns out that we we cannot get optimal results with symmetric protocols. So like one part should be like very different from another part. So protocols of Alice and Bob are highly non-symmetric. Alice and Bob are highly non-symmetric. So Alice is doing something, Bob is doing something, and it's highly non-symmetric protocols. And it's actually, like in this paper, there was like a conjecture or kind of proof that 2.7 is tight. And actually, the reason why this proof that 2.7 is tight doesn't work is because we think that the protocol should be symmetric. It's kind of conjectured with assumption that it's very easy to make. And I have to say, like, in And I have to say, like, in track protocol, what I found is like the order of speaking, it's a very important question for interactive protocol. And especially like, this is why adaptivity is very, very important and they have like a lot of influence. And also speaking, like usually it becomes like completely, completely non-trivial. Like you think like, okay, so you think like interactive protocols, like understand messages, and so on. So on. The message at all. So on, but in many, many things, so, for example, here, many protocols, like in which order people are speaking, it's completely non-trivial. Like the best way to get optimal reticence, it's completely non-trivial. So you think it's like will be something symmetric, something nice, but it's not. Okay. Questions from Carl? I just want to mention here from I just want to mention here some open questions. So, for example, one question which is still left open is: what is maximum noise resilience for interactive coding over adaptive channel? So, here we show that 5 over 16 is the optimal adaptive channel, if you want just to exchange languages. Okay, but what if you want to simulate interactive? What if you want to simulate interactive communication with a with a constant rate, what will be optimal or maximal resilience? It's like widely open. Okay. Now I want to say, like, what happens if only what? So, this is what I and I want. And I want to say that a few things about this here. One thing is that it solves many open questions. Another thing is like what's important and nice thing about this, we define something which called like non-symmetric codes. And it means that distance between different code words will depend on what kind of messages we are encoding. So some distances will be actually better than some. And I believe like this area of code didn't get like enough of research. I believe that it's very interesting area to start thinking about it. It's kind of like we can define a lot of questions, but the whole area which we believe would be tighten for surprisingly. I want to also mention that some related work, but if all what if we wanted to do like metrics transfer, but we want to be resilient to erasers, where like each symbol is replaced by eraser, when it's like in regular settings, we know that it's possible to deal with one half errors. But if you allow communication, you can deal with three over five errors. I want to talk a little bit why we get to 1.8 resilience. Why it's so hard to overcome 1.8 resilience when we are talking about binary metric structure? And the reason for this one, like three reasons, why we get one. Why we get one half. One reason is if you want, so usually instead of taking error correcting code, looking on a binary error correcting code, you're losing factor of one half. If instead of getting least decoding, you want a unique decoding, you're also losing a factor of one half. And if instead of having a one-way task, we're having two-way tasks, we also have a factor of one-half. factor of one half and i want to say that kind of uh if we are not learning the if we are not learning interactive like binary and unique decoding we know which one water is tight right if we want unique decoding and two-way task one water again is tight and if you want binary alphabet Want binary alphabet and two-way task and leave the code because again you know that one quatter is typing. So, like in order to beat one eight, we need actually like combine all of these three things. Okay, I want to say like there are like two things that I like, okay, like I from my Okay, like I from my like research in like or thinking about like interactive there are two things that I found that are really important. One thing I say that it's order of picking or adaptivity another thing is feedback. CBAC like it turns out like a very very important ingredient or a very important thing to like have it in mind. And here is the following and here what's what is feedback. Feedback it means that when we have Feedback means that when we have interaction, so here is like why it's why there is like waiting for Bob to speak when only Alice wants to send the message, because Bob can actually tell Alice what errors are there. So this is why it's important. And actually, there was like the whole question of feedback channels. And feedback channel is the Channels and feedback channels is the following channel. Alice wants to send a message to Bob, and adversar can corrupt her messages irregularly. But after each bit that Alice sends, she knows if this bit was corrupted or not. Okay, so this is a feedback channel. And Bernicam in 1969 actually studied this feedback channel and she showed that. she showed that channel is repeated to one-third of noise and actually it's very interesting because he was able actually to characterize the whole region of a radirt and distance for pick channels which is actually if you you know it's it's not known for for regular binary channels because for regularly bin binary channels you have a adversarial noise Also, the adversary of noise with some within the gateway was some other gaps, but there is still a gap between what is upper bounds and what is lower bounds. For feedback channels, we know exact answer. So, like, in the so it's a you by the way, no, note that without it, you could get only one word. So, what it implies, first, what it implies is a What it implies, it's bad, what we can have is one-third lower bound for message transfer. Why is it so? Because in feedback channel, it's the same channel as we were thinking here, the difference that we don't count communication from both to Alice, and adversaries not allowed to count communication. So it's much more restrictive, right? So we both don't count because counting communication means that if we Communication, it means that if we are counting communication, it means we are increasing the budget of adversary to corrupt, to make errors. And like it's usually in this case, it's assumed that it's noiseless secret, but you cannot corrupt actually what we get. It also implies one six lower bound for message exchange. Why it applies one six lower bound for? Why it's applied one stick slower bound perverted exchange because the adversary can like a concentrating part of two speaks left, corrupt one of one word of communication, and then it implies that the best logic he can get from the second party, like feedback, he'll also get the metric part. And but because we are corrupting one curve communication of one party, he will not be able to send this message to the depth party. That part. I just want to mention that these feedback channels, like they turn out extremely useful. For example, we were using them when you want to design resilient circuits or resilient formulas. And it's actually when you're thinking about resilient circuits or formulas, a double game. Formulas for A double games, it turns out like to communications, communication people. A question here from Zoom. Hi, I'm Amit. I'm on Zoom. So this message for the message exchange, are you assuming that there's noiseless feedback in both directions? No, here I'm not here I'm not assuming a noiseless feedback in both directions. Uh, noise feedback in both directions, but it's all it's if it's a non-adaptive, it's true also if noise will see back in both directions. Here, I'm like saying that the lower bound will still be called, but I'm talking about the question of message exchange. Right? So, if you want to just if you want to exchange messages, then the best one we can get is one six because the channel when we are not. Channel of when we are not assuming noise in both directions is strictly weaker when we are assuming. Okay, it doesn't answer the question. Yeah, thanks. Very strange when people asking this because they don't feel like okay. Okay, now I want to show you I want to show you a protocol for message exchange that beats 1.8. It's actually relatively simple protocol. So it's a protocol that have three routes. Total communication will be 39, right? 16 plus 20 plus 3 39. So it's slightly better than what Slightly better than one quarter because if you are long five five over one, slightly better than one eight. If you're length five over four, it's one eight and it's five over 39. You're getting here a little bit. And what would be a protocol? Protocol will be as follows. I just will send your message with a discodable code. This decodable code. Okay, over in the first part of the project. So, and what's mean this possible? We are thinking about this of type 3. It's all what we care about. Next, what Bob is going to do, he's going to list the code this message and send his. And sent his message together with list that he got from this department education and sent it back to Alice. And last, Alice is going to look on this list. And she is going to send index what is the index, what is the correct answer. Answer what is the short correct message. So, if like say she bought a bit, she ordered the bitlet graphically, and then she says, Okay, my message is the third part, or my second message is the fourth part. This is the protocol. Okay, so what I wanted to say about this protocol This protocol, first of all, like one interesting fact. So, which if you want a code which is least decodable to a list of sites 3, binary code, decodable list of size 3, if every dilance is actually binomial. Okay? So this means that we are sure that if Bob Lis goes here, he actually gets She actually gets Alice's message correctly. So, one of these three possibilities is Alice's message. Next, here we have 20, so we have only one, adversary can correct only one quarter of messages of Bob. So, it means that I just here actually get a message of Bob correctly. Not least decoding, nothing. And the last thing I want to say: talk about how I stand with index. And here is where why like plotting bound is not the asterisk of plotting bound. And asterisk says that we need actually our error correcting code, such as error correcting code called infinity. If the number of our possible code work is only four or only three. Only four or only three, you can get a distance of two thirds between our co-politics. Here's a very simple very simple code. And just verify that this is what you'll get. Okay, so this code can be resilient to one-third of errors. So uh what uh what does it so okay so what does it uh what does it mean here? So here it means that okay adversary what's what's the problem? Like adversary skill, we are saying here only three and beat, right? So adversary skill can take uh so it's enough for adversary in order to corrupt our message, it's enough for adversary to invest only one and error skill. Only one n error here. But what happens if a verter invested one n error here? If even a vertical invested one error here, it means he can invest at most four n errors here. It means here that here our least decoding will be correct. Like our if you just take the best or our first code word, it will be correct. It will be correct. Okay, and so okay, so here we need some kind of extrapolation. So, here we know, like if we are inviting only one earth, Bob will know that how many earth was invited here because she'll just see what we did into the closed code work, and if we didn't to the end, then she knows that it was an else. And errors. And we did like all interpolations in between, right? So it's maybe where adversary invested here more errors, but then it will be much. So if adversary invested, say, two and errors, then here adversary will invest at most three and errors. And if say I see here at most three and errors, she knows because the distance of our code is eight L, she knows. Is 8L, she knows that this answer is correct. It cannot be like something else because she cannot corrupt it from another code. So there is like all this kind of interpolation, and it's not very basically like a simple exercise to see that this work. I just want to stop here and like to see what is what is. What is actually here? What we see actually here is the protocol. It's like what we are seeing here. It's like just a protocol for Alice to send your message with one round of feedback, right? So Alice sends your method, she gets one round of feedback. And so this is the bit she got feedback from Bob. And we show that if And we show that essentially, like the protocol for one round of feedback can beat one quarter. And this is like, and it's actually convenient, right? Because you can improve protocols for one round of feedback, you can improve resilience of this protocol. Okay. Okay. Now I want uh to Now I want to talk how we are going from metrics transfer to from metrics change to metrics transfer. And what's the problem? The problem here is like the same protocol will work for just message for just message transfer. The only problem is like Transfer. The only problem is that the budget of a battery now grows. If before we wanted to beat one eight, now we want to beat one quarter. So the budget becomes much, much bigger. And the problem here is that we cannot allow us ourselves unique decoding in a second state. Like we just, you can just hear that, like, if you have an interactive protocol and both. Protocol and Bob speaks too much, right? When it's enough for us to corrupt only one third of communication from IEC. So Bob cannot speak more than one over 12 of total communication. So if you want to be so, like, and therefore, like, we in certain states, you cannot anymore assume that we have unique decode. Now let's consider the following task. Now let's so we have here, like I will tell you, like we tried to show that it's one quarter is tight. And what would be like approach to show that one quarter is tight? Let's say for even for three rounds, add it well. Add it. Add it. And let's assume that you have You have one quarter in every stage of the protocol. If you're corrupting one quarter of communication from Alex to both, there is no unique decoding. Unique decoding is not possible anymore. Okay, and since unique decoding is not possible anymore, in this case, both will have at the least two possibilities. Two possibilities, some possibilities, say y1 and y2. Now Bob sends one quarter message to Bob. So Bob can send these two possibilities that you have, Y1 and Y2. And Alice will also, like unique decoding, is not possible. Alice will get two possible leads. So one lead, like say F. D1, second list will do like straight x. G2, because if she knows if one of the list doesn't contain x, she knows that it's not correct list. And then if you are looking on the following task, I have some x and two sets x1, x, 2, and the top has the x and y, where y is the sum of these possible lists. So this is like a very. Possible leads. So, this is like a task for the last program. The goal is like for us to send message and want to for both to output X. And we can actually show that communication complexity of the task with order of log error. And when we have this result, we say, Oh, we are done with this problem. It's almost proven. It's almost proved that one block is time. Because if in this state, the number of possible messages that Alex could send goes to infinity, what in bounds of life, and therefore we know that every gen of what Alex sends here is at most one quarter. Therefore, what we have here at least two different possibility powers. So, how we are going around this, what's wrong with this argument? The wrong thing about this argument is that not all messages that go and send are equally good. Because some messages will assume a bigger amount of errors than other methods. Messages okay, because like for some messages you will have like to corrupt in previous rounds more to introduce more errors in previous rounds. And this is what makes what allows us to overcome this problem. So like it's actually like once we have this problem like formally stated, so you can actually like write So you can actually write what's what's a requirement for your authority code. It will take some time and the people will fall asleep completely if I'll do it. So I don't want to do it now. So I also worked with that even at least decoding is impossible in second stage because the adversarial actually got corrupted, the second stage could be forever. So what I wanted to say is that regularly we care about minimal hidden between two code words. Here we notice that some methods are more likely to introduce errors than others. And our problem is that clocking bulbs still takes over even for average. So even if you log For average. So even if you want to say to ask what's an average difference between any two messages, it's still called. So plotting bound code or average. And therefore, if you want for some code, the distance will be bigger, you have to deal with a case where for some messages the distance will be smaller. Okay. So how our protocol So how our protocol for generating our protocol will look will again send some list decode about erotics code. Bob will just take list decode and just send the list back. And then Alice will send the message here of X and the list. C of x at the list, and she got she listed code here. She gets like three possible lists, and she sends C of X the password of three possible lists that she got. This is how it will look like. And then, what will Bob do? He'll estimate how many errors here, like based on what he received here. So, like, it's I just Bob gives. Alice both gives feedback on Alice's method, and Alice gives the feedback on both methods. So it's a very interesting project here. So we are both giving feedback and explaining what we saw and the outputs that started. What I want to say is here, like I'm not doing like all this, like it's actually not if you try to do and concentrate for the take like several hours, but it's possible. No, it's it's possible like. But it's possible. No, it's possible to do it if I would explain it, it would cause you to fall asleep in the half hour, but it's possible to do it. But what will be conclusion? Like, we define what's called the location-tensitive codes. And what you want, you want the following proper. If we are encoding x and y and y and x, like just in different positions, if you are encoding x and y and switching your positions, And switching your condition, we want that our distance will be large, larger than one-half of some delta, plus something. If just one, if you are encoding x and y and only one of the methods is in the wrong position, you want like it's somewhere in the middle. It still should be larger than average, but somewhere in the middle. And if If uh if like uh no if there is no uh let's go if if there is like nothing if there is nothing is in the same petition on different position then it will be a little bit smaller. The worst case here is actually when d equals to d prime. So when we should we have the same code the same message like but on the same position. So this is like what kind So, this is like what kind of code work we needed to build for our construction. So, I will not go too deep into how to do this. So, I want to say that it's a randomized construction. So, kind of randomized construction where you so it's uh it's Well well so it's uh it's uh just rather so this is what I'm going to say. It's rather difficult. So I want to say that like uh open topics, this is what I want to get to. And I want to say that like like in interactive communication, we have like with what we want to advertise, like it's open problems here. And we have like way too many open problems and like many And like many very interesting open problems. I would like to mention several open problems related to this work. One open problem is what is best possible regulators. So we know that it looks like a very basic question, right? So like it's generalizing plot and bound for interactive communication sounds like super interesting and we don't know the answer. We don't know the answer. So far, it looks a hard question, but I believe maybe once we think and come up with the right protocol, it will be easier. After we will be passing, it will be solved, like what will rate a distant trade-off for what we can say at all, like for a distant trade-off for interactive charter. Because you know, take for example the Vershanov valve. What we can say for interactive phase? Can we like generalize Gilbert Version for interactive phase? Can we get to Gilbert Version of what point can we beat and what's the relation? The third question is like explicit construction. We had a construction of location sensitive code, which is like randomized. Is it possible to give an explicit? Is it possible to give an explicit construction of site code and how we can have such constructions? Next, I want to ask what's I feel like it's like could be field based. Or what happens if corruptions are on what happens if say corruptions are on bounds, say for example, which are differently when we're corrupting alito and you. When we're corrupting Arith, when we're corrupting both. We have also many combinatorial problems that are arising from this construction. For example, you can ask what happens for general, like I'm giving you a list of distances when code words is so I'm giving you like the whole graph, the distances between all code words, and when does it pass? All code work and when does it possible and when it's not possible, like how we can answer, or developing the theory around this? Like it's also, I believe, it's an interesting question. And yeah, and I think that's all. Thank you.