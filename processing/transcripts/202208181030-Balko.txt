Today we'll be talking about obstacle numbers of graphs. This is a joint work with many people: Steven Sheplic, Robert Jenny, Sina Gupta, Palf Mark Pavel Walter, and Alexander Wolf. And let me start by saying what actually obstacle numbers are. So we will be dealing with drawings of graphs. We will focus on drawings which are sometimes called rectilinear drawings. So here vertices are met to distinct points in the plane. Edges are represented by line segments. So edge corresponds to a Segments, so H corresponds to a line segment, a line segment that corresponds to points which represents the end vertices of the particle H. So this is an example of some graph drawing that we can be dealing with. We will also use so-called obstacles. So we will add obstacles to our drawing. An obstacle is just a simple polygon in the plane. Not necessarily convex, it's just a polygon in the plane. So here we already have our drawing. So here we already have our drawing. I can put some obstacles there. So those are, as you can see, are simple polygons. I have four of them. They are not necessarily convex. And now the crucial definition here is the obstacle representation of a given graph. So the obstacle representation of a graph G is a drawing of the graph G together with obstacles such that two vertices are connected by a line segment or by an edge in the graph if and only if the corresponding line segment avoids all the obstacles. Avoids all the obstacles. And this is really if and only if. So, as you can see in this example, whenever I have two vertices collected by an edge, the corresponding line segment does not interfere with the obstacles, so the visibility is not blocked. But whenever I have two vertices that are not collected by an edge in my graph, then if I would add, if I added the corresponding line segment, I would intersect some of the obstacles. This is real if and only if. And this is somehow visibility representation of how. So this is the obstacle representation. So, this is the obstacle representation on which all the concepts will be based on. In particular, the obstacle number, this parameter which I will denote by OBSG, is based on these obstacle representations. And this is a very natural parameter. It's the minimum number of obstacles that I can use to obtain an obstacle representation of my graph. So, if I'm given a graph, I can choose the drawing, I can choose the placement of the obstacles, so that I can find an obstacle representation of my graph. Find an obstacle representation of my graph, and I want to do so using the minimum number of obstacles that I can have. So, here, for example, in this drawing, I had four obstacles, so this shows that the obstacle number of this particle graph is at most four, but clearly this is not optimal, because I can merge all the obstacles into a single one, and this shows that the obstacle number of this graph is at most one. Because there is at least one knowledge, for example, this one, I need at least one knowledge. Example: this one, I need at least one obstacle, so this shows that the obstacle number of this graph is exactly equal to mine. Sometimes we also consider obstacles that are required to be convex, and then we are talking about convex obstacle number denoted by this obsc of g and this is exactly the same definition: this is the minimum number of obstacles that I need in an obstacle representation, that is just this additional requirement that all the obstacles should be convex. Be convex. So let me show some examples just to be sure that everybody understands the definition. So do the convex obstacles have to be disjoint from each other? Oh yes, we are always assuming data district. Because if they were not, I could merge them, I could decrease the number of obstacles. Oh, okay. For convex, yeah, okay. We are assuming data distribution. So some examples. Notice the obstacle number of an empty graph. Number of an empty graph? Well, it's not hard to see that this is one, because I can consider this particle drawing of the empty graph. I can place the points in a convex position, and then I can just add one convex obstacle like this. It blocks all the non-edges, and it shows that the obstacle number of empty graph, no matter what size it is, is equal to one. Because there is, again, at least one non-edge, so I need at least one edge together. Another example: what is the obstacle? Another example: what is the obstacle number of a tree? Well, I can consider a plane drawing of the tree and I can fill out the outside face with an obstacle. And this again shows that the obstacle number of any tree is at most one. If it has at least three vertices, there is a non-edge, so the obstacle number is exactly equal to one. Let's take an example. So, what is the obstacle number of a grid? So, here we have a grid four times five, it can be million times million. It can be million times million. Do you see what is the obstacle number? What did I guess this? It's quite surprising the obstacle number is one. You can represent the grid using a single obstacle. Because you can choose a different drawing of the grid. This one. It's still grid, right? This is just some hard twisting, but it's still the same grid. And then again, you can do the same trick. You can fill out the outer face with a swing. Trait, you can fill out the outer face with a single obstacle, and it shows that the obstacle number of any grade is equal to one. So, this particular example was found by Fabrizio Frati, and it shows that sometimes finding this optical representation can be non-trivial. Okay, so those are the stack members or obstacle representations. Let me show what we know about them. So, I will just introduce some more notations. So, this OBSN will be the maximum obstacle number of NA. Will be the maximum obstacle number of any graph with n vertices. I will do the same thing for the convex obstacle numbers. So this OBS C of n is the maximum obstacle number of any graph which has n vertices. And clearly you can see that this OBS n is always at most obsc of n, because if I require my obstacles to be convex, then I can never decrease that. So it's incorrect. There is a long-standing question of Albert Koch and Lyson, whether the obstacle numbers of n-vertex graphs are bounded by a linear function of n. So this is still open. We do not know whether this function is only linear. But we have some bounds that are fairly close. So for the lower bounds, many people people consider this problem and they improve the lower bounds until Limovich and Morem show the territory best bound, which is of order n over local conscript. And over local conscript. So, as you can see from below, it's almost linear, and somehow believed that it should be linear. For the upper bounds, we clearly have this trivial quadratic upper bound, which says that observes at most n choose 2, because we can do a simple trick. We can just define a single point obstacle, a small polygon, or place some small polygon for every non-edge, for example like this, and it shows that the obstacle number of any graph. And it shows that the obstetric number of any graph is at most tensions two minus the number of edges, so this is the number of total number of non-edges, and this is clearly at most enthusiastic quadratic function. For some time, no better upper bound was known. There was even a conjecture, contrary to this question, that these optical numbers can get quadratic, they are quadratic in n. But we disproved that some years ago together with a possible gun. Pavel Valtra, we showed the We showed that subcardinatic upper bound on these obstacle numbers, we showed that they grow roughly n times okay. So it's almost linear upper bound. So now we are close to the linear one from below and also from above. In fact, we proved something stronger which answered the question of Albert and others for graphs that have bounded chromatic number. Because we proved a stronger upper bound which shows that for any n-vertex graph, the obstacle. Vertex graph, we can the obstacle number is at most roughly n times the logarithm of its chromatic number. So if the chromatic number is constant, then this becomes a linear bound. For example, for planar graphs, we now have a linear upper bound. But in general, it's still open. We can improve this to a linear one, so we don't know. Here is a picture that somehow illustrates how to achieve this bound for bipartite graphs. So this is a drawing of your bipartite graph. Drawing of your bipartite graph that you work with. We call them so-called dilated drawings. They have the property that here we have sort of caps, or caps, or caps, sorry, which we can use to block all the non-aggressions by placing some convex obstacles like this. And then it just remains to block all the visibilities between vertices from the same color class, but we can do this easily by placing only two obstacles. In fact, here I'm using non-convex obstacles, but also. I'm using non-convex obstacles, but all these bounds apply also if we require the obstacles to be convex. So these upper bounds are also true for the convex obstacle number. Yes? You mentioned these almost linear lower bounds. Can you achieve those with bounded chromatic number? So the best one, probably not. But the other ones, I think you can. Because I will show you it's based only on counting arguments and the number of bipartite graphs is asymptotically the same as the number of Is asymptotically the same as the number of graphs, so it then doesn't matter. Okay, so those are the known results. Let me say what is new. What can we prove now about obstacle numbers? So, first of all, the paper is called Bounding and Computing Obstacle Numbers. I will focus only on the bounding part. We have some algorithmic results, but the structure results are closer to my heart, so I will not mention those. And I will only focus on the bounds, only being bounded. only focus on the bounds on the mean bounds that we have so first of all we can improve the currently best known over bound of mimovich and morin which was uh n over a log log n squared we can drastically improve it to n over log log n so we can get rid of one log log n factor for us this was a little bit frustrating because we are aiming for the linear lower bound which is believed to be tight and we really got close we cannot prove it only in some like strange strange settings Strange settings. In general, we have this n-log over log again, but not the linear one, which was a pity. But on the bright side, we can prove the linear lower bound if we require the obstacles to be convex. So for the convex obstacle numbers, we now have a linear lower bound, which I recall, believe to be a set of. Now, the proofs of these results are non-constructive. We use a counting argument that I will illustrate. So we cannot produce a particle drawing and placement of. Produce a particle drawing and placement of the obstacles that would, or some particle graph for which we would need linearly many obstacles. We just use a complete argument, a non-constructive proof. And this non-constructive proof is based on estimating the following functions. So for two numbers h and n, let fn be the number of graphs that have n vertices and that have obstacle number at post h. Similarly, I can define an analogous function for the convex obstacle numbers, so f. For the convex obstacle numbers, so FCHN is the number of graphs on n-vertices that have convex obstacle number at most. Now, if I have a good upper bound on these functions, I have a good lower bound on the obstacle number. For example, imagine that if I can bound this as a function which is roughly 2 to h times n, then I know that there are graphs with linearly large obstacle number. Because the total number of such graphs, Because the total number of such graphs is f uh two to h times n, but the total number of g graphs is two to h uh n squared, so h times n should be comparable to n squared, but this can only happen if h can be summarized in n. So those are the kind of arguments that we use. So if we have a good upper bound on these two functions, we have a good lower bounds on the obstacle numbers. So which bounds do we actually have on these functions? So for the function f hn, for the standard obstacle number, obstacle number, we can improve this upper bound, which is roughly 2 to h times n log n. So this improves a previous best known upper bound by Mukamalapa and Palvoggi, who proved the same upper bound but the exponent had an additional log n factor. So this is where we got this log log n improvement at the end. And this actually solves also a conjecture of Limovich and Morin who believed that some upper bound of this form Some upper bound on this form where instead of h we have some sub-linear function of h should be true, and this actually follows from this. So we have this for the standard obstacle number, for the convex obstacle number, we were also able to improve the kinetic best known upper bound. And we showed that this is at most roughly 2 to n times h plus log n. So it's not times log n, it's plus log n. And here for this convex obstetric number, what is interesting is that this button. What is interesting is that this bound is actually tight. Years ago, we proved with Joseph Sibulka and Pavalotre that for these convex obstacle numbers, this function can sometimes be as large as, can be as large as 2 to h times n. So this gives us this first term in the exponent. And if you have a single obstacle, then this can be as large as two times two to the n uh log n, which gives you the uh the second term in this exponent. So this bound is actually correct. So, this boundary section, right. So, I would like to sketch you the proof of this theorem, but before I do so, I will just mention one result that we also have in this paper. And this deals with the natural question, what happens if the drawing is fixed? So, I said that whenever we are constructing these obstacle representations, we can choose the drawing and we can also choose the placement of the obstacles. But now, assume that we cannot choose the drawing. The drawing is given to us. To draw. The drawing is given to us, and we can only place the obstacles so that we use as few of them as possible. We can define this natural parameter, the obstacle number, not of a graph, but of a drawing. So what is the minimum number of obstacles that we need to turn a given drawing of some graph into an obstacle representation of that particular graph? So we also consider this question. It was asked in the workshop actually once. And here we proved that this problem is actually not. Prove that this problem is actually not that interesting because we can have this quadratic lower bound. So, sometimes for some drawings, we need quadratic limits. And I recall that this is the best we can do because we still have this trivial quadratic upper bound. So, this asymptotically settles this question. It's at most quadratic, and sometimes it indeed is quadratic. Here in this figure, you can see an illustration of the drawings that we use. So, we start with a cup. So we start with a cup, which grows very, very fast. Then we sort of double it. So we take a copy, just place it slightly below. In this copy, we throw out some edges so that we have quadratically many non-edges. And then if we construct it carefully, there is this key property that every phase of this drawing is incident only to at most two non-edges. So whenever I'm placing an obstacle, I have to do it in a single obstacle has to like The obstacle has to lie in some phase, but then it can block only at most two non-edges. And if I have quadratically many non-edges, then I need quadratically many obstacles. So this is the rough idea behind this proof. Okay, so let's go back to this theorem for. So I will sketch you its proof. So recall that we want to prove this upper bound on the number of graphs that have n vertices and the convex obstacle number at most h. Obstacle number at most h. So we want to prove roughly this 2 to n times h plus again. And the idea of this proof is just to take such a graph, take its obstacle representation, which is optimal, which uses at most H convert obstacles, and encode this representation as compactly as possible. So, how to actually encode it as compactly as possible using that many bits? So, first, we encode the positions. So first we encode the positions of the point sets, so positions of the vertices of microphone. And we do this using so-called order type, which is an view it as an abstract view on a point set. It's just a list of all the orientations of triples of vertices, so every triple is oriented either clockwise or counterclockwise. If you keep all the orientations, then we have somehow captured combinatorial properties of microprocess. So we will just encode our drawing essentially as this order type of this. Essentially, as this order type of these labeled vertices, and by a famous result of Goodman and Bullock, for endpoints, we had at most roughly 2 to the n times log n for the types. So, this gives us actually this second term in this exponent. So, this is the cost of encoding all the vertices of our job, or actually encoding the job. What remains is to somehow encode the obstacles. And we want to encode this. And we want to encode these obstacles again as compactly as possible. We want to encode them using only h times n bits. So for a single obstacle, I can only afford n bits, not to use n bits. So how to do this? So this is based on so-called blocking intervals. This is the key concept here, this proof. So if I have a vertex V and an obstacle O, then the blocking interval of the vertex V with respect to the obstacle O, denoted by this IO V, Denoted by this IOV, is the subsequence of rays that start at V, go through the other vertex of my drawing, and intersect the obstacle O. So let me illustrate this on the picture. So here I have a vertex V, I have some obstacle O, so far it's not necessarily convex, but it's a general obstacle. And now what is the blocking interval of this vertex V with respect to this obstacle? Well, this is the set or the list of rings that go through. That go from me through the other vertex of my drawing and also intersect this obstacle. So, in this interval here, I have these four black arrays because those are the ones that intersect the obstacle, but these two grey ones I do not count in my blocking interval because they do not intersect this obstacle. So far, I didn't use the convexity in this definition, but if my obstacles are convex, then these blocking intervals are actually useful. Then these blocking intervals are actually useful for us for capturing the visibilities because we can then easily prove that the pair of vertices u and v form a non-edge in my graph if and only if u belongs to the blocking interval of v and v belongs to the blocking interval of u with respect to some obstacle of them. So here I'm using the convexity of my objects. Because if my obstacles are not convex, then this is no longer true. For example I can have a situation like this. For example, I can have a situation like this, in I vertex u, vertex v. The ray that goes from u to v intersects the obstacle all. On the other hand, also the vertex from v going through u also intersects the obstacle all. But as you can see, u and v are visible, the line segment between them is not blocked by this obstacle all. So this is where we really need the complexity. So we have these booking intervals, you can show that they actually form an You can show that they actually form an interval if my obstacle is connected, which is this. So, those are indeed intervals. They capture the visibilities by this lemma or by this observation. So, what we actually only need to do is encode the blocking intervals, and for this, it's sufficient to just encode the end points of the data. Two extreme rates the rates that are tangent sort of or almost tangent to the to the uh to the object. To the obstacle. And we want to do this, as I said, as compactly as possible, and it's somehow more convenient to do this in the dual setting. So, this is the particle duality that we could use. It's the duality that maps points to lines, lines to points, using these formulas. So, for example, if I have a set of points, then their dual is an arrangement of lines. So, for example, this blue point corresponds to this blue line, the green point to the green line, and so on. Follows somehow pair. Colours somehow pair the points and the lines in the reality. And if I have now fixed an obstacle O, I want to capture all the blocking intervals with respect to this obstacle O, which means that I essentially want to capture the lines that are sort of tangent to this obstacle for every point that I have here. And we will do this by traversing this obstacle around with tangent lines. We will do it twice, we will do it for the We will do it twice. We will do it for the upper envelope and for the lower envelope of the obstacle. We will keep track of the tangents hitting the points and we will keep track of it in the dual. And we will see that this will give us some curve in the dual that can be encoded quite easily. So let me show an example. So here I have some fixed convex obstacle O that I want to keep track of. I want to capture its blocking intervals. And I do it by sweeping the tangent. So I start with the vertical. So I start with the vertical tangent line and I will keep rotating it counterclockwise and keep track of hitting the points. So I keep rotating it, the first point that I hit is the blue one, which as you can see in the dual corresponds to this incidence. So this captures the hitting the point. When I was moving it to the right, I was drawing this black ray in the dual. So this slowly, this will eventually give me the curve that captures the motion of the tangent lines. Captures the motion of the tangent lines. But for now, let's keep rotating. So I keep rotating until I hit the green point, which in the dual corresponds to this incidence. The movement that I made is captured by this line segment, which is part of the new curve now in the dual. And we keep rotating, putting the yellow point next. Then I hit the red point, the brown point, sorry. Then the red point. Now I keep rotating, but now I had to switch the tangent point. The tangent point now we are tangent to this vertex. So here I'm hitting the red line again because I hit this red point for the second time. I keep rotating, so then hitting a yellow point, green point, blue one, and finally I reach the final destination, which is the other vertical line that is tangent to my convex obstacle O. And as you can see, the movement that I made in the dual corresponds to this black curve. To this black curve. And this black curve captures everything that I need because it captures the combinatorial structure of the endpoints of the block intervals. I just need to keep track of these incidences. So I just need to know the combinator structure of this line arrangement together with this curve that I call cut path. So again, as I said, traversing around all with the tangent lines corresponding to this cut path. I should have two of them. I showed you the one for the upper end of the. I showed you the one for the upper envelope of biological, but we also have the other one, which is for traversing around the lower envelope. And we have these two cut paths here, and we just need to capture them somehow efficiently. And this is actually not that difficult to do because these curves are quite special. First of all, they are convex or concave, and we can easily simulate them using two pseudo lines in our arrangement. The lines in our arrangement of lines or pseudo lines. So, for us, you can use resultby tool, which gives you an upper bound on the number of ways how you can put a new pseudo line or cut pad pseudo tool from below to up and arrangement of n pseudo lines. The number of such ways is exponential in the end, which is this. And because these two cut parts can be simul simulated, each one of them can be simulated by a pair of pseudo lines. Is simulated by a pair of pseudo lines, we obtain this exponential bound for the number of cut paths in our region. We have 9 to the n roughly, actually twice because we have two cut paths. And this is exponential, this is actually using n bits for a single obstacle. For a single obstacle, I'm using in the encoding only n bits, which is good for me because I have, so this shows you how to simulate this cut path using two zip lines. And this is good for me because I have eight obstacles in total. I have h obstacles in total. For each one of them, I use n bits. So in total, I use h times n bits, which is actually the number that I wanted to have. So this concludes this sketch of the proof. We now have this compact representation, and eventually we have the good upper bound on this function FCHN, and eventually we have a good lower bound on the obstacle, a convex obstacle number. So I will conclude with some open problems. My favorite open problems around these obstacle numbers. So first of all, Around these obstacle numbers. So, first of all, there is this long-standing question of alpa and Lyson, whether the obstacle numbers are actually winner in the number of vertices. They are fairly close, but not quite. Then there is this very nice problem which asks whether obstacle numbers of planar graphs are bounded by a constant. So, is it true that there is some universal constant such that the obstacle number of any planar graph is at most this? So far, this is wide open. So far this is wide open. It's known that if you have outer planar graphs, then the obstacle number is at most one. So you can always represent them using a single obstacle. We know that there is a planar graph that has obstacle number larger than one. This is because ahedron, which has obstacle number two. And there is even a more brave conjecture of Lerman and others who believe that actually the obstacle number of any planar graph is not bounded by some constant, but it's at most two. And this is why the And this is wide open because the best upper bound that we have on this obstacle number of planar graphs is linear in the number of vertices. Well, it's very far from a constant, but nobody knows how to do it. Okay, this is all. Thank you for your attention. Thank you very much. Any questions? What happens to the thing in dimension 3? In dimension 3? Or in higher dimensions? Dimension 3? Or higher dimensions? I don't think it was not considered in high dimension, so far it was considered only in the plane. And from the top of my head, so I would expect definitely that the numbers should be lower, but I don't know if it's somehow easy to see that was not considered. Is there some sort of curious state for why it's supposed that the obstacle number of a planar graph is above two? So the result for upper planar graphs gave some idea that it might be bounded by a constant. And actually, it's very difficult to find a planar graph that has obstacle number larger than one. So this ecosystem took some work. I actually think that this was actually the paper. I actually think that this was actually the paper only about this, that they found the planar graph which is optical number larger than one, but it's difficult to bound them in the numbers in general, like to show that if I give you a planar graph and to show that this has optical number large. For example, the grid is. I mean, first time when you see a grid, you wouldn't guess that it's an obstacle number one, but it does. Maybe I'm just asking the same question but dropping planar. Do you have examples of growth? Do you have examples of graphs where the obstacle members are big? Like specific. Yeah. Oh. Like what would they look like? Not really. Not really, but I would expect something like a random graph to work. Okay. Random graphs actually work, right? Because those are the arguments, but yeah. But not really a specific example. At the graph which has observed whatever. What about like you as a finite uh family of graph that you fall with as induced? I don't think there would be a nice characterization because if I remember correctly I don't know if it's proven or if it's uh if it's uh just a conjecture, but I think people uh then it's something like it either it's proven or it's a conjecture that uh characterizing graph which is of the moment which is Optical number which is and maybe even outside obstacle number one is NPI. Okay, but maybe just not that complete characterization just can release some induced some groups that cannot be as induced. It's probably everything which is full. There there is a paper that deals with uh grasp that is obstacle number one and they have some some description I think but I still it's not complete. But there might be some some conditions, but I don't know. Some conditions, but I don't know. If you're restricting to planar graphs, it might be reasonable to also restrict to planar drawings of those graphs? Oh, that was done. It was done, but then the obstacle numbers are not that hard to determine. You can use, I think, otherwise formula. And they somehow correspond to the number of faces or something like that. But it was matter. Main result could be stated as an opera boundary. Could be restated as an upper bound in some sort of pseudonym arrangements where a subfamily is rectifiable. Can you go back to your button? Which one? One more, one more. Like that. So this 2 to the nh log n is like the h are the pseudo. Is like the H are the pseudonyms? H pseudonines, and no, no, no, h is the number of obstacles. Yeah, yeah, I'm saying you could be stated as compounding the number of pseudonyms so that a subset of, say, in this case, n of them is rectifiable and the rest, h of them, are not rectifiable. Oh, yeah, but we actually, so we capture each of these edge opticals using this like a parallel angle. like a pair of pseudo lines of this convex curve uh but we don't place them like uh all all at once at the at the in the arrangement consider these arrangements separately because we are founding like each obstacle separately other questions 