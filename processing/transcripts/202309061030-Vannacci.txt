Good. So today we're talking about iterated risk products in product action. And so it's a long project that I have. I mean, so it's something that I started with my PhD and it's been years that I think about it. And I'm a little bit stuck. So I thought that so many young people at this conference, maybe I thought, okay. Young people at this conference, and maybe I thought, okay, you know, maybe there is some young person that wants to help me, and so that is a good setting to just tell you what I have so far. And maybe we can, you know, if you want to discuss it further, I'm very happy. So the plan for today is that we give you a short little survey of just infinite groups. They've appeared already in the conference in other shapes and forms. Then I will tell you actually about iterated reef products and then tell you a little bit about my idea, which is Cartesian decompositions and the relatives. And the relatives. And in the end, well, I'll tell you my two cents about this problem somehow. The very little progress I think that I made. Okay, so let's start with what's a just infinite group. So a group is called just infinite if it is just infinite, right? So it is infinite, but when you cut it down, it's suddenly finite. So every proper quotient is finite, right? So there's no infinite proper quotients. Okay, so this is kind of, you know, it's infinite, it's big, but it's not so big. Big, but it's not so big. And actually, so if you think about an analogy, so in finite groups, the building blocks of finite groups, you can think of them as finite simple groups, because you know, you can, for every finite group, there exists a quotient which is a finite simple group. This is true. For infinite groups, simple groups are not enough. So you might think that every infinite group might have a simple quotient. This is not true. Think about Grigotsi's group, for example. This is not the case. So you have to. So, you have to enlarge a little bit the class of what you think are the simple groups in your category, and you have to include actually the right thing to think about are just infinite groups. So, there is this lemma, which is very easy consequence of John's lemma, which is every infinite finitely generated group has a just infinite quotient. So, in this sense, they're kind of a form of simple groups in this setting. Good? So, we cannot talk about just infinite groups without talking about John Wilson and Slavo Grigachuk, which you Slavor Gygotchuk, which you know, I think most of the theory is due to them actually. So you can start thinking a little bit about just infinite groups, but the most, let's say, general result that I know of about just infinite groups is the following theorem, which was originally stated by John in his PhD thesis, and then Zlava wrote it up in his chapter in New Horizons. So if you have a just infinite residually finite group, then you have only two options. Might be that it's kind of wild, but you have only two options. One option is that it's a branch. options. One option is that it's a branch group. So in particular, it's a subgroup of the domorphic group of a rooted tree, for example, Grigotsu's group. And I'm going to tell you a little bit about this in a second. And or the second option is that it is hereditary just infinite. And in a second, I tell you the definition of hereditary just infinite. So there are only these two options, nothing more. I'm cheating a little bit when the hereditary is just infinite, but not so much. So let me tell you a little bit what are branch groups. Okay? So to tell you about branch groups, I have to tell you about automorphism groups of rooted trees. Automorphism groups of rooted trees. So let's consider a finite alphabet, which I denote by 0, d minus 1. And we consider the set of infinite or finite words, x star over x, and by empty, the empty word. Okay, we're all used to this doing the counter set, so this is kind of standard, right? The regular dead rooted tree, which is denoted by t, is the graph which has these finite words as vertex x, as vertex set. And you put an edge between two words if one. Between two words, if one is a descendant of the other. So, if one can be obtained by the other by adding one letter of your set, right? And we denote by OT the group of a graph automorphism of this. So, let's draw a picture, you know, just to have in mind what we're talking about, right? So, we have the root, which is one special vertex up here. And then we have two elements. I said that my set is only zero and one, so I have two elements zero, one. And then after zero, if I put a zero, I have the word zero, zero. And I declare that this is a descendant of zero. And if I have one, I have the word zero, one, it's also a descendant of zero, etc. Word zero, one is also the senate of zero, etc. Of course, you notice, right, you write this picture, and then this picture has a very nice form, I would say. So, like it has a very particular property. And what I like to point out in this talk is the property of self-similarity. Okay, so the tree is actually itself times the set X again, right? So, it's the same, just you know, the, if you think about a shift, you can shift another letter, it's the same. What does it mean for the three? What does it mean? For the tree, this means: well, if you look at the, say, the tree hanging down from the vertex one, this red tree is again the whole tree, right? It's kind of self-similar, right? So some part of it is the whole thing. This kind of set, kind of space. But what does this give you? So this gives you what's called a risk-product decomposition of the automorphism group of T. Okay, so having this similarity gives you this risk-braddle decomposition. Let's see it very briefly. So any automomorphism of the tree preserves the root. Automorphism of the tree preserves the root, right? And so it has to permute the vertices, the first level. So this gives you a permutation of the set x that you fixed. And now, right, permutation. And then you can just think that, okay, I have a permutation at the top, but then at the branches that I have, I'm going to do some automorphisms of the group T, some of the morphisms of the group T. So I just have to tell you how it acts on these two parts. So I have this wreath product decomposition of the thermos grouped tree. Right. And actually, this wreath product decomposition. And actually, this reflect composition is used to define groups. So, somehow, you know, now we have this tree, it's very nice. And from it, I have a group, which is the honor of this group of these. And then I use the shape of this space to construct groups. And for example, the most famous example of this construction is probably Grigorio's group. Appeared also yesterday in Reich's talk. So, for example, if you define, so I don't want to concentrate so much on this, I don't want to use it, but you know, just to show you that basically you see like You see, like automorphisms, let's say B, which is defined in fun in the using another automorphism A that I defined before, and another automorphism C that I'm going to define later, and they're kind of one related with the other. Okay, so this is actually based, this is self-similarity because you're really defining something saying, I do something to the top, I do something to the left, I do something to the right. That's it. And why is this important? Well, it has various properties, and so it is an infinite, finitely generated Tarshium group. So it's not the first, but you know, count. it's not the first but you know a counterexample to the general burnside problem it is the first group of intermediate word growth so it's a counterexample to the mineral problem it is the first example of a group which is amenable not elementary amenable so these problems counter example these problems counterexample it is a branch group which is what i said before so i'm not going to go deep into the definition of branch group which we actually discussed in the first in the group in group one but just note something that i'm going to use in a second that Use in a second that if it's a branch group, then inside G, there is at finite index a subgroup isomorphic to the direct product of copies of G. And you see, this is again self-similarity. This is really the tree, there are two copies of the tree behind, below. And third property, last property is just infinite. So every, it is infinite, but every finite, every proper quotient is finite, okay? Which is kind of, you know, following in our class. So I described to you, this is kind of a prototypical example of what a branch group is. So there are these types of groups, which are just infinite. Groups which are just infinite, but then let's go to the second bullet point of the theorem of Grigarchuk and Wilson, which is hereditally just infinite groups. Okay, so a residually finite, I will say that a residually finite group G is hereditally just infinite if every finite index subgroup is just infinite. Okay, so you're just kind of iterating what you had before. So hereditarily means that all finite index subgroups satisfy still that property. And Grigorius' group is not hereditally just infinite for what we just said. Just infinite for what we just said. So we said that G contains inside itself at finite index a copy of G times G. So there is a finite index subgroup in G, which is a direct product of two infinite groups. So it could project onto the first factor, and this will give me an infinite quotient. So it is not a Heritage Infinite. It's just infinite, but it's kind of special. It's not a Heritage Infinite. And actually, Heredital just infinite groups are very mysterious. So actually, we do not have enough. Actually, we do not have enough examples for this. The examples are Z, the integers, the infinity, which is an easy exercise. You can give your second-year students, I think they can do it. And then this is not an easy exercise. So we can show that the groups PSL and Z are hereditally just infinite. This is a consequence of Margulis normal subgroup theorem. Actually, here you can replace PSLN with lattices in high-rank Lie groups, and Z is some kind of Some kind of, you know, right, lattices, right? So that's what Raman was talking about yesterday, basically. And these are all, these guys are all hereto-just infinite. Note that these groups are linear, okay? So most of them are linear, but I mean, so they're close to linear groups, which I'm going to say something about in a second. And actually, these are more or less all the examples that we have. The list is pretty short. And so, for example, you can start asking, so you know, you had Girgottzh's group, it has lots of nice properties. It has lots of nice properties. Can these properties hold for heritalized infinite groups? So, for example, we can ask what other heritalized infinite groups are there, and can they be torsion? Can be aminable, but not aminable. Can they have intermediate growth? Can they have intermediate subgroup growth? So, these are all properties, kind of interesting properties of finitely generated groups that you would like, right? So, intermediate growth is very interesting property, right? And we do not know. So, apart from the first one, so Misha Ersha. So, Misha Ershov and Andrei Hiking constructed some torsion and italic just infinite groups, but these are obtained with the theory of Goldshaf-Revich groups. So, really, really not tractable. It's really not explicit. So they exist, the theorem is there exist such groups, but there is no explicit presentation even, for example. So this is really kind of very implicit. So it's an existent theorem and doesn't give you an explicit group, which is desirable sometimes. And the rest of the questions actually are open questions. So we do not know if there is a hard intelligence information. So, we do not know if there is a heritalized infinite group which is amino or notary aminable, which is if there is a heritalized infinite group which is which has intermediate growth. We don't know if there is a heritalized infinite group of intermediate subgrowth. Okay, so this is kind of where the story stands at the moment. And yes, so for example, let me remark that the groups PSL and Z cannot be satisfying of these because they're linear, because they're cross-trus linear, so you have some kind of tits alternative. So, yes, so. So, yes, so for example, they cannot have intermediate world growth because either they are solvable, and so there is the they cannot be solvable groups of intermediate growth, or they contain a free subgroup. So, they're exponential growth, right? Good. So, what then, right? Ah, sorry, let me mention a comment that I added. So, Stefan Kyonk and Edward Schlesler recently, like two days ago, told me that they constructed some new non-linear AGI. New non-linear AGI torsion groups, but I think we checked, we thought that this, so they do not satisfy any of this, at least on the nose. Okay, so there are some more, which is very nice to add the examples to the list, but they do not help with these problems, unfortunately. Okay, so what then? What do we do? So then I think usually now when the problem is too hard, you don't know what to do, you take a step back, right? So we had the tree, very good. So, okay, let me, yeah. So we had the tree, right? Yeah, so we had the three, right? So you have this three, good, and then you have these the tomorrow's group of these three is this iterated risk product, okay? But then, so if you're like me, so in my PhD, I looked basically at another iterated risk product. Okay, so let me tell you now about different types of iterated risk products and see what we can do with that. Okay, so let me just remind you the definition of a risk product of two groups, which we all know and love. So again, fix a set X. Let's again fix a set X with D letters and take two finite set omega delta. And so we take a permutation group A. So this just means that A is an action on delta, a faithful action on delta, and B, any group that you want. And then you can define the abstract as an abstract group. The risk product of A, W, R, I'm going to be this symbol A, is the group given this way. I change notation from one line to the other. So here this should be W R. So it's this group. So it's this group. So it's you have a normal subgroup isomorphic to B to the delta, right? So you have B copies. So I always think about it this way. You have delta copies of B at the bottom. And then you have a copy of A to the top. It's a semi-direct product. And I should tell you, since it's a semi-direct product, I have to tell you how A acts on B. And this is just permuting the copies of B. So A permutes the copies of B. So, A permutes the copies of B according to what the permutation tells you to do. Okay, this is the permutation. Yeah, this is called the risk product of these two groups. And so, remember, this is just A permutes the coordinates of this, it permutes these blocks, these copies of B at the bottom. Okay? Good? Until now? So, it's gonna get up in difficulty. So, I think you know, you have to get this before getting the next steps. Good. So, what you can do is that what you do with the tree is that you actually You do with the tree is that you actually, if now, so before you only have one permutation group A. Oops, you only had one permutation group A. And now, if also B, the bottom group, is a permutation group, you can define a new permutation group. So if B has an action on some set omega, then you can define a new permutation group, which is still called the Rift product, with this time we say, with the permutational action, and is a permutation group. So it's the same as an abstract group, is the same as before. Okay, so it's A semi-direct. Okay, so it's A semi-direct B to the delta. And now I'm going to tell you an action of this group on omega times delta. So what do you do? You take a couple, omega delta, the elements of B, depending on what delta is, do something. So you have to imagine that the little delta copy of B here is doing something on the delta coordinate of these couples, on the yes, on the things that start with delta. And A just permutes the delta. And A just permutes the deltas. Okay, so how should you think about this? A picture maybe is in order. If you draw the elements of delta here as points and you connect them to some root, and then you write after each element of delta, you draw elements of omega. Then what do you do? So AE just permutes rigidly. You see, it doesn't change the omega. So we'll send all the things hanging from something which is called delta here to some other delta, right? Some other delta, right? So it's moving rigidly this bit to this bit. And B is just changing, depending on which delta you're picking, is changing these groups, these vertices, right? It's a tree. So this is an action of these two groups on a tree. Nothing more, nothing less. So I hope I convince you that if you take this permutation of reef product, you get an action of these two groups on a tree. Good, of this group, of the reef product on a tree. The risk product on a tree, but but then you can iterate this, right? So you have A and B acting on this. You can iterate this then, right? So if you start with two groups, let's take more groups. Let's take a sequence of groups. Let's call them Sn with some actions on some fixed set X. And then we can define, okay, we can define the set X1, which is just X, and then S1 S1 hat, which is acting on that, which is action. Then Xn plus one, which is just now take X, the reference Xn, so the previous ones. So the previous ones, one more copy of X at the bottom, if you want, to the left. And then Sn hat is just the risk product of Sn plus one, Risk product Sn hat. Okay? So you do you do a rethink this form. So if you have a sequence of groups, you start like with a group S1, and then to the left, you add a copy of S2. Then you take this group and you read it with a group which is called S3. And then you take this group and you read it with a group which is called S4. So at n after n steps. And after n steps, the picture is going to look like this. You're going to have a group S1 with on the bottom some copies, isomorphic copies of the group S2, and then under that, some copies of the group S3, etc. It looks like a cake in some sense. Okay? Good. And now you have a sequence of finite groups, the one project onto the other. So you can take the inverse limit of the groups S and hat. If you don't know what's the inverse limit, you just do the finite. What's the inverse limit? You just do the following thing. You take the group S1 hat. The group S2 hat is a read product, so it's a semi-direct product with the group S1 at the top. So it projects onto S1, right? And the next one as well. So S3 also projects onto the previous ones, et cetera. And you have a line of projections with finite groups. And you take the group that is at the end of this line, which is the inverse limit of this finite group. So it's an infinite pro-finite group. Profinite group, and you have a topology on it. But I mean, there is a way to formally do this. I was just taking the immense limit. And this gives you a new group, right? So you have taken this iterative, this product, refrat, refraded, refrat, and it's giving you a huge profiling group. It's an uncountable topological group. And what group is it? So we said before that the automorphism group of a tree is given by risk products. So basically, the automorphism. So basically, the automorphism group of a tree is this iterated with product, right? Because this is actually the read recursion that we wrote before. You said that the automorphism group of T is isomorphic to automorphisms group of T with symmetric group on X. Right, but I can go again with this now. So then this is isomorphic to T with the previous groups. I'm just putting C. The previous groups. I'm just putting sim X and then reading with SIM X. Okay? So it is the automorphism group of a rooted tree. And you have the picture, right? Again, so the automorphism group of the addict rooted tree is the same. Now, so you have the swap at the top and then what we said before. Very good. Okay. Good. And now, so now, so this was if you took the CMA. So, this was if you took the symmetric group, okay? But we allowed to take subgroups of the symmetric group, okay? So, this is if you take the full symmetric group, you get the full automorphism of the root of three. But now, let's take some subgroups, some strictly smaller subgroups in the symmetric group. For example, let's take a sequence of finite non-abelian simple transit permutation groups. You could think about, for example, alternating group. Just take a sequence of alternating groups, AX, okay? All alternating groups on X. If you do these constructions, so if you do this iterative read. This construction, so if you do this iterated with product, and it keep iterating or reading with one fixed one if you want, then the profinite group that you get is just infinite, right? So it's the one, the type that we like, I like. It is branch. We said, no, basically, this is if each factor is inside the symmetric group, this will have an action on a rooted tree. Okay, so it is a group of automorphisms of a rooted tree. In particular, we can prove that it's a branch is profane. That is branch is profane, okay? So, and nice now. So, this is kind of a nice general way to construct the huge, just infinite groups, profane, just infinite groups. It's a nice recipe, let's say, you know, good. And if you look hard enough, you know, this is not so easy. Well, it's very nice construction, but I think, you know, I wouldn't come up with it necessarily, but just by looking at the group. Neumann, I think, was the first one historically to construct a finitely generated abstract just infinite branch group. Just infinite branch group, a subgroup of this. So you take this pro-finite group, which is an uncountable topological group, but inside you can find some finitely generated abstract subgroups of interest, because for example, the Grigatius group also sits inside this automorphism group of these trees. It also sits inside this profanite group. So this group is just infinite branch group, and it has interesting subgroups. It has interesting abstract subgroups. For example, it has just infinite subgroups of intermediate growth. Intermediate clause, okay. But then you say, Well, this is very nice. Where are you going with this? The point is, I told you about risk product, and this is the classical risk product, if you want, the permutational risk product, but there is another risk product. So you can define what's called the risk product in product action. Okay, so now let's take a step back. Take two finite groups, A and B, A with an action on a set delta and B with an action on a set omega. And I'm going to tell you another action of the And I'm going to tell you another action of the same abstract group, B with A. Okay, so the group, the finite abstract group did not change, but now I'm telling you a new action. Okay, so I have to tell you a new action on omega to the delta. Okay, so you do the following thing. I have to tell you how the elements of A act. So if you see omega to the delta, these are all the functions from delta to omega. Okay? And I'm telling you that the function, the elements from A have an action on delta. So in this function, An action on delta, so in these functions, I could act in the domain. So I'm telling you, take a function, and then A is acting by permuting the elements of the domain according to the action of A. And B, so I have delta copies, you know, so this is X, this is not X, sorry, so this is delta. I have delta copies of B here, and each element in this delta tuple of elements of B acts coordinate-wise. So in each coordinate, I can put a different permutation. Each coordinate, I can put a different permutation of B. Okay? And well, of course, you can see immediately now. Okay, so this is again stated. So we act, so A permutes the domain and B to the delta gives one automorphism for each coordinate and acts on that coordinate. Okay, you can see that these are very, very different actions because the sets are very different in cardinality, right? Before it was delta times omega, and now it's omega to the delta. This is much bigger. So it's different, completely different action. And actually, it's really different action for other reasons. Is really different action for other reasons. So, the previous action, let me go back a time a bit. The previous action has a property which is called imprimitivity. So, you see, you have this set, so the set of the direct product of omega times delta. You can split it in blocks. So, there are some subsets that either are map to themselves or they are moved completely away from that. So, that's a trivial intersection. And these are these copies of omega that I wrote here, right? So, these leaves are either permuted among themselves or they're moved to another. Cells, or they're moved to another block somehow, right? So, this is an imprimitive action. While the brief product in product action has another property, so it's primitive. Actually, you cannot find the type of decomposition. Okay, so this is completely different action. Very good, but I mean, I have a risk product, I have some finite groups. I can try to play the same game as before. I can try to iterate the risk product. So, before we had the permutation of risk product, and now I have the risk product in product action, and I can try to iterate this. So, again, take your favorite sequence. So again, take your favorite sequence of permutation groups, Sn, and some finite permutation, some finite set X, and then you can iterate the Reaf product. And well, okay, now let's stop a second to look at this a bit because it's the notation I want to assimilate. So I denote X arrow down one, the set X, and S1 tilde, just the group S1. Then at the end plus one step of this construction, you take X to the whatever was before, right? So at the end step, you will have X. Right, so the end step you will have x to the x to the x to the x to the x to the x to the x with this bracketed, right? So, if I wrote down, it tells you put the new x at the bottom. Okay, this is no full notation, I'm sorry, but this is the best I could come up with. And so this is the set, so these are functions of functions of functions, of functions, of functions, functions, from x to this, okay? So, this is kind of scary, but okay, that's what it is. And from what we just said, we know that the s n tilde, s n plus one tilde. Tilda, Sn plus one tilde, which is the read product. I maybe should have said this. So I use this funny notation. This is not standard notation at all, but if I write B circle, read circle A, this is this read product with this product action. Okay? So I make a read product with this product action of S and plus one with the previous ones. So I played the same game before, only now I'm putting circles. Okay? And promote, so this is actually, I'm gonna add for to be the final action of s n plus one tilde on x arrow down and plus one. Okay, so x arrow down n are functional function, function, functions and times. Good. Again, we have this is a rich product as before. So it just you have homomorphisms projecting one group S1 tilde. So S2 tilde projects onto S1 tilde, etc. Right? So exactly as before, they are abstractly similar. Exactly as before, they are abstractly semi-direct products, so it projects. You remove the normal sub reproject, it projects onto the top. So, again, you have an inverse limit, which now I call w tilde s of these groups. And you can play the same game and you can obtain a new profinite group, which is called w tilde s from any given sequence of these groups. And this is a theorem, so it's an uncountable group, and it's a theorem of, well, the first to come up with the idea was John Wilson, 2000. And so his construction is a bit complicated. So I think I, in my PhD. Structure is a bit complicated, so I think in my PhD thesis, I changed it a bit formal. It was not stated in this way in John's article. So I let's say this notation is my work. So you take a sequence again of finite Non-Abelian simple transfer notation groups. For example, take A5, the group A5 all the time. Then you have defined this profinite group, W tilde S, and this is a hereditarily just infinite profinite group. We change the brief product, we change the side of the world. We change the side of the word in which we run. So, like, if you take the implementation of this product, you get a branch group, and you take the product action, you get a Heredale just infinite group. It's nice, right? I mean, this is some sense. So, John's construction was to construct basically a new Hereditalized Infinite Profinite groups. So, this gives you that. So, it gives you kind of a huge family of pro-finite Heredite just infinite groups. But we're missing one step now. So, before inside of the Marcus group of the So before, inside the thermophysics group of the rooted tree, we had, for example, Gregausius groups. So we knew that there were some interesting subgroups inside there, which had some nice property. And maybe one can wonder if there are also in this. But we're missing something now. So, okay, before, what was the game? The game before was, okay, it actually was the other way around. So we started from a tree. We realized that the tree has this nice automorphic group given by iterated with products. And then we found some subgroups using this structure, this tree that we had at the beginning. So Grigorius' group is really. We had at the beginning. So, Grigorius' group is really using these three that we found at the beginning. And now, what do we do? Well, now we kind of started from the second step. So, we had the iterated risk product with another risk product. We have a group, and the ambient group has the property that we want. So, it is intelligent. But what we are missing is the very first step. So, what's the structure? What does this group act on? So, that's a question. So, for the rest of the talk, I'll try to concentrate on telling you what I think is the structure on which these groups act on. Which these groups act on. And if one is lucky, then if one understands well enough this structure, I think there is hope to construct then groups of it. Sorry, it tells you the groups of with nice properties, so intermediate growth, torsion, et cetera, et cetera, et cetera. At least that's the hope. Okay, so good. You have any questions until now? This is kind of the past, 2015. And I'll tell you about, yeah? Good. Okay, so it gets, I'm going to say, unfortunately, so it gets very notation-y from now on. Notation from now on. So there are some numbers. So please, you know, stop if then this, yeah. Okay. Good. So this is what I said. I put this up earlier. So then, so the question is, does this W tilde about respect to the symmetric groups correspond to some combinatorial structure, which is what we are searching for? And if it does, can you use this combinatorial structure to produce interesting finitely generated, these are just infinite subgroups of these? And so if And so you have to start with something, right? So now you have an iterative read product. We know, we saw before immediately, also that B read A preserves a finite little tree. But what does then the first step of this construction, so sim read sim with the circle, what does this preserve? Any guesses? Joshua, I was really surprised that this is not, this is not, I mean, the other one is a tree, so it's super well known and something. And this, okay, it's another rich product, but this is not known at all. What it presents. At all, what it presents, so it is known, but it's not well known, let's say, and it preserves what's called a Cartesian decomposition. Okay, so now let's delve into jump into the word of Cartesian decompositions, right? So, first of all, we know, so what does this act on? So, the action of this, so it's on x to the x, right? So, we have an action of this group on x to the x, but x to the x is too big. It has to preserve some substructure, something. Structure, something. So inside x to the x, so this is we can do in general for x to the delta, inside x to the delta, we define a Cartesian decomposition, or the standard Cartesian decomposition, if you want, to be a set of partitions given by what's called the coordinate partitions. So bear with me. So you have a set, which is, if you want, you can think about this set, x, the delta, with tuples, not delta tuples of x. And I'm telling you, I'm partitioning my huge set. I'm partitioning my huge set coordinate by coordinate. So, for each coordinate, I pick and I will say that this is a partition. Okay, so I get a set of partitions, one for each coordinate. And how is the coordinate partition defined? Well, the coordinate partition is all the parts of this partition. So, delta gamma delta x is a part of the partition gamma delta and is given by all the functions that have value x that. That have value x, that little x, at that coordinate delta. Okay? I'll write down an example in a second to make this more clear because it's not very clear, I know. For example, ah, first one moment of notation, just to then write more easily things later. So you have this x to the x to the x to the x. Let's just fix some notation once and for all to denote the elements of this set. So if you fix the elements of x to be elements between 0 and d minus 1, the elements we denote the elements of x to the x. Elements we denote the elements of x to the x in the following form. We will denote them as strings. So I will say, for example, let's do this example. So x to the x, these are all functions from x to the x. And with the following notation, the element 0, 0 is the function that sends 0 to 0 and 1 to 0. So these are the two coordinates. Okay? So 0, 1 is the function that sends 0 to 0 and 1 to 1. 1, 0 is the function that sends 0 to 1 and 1 to 0. And 1, 1 is the function that sends both to 1. Okay? Is the function that sends both to one? Okay, so I wrote all the functions from x to x with this notation. Okay, it's going to be later on. We can, you know, we see we see why this matters. And for example, x arrow down three, just to think about a second. So this is x to the x to the x. So these are functions from x to the x to x. How many functions are there in x to the x? So my domain is size four now, right? Because I have these four functions are the domain of the functions that are here. So I have to write four tuples. And so this means. Tuples and so this means this function is the function that sends zero zero, which is the first element of this set, to zero, the second element to zero, etc. So this function will be the one that sends all elements to zero apart from one one, which is sent to one. Okay, I hope the notation is clear, right? Good. And yes, so any order them. So how do I do these? Let's mention is ordered by lexicographic order, of course. So you just fix an ordering to write them down basically. Okay, so we're ready to write down our first Cartivian. Ready to write down our first Cartesian decomposition. So let's fix the set x, 0, 1, which is the smallest possible. And let's look at the standard Cartesian decomposition of x to the x. Okay, so I'll tell you, so now I have to give you a set of two partitions. Okay, so I have two coordinates, so for each coordinate, so for each element of this x to the top, I have to give you a partition. I will call them gamma zero, gamma one. The first partition are The first partition are the elements that are given, parts which elements which are determined by their first coordinate. Okay, so for example, in the partition gamma zero, I have two parts. I have gamma zero zero and gamma zero one, according to notation. Gamma zero zero are the functions that in coordinate zero, the value zero addressed, okay, and gamma zero, one. Gamma 01 are the functions that in coordinate 0 at value 1. Okay, so this is this. And then I have another coordinate partition, which is the gamma 1, which is in blue. So this distinguishes elements according to the second coordinate. So these are all the functions that have value zero in the second coordinate. And these are all the functions that have value one in the second coordinate. The red one is a partition. The blue one is a partition. We have two partitions, a set of two partitions. Okay? Okay I want this to be clear because later it explodes the difficulty explodes okay let's see the step we take one step forward so let's take the let's see the Cartesian decomposition of x are down three so this is x to the x to the x in this domain we have four coordinates so what are the coordinates called they're the elements of x to the x and these elements we saw in the little example from before they were called they were this no Called, they were this, no? 00011011. And so we have these four partitions. And what is the partition gamma 01? These are all the elements of x darrow down three, which are distinguished according to their second coordinate when I write them in lexicographic order. So there will be all the elements, for example, in the partition gamma 0, 1, 0. These are all the elements of the value 0 at the second coordinate, 0, 0, 0, 0, 0, 0, 1. 000 000 00 see if I did it well 00. So there is a 0 here, there is a 0 here, there is a 0 here, there is a 0. Okay? So this is a part of a partition. And you have the other part, which is the one with the ones. Okay? Good. And magic, the magic happens. And the magic is when once you define this Cartesian decomposition, this is actually what is preserved of the product action. I find it very beautiful because, you know, like it does not preserve any particular It does not preserve any partition because it's primitive. So you cannot stay in the set x to the delta to find a structure that is preserved by this. So you have to go up. So you have to go up. It means you have to look at partitions of this set. So this preserves partitions of this set. So you're kind of one level higher of like, I don't know, abstraction, if you want. But the theorem, this is a proposition, is a theorem of Schaba Schneider and Sherry Prager. Sherry Prager and Shaba Schneider, automatically, sorry. Automatically, sorry. And so X and Delta be finite sets. And then the, so you know, you have the symmetric group on this set, X, the Delta. The set that preserves the standard Cartesian decomposition that we defined before is exactly the risk product with product action. Okay, so the Cartesian decomposition picks up the risk product in product action, which is what we want. Good. Very happy, but not so happy because it was the very first step. So now we need to kind of. So now we need to kind of so now iterate in this risk product action. And before it was fine, no, because before there was a tree and we're just kind of enlarging the tree, it was all happy, happy going. But now, no, because now, let's see. So, for example, let's do the next step. So, let's say sim x read sim read sim with this bracketing. Then, so this is a group acting on x arrow down three, right? So, this is function x to the x to the x. X. If you take Cartesian decompositions of this set, okay, how many coordinates do you have here? If X has cardinality 2, as we did in the examples, it has cardinality 4. And a Cartesian decomposition, as this proposition says, preserves sim X, sim number of coordinates. But these you have four. So the thing, the Cartesian decomposition will be preserved by this group, by sim X read Sim4. X read sim4. But this is not sim, no, it's not, it's not the one from before. It's not the sim x read sim x with the product action. This is bigger. Okay, I don't know if I it's not the right thing to do. So you cannot. The next step will just pick up the coordinates of the last level, forgetting completely the previous structure that you had in the iterative risk product. That's what I want to say. So So maybe write it down. Maybe write it down here to make it a little bit more clear. So if you have this set, so you have x, arrow down three. Okay, so this is x, x to the x. Okay, so we said that if you take a Cartesian decomposition, so the automorphism of a Cartesian decomposition. position of x arrow down three is what this proposition says is that this is just uh is written as x to the something so this is the symmetric group on the bottom x risk product in product action sim delta which is written here so sim x right so this if this is uh yeah so Is uh yeah, so this group, but I'm interested in the group sim X with product action sim X with sim X. And this is much bigger. This group here is a subgroup of this. So I've lost the structure, I've lost this top x to the x somehow. X somehow. So I need to do something else. I cannot just take the Cartesian decomposition of X arrow down three to capture the structure of this iterated brief product. Okay, so let's do something else. And what we have to do, or what I think one should do, is the following thing. And what's called an iterated Cartesian decomposition. Let's take it slow again. So let's see. I think then the definition will confuse everybody. The definition will confuse everybody, never see an example, and hopefully we will converge understanding a little bit better. So, again, fix a finite set x and fix a Cartesian decomposition of the first set x to the x. Okay? Fix it. So the one that we had before, this, for example. This is the Cartesian decomposition. So gamma 0, gamma 1, these red and blue partitions, this is a Cartesian decomposition. Take that, for example. Cartesian decomposition, take that for example. Now I define the iterated Cartesian decomposition E n, and we define it inductively as follows. So E2 is just E, the Cartesian decomposition is fixed. And now suppose that you define at the end step some iterated Cartesian decomposition, we define a new set of Cartesian decompositions the following way. compositions the following way so your set en plus one is given by elements lambda p with p is an element of the previous iterated cartesian decomposition that you want now these guys have for each of them they have a part uh so sorry this is a set of cardes and composition so this is gonna gamma lambda p is gonna lambda p curve this is a curly p I don't know if you can see it but this is curly p and this is like straight p. But this is curly p, and this is like straight p. So this has parts given by lambda straight p, where p is a part of p curly p, but curly p is a partition in the previous one. And now to tell you what is lambda straight p, lambda straight p is the intersection of all the coordinate partitions relative to all the elements of this part p. The notation is terrible. I'm sorry, but I could not find a better notation. I could not find a better notation. So, first of all, notice that when you take two partitions of a set, then the intersection of this partition, so part by part, if you take the intersection, this is a new partition, is the intersection partition, right? Some of them are empty, throw them away, and then the rest form a partition. So these EN are sets of sets of Cartesian decompositions. So let me show you an example, which I think is much more illuminating than staring at the definition. So fix again the set X. So fix again the set X and 0, 1, smallest possible, and fix the Cartesian decomposition that we said before. This is E2, the one that we saw before, so this red-blue thing. So I define E3 in the following way. I have two Cartesian decompositions. So the first red bit is a Cartesian decomposition of x to the x to the x three times obtained from the red bit, which is a part of a partition at the level before. Partition at the level before. And the blue one is again a Cartesian decomposition obtained from a part of the previous Cartesian decomposition. For example, what does this mean? So now the partition, for example, let's concentrate on the first. So this is a, so I told you, now the red one is a Cartesian decomposition, so its elements are going to be partitions. And these partitions are obtained by intersecting. By intersecting coordinate partitions relative to the parts of your previous given partition, the composition that you had before. So gamma 0, 0, lambda, 0, 0, lambda, 0, 1 is the following partition. So you see, well, what can you do? So what's the intersection of these two partitions? Lambda 0, 0 has two parts. So at coordinate 0, 0, pick the value 0, coordinate 0, 0, pick the value 1, and the same for the other one. And the same for the other one. So, when you do the intersection, what are you doing? You're specifying the value. So, now I'm telling you that the first part of this intersection partition are all the functions that have value 0 at 0, 0 and 0 at 0, 1. So, I'm picking the value at two coordinates. But how I'm picking it? I'm picking the coordinates according to the previous Cartesian decomposition. So, you see, the coordinates 0, 0, 0, 1 are the elements of the first part of the previous. Elements of the first part of the previous part of the Cartesian decomposition. And one, zero are the elements of the second part. So this will be a partition partition obtained from these two. And so this, you see, this is N is a partition obtained from the first part of the Cartesian decomposition from before. From the first part to the second partition of the Cartesian decomposition. Okay, I don't know if this is very clear, but and again, so this is what I said. So lambda. So, this is what they said. So, lambda 000, intersection lambda 0, 1, 0. So, again, we fix the value 0 at the coordinate 0, 0, and 0, 1, which you said the first two. So, these are all the functions that have value 0, 0 at the first two coordinates. So, it's a very complicated way to find new partitions, but I think that it works because, okay, so you have all these, so you have done all this work, right? So, very good, fine. What do you do now? Do now? Okay, so it's defined in this very complicated way now. So you have this kind of Cartesian decomposition and blah blah blah. But now, what did you do? Basically, now you define. So since the new iterated Cartesian decomposition, En plus 1, is obtained from the previous one, naturally you can say, well, this Cartesian decomposition, this Cartesian decomposition was coming from a part of a previous Cartesian. From a part of a previous Cartesian decomposition. So you can associate, you can link them in some sense, because that's how I define them. And by how the product action is defined, this is actually equivariant, because you use parts of this partition to form the new Cartesian decompositions. So this is just literally, this is kind of a tiny observation. It's nothing hard. But this gives you what I call the tree of partitions. So now, let's see. Let's see. So you have a set X, very good, with a trivial partition if you want. And on the set X to the X, you have a Cartesian decomposition, which was, you remember. So this was the first part. This was like the elements of the value zero at the first coordinate. The elements of value one at the second, the element, sorry, this is that the Cartesian decomposition that distinguishes according to the first coordinate, it is the Cartesian decomposition that distinguishes according to the second coordinate. Starting from this, Starting from this, I can define a new iterated Cartesian decomposition. So if you remember, let me write it there. So let's do it again. Gamma zero was this gamma zero one, which is zero zero zero one zero. Right, so these I called I called this is what I call gamma zero zero. So these are all the functions that have value zero coordinate zero. And then you have the other one. And with this, I create a new thing, which I call gamma, gamma zero, zero. This is not gamma, this is this gamma, yes, sorry. Which is just take, just look at the this. So look at these two coordinates and take the intersection of the coordinate partitions relative to these elements. This is lambda 00 intersection lambda 01. And this guy is coming from, so this is what's written here, this guy is defined through gamma 0. And I told you the rule is if a new iterated Cartesian decomposition is defined using a previous one, put a line between them. So put this line. And then I have another one, which would be what's called. Which would be what's called lambda gamma zero one, right? So with these two other ones, so this would be lambda one zero intersection lambda no lambda gamma one one right with this. So I told you, put an arrow there. You can do the same. This side, the next step you can do, no. So now I have a new partition defined on x to the x to the x, and I can define a new partition on x to the x uh and x r down four. X to the X and X are down four. What do you do? You look at this partition, you look at a part of this partition, and this, I think, we wrote at some point. So, what are these elements? So, these elements are all the functions. Well, if you look at one part, so for example, all the functions have values 0, 0 in these two coordinates. And you use this to define a new iterated Cartesian decomposition. And you have four of them, if you think about it, and et cetera. So, in this way, you obtain a tree. obtain a tree okay i don't know if this is the i know it's very the notation is terrible absolutely terrible but i hope that maybe the the idea behind this is clear and the point is that the iterated risk product in product action preserves this tree from how we defined it because this is the equivalency here okay and so the iterated reef problem And so the iterated with product in product action acts on this tree. Okay? So this is kind of all after all this big mess, you got a tree. And so I hope, no, so I didn't know this is where I'm at. So this is, you know, this is kind of, you can define this tree. And I hope that this could be used to find newer intelligence infinite finitely generated abstract groups. So the challenge then now is: okay, now I give you, for example, let's fix. Is okay now. I give you, for example, let's fix a group, let's say C2. This is iterated with product in product action of copies of C2. We need to find some elements, A1AN, which generate a head-telijest infinite group, which has some interesting properties. Okay, so I think the game again is now you have, I'm proposing to you a structure that we should use to then produce elements like Gricaus' group, let's say. Okay, of course, there are some challenges in the sense that, you know, so this tree is not self-similar in any way or anything. Is not self-seminal in any way or anything, so you cannot just, you know, use, you know, it's not clear what you should do yet, I think. But I think there should be some structure hidden here that then you can use to define these kind of elements. Okay, so but then you're telling me, right, okay, you did all of this work and at the end you got a tree. You're trying to stay away from the tree and then you all this, you did all this work and you come back to the tree. Are you sure you're okay, you know? Are you sure you're okay? And let me remark that actually this tree is good. So this tree is very different from the previous tree because pay attention. So the point is that I have an action on this tree, but it's not. So the what do you need to say? So it's a very different action that the usual automorphisms group of this tree. So it's a subgroup. Maybe it's a much smaller sub. So it's a way to represent it. It's not the whole automorphism group of this. Automorphism group of this. In fact, so okay, the degree of partition is preserved, we said this, but the action is not canonical. So, for example, let me do a little example. Let's see. So the element 0, 1 identity, right here. I'll try to convince you now that, okay, this tree is very different from the other tree. So, the element, so now inside C2 wreath C2, say this way, you have an element, right? So, you have two copies of C2. So, you could take the element, for example, sigma, which is WAP, element 0, 1, with that identity, identity. Okay, this is an element of a risk product. Okay? And now, so if I look at this in the tree, in the usual tree, so as an automorphism of. Tree, so as an automorphism of a rooted tree, remember the iterative root product was just like, okay, so if you have something on the left, do the thing on the left and the thing on the right. No? So this automorphism swaps the two sub-trees hanging here and doesn't do anything else. There's an element in this with product and this tree, it does this. However, the same element, so remember, this is an abstract group, but we defined two different actions. So on one hand, you have the action on the tree, and on the other hand, you have the action on the tree of partition. Other hand, you have the action on the three of partitions we're given by the brief product and product action. What does it do? So, you have to look a little bit, you have to think about it a little bit, not so long, to realize that this element doesn't do this, it does this. So, it's a representation inside this new tree is this, which in the picture, so this is the previous element that we said, it does this. It moves these two sub-trees as the other one did, but also moves these two sub-trees down. Moves these two sub-trees down here. Okay? You can, it's a calculation. Okay, so you can see that basically it's like because there are elements, the elements starting with zero will also appear in these partitions, and so it will be moved somehow. Why is this good? This is good because I did not tell you the definition of branch group, but just know that all branch groups are weakly branch as well. So what is weakly branch? Weakly branch means the following thing. So notomorphism of the super. Of the subgroup of automorphism of a rooted tree is weakly branched. If for every vertex in the tree that you like, you can find an automorphism of the slies in this subgroup G, which acts trivially on the sub-tree hanging around, hanging down from V. So it does something here and nothing else on the rest. But what we said before is not like that. You see, so it looks like elements are doing things like here. Are doing things like here, but also here. So it looks like we're not able to separate these two trees, and all elements are going to have that kind of shape. So it's kind of really, it doesn't look like a weakly branch action, which is good, which is if it was branch, then you would have again the groups from before, but it's not. So it looks like it's a different action. Okay? So it looks like the action of the theory of partition is not weekly branch. Good? So, good. Okay. So maybe I have. Good. Okay, so maybe I have five minutes and then I can tell you like why what do you do with all of this? What I've been trying to do with all of this. Right, so you can, I think again, I don't understand 100% the tree of partition, right? This picture. So I don't understand so well the action of this iterative reach product infrared action on this tree. But one could try to take some random elements, some elements, and see if it works and see if these elements generate something interesting. Interesting, these economists. But it's not so easy, for example, already to find elements of finite order, because the action again on these tree is quite complicated. So, okay, so one idea could be the following. So, Grigacius group is actually, so this is actually, Volodia talked about some kind of fragmentation, but in theory, in reality, Grigacius group is already a kind of splitting of the infinite dihedral group. Why? So, if you look, Why? So if you look in the automorphism group of the rooted tree, you can realize the infinite dihedral group as these two automorphisms. So the automorphism A is just swap at the top and do nothing else. And the automorphism B is the following. It's called B sigma B. So you see it does kind of on the left branch, it does sigma. And then on the right branch, it does sigma B. So we do sigma. Then you go down and sigma. So there is like a spine along which on all the things. Along which, on all the things hanging down from this spine, you do sigma. And you can prove that this is the infinite ahedral group. But if you know Grigacious group, you know that this is a very similar picture to Grigacious group, because Grigacius' group is just this. So it's just delay the action of this. So basically it's taking sigma sigma one, sigma sigma one, sigma sigma one. And the automorphism C is instead the sigma one sigma, sigma one sigma, etc. And D is one. etc and d is one sigma sigma one sigma sigma so basically you're doing that automorphism split up in three different ways it all magically works and it gets you get the regression group the regression group is just this so maybe i one could try to say well and if you write the risk uh recursion of these elements as we said the elements of the tomorrow's two for rooted three are these iterated risk products so i can write them as this as an element of the iterated risk product right so you have a so this b is there is a sigma here to the left Is there a sigma here to the left, and then you have a B again, but B has a sigma in this position, which is the position one, two, three of these three. So we'll have this element, right? So we'll have one sigma one, one, one, one, sigma, one, right? So this was position three, if you remember, exactly. So right, the requirement is this. So, well, okay, I'm running out of ideas. You can just try to just say define the automorphisms beta of the tree of partition in the The tree of partition in the following way, in the same way. So, this is basically just the following thing. Let me just go back one second to the three of partitions. So, this is what I wrote, this beta, is the following thing. Do a swap. So, let's say that you are with C2, do a swap to all branches hanging down to the left from this leftmost branch. Okay, so you imagine that, for example, here. That, for example, here you have gamma zero. So, gamma zero is a partition, so there are some elements inside there. But then I could just do a sigma constant in all the elements of that partition, of that part of that partition. Which is this, which is this element. If you write it down, what I said, you get this, and the elements that do not appear are identity, and you could try to do. And you could try to do what you did for Grigasius group. So, this is what it looks like, basically. So, these are all like you write sigma in all the iterated Cartesian decompositions kind of hanging down from one of the right. This is how this is defined. This is a way to make this formal, but okay, let's write it this way. And then you could try to so this, and now it's clear, you can show that these two elements generate a dihedral group, so gamma and beta squared. And beta squared have order two, and their product is of infinite order, so they generate an infinite ahedal group. So you could try to play the same game as Grigorch's group, so you could try to split them. So you could try to take like, you know, just something that does something to all the levels congruent to zero modulo three, to all the levels congruent to one modulo three, or two modulo three, or one module three. And because of the tree of partitions, so the one thing that I can prove is in the tree of partitions. That I can prove is in the three of partitions is that these three elements define this way of order two. Okay, so this is not even clear to how to write down like elements of finite order. So now I can write down three elements of order two, and then I have no idea how to prove other problems. So for example, we don't know what the order of B times C is. So this one, okay, I need one, one needs to do a bit more work here, but I think, you know, one already this gives you some elements of finite order that one could try to use to. Of finite order, the one could try to use to find other subgroups. Okay, so I think then my time is over. So maybe I will stop here and thank you for your attention. Thank you very much for the talk. Are there questions? How was the thing? It's not clear, but I think not. I mean, I think it's just they're too close to being branched, no, in some sense. So, watch. Branch, no, in some sense. So, one should look some far somewhere far away. I mean, that's the reason why these are not branch, let's say, no, because if they are not, I mean, if to be branched, there would have to be at least a weekly branch. So, these are not branch, right? So, just to point out that it really is a different new kind of action on a tree, right? So, I know, so it's a result of my PhD thesis that I know some dense subgroups. So, I group that they're finitely generated, so I find some dense subgroups. But I mean, these dense subgroups, these dense subgroups, I'm not so confident that they give you anything like torsion or intermediate growth or something. I don't know. They feel like too free in some sense. But I do have some ups, some dense subgroups. But yeah, so they would like them to look more like regardless of. I would like them to look more like regards to in some sense, like an intermediate growth and something like this. Because sorry, my examples look more the Neumann example. My genetic is basically they're obtained in that way, and that is not of intermediate growth. So I don't have any hope to say that the other one is of intermediate growth. I say this way. Well, we don't know actually if they're an intermediate growth. I think they're not. Okay, thank you. Are there more questions? Are there more questions? Berne, thank you. So you're doing this because people lost any hope to find editorita-simphilic samples in the typical tree? So that's another talk for another day. Basically, so in the usual tree, right? I mean, in theory, we're talking about residual effariate groups. So in theory, it should live inside some tree, right? So it's not that you lost hope, but I mean, That you lost hope, but I mean, we have another project with Mario Laura Noche and Gustavo Fernandes Alcover, where basically, so you know, there is a in this New Horizons chapter of Grigor Schuk, so it proves that if you have a head retaliatory infinite abstract group acting on, say, a regular rooted tree, then it has to satisfy a very specific property. Let's call it star. And so you would have to look at groups that satisfy this star, but now we have been looking for a little and we couldn't find any. We have been looking for a little and we couldn't find any, right? So, sorry, and in addition, you have to ask the self-similarity. So, we're looking for any telling just infinite self-similar groups. And it looks like this property is not very easy to satisfy. So, we looked at like all these automata generated, and they don't satisfy this property star. Because all these things are weakly branched. If you're a weakly branch, you cannot be Heritage Infinite. So, it's kind of a very, there might be, but it looks like it's very difficult to do it on the usual tree somehow. So, that's why, you know, I, okay, I have designed. So that's why, you know, I okay, I have this other thing which gives you just infinite profinite groups. So maybe, you know, these are kind of closer to other new Heritalist Infinite abstract groups. That's the idea. Thank you. Yeah. Are there more questions? Let me maybe just to clarify something I didn't quite understand. So you started building this tree of partitions. Building this tree of partitions is, if I understood correctly, to find an object where this iterated wreath product in product action is the automorphism group. Yes. But the tree of fritition doesn't satisfy this. So maybe there's a better object. Absolutely. Yes. But I couldn't find a better object. So this is kind of, as I said, so it's it embeds in the the morphism group of these three. So this is a way to kind of represent it, but yes, it's not, I would really like to find something, some object that is the Something, some object that is the, of which that is the automorphism group of. But I could, I tried to think very hard, but I couldn't. That's the answer. Thank you very much.