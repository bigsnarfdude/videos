Okay, let me just get rid of this thumbnail video. So, yeah, I think the thing with Zoom is that if you guys write something in the chat, I can't see the questions or I may or may not see them. So feel free to just unmute your mic and just ask me. So thanks very much for organizing this workshop and also for the invitation. I want to talk to you today about reconfiguration in the quantum setting. And I realize, of course, you guys, most of you, if not all of you, are probably not quantum people, right? So I'm going to make it very gentle. So I'm going to make it very gentle. I want this, think of this as kind of like a, you know, when I was a young teen or before that, you know, in Canada, there were always these books like Choose Your Own Adventure that I'd get from the library and you can kind of decide what decision the main character, the protagonist makes next. And then you flip to that page. And this talk is supposed to be designed a little bit like that. The actual slides are maybe 15, 20 minutes long. And then there's some extra time at the end so that if you want to ask me about anything you want, we could just kind of do that. Want, you know, we can just kind of do that. You can follow your adventure in that sense. Okay, so keep that in mind as I talk. If there's something you really want to hear more about, you know, you could ask me that at the end and we can really go into detail. Okay, the other thing maybe I can quickly mention is that my story also starts at Waterloo. Naomi was one of my teachers. I think I annoyed the hell out of her at one of her office hours. I remember asking her just way too many questions. And there was a huge lineup outside her door of other students. So anyway, but you know, she's been very supportive since she's wrote many. She's been very supportive since she wrote many reference letters for me. So, you know, that's my connection, I suppose, to Naomi. With that said, let's talk about reconfiguration in the quantum setting. So my name is Sevak Gribian. Most people just call me Sev. Nowadays, I'm found in Germany at Parabon University. And what I want to do is give you a very gentle introduction to what in the world is reconfiguration in the quantum setting, why should you care about it? And just a bit of a high-level overview of some of the results we've had over the years. The results we've had over the years, okay. So, again, if you have any questions, just stop me at any time, and they could be really basic questions, right? I mean, I'm not assuming any background here. Okay, so you know, for the talk, there are four guiding questions that you should kind of keep in mind, right? So, I'm sure pretty much everybody here is familiar with classical reconfiguration, but you know, quantumly, you know, we have to be careful how do we even rigorously define what it means to do quantum reconfiguration. Okay, so. Reconfiguration? Okay, so that's the first question we want to ask. And I've got these kind of numbers, right? These works up here, one, two, three. These arrows are supposed to kind of point to which works kind of did what in some sense. Okay. The second thing we'll talk about is physical motivations for studying quantum reconfiguration. It turns out that in the quantum setting, reconfiguration has a really natural, physically motivated meaning, and it's connected to things like quantum error correction. Number three is, of course, just like in the classical setting, Is, of course, just like in the classical setting, we want to know what reconfiguration has to do with complexity theory, right? What is the connection? And finally, and this is kind of the most fun one in some sense, which is that what can we do in the quantum setting that is impossible in the classical setting in the world of reconfiguration? Okay, so what kind of phenomena show up, let's say? Okay, so as you can see, kind of the works one, two, three, you know, touch on all these in various ways. And I'll try and outline those in a In various ways, and I'll try and outline those in a high level. Okay, so those are the guiding questions. And of course, like I said, I'm not going to assume any background in quantum computing, and you really don't need any to at least understand the high-level concepts in this talk. But of course, what that means is that, you know, I've got to give you a quick introduction to quantum computing, right? And so here it goes. It's, you know, technically it's on one slide, but you know, the slides on this handwritten are not in any standard length. So the meaning of one slide is totally useless here. Totally useless here, but there's one slide on this, and basically, um, the story is that in a classical world, a state is an n-bit string, as you all know. And for this talk, in the quantum world, you know, just think of the analog of this as an n-qubit state is nothing more than a unit vector in dimension two to the power n. Okay, so here it's very important that the dimension of this Hilbert space or this vector space is exponentially large in n. And so, of course, we cannot hope to represent an arbitrary. Course, we cannot hope to represent an arbitrary unit vector in the space efficiently classically, and that's essentially the whole reason why we don't believe classical computers can efficiently simulate quantum computers. So if I were to draw this on a picture, you know, just think of the unit hypersphere in high dimensions, right? In exponentially large dimension, any point on the surface of that hypersphere, that's a valid quantum state, okay? That's literally it. And then that's an accurate statement. I'm not simplifying things here. Okay, so quantum states are vectors. Okay, so quantum states are vectors, unit vectors. Just think of it that way. But so let's continue with our comparison of these two worlds, right? So the next thing you ask is, okay, what kind of operations can I do in the classical world? Well, you know, the most general thing you could do is a Boolean map, right, from n bits to n bits. And the analogous thing quantumly is, or the more general thing quantumly, is the notion of a unitary gate. Okay, and this is just some map from the Hilbert space of dimension 2 to the power n to the same space. The power n to the same space, basically. And you know, all you need to know about unitary gates basically is that it's essentially just a rotation in space. That's it. Okay, so in this picture, what I'm trying to show you here is that, you know, here's a vector, right? That's my unit vector, you know. And a unitary operation, you know, does two things, right? In this high-dimensional space, it picks some rotation axis. So, you know, I tried to draw, by the way, I suck at drawing. So forgive me here, but here's the rotation axis. Here, but here's the rotation axis in blue, it's vertical, and um, then you have to pick the rotation angle, so that's maybe this. And so, maybe I take this vector here and I rotate it, you know, about this blue axis, and I suck at drawing, but the point is that you know, imagine that this, um, the black arrow is leaving the piece of paper and it's coming out into 3D and then rotating around this axis, right? And that's what I'm trying to indicate here. So, what I've drawn is not a reflection, it's actually a rotation, okay? So, bottom line, what a quantum computer allows. Bottom line, what a quantum computer allows you to do is arbitrary rotations on this unit hypersphere. Okay. Good. Of course, what's the catch? The catch, classically and quantumly, is that we cannot efficiently simulate any Boolean function f or any unitary gate u. Okay. And so we need to talk about what it means to have a notion of efficient computation in both these models, right? And classically, of course, we think of a function as being computable efficiently. It's being computable, efficiently computable if it's polytime computable via a Turing machine, for example. Quantumly, we hate Turing machines. There is a notion of a quantum Turing machine, but only crazy people work with it. We always work in the circuit model because it's a lot more natural for us. And so what we say is that the unitary U, this big rotation in this giant Hilbert space, is efficiently implementable if I could write it as a sequence of two qubit gates. So these are just gates. Qubit gates. So these are just gates that just act on at most two qubits at a time. And I have at most t of them. And t is some polynomial in the input size. So for example, you know, I could have here, I have three wires here corresponding to three qubits, and I could apply things like a NOT gate, which is X, a controlled NOT gate, or something that's generally quantum something called the Hadamard gate. Okay, and in general, of course, these can generalize and/or NOT gates, right? So this is the basic idea. This is the basic idea. Good. So now we know quantum states are circuits, sorry, are unit vectors, and the operations we're allowed to do are basically rotations. Okay. Good. Now, how do we define constraint satisfaction? Because what we're going to talk about is a quantum analog of satisfiability and reconfiguration of that in the quantum setting. Okay, so classically, as you all know, I mean, So, classically, as you all know, I mean, a KSAT formula is just going to be a set of clauses, like this, for example, clause C1, C2. And each of these clauses acts on a constant number of bits at a time. And there's some satisfying space of solutions for each clause, right? And the quantum analog is exactly the same, okay? And what we do basically is that if my state is a unit vector, my quantum state, there is a very natural notion of what a constraint should be, right? A constraint is just you're going to force that vector. A constraint is just you're going to force that vector to lie in a subspace now, right? That's that's the obvious notion of what a constraint should be. And the way we do this is analogous to the classical setting. We actually generalize this. We basically write down, instead of these clauses, you can embed each of these clauses into matrices. These are constant size matrices. They will act on a constant number K of qubits at a time. That's this K here. So just like this acts on K bits at a time. And the point is that, you know, each of these is acting on some other. That you know, each of these is acting on some other some subset of k qubits. When I add them all up, I get my full constraint system, my full so-called Hamiltonian. And the dimension of this matrix is exponentially large, okay, because it's the total of an n-qubit system. And, you know, in terms of linear algebra, the way you should think about this is that each of, you know, to satisfy each of these small clauses, constant size clauses, it just means that your quantum state, your assignment, needs to be in the null space of that operator. Okay, it needs to be annihilated by. Okay, it needs to be annihilated by that operator. Okay, good. Questions so far? Okay, good. So then, if that's a constraint satisfaction system, let me tell you, you know, how we define constraint satisfaction problems quantumly. So, classically, of course, the input is going to be a K-stat formula phi, right? And your output is going to be. Right, and your output is going to be: give me some string that satisfies the maximum number of clauses. Quantumly, it's kind of upside down, and this is a motivation that comes from physics, in fact. And we tried to do the opposite quantumly. The input is one of these quantum constraint satisfaction problems. So it's essentially a big symmetric matrix on dimension 2 to the n, but it's specified locally via these local clauses. So it is a succinct description. And basically, what you want to do is more or less you want to output. Do is more or less you want to output the state psi on n qubits that minimizes your expectation against this operator h. Now, I mean, if you don't know this notation, that's fine. I mean, basically, all this is really saying is that you want to compute the smallest eigenvalue of h. This is just a variational characterization of the eigenvalues of this operator. So, really, when you generalize classical CSPs to the quantum setting, it's just an eigenvalue problem. It's just an eigenvalue problem, and the reason why it's hard is because you know the matrix is just too damn big, right? It's exponentially large, and that's the issue. Now, why in the world do we even care about this? It's because physical systems in nature, they can actually be, I mean, you might have heard of this Schr√∂dinger equation, which dictates how quantum systems evolve in time. And the kind of Hamiltonians which get plugged into this equation in quantum physics are typically, if not always, of the form of these local Hamiltonians. Of these local Hamiltonians. It turns out that, you know, just like the Cook-Levin theorem tells us that computation is local, it turns out nature is also local in this fashion. Okay, like the rules which govern its evolution are little local rules that are kind of pieced together. And so, you know, what does it mean to find the smallest value of this Hamiltonian optimization? You're looking for the so-called ground state energy. It's the, if I were to take my quantum system and cool it to basically absolute zero, what energy level would it, what would be its energy? What would be its energy at that level? That's this lowest eigenvalue. So that's why we call it the ground state energy problem. And the corresponding assignment is going to be the corresponding eigenvector for that lowest eigenvalue. And that's called the ground state. Okay, so it's a very well-defined physical problem. Good. Okay, so now we know what we mean by just quantum CSPs, and now we can talk about quantum reconfiguration of CSPs. Piece. So on the left-hand side here, I've got, you know, reconfiguration for SAT, right? And, you know, how do we play this game, right? I give you two assignments to your SAT formula. And your job in the way we're going to set it up is that we're going to ask, is there a sequence of at most, let's say, n bit flips? Okay. Or in quantum terminology, X gates. These are NOT gates. So that, you know, by applying these NOT gates, you go from X to Y and every intermediate. And every intermediate vertex you visit on the hypercube during your trip, you know, that's also a solution to your SAP form, right? This is just standard reconfiguration. So that's the picture on the left. Good. And so we're going to just blatantly copy this definition for the quantum setting. For the quantum setting, instead of a SAT formula, we've got a quantum CSV. Instead of two classical solutions, we've got two quantum solutions, sine phi. We have to be a little bit careful because, of course, we cannot represent an arbitrary sine. cannot represent an arbitrary sine phi efficiently. So we're going to assume this blue star is just that we're assuming that sine phi are given to you in terms of short quantum circuits to prepare those states. So there's a classical input. And the question is the same. Is there some sequence of gates? And now they're just not just like bit flips, but they're arbitrary two-qubit quantum gates. So that the initial state psi is mapped to the final state phi. Okay. So here's my picture, for example, of my the solution space of my CSP. My solution space of my CSV, the ground space. I've got two solutions. Here's psi, here's phi. And I want to apply some sequence of steps, right? So that number one, when I apply the first gate, the second gate, let's say the third gate, I go from psi to phi. And number two is that throughout this entire evolution process, after each step, I'm always in this null space, okay, in this vector space of this Hamiltonian. Okay, so it's like the directly analogous definition. It's like the directly analogous definition. It's just that now we're talking about vectors and subspaces. Any questions? How can you decide a neighborhood for the states? How can you decide the name of the states? Is that right? Yeah, yeah, yeah, yes. Yeah, yeah, yeah, yes. What do you mean by that? Can I ask? In the quantum word, I wonder if you give the two states, then I can decide if they are close in this cloud space. Oh, whether the states are actually close or not. Okay, it depends, I guess, what setting we're talking about. Like, are you giving me physical copies of the states? Are you writing them on paper, right? States? Are you writing them on paper, right? In principle, I mean, they're just vectors in space, so you could always evaluate the Euclidean distance between the two. And there are quantum protocols that also estimate that for you via a circuit called the swap test. So even if you give me physical copies of two states, right, I can do the swap test and I can check what is their overlap approximately. So there are ways to do that. And maybe when we are considering the reconfiguration, for example, you are For example, you are healthy figure. We imagine some kind of during machine which decides the neighborhood and the considerability or something like that. But when you consider when you consider the qubit work or the quantum computer work, you want to solve the configuration problem itself by quantum computer. Yeah. Well, no, we're not trying to solve the problem, right? We're just going to show that the problem is hard, just like in the classical setting. Just like in the classical setting. Okay. But what you can certainly do, if what you're asking is, we can certainly check if any of these intermediate points is still a satisfying assignment. This we can do. So just like Stephen Mandela, I'm sorry? Please go ahead. Okay. Is it okay? Yeah. Okay. Good. So this is the way we'll define quantum reconfiguration. And, you know, I want to tell you, take a moment. And I want to tell you, take a moment to tell you about motivations for ground state connectivity. Like, why is this interesting? So, I mean, we did it as computer scientists. Like, I was interested in SAT and I ran into Christos and Friends' original ICAL paper on this topic. And that's what got me into it, basically. But, you know, after we wrote this first paper on the topic, we talked to synthesis and they're like, oh, this is just the energy barrier problem. And I was like, what's an energy barrier? Right. And so they told me some things. I cannot say I fully understand them. But basically, the premise. Them, but basically, the premise is that sometimes if you want to map a quantum state to another quantum state, if it's not possible via these local circuits while staying in the low energy space or in the ground space, what it means is that to map from psi to phi, you have to inject a lot of energy into the system to cross this so-called barrier. Okay, so at some point, you cannot stay in this very low energy subspace. Low energy subspace. You've got to go into a higher energy space to make the transition from psi to phi. And that's this so-called energy barrier. So if you're a physicist, I guess that's interesting. I think what I find a lot more interesting is the connection to quantum error correction. And so here's the idea. So quantum error correcting codes and quantum memories kind of work in this way, which is that the code space of all valid code words is really just the solutions. Really, just the solution space of some quantum CSV. It's some Hamiltonian you write down, and the ground space is the set of all valid code words. This is typically how it's done. Okay, so here, for example, just like before, you know, I imagine I have the ground space in my Hamiltonian. I've got two code words, right? That's fine, right? So that's typically how quantum codes are done. And how do you ideally want a quantum code to work, a good quantum code or a good quantum memory, right? Ideally, what's supposed to happen is that a good quantum memory. To happen is that you know a good quantum memory. Suppose I start my computer in the state psi and then I go home for like the day, right? What should happen is that if overnight, you know, some very short sequence of errors happens, you know, some polynomial number of gates, right? Then the state I have psi should leave this solution space. It should leave this ground space. Because then I can detect, I can do a measurement and I can see, oh, I'm not in the ground space anymore. I'm in this high energy space up here. An error has occurred, right? My memory is corrupt. Occurred right, my memory is corrupt, and then I can catch it and I can hopefully correct the error if I haven't gone too far. Okay, that's the ideal way memories are supposed to work. And so what is reconfiguration trying to do, right? Reconfiguration is trying to get a short circuit to kind of stealthily corrupt psi into phi, kind of through the ground space itself, right? And if this is possible with a short circuit, then that's bad. This is not a good quantum memory because without Memory because without me knowing it, right, I can change sine into phi. And the whole time I'm in like the code space. So if I measure this Hamiltonian, I'll never catch the fact that some corruption process is taking place, right? Because the only thing I can detect is I can detect if you're in the space or not. That's basically it. So that's a really nice motivation I find in the quantum set. And one of the results I'll show you shows you that something very kind of unexpected happens in this picture if you really consider the extreme version of. If you really consider the extreme version of reconfiguration. Okay, so maybe I'll tell you about my results. And clearly, this is taking more time than I thought it would, but it's fine. You know, I'm trying to go slow to make sure that you can follow because, you know, again, I don't want to assume any background here. And I'll get through as much as I can. So the first theorem is basically that, you know, classically, we know that configuration is generally speaking hard, right? And what we find is that Find is that if the number of gates you're applying is polynomial, so you can take a poly number of steps on the hypercube, for example. Classically, you would expect this to be an NP-complete problem, and quantumly, we get so-called a QCMA-complete problem. This is just a quantum analog of NP. And what's nice about this theorem is just because I'll tell you later, but you know, this class is a bit funny to get natural problems for it. So it's really kind of a nice surprise that we were able to get essentially the first natural complete problem for this class. Problem for this class. The second thing we can show in the second work is that, you know, in strong contrast to the one, to the, you know, the classical setting, in the quantum setting, if you have a constraint system, which is just in 1D, so you line up all your bits on a chain and all the constraints are on nearest neighbors. And on top of that, all the constraints are completely identical. This problem is still hard to solve. The reconfiguration problem on this very simple 1D SAT problem. Very simple 1D SAT problem is still hard to solve quantum. Okay, so in fact, it's quantum next part, if you will. Okay, so as I have time, I'll say a bit more about each of these. And finally, the most recent result that we keep saying is going to come out any day now. I mean, we already presented this at QIP this year. But basically, what is really neat, which also surprised me, is that on the Boolean hypercube, right, if I have two solutions. If I have two solutions to my indicators, they're always connected or disconnected, right? I mean, there's just a discrete number of steps you can take, and the answer is always yes or no, connected or not. Quantumly, this is completely false. Quantumly, if you take an exponential number of steps, like you might on the hypercube classically, it turns out that you can connect any two quantum solutions basically while tracking this ground space exponentially closely. So this is really a genuinely quantum phenomenon. Really, a generally quantum phenomenon. Okay, now I'll. So, basically, this is what I'm trying to say: that classically, you know, if you want to get this p-space hardness results for reconfiguration for SAT, you need to consider exponential length paths on the hypercube, right? Because otherwise, at best, you get empty hardness. But quantumly, as soon as you allow these exponential length paths, it turns out the problem is trivial, right? We can always do this mapping. And it's, you know, for us, this was surprising. Okay. Okay, so let me try and tell you just a little bit more about each of these. I won't go into any serious detail, but you know, just so you can help me to make some sense of these statements, right? So the first one is that the ground state connectivity problem, where you're allowed a polynomial number of gates so that you can send me a proof telling me what gates to apply, is so-called QCMA complete. And so let me just tell you what QCMA is so you kind of get a sense of what kind of things we're proving hardness for. Things we're proving hardness for. So, QCMA is just a very simple class to define. If you're familiar with NP, it has its randomized analog, which is Berlin-Arthur, and QCMA is one step further. So you have a verifier. The verifier is some polynomial size quantum circuit. And what it takes in is a classical proof. There is another definition of quantum NP called QMA, which is a bit more mainstream, if you will. That one takes in. Bit more mainstream, if you will. That one takes in a quantum proof, which is verified by a quantum verifier. But QCMA is also a very natural class, and we know relatively little about it. And here you get a classical proof, okay? And there's, of course, some workspace as well, polysize workspace. And given all this information, the verifier does the computation, and then there's some output wire, and we measure this output wire. And depending on the output bit, we decide to accept or reject. This is the idea. And, you know, the funny thing is that we're going to be able to And, you know, the funny thing about this class is that it's quite natural to define. It's been around since 2000, but in general, nobody really knows. I have a quantum verifier. What good is a classical proof to a quantum verifier? It seems like a very odd thing to have. We can say much more about quantum proofs to quantum verifiers, but classical proofs to quantum verifiers, this is a very weird thing. And so the nice thing about GSCon is it kind of very naturally. thing about gscon is it kind of very naturally falls right into this boat right like containment in qcma is is relatively easy to show because the proof the classical proof you send the verifier right is just going to be the sequence of gates that you're supposed to apply uh to my state to move it from you know starting point in the ground space to the end point in the ground space and each gate is just some four by four matrix so this is you know certainly i can write this down classically good so let me not say more about that this is uh qcma Say more about that. This is QCMA, and this is the class we get completeness for. I'll skip over the construction, but let me be clear that the construction, in principle, certainly also applies classically as well, I think. So you can apply this in the classical setting to get NP hardness results. But it's a lot more interesting quantumly in the sense that the soundness proof is a lot more non-trivial. Good. Let me just very mention, briefly mention, tell you a bit more about the second. Briefly mention, tell you a bit more about the second result and what exactly this means. How should you think about this? So, here we are saying that the graphic connectivity problem now on a 1D system is still hard. And what do I mean by that? So, imagine your bits or qubits in our case are arranged on a chain like this. And where are the clauses, the quantum clauses? They act on neighbors. So, qubit one and two are constrained by some clause, qubits two and three are constrained by some clause, and so forth. And on top of that, And on top of that, because it's so-called translationally invariant, that means that if I translate the whole system to the right one, it should look the exact same. And this is certainly motivated by physics, right? These are the kinds of systems one often sees. And so this means that all the constraints are, in fact, identical. They're the exact same constraint. So really, in this CSP, there's really only one parameter, which is the length of the chain n in binary. Like that's it. And it turns out that even in this And it turns out that even in this setting, you know, this ground state connectivity problem is hard. And technically, you get quantum next instead of quantum NP. And that's just simply because the input size is logarithmic in the size of the chain, because the input size is really just a binary encoding of the length of the chain. Okay, so the moral here is that even on a 1D system where all the constraints are the exact same, quantum league on state connectivity is still a very hard problem. Okay, again, I will not tell you more about that. And finally, in my final two minutes, let me just briefly flesh out this last result, which was that in contrast to classical reconfiguration for SAT, the solution space of any quantum CSV is always connected as long as you're allowing an exponential number of steps. Which, again, let me be clear. Classically, you also need an exponential number of steps to get this P-space hardened. An X dimensional number of steps to get this p-space hardness result. And you know, very briefly, what is this saying? This is saying that if I have two, I'll look at the picture rather than the technical stuff. If I've got, you know, two code words in my ground space, doesn't matter which Hamiltonian, you can give me any Hamiltonian. There's some sequence of gates. It's an exponentially long sequence, okay, so it's not short. Sequence, okay, so it's not short, but the point is that this sequence will always keep you exponentially close to the solution space, but really, really, really close. So, if at any point in time during this evolution, like let's say you're over here, technically, even if you're outside, you're so close to that ground space that if I were to do a measurement of the Hamiltonian, like the odds of me catching that you've left the ground space are one over exponential. I'll never see it. And this is why we call this some notion of stealthy corruption. Notion of stealthy corruption of code words where psi and few were code words. And, you know, what is the basic technical result here? I mean, I won't go through it in any depth, but basically it turns out that in the quantum setting, you know, why is this possible? Well, it's not really anything to do about reconfiguration or SAT problems per se. It's really a more general result, which is that if I take any two points on the unit hypersphere and I draw any nice continuous path, like a Lipschitz bounded path. Lipschitz bounded path. Then I can also approximate this, it turns out, with basically two qubit gates, like the kind of gates you do on a quantum computer. I could always follow any path you give me really, really closely, with an exponential precision. But of course, the trade-off is that the number of gates I apply is now exponential as well. And it turns out that once you have this, then you can apply it to get this kind of result. And this essentially shows that reconfiguration when you allow these very long sequences. These very long sequences, but only a one-over polypromise gap is actually just trivially in p. Okay, the answer is always yes, they're connected. Okay, so now it's one. Can I ask a question? Sorry. Yeah, go for it. So does that mean that there is no P-space analog in the quantum world? A P-Space complete analog? So there is a P-space complete analog, but it's kind of the one you would all be. Analog, but it's kind of the one you would obviously expect, quote unquote, which is that if you allow only one local gates, because essentially what you could do is you can embed the classical SAT where you're just doing one local bit flux, that's going to be at least PSpace hard. And if you're only allowing one local gates, then you can't build up any entanglement. The state you have at any point in time will never be that complicated to write down. And so you can also show containment in PSpace. So it's hard when we start doing two local gates or two qubit gates. Two local gates or two qubit gates because then you could build up entanglement, and then the state I get can be really complicated. And I cannot describe it using a polynomial bits anymore. So the short answer is yes, there is a p-space variant, but it's arguably less well-motivated quantumly because you're really restricted to just very simple gates, which just act on one qubit at a time. And that's too weak to do universal quantum computation. Okay, but that's a good question. Okay, so maybe I'll just summarize. Okay, so you know, there is a quantum analog of reconfiguration. You know, it's physically motivated. You know, we have hardness results for classes we didn't expect to get hardness results for, which is really nice. On even very simple physically motivated models, you know, we can show that this problem is still hard. And we have this weird kind of phenomena where if you're allowing exponential number of reconfiguration steps, you can kind of. Of reconfiguration steps, you can kind of trivialize this problem of connectivity, it turns out now. And that is a bit of a funny implication for quantum error correcting codes because it says that I can always corrupt any quantum memory, let's say, as long as the evolution time is allowed to be exponential. I mean, of course, that's not practical. I'm not saying this is there's everybody's going to go home and worry about quantum memories not being good anymore, but you know, it's just a bit of an unexpected result. Good. And then, in terms of open questions, well, I mean, I could state a few. Well, I mean, I could state a few. The most obvious one is: you know, is there a reconfiguration for other quantum problems, obviously? So we just did the natural one of quantum CSPs. Another cute question is that a PCP theorem for quantum NP, which is QMA normally with a quantum proof, that is a huge open problem, right? It's notoriously hard. And so what you can first try and show is maybe we can do it for QCMA first, because here there's a classical proof. It's a bit easier to think about. And the only kind of good natural About. And the only kind of good natural problem we have right now is graustic connectivity, arguably, for this. So maybe you could use that to show a PCB theorem here. And finally, of course, what we always like to do in quantum computing is that we like to show that these problems are hard because they're physically motivated. We like to show that they're hard even on problems that actually come right out of the physics playbook. So things like the Heisenberg anti-ferromagnet, which is a model that's been around for 100 years. It's used to model magnetism, for example. It's basically quantum macro. It's basically quantum max cut, and so can you show that ground state connectivity stays hard in that model? You know, we don't really know how to do that yet. Okay, so I'm three minutes over. I apologize. So, thanks very much for your attention. Any questions? May I ask one question? We have some trade-offs of the QB. Of the cubit. I mean, for example, you have the connected and the exponential range gates, but the way you pay much more qubits, you can pay shorter. Sorry, say that again. I cut you out a little bit. Yeah, do you have some trade-offs, the number of qubits, and the diameter of the space? Oh, that's a good question. So, okay. So, okay, so I had to skip over a little part. The notion of diameter quantumly is extremely misleading. We have to be very, very careful here. So, this is one thing I was trying, I was going to say here, but I didn't have time. So, you can imagine that I have two points on this unit hypersphere, right? They're infinitesimally close together. They're epsilon close together, right? So, you'd, you know, if you measure diameter in the usual sense, which is the Euclidean distance between these two, you know, they're really close. They're only epsilon far apart. So, that's this here. Epsilon far apart. So that's this here. But the problem is that, you know, if you want to write down a unitary which rotates the first vector into the second one, it could be a global unitary. It's acting on all n qubits at a time. And even though it's a very small rotation, if I were to decompose it in terms of two local gates, then I might suddenly need an exponential number of gates, even though the effective rotation is still extremely small. And so the notion of diameter is not, or you know, distance between states is not really a good proxy for how many. Good proxy for how many gates do I need to connect psi to phi on an actual quantum computer, let's say. So, the you know, the even shorter is the answer is, you know, I don't know how to answer your question because I feel like it's not, I would need to think about what it means to talk about diameter in this setting, to be honest. Okay, so any other questions? No, so thank you very much. Thank you. Thank you, Helps. Do you have some announcements or something? I mean, some organizers, I can hear some other guys. Do you have any announcements? No? Okay, so let's conclude this session and we have lunch and free afternoon. Okay, thanks.          