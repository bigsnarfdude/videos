Thank you. Can you see my screen? We can see your screen. We can't see. Can you see my slides? Yeah, I can see your slides. I can't see you. Oh, there you go. Oh, yeah. I think you can't see both. Oh, I see. Well, then we'll take the slides. That's fine. Okay. So. Okay, so the problem that I'm going to talk about is motivated by challenges that are faced when building quantum simulators. And to abstract away the physics behind all of this, imagine that you're given a positioning of a set of traps in 2D. And then you're given a process that loads atoms into those traps. But the process is flawed. Thus, it results in a random and non-discrimination. It results in a random and non-desired arrangement of those atoms. But what you're allowed to do is to move an atom along a connected series of traps as long as they are empty. Another problem that you're faced with is that there is a survival probability that is associated with the atom and it decreases whenever you move the atom. So, a reasonable goal would be to try to minimize the total number of moves when solving this. When solving this. So, and it's easy to see that this problem can be seen as a problem on graphs. You can look at the traps as being vertices, the atoms being tokens, and also you can model adjacency using edges. In fact, this problem falls under the reconfiguration framework, and I'm sure everyone right now knows about the reconfiguration framework. So, I'm going to give the definitions that are specifically relevant to the problem. Specifically relevant to the problem we were just able to define. So, we call a configuration a set of vertices that represent the placement of tokens in a graph G. We'll define a move to be a displacement of a single token along a path of three vertices. And what we are looking for is a sequence of moves that will form a target configuration set T from a source configuration set S of a graph G, and we call this sequence a transforming sequence. A transforming sequence. Throughout this presentation, we're going to assume that the two sets have equal cardinality. So now we're able to define the token moving problem where we're looking for a transforming sequence that has size at most some parameter L. We looked at four variants of this problem. So we looked at the cases where the underlying graph is either directed or undirected. Either directed or undirected. We also looked at the cases where the tokens are distinguishable or indistinguishable. And the problem is NP-hard under all four variants. So naturally, we asked if we can find fixed parameter tractable algorithms for these problems. And so I'm going to give a high-level idea of what fixed parameter tractable is. Parameter tractable is. So, in parametrized complexity, we might pick some parameters that are relevant to our problems, and we try to design algorithms that run in some function of those parameters times a polynomial in the input size. And the intuition is that we are putting all the loads, all the exponential blow-up on the parameters. So, if your parameters are small, then you get away with. Small, then you get away with like a reasonable running time. And whenever you find such an algorithm, we call the problem fixed parameter tractable. And now it belongs to a class of problems called FPT class. And whenever we want to prove that it's highly unlikely to find such an algorithm, we prove that the problem is W hurt, W1 or W2 or etc. But it doesn't. Et cetera, but it doesn't matter now. So just think of W hardness as being something similar to NP hardness. So just in the same way you try to prove that it's unlikely to find a polynomial time algorithm, it's the same way you prove W hardness for not finding a fixed parameter tractable algorithm. Okay, now some more definitions that relate to the unlabeled variants of the problem. labeled variants of the problem. So we can combine the two representations, the representation of the two sets into one color-coded graph. And on this you can see relevant sets that will show up later. So we have the set O, which is the set that is in the intersection of S and T, and those are, we call them obstacle vertices. We also have the set T minus S, S minus T and the set. T minus s, s minus t, and the set f, which is the set of three vertices that don't appear neither in the source nor in the target. Sorry. Okay, so just from the problem definition, we can see that possible parameters would be the number of tokens, the number of moves, or the number of UHCs. Below, like here is the table that shows the The results that we were able to prove for these parameters. And so, everything that's highlighted in blue, I'm going to give a high-level idea of the proofs. And yeah, so I'll start with the parameter K. We proved that the unlabeled version is fixed parameter tractable for the parameter k's and L. Okay, so for the parameter k, which is the number of token. K, which is the number of tokens. So, something that is usually used a lot when trying to design a parametrized algorithm is to, and it's called kernelization, which is when we try to build a smaller from a given instance, an instance of size that is smaller and it's some funk and it is some. And it is assigned some function of the parameter, and such that the new instance that we build has the same, the shortest transforming sequence of it has the same length as the shortest transforming sequence of the original instance. And we call those two instances equivalent. And the idea is if we're able to find such an instance, then we're able to afford to run any slow algorithm on the new instance. Algorithm on the new instance, and we find it in fixed parameter tractable time. So, and an observation here is that if you look at our initial graph and if you actually delete for any instance and you delete the three vertices from it, then the instance becomes actually the size of the instance actually becomes bounded by 2k. So, we ask ourselves if we can actually remove the fever. If we can actually remove the fevered Cs from the graph, and the answer turned out to be yes. So we proved this using the following lemma. So, for the unlabeled token moving version, in a shortest transforming sequence, no token has to move more than once. And we proved the following by contradiction. So we picked a shortest sequence from So we assume this is not the case, right? And all the transforming sequences will move a token more than once. We pick one such shortest sequence that minimizes the distance between the first and the second move of the same token. And let's call this, let's call the sub-sequence that is formed from the first to the second move of the same token. Let's call it beta. And the pictures below show. And the pictures below show a beta. So these lines represent S0 to T0, etc., up until Sy to Ty. And so S0 to T0 and Sy to Ty are moves of the same token. So T0 and Sy are exactly the same vertex. So what we do is we build a new sub-sequence, beta prime, that has the same. That does that has the same exactly the same effect as beta when applied on the graph, but it has one less move, thus disproving that we started with the shortest transforming sequence. But yeah, so and we do this using like taking advantage of the minimality of the subsequence because this subsequence is minimal. I'm going to show you like on the first two moves what happens. So you have as moves what happens. So you have S0 to T0 and S1 to T1. And let's say S0 to T0 is the token on C moving to the top the vertex D. And S1 to T1 is the token on A moving to the vertex B. Because this sub-sequence that we started with is minimal, we know that the second move happening depends on the first move happening. It cannot be done before it. So we know that there is a path from So we know that there is a path from C to B, and we can move the token on C to B and not D. And this way, we did not move S0 to T0, we moved S0 to T1. And using the minimality, we also proved that all other moves that we're doing are possible. Yeah, and now we prove that no token moves more than once. So this results in like the only role. Like the only role a three vertex can play in the graph is to connect its neighborhood. Thus, we just remove those three vertices and we connect the neighborhood appropriately, depending if it's undirected or directed. And the instance we got has size, some function of k, and we call it an equivalent contracted instance. Also, using the previous lemma, we're able to prove that the problem is fixed parameter tractable. One parameter When parametrized by K, because we know that the three vertices won't be, so basically they won't be used. So we can just pick up to two L vertices from the set S union T. We can pair them as sources and targets of moves and we can order them and then test whether this is actually a transforming sequence or not in polynomial time. Okay, so now moving to the unlabeled undirected token moving UUTM for the parameter L. And for that, I need to define a graph G of alpha. So for a transforming sequence alpha, we call the graph G of alpha the graph that results when you delete from the graph G, from the initial graph G with the rep with the source representation, you delete all the edges and all You delete all the edges and all the vertices that the moves of alpha did not use or did not go through. So it's like the graph induced by the moves in alpha on the graph G. And in this graph, we know that every token that appears here has participated in at least one move. Okay, so we prove, we start by proving the following. So for the UTTM, for any instance, contracted instance, there is instance, contracted instance, there is a transforming sequence of minimum length such that g of alpha is a forest. And we prove this by contradiction. So we pick for one such instance where all the G of alpha have cycles, we pick one sequence and we look at the sub-sequence that is formed from the first move in alpha up to the first move that forms a cycle. move that forms a cycle or a set of cycles in G of alpha and we let's call this subsequence beta so the picture below shows g of beta and the last move like the last move in beta is the move s to t and those those edges that are like dotted lines are the edges that were added by this last move and they form the cycles okay and because this Okay, and because this is like G of beta, we know that every token here has moved at least once, but also because beta is part of a minimum transforming sequence, we know that every token here has moved exactly once. So we know that the number of moves in here is actually equivalent to the number of tokens that appear. And what we do is we prove that we can build from We prove that we can build from this G of beta if we can over some of the parts that were added by this last move, specifically those highlighted in red in the picture, and form a forest of trees where in each tree you have equal number of vertices in the source and the targets. And so once we get this, there is a result by Kalinasco et al. from 2018 that she That shows that designs a linear time algorithm for UUTM trees. And basically, whenever the sets S and T are equivalent in a tree, you can find an optimal transforming sequence. So we know that these trees that we just formed have an optimal transforming sequence where every token moves once. Every token moves once. So we know that we can now substitute beta by a new sequence beta prime that does the same thing, but does not use cycles because no cycles in the trees to begin with. So we replace alpha by beta prime, and this is how we got rid of the first cycle. And we repeat the same reasoning for the next cycles, proving that the whole thing is like G of alpha is a forest, must be a forest. A forest must be a forest. Actually, what we also prove is that it's not just that we can find a minimum transforming sequence alpha of minimum length that is where G of alpha is a forest of minimum steiner trees and where the terminals and leaves are in the symmetric or like in S del in the symmetric difference of the sets S and T. The internal vertices are in the union of S and T and each S and t and each vertex that is an obstacle vertex is the source of a move because it's appearing in G of alpha, so it must participate in a move. So yeah, and there is a result by Dreyfus and Wagner from 1972 that proves that you can find a minimum signer tree in fixed parameter tractable time when parameterized by the number. Parameterized by the number of terminals, and the number of terminals in our case is bounded by S delta T. So what we are able to do now is to prove that UUTM is fixed parameter tractable when parameterized by L. So whenever we're given an instance, we know we can form an equivalent contracted instance. And what we're doing now is we're attempting to build we're attempting to build uh we're attempting to see if there is an a minimum transforming sequence alpha and we're attempting to build the forest g of alpha so we try all possible partitions of the vertices in s delta t into one up to l Steiner trees and we use the the algorithm of Greyfus and Wagner to build those Steiner trees and also like we're making sure that even Like we're making sure that each group in those partitions have an equal number of vertices in S minus T and C minus S. And for each forest that we build, we know that the number of moves that are associated with this forest is equal to the number of tokens that appear in the first. So we just count them. And if this is less than L, we get a yes instance. Otherwise, Instance, otherwise, yeah, it's a no instance. Okay, so now for the unlabeled directed token moving, it is like it, the proof has exactly a similar flavor. We're attempting to prove that it's a forest of directed trees, but we had to like do it in a slightly different way. So, so what we prove first is that if you have instances That if you have instances of UGTM such that every transforming sequence of minimum length G of alpha is not a forest, then at least one of those instances must look like a picture and it's called a contracted circle instance. And so this contracted circle instance is formed of cycle vertices, like exactly one cycle where, and the vertices of that cycle. You have also cycle segments, which are Cycle segments, which are parts of the cycles that are either move like going clockwise or counterclockwise, which here appear in green and orange. And also, you have a forest of trees that are attached to those cycle vertices as roots. So the roots of those trees are the cycle vertices. And one thing, one last thing is that we have also junction vertices, which are vertices that are at the intersection. Are vertices that are at the intersection of two cycle segments and they are either sink, like in this case, uh yeah, in this case, like this is a sink junction vertex, uh, and this is like here a source junction vertex. So the tree is going like all the vertical all the all the things will go outside of this vertex into the tree or a sink from the tree to the cycle. Think from the tree to the cycle. Okay, and then after that, we prove that if you are given a tree and two configurations, S and T, and a one such that every leaf of D is in S delta T, and a one-to-one mapping from S to T such that if one vertex is mapped to another, then there is a there is a There is a directed path from that vertex to the other vertex, then you can find a minimum transforming sequence from S to T. And we use this to disprove the fact that we cannot always find a G of alpha that is a forest of directed trees. And we do this by finding in this contracted circle instance a one-to-one mapping. So if One-to-one mapping. So, if let's say s to t is the last in this contracted circle instance, then we show that we can ignore this last edge s prime to t prime that forms the cycle. And we can solve this instance without using s prime to t prime by finding a one-to-one mapping between the vertices in s and t. And we do it like we take s to t1. Take S to T1, then like S1 doesn't use anymore T1, it uses T2, etc., etc. And this mapping using Lamard 3.2 shows that we're basically able to solve it on a tree. And this shows that for any S instance, we have a transforming sequence alpha of minimum length such that G of alpha is a directed forest. So now So now, using that, we prove that UDTM is fixed parameter tractable when parameterized by L. Again, we form an equivalent contracted instance of the initial instance D. And then so we know that the number of vertices that will appear in D of alpha is bounded by some function of L. So we try to enumerate all possible. Enumerate all possible, all directed forests on those vertices. And then, while enumerating the forest, we also enumerate all possible sets, S prime and T prime, where like this is the source, this is the target. And then we try to solve it. Because we know that the number of vertices inside these forests is bounded. We know that we can solve it in FPT time. FPT time. And if we get a forest that is a yes instance, then what we do is we try to see if the initial graph D contains a subgraph that is isomorphic to this forest. So, and because this, like we have to respect the sources and targets, we use also weights on the edges, like we add some edges in a specific way. We add some edges in a specific way so we can find this subgraph that is specifically isomorphic to the directed forest we have. And we do this by using a theorem of Allen et al., which given a directed forest on Q vertices, H, and a graph D, that is a directed N vertex graph, if there is a real weight function defined. There is a real weight function defined on the edges of D, then you can find a subgraph of D that's isomorphic to H with a maximal total weight. So we use this to find a subgraph that is exactly isomorphic to the forest we built with the sets S and T as we defined. Finally, so we proved for the parameter L minus S minus T that the problem is S minus t that the problem is W2 hard under four under all four variants and so the red blue dominating set is you're given a bipartite graph you're given two partitions of the vertices a blue and a red partition and you're also given an integer k and you're asked to determine whether the blue set contains a subset that is of size at most k and that Size at most k and that dominates all the vertices in the red set. And this problem is W2 whole. And so, what we do is we do this, the following reduction. So, basically, we take the Boi-Perthoid graph as it is. The blue set will be a set of obstacle vertices. Okay, and here they are the black vertices. We have also the red. We have also the red set will be the set of only target vertices, and these are the red vertices in the picture. And also we add one path of length of a number of vertices equal to the number of vertices in R. And this path will be of only source vertices. And then we connect one, the last vertex of this path. The last vertex of this path to all the vertices in B. Okay, so and now we ask whether we can find a transforming sequence for this graph of size at most the size of R plus K. Okay, and it's easy to see that if you have a set, if you have this dominating set of size at most K, then you can choose those dominating vertices from B. From B and move them into R. And now you have a free path to all the vertices in R from W. So you can move all the vertices in all the tokens in W to fill the vertices in R and then to close every possible vertex that you freed also in B. And you will use exactly R plus K moves. And the same thing happens for the direct. The same thing happens for the directed case, right? Like, there's no, there is the same thing, okay. And again, like, this also we use it for build version. And the only difference between the unlabeled and labeled is that now you cannot just move the tokens into from B into R because R has specifically needs specifically the very the tokens that are on W to move to them. So, what what we do is we add a So, what we do is we add a free vertex, and basically, the tokens that are of vertices, of dominating vertices, just need to move into the free vertex so that all the tokens in W move to R and then go back to their places. Okay, so last thing. So, there are other challenges. So, for now, we assume that the sets S and T have equal size, but the Sets S and T have equal size, but this is not actually the case. Most of the time, the set source is larger. Also, under other conditions, the atoms can be displaced simultaneously, so you can move some atoms together. And the survival probability of the atom decreases with not just the number of moves, but also the passage of time and the distance that. Time and the distance that it traverses. So, other open questions can be: Can you find efficient approximation algorithms for these variants of the problem? Can we these efficient parallel approximation algorithms also? And how can we incorporate the movement of atoms in batches subject to a given set of physical constraints? Okay, and thank you so much. So much are there any questions for the speaker from people who are local first? No? All right. Well, then let's turn to Zoom. Are there any questions on Zoom for Stephanie? No, I didn't see it. Amar says very nice talk. Stop uh can I raise hand? Uh go ahead, yeah. Yeah, so in the last slide, you mentioned the parallel approximation algorithms. And do you mean that algorithm runs in parallel or atoms move in parallel? So we have so all of them are like open, so they are the problem where the atoms. The problem where the atoms move, like not just one atom, you can grab, like, there are some constraints, but you can grab some of the atoms together and move them together, right? And there is other, like, also there is the approximation algorithm, like, can you not solve it optimally? This is another question. And parallel, I mean, like parallel as in implementation-wise, because like on a GPU or something. GPU, something like can you find an algorithm that also is efficient in a parallel way? You can you can find a parallel algorithm that's efficient. Okay, thank you. No help. All right, if there are no more questions, then let's thank Stephanie again. I believe it is time for a coffee break. So we take a half hour and then we'll be back. So we take a half hour and then we'll be back.