And so in this talk, like I will go over some of the like oh, let me start my talk differently. So why are we talking to you about MultiPay? So I know if I look around like different proof assistants, then like what kind of things have been formalized if you just look at function proof. So for example, if I look at the functionality, So, for example, if I look at the fundamental group, that has actually been done in quite some systems. The earliest one was in a group system called Wiesard, 2004. And it is also in various other groups. This list is not exhaustive, and also in Lean. But if I look at a slightly more complicated object that is still very, very basic in Omni theory, Homotopy group, then I think this list is has. Is has, depending on how you count zero or one pre-resistance, lean has home tree groups, but it's still an open PR that they are effect groups. So we know that we have the home tree types, maybe now merging Matt Lib. But these are still very basic objects. And there is still a lot of very basic HOM3 theory missing. Of course, there is a lot of homological algebra and in this And in this originally, I wrote in this slide there's some homological algebra, and actually, this in the last few days, I think there's actually quite a lot of homological algebra looking at all the different things that have been done. And of course, there are things that can be called Hometree theory that are leaving out now. But there's still a lot of things missing. But if you look at what has been done in Hometree Turkey theory, Yeah. Then there's actually quite a lot more contributed done in like formalized activities, so in a group system. And so, for example, we have the Linux X sequence of home three groups. Blaker is not working very well. Okay. So here's a list of some of the things. So we have Blaker-Fromasi theorem, which is about taking a push out and then a Taking a push out and then a pullback, and then connecting that to the original type, computing like some non-trivial homesy groups of spheres, so for example Pfeiffer of S3, that is the integers modulo 2, eigenvector plane spaces, Seifert and Cond theorem, like there's homology and cohomology theories, and things like spectra and omega spectra. Things like spectra and omega spectra, and the like actually spectral sequences. So the Sarah spectral sequence and the Attier-Hirscherbruk spectral sequence, which I'm formerly right. So if you know some of these results, like there's, I mean, they are not like the most, they're definitely not the most advanced Hunting theory, but actually there's quite a lot there. And so the question is, why is all this done in Haunted Bank theory and why don't we have this in public yet? In public yet. And it's not because there's more effort being put in these systems, but some of these things are actually simpler to do in the synthetic concrete theory. And so the question is, can we learn lessons from these formalizations to maybe do them in Naval from these formalizations? These formalizations. So, for a large part of my talk, I'll just talk about what is something that you're not assuming that you already know anything about it. Then, I will go in a bit more detail about some of the things that have been done, and then I'll end with maybe some modest lessons we can learn and apply in Math. So I also say what I don't want I don't talk about in this talk. I don't talk about it in this talk. So, I don't want to try to convince you during this talk to switch to Hometime Theory. I think HomeTreat Type Theory is a wonderful system. I think it is really convenient to do HomoTree theory in, but it's also limited. I think HomeTree Type Theory, you can view it as a domain-specific language. It's really good for proving and formulating things in Honc theory. But there are things you cannot do nicely in it. So, for example, I will. So, for example, I will say in a little bit like everything in home detector is home to invariant. But sometimes, even in home tree theory, you do constructions that are not home to invariant. And then you cannot do them, or you have to do them in some different way in Home Depth Theory. And yeah, and there's like of course a wider world out there than Home G theory. And I don't think Home G Tag Theory is the best language for doing that. Language for doing that. In this talk, I won't give a comprehensive introduction to HUT, but I'll try to make my next slides accessible and give you sort of a deep dive into one aspect of HUMPD type. I know that you can understand that. But of course, I'm happy to talk more if you want to learn more during today's tomorrow. So, Home Teeth Pack theory, a little bit of history. So, this is a This is an adaptation of the technology we have in Lean. And it was really. It started by discovery independently by Vladimir Vwotsky and a paper by Steve Audi and Michael Warren of the homotopical interpretation of type theory. And what I mean by that is that they made a categorical model of type theory where types are not interpreted as sets. Like interpreted as sets. So, for example, Mario has written his master thesis on a set-theoretic model of lean. But this is different where types are modeled as spaces or like group points at least. Although the group point model was before, but before this, but you can, for example, there's the superficial set model where types are modeled as superficial sets, and that means that the results in That the results in UFI tag theory can then be translated to results by extension sets. Yeah, and I'll be a little bit imprecise. And I think that you should think of types and object theory as sort of topological space, but maybe a bit nicer, like having simplicial sets. And yeah, and so this is Yeah, and so this so these papers were around 2011 I think and then in 2013 there and 2012 and 2013 there was a special year at the Institute of Advanced Studies on Hong T-type theory and then like a big collaborative effort was done to write this nice book, Hong T-Tag Theory. And actually there's some news about this book that, so it was 10 years ago that So, it was 10 years ago that this book was actually written, and now they've yesterday announced that they have the final version of this book. So, for the last 10 years, you could make teleports and small fixes in the book because it was open source on GitHub, but now they have finalized the book. Yeah, and so because types in Homptic Type Theory you can interpret them as spaces, that means you can. Interpret them as spaces that means you can reason about these spaces just by working with these papers and you can do homage theory with them and that is sort of a synthetic version of homogeneity you and with synthetic I mean like the spaces are like abstract objects like the types but and that is in contrast to like the classical way of doing horror theory where like you have like a set with some topological space structure. With some topological space structure, and you define homotopies or like paths as functions from the interval. But here it's really synthetic, where some of the basic building blocks of homotopy are foundational without definition. You get for free from the light. So yeah, here's a little formula, which is not a little precise, but what is the difference? But what is the difference between Hompty Type Theory and Lean? So let's start with Lean. So, what do we need to remove from Lean to be able to do Hompty Type theory? Because we cannot do Hungary Type Theory in Lean because Humpty Type Theory and Lean are inconsistent. So first we have to remove the choice operator. We have a mean. Honky Type Theory is consistent with some version of choice, but you have to be a bit more careful with formulating it. You can assume the axiom of choice. You can assume the actual choice, but like lean choice operator is inconsistent. And you have to remove truth irrelevant. So maybe the easiest thing to do is just remove proper altogether. So the fact that if you have two truths of the same proposition, that they are automatically equal, you don't have that in Huntington. In fact, it is a main part of Huntington that they're different proofs of the same thing. And we have to remove some things, but we also have to add something. So there's an axiom called the univalence axiom, and there's a new way of constructing patterns. So to get like non-trivial spaces, called higher inductive patterns. And I'll talk about that more in later slides. So what does it mean for type to be a space? So it means that if I, so it's a type theory, like if I say A is a type. A is a type, then what that means is that automatically I have paths in this type. So I think of this type A here, and if I have two points in this type, then I can define this path type. So these are paths from A to B. And then like I the type can have like different paths from A to B. And there could be a whole in this type and then Could be a hole in this diagonal. I could have non-equal paths, of course. And then, like, I can also have homotopies between those paths, and those are just paths between paths. So P and Q are paths from A to B. And so now I can look at paths between P and Q. And then there could be like paths between P and Q and those are interpreted as the homoties between the paths. Point leads between the clocks. And you can continue on and on, and you have this higher structure of paths and higher paths. And so what is this path type? So the path type, it's also sometimes called identity type or equality type. And the reason that it's sometimes called equality type is that it's defined almost exactly the same way as equality is defined in Lean. So in Lean, if In Lim, if I change this. So, this is a way to define paths inductively. And probably not all of you are completely familiar with these kinds of inductive families. But if I replace type star here with proc, then you get exactly the definition of equality in the, except of course, the names are different. So, like, paths in LT. Like paths in optiary really behave like equality would behave in lean, except that you can have multiple unequal proofs, well like multiple unequal paths in between points that may or may not be equal. So in lean, automatically, like if you have two proofs of an equality, of the same equality, they're automatically equal. They're even definitely equal. But in yeah, so in Yeah, so in home detectory that doesn't hold, and that's why home detector is sort of inconsistent with this proof of elements. So, what does it mean that paths are basically defined the same way as equality? It means that we get an induction principle. So, with equality, you can do substitution. If you have proven some property for A and A is equal to B, well, then that property automatically holds for B. It doesn't matter what. Mostly holds for peak, it doesn't matter what the property is. And this is also true for complex detector for paths. Anything you can prove for a point, you can transfer along a path. So this is called path induction. And here's a way to formulate it. So if I have a path, a path P from say A to X, and here it's important that X is a variable. Here it's important that x is a variable. And that corresponds sort of topologically, you could think of this. This is a path where one of the endpoints is free. And to prove anything about this path or the endpoints of this path, it is sufficient to prove it in the case where this variable x really is a, like definitely equal to a, and b is the constant power. So, and So and this of course, topologically speaking, just corresponds to the fact that if you have a path at the free endpoint, it comes you can contract that path down to the constant path. Like the path space is contractable with one free endpoint. Yeah, so here's the slogan: everything in object in the respect path. So in particular, functions respect spell, the respect path. And that means that, did I write that on the slide? Yes. So it means that functions in non-detective are automatically continuous. I put it in scatter points because we cannot define continuity because it's just a property that every function has that respects path. When you say respects path, that's you literally mean it satisfies the path induction. Yeah. It's like, for example, if you have a path, like, like Have a power, like if I have two types A and B, and I have a function between them, and here I have a path, then this function automatically transfers it to a path here. And also, like in lean and in home detector, you have dependent types and dependent functions, and they also expect partial functions. And they also respect bias. Of course, that is, I cannot draw a nice picture like that as easily. So let's look at what are the paths in various types. So an easy example is the product type. So this is just the product space. And so a path between pairs of points. Buff between pairs of points, it's just a pair of buffs. And which one do you do first? Which one do you what's the picture? The picture? I mean, if you go up with them right, or would you go right in the same? What do you... Oh, no, no, no. So this is a part of the product experience. I was thinking you could go via A prime to B or via A B prime. Or via A B prime. Yeah, you can, but you can, like, they are equal. Very equal. In the sense that there's a path between them. Yes, exactly. Yeah, I mean, so in non-detect, so in these slides, I made sure to always work so that you don't have all the foreknowledge of equality. But of course, when working non-detectory, these paths, you also treat them as equality. You also treat them as equality. Like to say that two objects are equal, you just construct a path with them. Yeah. So, yeah, so this is for the product type. And so, yeah, so this, we also have this function type between maps from A to B. And so this corresponds topologically to the mapping space, like the topological space on continuous functions. I mean, suitable things. I mean, suitable things on it work. And so now, what is a path between two functions? So a path between two functions is a homotopy. And here, like here is something weird. So the well, so one way to interpret this is to think of this, like if you think of this as equality, this just says something we also know in lean, to prove that f is equal to g, and it is sufficient to prove that for all x, f of x is equal to g. That for all x, f of x is equal to g of x, it's a function x. But here we have a different interpretation of what this is. It is not just for every x f equals u x, but even like this, like an element of this sort of has to continuously vary in x, because everything is continuous. So this doesn't just say like for every point I arbitrarily choose some kind of level of x and d of x, but these pass. But these paths also sort of have to continuously transfer. So this is really the type of homotopies between f and d. And like using functional extensionality, you can prove that the class between f and d correspond to the homotopies. So functional extensionality is a theorem then? Yes, so functional extensionality can be derived from the next one, which is called univadance. So now we also have So now we also have types and we all know in lean, or I mean in lean there's a slogan, equality between types is evil. Like don't ever write an equality between two types. But actually in Honkey Type Theory there is like equality of types is embracing like there's an interpretation for equality between types. For equality between types. So, the paths, so I'm already starting to go back to saying equality instead of paths. I should say paths. So, paths between two types. Paths between A and B correspond to homotopy equivalences between A and B. And so, what is an homotopy equivalence? Well, it's roughly like what the equivalent type is in U. So you have functions back and forth that. functions back and forth that each are like both compositions are homotopic to the identity so like uh using this like the if you take a composition that uh of the two functions back and forth they are equal to the identity uh and so this you cannot prove in type theory uh but so this is uh i mean this is an axiom of functive type theory it's called the universe axiom uh and it was introduced Action and it was introduced by Vladimir Zavotsky. And this is actually a really powerful action that you use a lot when reasoning in synthetic computing. For example, if you have dependent types, you can now characterize what it means for two inhabitants to be equal because you can reason about that equality. And yeah, and so this. And uh yeah, and so the slogan here is because paths between functions are homotopies and paths between types are complete equivalences, it also means that everything in health respects homotopies are homotech equivalence. And actually univalence gives you a little bit more because so in uh like in this stand here you can also define what is a group and from this univalence axiom you can prove that the equality between two groups corresponds actually Between two groups corresponds exactly to group item markets and to these two groups. And so you also get from UniVatans the property that if you've proven something for one group and it's group isomorphism to another group, then it automatically holds for the other group. Which is something that, like, I mean, Kevin has talked a lot about this: that this is absolutely essential to have, but apparently, you're not. To have, but apparently in Mautlib, we like we don't have this automatically, but we still make it. Yeah, I was completely wrong. Yeah. When I learned this, I just couldn't imagine how that should. I'm sure I'm using that all the time. I think in Mount Lib we've set up certain definitions in such a way that you don't have to do that all that often. So but yeah, this is uh it and it it can still be convenient to have this. Convenient to have this. So, here let's I had a little bit of a code snippet of like back of the Lean2 days. Yeah, so Lean2 had actually two versions of the kernel. One that was like Mazlib style, the normal kernel, but there was also a specific thing for hometip type theory. And so, actually, in the link to library, there was quite a lot of. Library, there was quite a lot of multi-bacteria done. And so here is how this looks, except that in the Link2 library, we would really just write x equals y instead of path xy. But so this is the defin-the full definition of concatenation of two paths. So p is a path from x to y, q is a path from y to z, and we want to convert the path from x to z. Well, Q here is a path where Z is a free variable. So we can just contract Q down to the constant path. That is what this induction Q is doing. And now this Z doesn't magically become the same as Y because I did path induction. Now it's the constructed path from X to Y, and I already have this T. So this is this one line is the full definition of concatenation of the. Of concatenation of two parts. You've made a definition in tactic mode. So it's hard to work with. No, no, no. This just produces a proof term. You can make definitions in tactic mode also in Lee, but... I've been told not to. You shouldn't use... Like, if you use things like rewrite and synth, then your definition gets very ugly because they produce very ugly definitions. But induction doesn't give you an ugly definition.rep and stuff again. Yeah, yeah, there there will be path.rep. Yeah, yeah, there there will be a path that works. But but for if if I do P concatenate so if I do this, P concatenated with the constant path, like that will reduce the Q. Because that is the computation rule for... The constant path concatenated with Q won't reduce the Q. Correct, but you can prove it in a one-liner reduction of Q. So and you can do something slightly more complicated. So this is associativity of path concatenation. So we have three paths that we can compose. We have three paths that we can compose, and then there's a path, so a higher path of homotopy between these two paths. So we do induction on R. So now this R and this R becomes the constant path. And then we know that anything concatenated with the constant path is just itself. So now this reduces to P concatenated Q, and this reduces just to Q, so this is also P concatenated with Q. So this is what I see. And actually, like all the operations you can do on paths, like any homotopies between paths, any higher homotopies between those homotopies, like all of them are just do induction on one or more path inductions or let's see. Which is actually, it is, I mean, kind of weird that it all works that way. And yeah, and even like, so for example, defining the homotopy group is also very. Defining the homotopy groups is also very easy. So, here let's take the pointed type, so just the type together with the points. And then we can define a new pointed type, the look space, and that is just the path from this point to itself. And that itself is a pointed type with a constant path. And this sort of has the structure of a group, but it has a multiplication or a group operation. Multiplication or group operation given by concatenation, it has inverses given by path inverses, which again you can define by path induction. It has the neutral element given by the constant path. So this satisfies all the group laws. Except this is not a group because this is a space with higher homotopies and things like that. Like there's still non-trivial paths in this. Look, bars in this looks like. So, this doesn't satisfy the axioms of a group in the homotopy time field. Well, it satisfies all of most of the axioms. Yes, but it's not a high group. Yeah, exactly. But what is the difference between a group and high group in a lot of? So that has to do with something called truncation level. So, for example, so in So, in only type theory, you can define what it means to be a proposition. So, we don't have like this prompt that Lean has, but you can define what is a proposition. It's just a type where any two elements are equal. So it is a type that satisfies prover elements. And similarly, a set is a type where there's only at most one equality, well, at most one. One equality, well, at most one part between two elements. So, like A is a set if, like, for all X and Y in A, so there's at most one equality between X and Y. And so I can write that as if I have two equalities between X and Y, or path X Y, then I can prove that P is equal to Q. Prove that p is equal to q, or then I get a path between p and q. So this is a definition of a set in homety type theory. And of course, in lean, if you translate this to lean, everything is a set. But in Hompty Type theory, of course, that is not the case. Or well, actually, that is not, of course, but you can actually construct types that are not sets. And this is an example. Uh well, depends on A. Yes. Well, depends on A. Yeah, sure, sure. But yes, in for for but I still have to do some work to actually construct something that is not a set. Yeah, but so what we can do in ONP30, there's an operation called set truncation, which is or taking the set of connected components. So, given any type, I can do this operation on it, which is just the set of connected components of this type. And you can define this as a higher inductive type, exactly. And if you do that to the loop space, this is exactly the fundamental group of A. And this really is a group because it has the same multiplication given, just doing these operations, but then on the components. And this really is a group. And actually, defining the home to be groups is also very easy. We can just, instead of taking the loop space once, we can iterate the loop space. Because given a pointed type, we have another pointed type, and I can just take the loop space of that again. And if I do that n times, I get the n-fold iterated loop space. And if I take the connected components of that, that is a set. And it is very. It is very true, like it's very trivial to prove that this is no a group if n is at least one because this, if for n at least one, this is really the loop space of some well, omega to the n minus one. So it is really a group again, and you can do the Eckman-Hilken argument and show that it's abelian for n at least two. Sorry, but usually the Eckner-Milner's relation between is that the motorbase they should be specifically. That your motives should respect endpoints. Yes, where is it incorporated in the so that is like sort of in the equality of paths? So we interpret higher paths as homotopies that preserve the end points of the path. So like if like P and Q are of type path AB in some uh type, then like Uh, type then like the type path PQ, this is now a path in this type, and like paths in this type are interpreted as like homotopies that respect the endpoints A and B. So that is like, yeah, that is encoded in the type itself, in the past type. Or, and yeah, I mean, but of course, like, another view of this is like, well, types are just types. This is like, well, types are just types. I'm agnostic about what I mean by the interpretation. Like, the yeah, I mean, we just, like a type is just an uninterpreted fundamental thing in your type theory. Yeah. But yeah, so that is the like it's encoded in the cluster. Yeah, and all of this takes like very little work and only. All of this takes like very little work in home detector. Yeah, you can prove that they're functorial. Like the like, I mean, this operation that if you have a map within three spaces, like an exon path, that basically gives you for free that it respects the fundamental group. Yeah, that was really good question. With slightly more from path deduction. Everything I've said so far gets from path deduction. And so you can ask, like, I mean, this seems to be a little bit. Ask, like, I mean, this seems almost too easy. Like, is there a catch here? Like, is HUT cheating? Like, do you really get that if you do this proof in HUD that it's true for like real topological spaces, like, not these crazy types? Like, is it really true now for topological spaces? And the answer is almost. So, you don't get it for arbitrary topological spaces, but you do get it for, for example, some special sets. So, there's So there's models of Homptic type theory that's in the category of simplicial sets. And so you can interpret everything that you do in Honky type theory as simplicial sets. And then the path type really become paths in simplicial sets. And the fundamental group really becomes the fundamental group of simplicial sets. So if you have a Superficial sets. So if you have a topological space that is nice enough, like it can be described by superficial sets, then what you proven would be really you get for simplicial sets. I have to say, this is not formalized. Like, so if you want to formalize something for synchronic sets, like you cannot use the, I mean, yeah, you don't get this automatically, but it would be You don't get this automatically, but it would be an. I mean, it would be a nice, but I think very complicated project to formalize a complete model of Honketector that simplists form a model of Hunky Type. But actually, Hunt Detector has other models. So I've been told that any infinity one topos, any grotencinity one topos, models Hunt Detector without really knowing what that means. Really, knowing what that means. But what this does mean is that you can interpret all the theorems that you've proven on G-type theory automatically in all these different Nventi1 tocuses. And the whole G theories care about more than just simplicity threats. There's other interfining Nventi1 tocuses. And so if you do something in Opi Telector, you get it in all of them for free. So that is. So that is pretty nice. But yeah, so I still didn't tell you: like, are there types in multi-type theory that are not set? Like, are we just, I mean, we have this nice theory, but can we actually construct something that's actually a space? Like not just a natural number. And that is where higher inductive types come in. So this is not a high-inductive type. This is just, I mean, sort of pseudo-syntax for does the natural number. Syntax for just the natural numbers which we have in lean. So if you, yes, so you've probably seen the syntax maybe in lean. So you say the natural numbers, we define it as a type, and it's like the smallest type that has these two things. It has a zero, which is just an element of the natural numbers, and it has a successor function. And the natural numbers are sort of freely generated by this zero and successor. And higher inductive types are like that, except that you cannot. Like that, except that you cannot just say it's really generated by these elements, by these functions between these endo functions, but also by certain paths in the type. So here is, like, this is not an actual, like, there's no proof system that has this syntax, but this is sort of the way to think of our inductive types. Like, we just specify a list of things that have to be in this type. Things that have to be in this type. So the circle has a point. Like here's a circle, it has a point. And the circle has a path, a loop. And it's a path from the point to itself. And the circle is sort of freely generated by this point and this path. And I mean, here's a picture. I have a point in the loop and it's a circle. And if you have inductive types, you get an inductive. So, if you have inductive types, you get an induction principle and a way to define functions out of an inductive type. And the same for higher inductive types. If you have a higher inductive type, you get an induction principle and a way to define functions out of the higher inductive type. So, that is called the recursion principle. So, here's a recursion principle. If I have any type, so any type A, any point in the type A, so X is type A, and any Type A and any path between x and itself, so any loop in any type. Then we can define a function from the circle to A such that sends this base point of the circle to X and it sends this loop, the loop of the circle, it sends to P. And I put this in red because this is not just function application, like F is a so f has type S. address type s1 arrow a and I cannot apply it to a loop of s1 but what I mean is this like I have a path a loop in the circle and after I apply the function I get a loop in my codomain so when I so this this red f applied to L I just mean this defined notion this the factorial action of functions on others um And you also get an induction principle. That one is a bit more complicated to write down, but it basically states: like whenever you want to prove something for the circle, or want to prove something or construct some dependent thing on the circle, you have to prove or construct it for the base point. And then you have to say that there's truth or that construction sort of like coherent along this root. Like if I walk along the. Here's along this loop. If I walk along that loop once, I have to get a sort of dependent path over the loop. I'm confused. There's no prop. So what do you mean by to prove something? I mean, so why isn't it just exactly the recursion principle? It's for the recursion principle, but then for dependent functions. Oh, okay. Yeah. Got it, got it. Yeah, yeah. There can be no problem with the. Yeah, yeah. So, and using this recursion principle, this induction principle that we didn't write down, and using the innovations axiom, we can actually prove things about the circle. We can prove, for example, that the fundamental group of the circle is equal to the integers. So we can define a group isomorphism between pi1 and s1 to the integer, and then And then every group isomorphism corresponds to an equality because of univalence for groups. So we actually have this equality between these two groups. So this is not abuse of notation. It's actually, well, maybe I should have written path. You can construct a path between this and this. If that is true, right? If I get an L to negative one. Yes, there's there yes, but indeed. Yes, but indeed, I've read this equality, but there's more than one proof of this because every group is in my two indeed gives you a clock. Just two? Oort of Z has got a size two. But Ot of Z in Ot, isn't it bigger? No, it's still. The integers are just a set, you know. Like everything set level works the same in HUD because you just interpret everything as sets. Yeah, so I mean this is one very simple higher inductive type, the circle, but you can sort of imagine like, oh, instead of a single point, let's take two points or something, and instead of a single loop, let's take a whole family of paths between the two. Of paths between the two points. So let's imagine the following higher inductive type, which is question mark. So I have two points A and B in question mark. And say that I have a whole family of paths which are of type, let's say for every A, I get a path from A to B. So I have two points A and B, and then I have a whole family. And then I have a whole family of paths sort of indexed by A. And what is the higher inductive type I've defined here? Well, it's a suspension of A. So this is sort of the Home T-type theory definition of suspension. Like it's again a higher vector type, where now you have two points and you have a whole family of loops. An A here can be a set. An A here can be a set, and then you just have like individual loops, or it can be a space with additional structure, and then there's non-trivial higher homotopies between these paths, but it's really the suspension of A as a topological space. There's no terms on the path, no? No terms? Yeah, but there's not physical points. No, it's not like a topological space expansion, there's physical points. Yeah, no, no, like a path. So a path in home detector is not a function from the interval. It's not a function from the interval. Like it's really an abstract, like a synthetic thing. You're claiming this is the suspension, but it's only actually got two points you can write down. Yes. And neither of them are suspending. Like any point I can explicitly write down in the suspension must be either A or B. S1 or that's only one point. Yeah, no, I mean there's only one point you can explicitly write down. Only one point you can explicitly write down, correct? Yeah, exactly. Like there's you can also only explicitly write down kind ofly many real numbers. Same phenomenon. But essentially I define as one in the way that the calculation of the fundamental group is by definition. There's definitely something to prove here. You should try some functional way that this is not. Why do we call this the suspension? Well, it has all the properties of the suspension. We can prove that there's an adjunction between loops and suspensions. We can prove all these things in-homely thank you. But also, this is you could construct the suspension in simplicial sets using some pre-work that makes this. Exactly. Homo3 pushouts are also higher inductive types, and then like you can write down all these, I mean, many of these things, like a smash product and a suspension and the wedge product and so on. You can all write down as some decoding it. And yeah, they have the usual properties. So that's why I call them the suspension and the usual thickness. Can you hope in some sense that this is the quote? The quotient of real solar integers. So I'm here talking about the Home Technology that was originally presented in the book. And any relation between Home Tree theory and the real numbers, you cannot prove. The oldest Home Tree theory is not related to the real numbers or intervals or anything like that. I mean, there's other versions of Hong T-type theory. I mean, there's other versions of Ointite Type Theory can do something like that, but that's a bit out of the scope. Yeah, and so for like even like Eilenberg MacLean spaces and like the set functions, like they are also things, they're also instantiations of these very integrated papers. Okay, so then let's start off an introduction to compute technique. Are there any questions so far? Okay, I see that time is a lot quicker than That time is a lot quicker than I thought. I mean, this was the biggest part of my talk. Yeah, so I want to give one like concrete thing that I want to mention. It's like, how do you do cohomology groups? So, here is sort of a quick recipe of how do you do cohomology groups like in like normally just like where X is like a real Where x is like a real space, like really a topological space, and it's actual paths from the real numbers and stuff. Like, you consider, like, this is singular cohomology. So, you consider simplices, which are continuous functions from like this standard delta simplex, the end simplex, to x. So, these are like the simplices in x. You take the free abelian groups of these simplices. You define like this binary map in some way, like by Some way, like by taking an n simplex and turning them into like some formal sum with like signs with n minus one simplices. And this turns, like this is differential, so this becomes a chain complex. And then we take the homology of this thing, chain complex. And for cohomology, you do one step between these two steps, you dualize. So you consider the group morphisms to some like chosen median groups. Chosen reading groups. So let's do this in HUT. So let's start by considering what is a simple space. Well, the simplex is a contractible space. And any two contractible spaces are home to be equivalent. So, and anything home to be equivalent becomes an equality. So the simplex is just a point. That doesn't look good. I mean, what is this free reading group? Like, this is a space, it has a higher non-free structure. It's not a set. Factor, it's not a set. What does it mean to take the free reading group on a space? I don't know. Now, this boundary map is really a problem. Like, this is an n-simplex, or I mean, a word from n-simple C. And I want to sort of look at the boundaries, but it's really just a point in X. Like, we cannot look at the boundaries of a point. So, even though at the end we get something that is honestly invariant, like this recipe. This recipe doesn't work. So we cannot use this in home to character theory because these intermediate steps are not homogeneous. So how do we do homology? Well, there's results that you can prove for normal spaces. Like if you have a CW complex, the homotopy groups are equivalent to the homotopy classes. You can take the Eigen Brackman plane space. You can look at the mapping space. You can look at the mapping space from your space to an eigenmarket plane space. And it's a theorem in Opti theory that this is equivalent in a factorial way to the cohomology group. And this, like, we can all do in Opti Tech theory. Like, we can construct the Einenberger plane space as Heinrich's types, and then this is just the maps or the maps, the base point preserving maps or something. And so in optite theory, And so, in Octite Theory, this is the definition. So, we can define. So, here, for example, I take the reduced chromology. What does that mean? Reduced chromology. Oh, it's... Drop one point, basically. So from the redu I mean, I I know the the other direction, if you if you have the reduced cohomology, you can the cohomology, you can define the unreduced cohomology by adding one point. Chromology by adding one point. And it makes the formulats a bit nicer if you work with reduced chromology. But so, yeah, so this chromology is just take the pointed maps. So these are base point preserving maps from X to diagonal K space. And then just take the set of components of that. And that is a combinology that you can reason with. You can prove the Einberg Steam Rotaxion for combinology for this. Cohenology for this thing. And actually, I think the Einberg-Simmons actions are a lot easier to prove for this definition of cohomology than for singular chromology. When you reason about these things, I assume that it just boils down to reasoning about dialogue with plane spaces. Yeah, exactly. Like you can define a cup product, and that comes from some operation from some binary operation of two any background name spaces, the latter one. And we can also define homology. That one is slightly more complicated, but basically, it means instead of taking this mapping space, we take some kind of smash product. And then, like with some animal plane spectrum, like you have to sort of take the stable homotopy group. But you can define that as sort of a coding homotopy groups. And you can do actually non-trivial things with co-managing. So in my Cohenology. So, in my PhD thesis, I constructed two spectral sequences. So, this is the SER spectral sequence. This is not a full general form, but maybe a form that if you speak in the SER spectral sequence, you might be familiar with. So, if you have a pointed simply connected space and a map into it, so normally you would assume that this is some kind of verbation, some surfurbation, but being a surfurbation is not. Being a surf vibration is not invariant on the homotopy, so you cannot define what a surf vibration is. But you can do it for any map in HomeGeck 2. So if f from x to b is any map and it has fiber f, then you can construct this spectral sequence. And I won't go, like, I don't want to explain what this exactly means, but like a spectral sequence is like this page, like has like pages of like grids of a beat. Uh grids of abelian groups or modules or some other thing in an abelian category, and then sort of this describes the second page, and then like it eventually converges to some infinity page, which are like this are described by these groups. And so this gives some like description of like these cohomology groups with coefficients, these cohomology groups in terms of, and this is the cohomology groups. All and this is all uh the combology groups of the base space and to describe them in terms of the orchestra relation between them uh between the combology groups of the domain of the um yeah and so so there's uh we even pushed a more generalized version of this uh so where instead of taking ordinary cohomology uh we worked with generalized cohomology and you can also do some like parameterized version which in contradictory means Which in quantitative theory means like sort of working with dependent types. And that sort of corresponds to taking homology with local coefficients. Is it only formalized in the case where the base is simply connected? No, so this general case you can do without a simply connectedness assumption. So the simply connectedness assumption is only needed to go from this parameterized case to just ordinary gets. And you also get the action of. So if B is not simply connected, the action of pi 1 only. Yeah, that gives you. Yeah, that gives you some direction of the chromology groups. So there's one caveat, or I mean, there's a couple of caveats like of things we could improve in the formalization. So one thing we didn't prove is that this spectral sequence respects the copper. I mean, I don't think there's an inherent obstacle, it could just be more important. Okay, so let me wrap up with like what can we learn from like We learn from like these doing these things in Object Tactory. So, one thing, I think, so I mean, my motivation for trying to give this talk was some of these verbs in Object Title are incredibly simple and incredibly elegant. Can we sort of transfer that to Lean? And I don't think it's easy because many of these reasoning principles just don't work in math. In math. They're just false. So, for example, some of the reasoning principles I mentioned, like there's path induction, univalence, like the fact that everything respects homotopies, the higher inductive types and their induction principles. Like if you easily translate them into lean, it's false. You can write things in lean that are not invariant on the homotopy, of course. So, you cannot reason with that. And, like, univalence is not consistent with the foundations of B. But maybe we can sort of mimic the reasoning principle. So, for example, like the recursion principle for the circle is very useful in multiple factory. Can we like prove the recursion principle for the circle and maybe some kind of induction principle and then use this abstractly and for other high-inductive types? Like, I mean, this is sort of. Uh, I mean, this is sort of. I mean, this is something we know. You mean the name circle? We know about yeah, you're sort of like you can still prove that if you have a loop in an arbitrary space, you get a map from and I mean, I'm not saying anything new here. This is just saying, oh, maybe we should consider like universal properties. Like, what uh like what is the how do we map out of a space, like uh characterizing that? Uh something like that I think it could be useful. think it could be useful um to to to reason like uh to to to to take these like elimination principles sort of as a black box and reason with that uh one thing i already mentioned is maybe we can construct a model of hunted type theory like uh i mean and then um if we construct a model of haunted type theory then we can prove these things in like this internal version of haunted type the In, like, this internal version of multi-type theory, and then we can interpret them in simplicial sets. I mean, this is kind of visual thinking. I think this would be incredibly big amount of work to fully describe the syntax of quantum type theory and then write down a model, like proof that it's infrastructure sets from a model. But if you have that, I think you've spent more work on doing a lot of the whole description, doesn't mean. Describe doesn't mean. But if you have that, you could like reason in non-Qtag theory in this internal model and then interpret this proof in some visual settings. Yeah, and I think maybe one more promising thing that is maybe less preferent is just maybe we can try to imitate the definitions of quantity criteria. So, like, in order to So, like, in architectural, sometimes we have to be creative with definitions because our definitions cannot do, for example, singular chromology. But that also sometimes gives very convenient definitions. I think proving the Einberg singer actions for the definition of chromology I gave on a couple slides ago is easier than doing it for singular chromology. And I think it roughly gives you the same Give you the same common theory, like the same properties. I mean, maybe for like more pathological spaces, it doesn't work as nicely. But for example, maybe it is useful to think of like defining the loop space first abstractly as a topological space, and then just considering the home tree group as a set of connected components. And we can really do this. And we can really do this. We can iterate just a single mapping space and then get the higher rich spaces. Yeah, I already mentioned this. And yeah, and I think this fits sort of within the Mauslin model that we try to do things in an abstract and general way first and then apply them to special cases. A lot of the properties for coherency. Of the properties for cohomology theory come from properties of animal clan spaces. But we want to study anemarical plane spaces anyway. So I think a lot of the work you have to do to get the properties for chromology, you get for free after you've proven various properties from America's precisions. And actually, there is also one thing I like to study: proofs that didn't work very well. Is proofs that didn't work very well in home-theory. There are some proofs where it's actually really inconvenient that everything you do is home to be invariant. Like, for example, working with co-limits in home theory, like you can choose to, like, normally you can choose to take really co-limits where things like respect points on the nose, and you can take homotopy co-limits. But in homogeneous, you only have homotopy co-limits, and you cannot work with like. Work with like equality on the nose. And that means that you have to reason about this higher categorical structure of all these phases. And that can combinatorily just really explode the complexity of your proof. And I think it would be interesting to investigate what if in something like lean, these kinds of arguments can be done actually. Kinds of arguments can be done actually easier and nicer than results. So that was my thought.