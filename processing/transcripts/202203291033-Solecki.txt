Okay, good. Thank you. Okay, so it's it's all good. It's ready. It's all good. Okay, all right. So what let me just say a little bit of what we've done so far. So we introduced analytic sets. These are continuous images of Polish spaces. They turned out to be the same as the results of applications of operation A to closed sets. A to closed sets. And then Borel sets introduce them as continuous injected images of Polish spaces. And they turn out to be results of applications of countable operations of countable unions, countable intersections, and complements to open sets or closed sets. Doesn't matter here. So this is a sigma algebra. The difference here between these two that I kind of came up yesterday in the last talk was that together. The last talk was that to get analytic sets, we just apply A once to closed sets, and then actually it's idempotent. If you just keep applying A, nothing happens. So you apply them to closed sets, and then nothing happens if you iterate. Well, here you have to iterate these operations of countable units and countable intersections, and this leads to this long filtration of Borel sets, this growing family of Borel sets. This growing family of Borel sets of length omega one. So, and it's truly omega one on uncountable Polish spaces. So, this gives rise to this interesting hierarchy. Okay, so now there's one thing I owe you is another, well, we talked about analogies and similarities between Borel and analytic sets, but we hinted at it at the fact that there are. At it, at the fact that there are analytic sets that are not Borel, but I never produced one like that. So, here we'll try to produce, look at this differences between these two classes and produce an analytic set that's not Borel. So, this goes through an interesting construction of universal sets. So, fix for various classes, not just analytic sets, but open, closed, and so forth. So, fix a Polish space. Fix a Polish space and a countable basis, topological basis in it. And notice containing the empty set. I think everything I said is modulo the empty set. It's a special case in some situations. But in any case, here I have a so then, okay, if you have this basis and you pick a parameter here from n to n, from the bare space, so a sequence. Bare space, so a sequence, an infinite sequence of natural numbers, and you can form this union. Just take the union of all u's indexed by whose subscripts come from images, the image of alpha. This gives you an open set, and clearly every open set, a subset of X, is of that form because it's a union of some family of basic open sets, and we can just enumerate that family. Okay, but Okay, but the point, so that's not surprising, but what is maybe somewhat surprising is that we can put all these, so it's for given an open set, subset of U, I find an alpha. But we can now look at this two-dimensional set that I remember the alpha. So I look at alpha and then I look at with alpha, I look at those X's that are in the set coded by alpha. So what I'm doing here is. So, what I'm doing here is I have n to n, and I have an x, I have an index alpha here, and above this index, I put the open set coded by alpha in this fashion. And I do it for every alpha. And the thing that is maybe somewhat surprising, but very easy to check, is that that set U here, this two-dimensional set, subset of this space, is itself open. So, I can put all open. So, I can put all open subsets of X into a single open subset of the product N2N product X. And then this is a universal set in the sense that for every open, a set is open in X precisely when this U here turns out to be a vertical section. So, U alpha is just the vertical section of the set script U that I. Of the set script U that I produced here. So U is open if and only if there exists a parameter alpha in n to n such that u is the section of the set script u. So every, so I listed in a coherent way open subsets of x. So this set u is then called universal for open sets. It's this construction, it's a very simple construction, but it's some, it was surprising to me when I years ago I saw it for the first time. So there's this universal So, there is this universal set, and now, well, I can do a closed universal set. I just take my script U in this product, I take its complement, and it's very easy to check just from the definition that this resulting set also in this product is universal for closed sets, meaning a subset of f is closed, of x is closed, even only if there is a parameter here, there is an alpha in n to n, such that f is obtained. n to n such that f is obtained as a vertical section on f right so it's again the same situation n to n here x there is a subset here f and i get every open set every closed set as a vertical section of that set f yeah so i can do it for for closed sets fine so this was done uh remember for this x x is an arbitrary polish space so let's take let's Space. So let's take, let's soup it up a little bit, and let's take this Polish space to be the product of some other arbitrary Polish space y and end-to-end itself. Okay, then I still have the same, the same construction, this is still a Polish space. By the construction above, I get a closed set, subset here, universal for closed subsets here. Like this can be done. And then what I do, I take And then, what I do, I take the projection, I change the order of parentheses, and I keep these two coordinates and I project along this one. So I project onto the first two coordinates, my set F. So what does this mean? What points do I get? I get point alpha y such that there exists some beta such that alpha y beta is in f. So I project it along the last coordinate. Along the last coordinate. Geometrically, maybe getting a little tricky to see it, but well, this can be done clearly. Now, notice that this set is closed. Its projection is a continuum. Projection is a continuous function, so this set is analytic because it's a continuous image of a Polish space. So it's an analytic subset of what space? Space, it is a subset of the space n to n cross y. Moreover, notice that any analytic set can be seen as a projection of a closed, any analytic subset of Y can be seen as a projection of a closed set of the product Y close end to end. The reason is an analytic. The reason is an analytic set is the image is the image of n to n modulo n to n a continuous image of n to n. Well, the graph of that continuous function is a closed subset of this product. And the image is just the projection of that closed subset. Right, so I represented my arbitrary analytic subset of y as the projection. Analytic subset of y as the projection of a closed subset of this space. And then I can also, if I have a projection of a closed set, that's clearly an analytic set because it's a continuous image of that closed set. And that closed set is Polish. So an analytic set, subset of Y is precisely a projection of a closed subset. A projection of a closed subset of this product. Okay, so using that point of view, one can actually see that this set A, that's analytic subset here of N to N cross Y, is universal for analytic subsets, for analytic subsets of Y. Because here I look, F was universal for closed subsets. Uh, for closed subsets, here I did the projection. So essentially, I projected every closed subset of that product onto y. So I must have gotten all analytic sets. So let me state it formally. A is subset of y is analytic if and only if a is this a section for some alpha of the set A. So this is a universal set like that. Are there questions? So you can see this universal set, they actually behave pretty. Universal set, they actually behave pretty well. You can, out of simpler universal sets, you can get universal sets for more complicated classes, as long as the more complicated classes are obtained from the simpler classes by some decent operation, like projection here. Okay, any questions about this? So, I have this one single set, subset of y cross end to n that encodes as sections or analytic subset. This looks like a pretty complicated analytic substance. I mean, this is the most complicated analytic set. So, if there is an analytic set that's not Borel, this must be it. As long as y is non-trivial, not countable. So, there's a theorem of Sussvin. Each uncountable Polish space contains an analytic set that is not Borel. So, they are everywhere. These analytic sets, non-Borel analytic sets are everywhere. Analytic sets are everywhere. Let's just show that one such exists, and then you will believe that you can repeat this construction in every uncountable Polish space. So what is this subset? Well, let's, well, this will be one of those A's. So A subset of N to N cross N to N, where this is my Y. So this is universal. My Y. So this is universal for analytic subsets of Y. And then what do we have? How do we produce? I want, I will produce, I claim this is not, so this is a Polish space. I claim A is not Borel. Why would it be? Why is that the case if it were Borel? Assume if A is Borel. That would imply that this set C, this is the set of all alpha, well, this has to be properly C, is the set of all alpha in end to n such that alpha alpha not in A That this set is Borel. Right? Because what it is, is I take the intersection of A, of this set A, with the diagonal, and then the diagonal is homeomorphic via this trivial homeomorphism. Alpha goes to alpha, alpha, with n to n. I pull back this intersection. Pull back this intersection of A with the diagonal. A is Borel, its intersection with diagonal is Borel, because the diagonal is closed, so Borel, intersection of two Borel sets is Borel. And I take then the complement of that intersection of A with the diagonal. If this intersection was Borel, the complement is also Borel because Borel sets form Borel sets form sigma algebra. So this set is Borel, so is analytic. So it's analytic. So it is analytic. But that's the trouble with Cantor. So now we run the Cantor's argument. Since this is an analytic, notice the subset of N to N, this is universal for analytic subsets of N to N. So if this were analytics, there would be there is an alpha zero such that C is A alpha zero. But this alpha zero is strong. But this alpha zero is trouble because it doesn't know where it belongs. So now let's run this standard counter computation. Assumes alpha zero is in C, this happens if and only if, notice by the definition, if alpha zero is in the section of alpha. This is if and only if, just by definition of sections, of vertical sections, alpha zero, alpha zero. Alpha zero, alpha zero is in A, just by the definition of sections, by the definition of sections. But this is if and only if. Notice, if alpha zero, alpha zero is in A, then clearly it does not fulfill that condition. This happens precisely when this condition fails. But this condition, therefore, this means failure of this condition, this means not belonging to C. means not belonging to C. So this is if and only if alpha zero is not in C. So you can run this sequence of equivalences in two directions and alpha zero cannot be in C and it cannot be not in C. So that's a contradiction. Can you move your paper up against the bottom? Okay. Is it up enough? Yes. Okay. So that's a problem. So let's see. So this set. So this set couldn't have been analytic, so it couldn't have been Borel. Therefore, this could not have been Borel, a Borel, a Borel set. Notice that this shows that I still have space here. So this shows that, for example, you can show that Borel sets don't have a universal set. So this is something that distinguishes Borel sets from analytic sets. Analytic sets do have that universal set. This argument will show. This argument will show that Borel sets don't have one, yeah. And now, how would we get the Susslin Core and from the? Let me just say it quickly from that. Notice, this is an analytic non-Borel subset of that space. It's very easy to see that this space is actually homeomorphic with end-to-end itself. So I have an Borel or an analytic non-Borel sub- Analytic non-borel subset of this space. But I already said that every uncountable Polish space contains a homeomorphic copy of N to N. So then I just transfer this analytic non-Borel set through this homeomorphic embedding of N to N in my given Polish space, uncountable Polish space. And I have there an analytic non-Borel subset of the given space. So I can get Sussman's theorem in that way. In that way, there are some checking that needs to be done about homeomorphism transferring appropriate things, but this is how it goes. Any questions here? So we have an analytic non-Borel set, and we have some structural, some interesting structural property of analytic sets that is not shared with Borel functions. Okay, so let's do something now. So the, but also all former spaces are. all all uh polish spaces are isomorphic right all uncountable yes but yes sure you could also go that way all polish uncountable spaces are isomorphic there's some again a little bit more checking there notice that this in my view depended on the fact that n to n homeomorphically embeds in a con so so yes that that's correct that's correct but notice that this the proof that i was giving is simpler because Is simpler because the fact that all Borel uncountable Polish spaces are Borel isomorphic depended on the fact that an uncountable Polish space contains a homeomorphic copy of N to N in the way I did things. But that's correct. They are all the same. Okay, so now I was, when Matt asked me to do this, I was okay. There was this thing about Borel being different from analytics. Borel being different from analytic in some computational sense, in some sense that if you do, there was this, I mentioned it, Simon Thomas' Church's thesis that says that if you run any kind of effective procedure that involves only countable operations and you start with decent sets, you will end up with Borel sets, no matter what you do. So there's some kind of way of, okay, there's some kind of Okay, there's some kind of computationally, Borel sets are simpler, and analytic sets are far, far away. If you simply cannot reach analytic sets if you just do these countable iterations. So I spoke with some friendly computer science people here at Cornell, with whom we have sometimes post-seminar beer on Friday. If there's something like that, turns out there is exactly, so they actually thought. So, they actually thought about things like that. So, let me say a little bit more because this makes this computational point of view formal. And it also proves some interesting theorems. But so let's talk about Borel automata. So, okay, so what do I have? I have a Polish space. I have a fixed Polish space. I will fix it. And then what are these automata? So I have the set of states. This is some countable set. Double set. So, this is quite different from everything that preceded it. So, we can start from zero here. You didn't have to understand anything that came before. I'll have some special state, S0, and I will have a family of statements. So, this is a set of statements about a variable. So, x is a variable. And let's say this can be made very general, but for us, the statements which For us, the statements, we can just limit ourselves to the statements of the foregoing form. X is in U, where U is an open subset of X. So this will be statements that we will check about, we take, there is a variable. So in this, this is a formal expression. X is a variable, but U is an honest open subset of X. And then we'll have possibly some element of X, and we'll be checking whether the statement holds or not. The statement holds or not. Okay, so these are automata. So I want to do some there will be an automata and essentially some kind of a program. So what are the program instructions? So these are the four program instructions and they are just essentially kind of Boolean, countable Boolean gates or something like that. Yes. So what we have here is this. So let's look at the first instruction. These are all possible instructions. Instruction. These are all possible instructions. I'm not saying I'm using all of them, possible instructions. So I have a state S. So that's an instruction, this whole business. It is S, column all A, where A here is a subset of S. So what I have is S is a state and it will look up. It depends. We say that it depends on the set A and it will. And it will look up if the program is run, the states will either accept, reject, or will remain undecided. So what will be happening here, S will look up all elements of A, see how they decided things, or maybe they are undecided, and then adjust itself depending on what it looked up at the states in A. There is another instruction say. There is another instruction. We'll say what they mean in a moment. Also, this depends on A. So, this is, of course, the universal quantifier. All means essentially S will accept if all states in A accept it. This one is S will accept if all states in A, if some state in A accept it. This is another Boolean gate. It's just negation. S will look up T and say, if T accepted, I reject. If T accepted, I reject. If T rejected, I accept. And then there is a last one, last instruction, type of instruction is here. It's an implication. So if, and I look up the statement phi, phi will be coming from my family, capital Phi. If phi holds, look up T and see if it accepts. And then if Phi fails, look up U and see if it accepts. And see if it accepts and adjust yourselves. So these are possible instructions. So these are kind of what you would expect: Boolean gates, countable Boolean gates here and here, negation, and then implication. And then the Borel automaton is a function from delta from states with these values. So these values are possible instructions, right? So maybe I have delta of s is this. Maybe I have delta of s is this, then this means that instruction shows up. Delta of s is this, then this other shows up. At s, this other shows up, and so forth. So delta s may take all these values. So once I specify this delta, I have a program. I have this automaton. So at every state S, I know what to do. There is more to be said, but is that clear, at least on a formal level? On the formal level, so when a state accepts it, like you somehow record that information. I'm sorry, can you speak up? When some state accepts, you sort of record that information? Yes, so I will say how it is done in a moment. I will say how it is done in a moment. So exactly. So for now, it's just instructions, just a function. It's just a program that is not being run. So it just stands there. Being run, so it just stands there, nothing is happening. But now, very good. This is a very good question. So, to say how a program is run, I have to tell there is one additional gadget I need. So, this is the three-element set consisting of zero, one, and perp. Yes, so zero is read as reject, one is read as accept, and this perp is Except and this perb is read as undecided. This is kind of a kind of trivial set, you have three elements, but it has two natural partial orders. One is the scode order, which puts this undecided at the bottom and zero, one at the top, and zero and one are incomparable with each other. So perb is between below zero and below one. Zero and below one, and nothing else is comparable. Yes, and then there is another order called Wukashevich order, and I can pronounce it properly: Wukashevich order that looks like this. So if you are completely ignorant, it's at the bottom, undecided in the view, if you are undecided in the middle, and you have full knowledge, then you are at the top. So this is then this other order. There are two orders: one is denoted by less than or equal, the other one is by this. Other one is by this, okay. So there is this gadget on the side that we need. Is that clear here? Just three elements set and two orders on it with a kind of appropriate intuitions behind the elements of the set, accept, reject, undecided. Okay. And then, okay, so how now, so to Anush's question, how are we running this automaton? So what's the input? Input will be an element of this Polish space. So I have this Polish space, I pick an element of it. You can think of it. I pick an element of it. You can think of it as n to n, x is n to n to n, and this is just some element of x. And then I have these states, I can attach labels. So this is what's happening in the program. How they attach labels to it. So this is just in general, I can, this is what I think Anus was asking about. To each state, I can attach 0, 1, or perks. 0, 1, or per. So this means at this state, I reject, I accept, or I am undecided. And then given this A, there is a transformation on the labels. So there is a transformation tau A of L, which will lead to a different label. So for a given label, L, so a label function, it will lead to a Label function, it will lead to another label function and it will lead to it in a natural way. So I look at t a of l and let's evaluate it on s I have to tell you this is a new label function, so I have to tell you what's the value at s. Okay, so it does it in the very natural way. So if I am at s, I look up what kind of instruction is associated with s. So in this case, So in this case, delta of s, remember, this was the instructions. So this is the instruction. So this is the instruction at S. So what I do is I will at S, I will accept. So this means take the minimum. So take S, look up all the T on which A depends. This is given. Which A depends. This is given by the instruction at S. Now look up what the old label is telling me about all these T's and take the minimum with respect to the Wukashevich order, with respect to this order. So if all L of T are one, all the T's accepted, make me accept. So now tau A of L at S will also accept because everything that it depended on. Because everything that it depended on, S depended on, already accepted. If everything that S depended on, either accepted or are undecided, and there is at least one undecided, then make S undecided. Then this is then equal to the undecided, is the minimum of the two values that were taken at possible t's on which S depends. And if Depends. And if there exists one T on which S depends, which reject it, then make S reject in this new label function. Right? So this is this transformation from a given label function and an input A, I will give you a new label function. And then you do a very similar thing if it's this dual instruction, sum A, except you have to flip everything upside. Except you have to flip everything upside down. So let me not talk about this. If the instruction at s turns out to be the negation, then you look up the T on which S depends, see what it is. If it accepted, you reject. If it rejected, you accept. If T is undecided, you stay undecided. That's the negation. Okay, and then there are these instructions. Okay, and then there are these instructions if phi then then what was it? Then t if not phi then u if else u. So this is this instruction. Remember, this was this implication. If phi then t L's u. So what you do here, so if that happens to be the instruction at s, what you look up, now the input comes in. You look up this file. Up this phi, the statement phi, this is the statement given by delta at a. This is a statement for us, it's more general, can be made more general, but for us, this is a statement is in you. A is in some open set U. So check if A is in U. If it is, if it is the case in X, then my new label at S is what it was at T, at the T on which S depended. At the t on which s depended, this one here. I should switch to green. Or in the opposite situation, if phi of A failed, then my new label at S, it was what it was at U. This is this other. This is this else part of the instruction. So there is this transformation. Given an input, I have a transformation from one label function to another label function. And it takes a little bit of not much. Not much, a little bit of thought. And you notice that this transformation, if I go from one label function to another label function, is monotonic with respect to this Scott order. So it can go from undecided to one, and then it cannot, if it's one, it cannot do anything more. It will stay one forever if you keep applying this transformation tau. Or it can go from undecided to zero and then. Go from undecided to zero and then it's stuck at zero. So at given S, it can do one jump from undecided to zero and one, then it has to stay there. And of course, at other s's, at other t's, it may still remain undecided, even if at a given s it jumped up. So now there is a general thing for things like that, that there exists at least so these functions now, these label functions, are comparable, just like you compare a compare so l1 right l2 you can compare them because they have values in a partial order so you can compare them like that so there exists at least such function i will call it l equal l a this because everything here depended on a that is a fixed point so if i have l i apply this transformation tau a to l it's just l nothing To L, it's just L, nothing changes. There is a canonical L like that. How is it produced? So, what we do is we assign the value undecided. So, we start with the label function L0 to be constantly equal to undecided. For all essays, we just put undecided. And then we take the transformation tau a and we run it on this L0. We just iterate it in the transfinite, we keep iterating. We keep iterating it. And at some point, this is we are getting functions that are bigger and bigger. So at some point, they will stabilize. This point is this L. That's how it's produced. But there's an abstract theorem that says in situations like this, you have this function, this fixed point here. But somehow, this procedure of getting this fixed point corresponds to running the program. We just keep, this is like running. This is like running the program, right? Running the automaton. We start with this kind of trivial label function and just keep running the automaton. And at the end, we produce an outcome. Okay, so that's is it is that clear? Okay, you run it countably many times or countable or minimal times because yes, countable or so to start with, you just round it into. I don't want to, because there are people in analysis. There are people in analysis, so I don't want to kind of too much emphasize this transfinite character of the thing, but you run it into the transfinite, and then you, because of countability of S, you can prove that actually this fixed point will get attained at the countable ordinal. For every S, there will be a countable ordinal at which you are. Okay, so, but yes, you run it, you run it into the transport. Okay, so now, okay, so we've run it, this automatic. Okay, so we've run it, this automaton, and then what does it do? So remember, this depended on A, this element of X. And then notice here, you probably forgot, there was this special state as zero that I said is part of the, it hasn't played any role yet. But now here it is. So we say that A is accepted by delta if at this special state. At this special state, this fixed point that I produce, this ultimate function, label function, at S zero, will accept. So accepts at S zero. A is rejected by this delta, the delta that we considered, if that ultimate function, label function, at S0 rejected. And we say that delta holds if either accepts either accept holds at A if either it accepts, so I should say at A if either it accepts A or rejects A. So there is an outcome. There may be a situation, there are situations, where A will be neither accepted nor rejected. So there will be L A of L zero. It's possible that L A of L zero is just is equal to undecided. That can happen. Okay, and then let's have this one here. And then let's have this one here. So, this L of delta, I would say this is the set of all A that are accepted by delta. So, I have a I had these instructions. I told you what an automaton, a program was, I told you how to run it, and then on a given input, and then I look at all the inputs that were all the inputs A on which that automaton halted and accepted. And accept it. Okay. So this whole, so this is the computer scientist, Kozen is here. So Kozen and Mota, this is this whole setup is due to them. It's actually not that old, kind of recent. And they proved the following theorem that if I have a subset of this Polish space, the subset, its complement, co-analytic means x minus a analytic. So x minus a is analytic. So a is co-analytic precisely when it is the set of all a in x that are accepted by some automaton. So if there is an this countable procedure, there is a countable procedure. This really completely is a completely abstract way of saying, okay, what is a countable procedure on Accountable procedure on Polish spaces starting with basic statements like a point belongs to an open set. This is kind of as general and abstract as it gets. So if there is an abstract procedure like that will accept precisely the points in A, then this A is co-analytic. And for every co-analytic, I can find a procedure like this that will accept precisely the points in A. That will accept precisely the points in A. So it looks like almost, I mean, these co-analytics are so good, but there is a drawback here. The reason is, and I mentioned it here, it's possible that on some inputs, delta will not stop. Delta will not reject, will not hold, will not reject, and will not accept. So if you are outside of A, so if you happen to be a point in A. Happen to be a point in A, you will be eventually accepted by this delta, for which this is true. But if you are outside of A, you will never know. I mean, maybe you will get rejected, but there will be points outside of A for which delta will not return a rejection or acceptance outcome. It will just remain undecided, and you will never know what happens to it. So, this is exactly what not happens, what does not happen. Happens, what does not happen for Borel set? So A is Borel. If A is the set of all accepted points with some this very abstract countable procedure for some procedure for some delta that holds on all inputs, right? So So, if I have a procedure that for every input in X, I will get an answer, accepted or rejected, then the set of all accepted inputs is Borel. And the other way around, if a set is Borel, then it is a set that is, I can come up with a procedure like that that will accept precisely the points in me and reject everybody out. And reject everybody outside. So, this is kind of an honest, this is what we would want. This is like a countable procedure that decides about everything, about every point, and decided positively for points in the set that I wanted. While for co-analytic sets, so this is the complements of analytic sets, I do have such a procedure, but it has this huge drawback here, that there will be points about which I will never know to. I will never know what happens to those points. And okay, so this is that's it. That's this theorem of Cosen and Mota that I think nicely, in a very abstract way, codifies what we mean by this Borel sets being outcomes of some general countable procedures and exactly those being the outcomes. Okay, so I think there is one more thing that I just There is one more thing that I just want to indicate. I thought this was kind of interesting, but there is a let me come back here to what I started with today: that is Susslin analytic sets that are not Borel. I produced one here using universal sets. This is not exactly satisfying solution because this is a kind of an abstract set, and who knows what it looks like, a universal set like that. But there are concrete. But there are concrete space sets that are co-analytic, analytic non-borel. Let me just say, just very quickly, just so people maybe can look it up in Kekris's book, for example. You look at, remember I introduce a space of trees. These are subsets here, subsets here. And then all subsets of less than, all such subsets. Less than all such subsets, well, a subset here is an element of this counter set. So this is the index, and this is zero, the zero, one, discrete zero, one. So now I can look at the set of all t's such that t in to n less than n such that t is a tree. That's a nice set. This is closed. But then I look at, so this is trees. I look at the I look at the t and 3 such that 3t is ill-founded. And this means it has a branch. There exists an alpha in n to n such that for each n, alpha restricted to n is in the tree. So there is an infinite sequence such that every finite truncation of this infinite sequence is in the tree. Sequence is in the tree. Every finite truncation is in the tree. There is a tree here, some tree growing downwards, as they sometimes do, and there is an infinite branch through it. Then a tree is called infounded, ill-founded. This is a subset, remember, of two, on this nice compact space, so Polish space, counterset. This is analytic, not Borel. And this is concrete enough, and at the same time, general, kind of this is a very important set in the analysis of analytic and co-analytic set. This set and its complement in trees is very important in this finer analysis of co-analytic sets, but I will not go there. So, let me just finish with that. All right, thanks. Actually uh we have the question session here, so uh let me get run again maybe we have questions. You can yeah, you can start asking what oh I think I'd say it's for both of them. No, no, no, it was separate. It's separate? Okay, so okay, sorry, separate. So yeah, so questions. Sorry, Stavik. So, yeah, so questions? Yeah, I think I'm sorry. So, Swavin, so now we can use these two machines to prove, say, analytic separation, just like we do with... So correspond to funny enough to RE sets, like recursively enumerable. Yes, yes, yes. But that's how it works, right? It's great. Yeah, so actually, this is what they use it for. They actually prove, they give a kind of nice computational whatever. Computational, whatever. So in their language, proof of the fact that a set is Borel even only if it is analytic and co-analytic. So they use that to give a proof like this. And they have hopes to use it for maybe doing some kind of this is probably, I'm not sure if it's, I mean, they express that hopes that, for example, you can give a nice proof of. Give a nice proof of Borel determinacy, things like that. And yeah, I know, but I'm not sure. Yeah, so they do hope that some basic theory of so some basic theory of analytic and Borel said they develop. And they hope that there is more that one can kind of do in that language. Yeah, exactly. What do you think? And it also implies, I forget the name of the talk, reduction, reduction, I think. So you get reduction. So, you get reduction for coinity sets, like you run both of these automata. If you have two coinity sets that maybe overlap, you can this is possible. They didn't go any farther. They just proved this. Borel is analytic and co-analytic. And some it's very likely true what you are saying, but it is not thought through. So, they didn't think it through completely. So, they have some what you said, they don't don't. What you said, they don't prove, but I agree with you that it seems likely that this can be used to do that. Yeah. But if the property I said is it is, I guess I've never seen it in classical discourse. So that would be interesting then. Yeah, I mean that's yeah. So that reduction property implies analytic separation. I haven't seen it. Okay. Very cool. Abba, can I just a follow-up question? So you mentioned AMOS to prove things like ORL determinacy using these things. How does it line up like with Rainers? I think Albert Friedman proved that you need power sets, right? Look, this is, I'm just, they wrote one or two papers about this. They did not. Papers about this. They did not, they expressed a dream. And I, I mean, I had my objections when I spoke with them, but I'm just saying this is where, what they would like to get. I don't know how, you know, of course, there is. You see, these sets, there is some, there are some situations that I should say here, the set S doesn't have to be countable. This set can be uncountable. You can run all these things. So there is an uncountability here. So, there is an uncountability here. I said it for S-countable. You can write it for uncountable sets. The only thing you have to take care of is that in the instructions, for every S depends, a little S depends only on a countable subset of the states, of the set of states. But the set of states can be large. So, there is some uncountability here that can be injected. Accountability here that can be injected and maybe exploited. Thank you very much, Sustain. Thanks. Thank you. So now we have the question, another question and answer session with Brazil.