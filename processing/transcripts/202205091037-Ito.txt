  Like this, and so there are 15 tiles and one empty spot, and hence the number of possible border states is a factor of 16. Sorry, slide is not okay. So, the number of possible Possible border state is a factor of 16, which is approximately 10 to the 13th power. So we have a lot of zeros here. And so among such a large number of possible ball states, we need to find a procedure to identify from the initial ball state, the target ball states. So this is a typical example of competent reconfiguration. And another example of component reconfiguration appears. Of component reconciliation appears in 24 hours and seven days service systems, such as the power distribution system and the mobile network systems. So, for example, consider a power distribution system. So, a power distribution network have many feasible configurations so as to deliver accuracy even when some trouble happens. So, if we find a so if we so there are many uh feasible There are many feasible configurations. So, if we find a better network configuration, we want to change the current configuration. So, my point is not good today, but if we find a better network configuration, we want to change the current configuration to the optimal. So, however, due to the electricity conditions, we cannot change directly, but need to change the switch configuration one by one. Of course, Of course, we cannot cause any bracket even during the transformation, and all the X3C condition must be satisfied. So there is a benchmark data I will explain later, but so there is a benchmark data for the standard model of Japanese power distribution networks. And it is known that this benchmark data had 10 to the 53. 50 cent power of feasible network configurations. So we have lots, lots of them here. So among such a huge number of possible network configurations, we need to find a switching procedure from the current configuration to the optimal. So in both situations, we wish to find a procedure for transfer. Find a procedure for transformation over the state space. So, combined deconfiguration is an algorithmic study on procedures for transformations. So, this is a puzzle and this is a part distribution network, but both of them we want to find a procedure for transformation. So, algorithmic study for such a situation is a commutary configuration. So, more theoretically, computer reconfiguration. Computer reconfiguration asks the reachability or connectivity of the state space. A typical search problem asks the existence of at least one feasible solution in the state space, while the reconfiguration problem asks the legibility between feasible solutions. So, for example, consider the most fundamental reconfiguration problem. Sorry, not reconfiguration, but for example, consider the most Condition, but for example, consider the most fundamental problem: satisfiability. So, in the standard SAT problem, so we are asked to check if there exists at least one feasible solution, namely satisfying truth assignment of a given SAT formula from two to three n candidate of solutions for any variables. So, in this example, so if we are given this formula and there exists. And there exists a satisfying use assignment 001. So we answer the yes for this such problem. On the other hand, in a reconfiguration program for SACT, we first introduce adjacency relation on the defined on the feature solutions. So we have several, we may have several ways to choose, so how to choose adjacency relation, but so here, But so here, for example, as the adjacent simulation for SAT, we may choose having distance one that is a field of a single variable, single variable assignment. And there are actually several variants of the computation problems, but here, suppose that we are given two satisfying truth assignments, this and this. This and this. And we are asked to ask the existence of C case of addressing features solutions among two to the n candidate of solutions. So, but please note that although we have initial alternate solutions as input, like this, but we do not know the feasibility of the other two to the n minus two candidate. Candidate. So, in this example, is a yes instance. So, we don't know, actually, we didn't know that this is a feasible, sorry, satisfying this assignment or not. But here we have a path. And as another example, consider graph curving. In the typical such problem, we are given a graph and integer k and asked to check there is the atomist. To check there is at least one proper coloring for the graph using the k-curves. So, on the other hand, in the reconfiguration program for graph coloring, we first induce the adhesion simulation on graph coloring. So, there are several ways I'll explain later. But for example, here regarding a single vertex at a time, then we are asked to ask the existence of a sequence of adjacent proper. Of a sequence of adjacent proper curring between two given ones. So, like this. So, this space can be seen as a graph called a solution graph. Maybe there are several ways to call it, but so in this talk, I call the solution graph. And the non-set of the solution graph is a set of all feasible solutions, for example, a satisfaction use assignment or a proper trial. Use assignment or proper triing of a graph. And the edge set of the solution graph is defined by introducing adjacent simulation on feedback solution, such as having distance one or regarding one bar text at a time, and so on. The adjacent simulation may be defined by so application or if there's no clear Uh, or if there's no clear application, then we may choose the most elementary change to the solution. But anyway, so there's no clear state rule for the choice of adjacent situation. So let me talk more about the adjacent simulation. So, for example, more than one adjacent regulation have been studied for independent sector modification program. So, maybe many of you know. Maybe many of you know also. But so because an independent set of a graph is a vertical subset such that no two vertices are adjacent. And in this talk, and I think in this workshop, we can assume that a token is placed on each vertex in the independent set. And we take all feasible solutions of, sorry, all as a feasible solution. Sorry, all as a feasible solution, we take all independent set of sites exactly k and take the adhesive relation as a move a single token. Moving a single token at a time. So then this is a yes instance like this. So we first move this token to the upper side and obtain another set here, but consisting of three part tokens. Tokens and then move this token to the left and obtain another inventory here. And finally, we move this token to here, then obtain the target one. So this problem is called the token jumping, because we can move a token to any vertex as long as it results in an independent set. So here, there's no edge between these two vertices. Edge between these two parts is, but we can move this token to this vatex directly. On the other hand, token sliding takes another addressing deviation such that we have to slide a single token to its neighbor along an edge. So this sequence is not a Z one for token sliding because the last step we jump the token here. Here. And actually, this is a no instance for token selective. So for this one and this for this initial and the target independent set, so there's no reconfiguration she cast between them if we take the token sliding group. So in this layer, the reachability depends really on the choice of the address registers. And digitally depends on the choice of the addition simulations and that is the structure of the solution space. And as an observation, the solution graph for token sliding forms the spanning subgraph of the solution graph for token jumping. As another example, I'd like to introduce a curling recognition program, which is Reconciliation problem, which is another one of the most well-studied reconciliation problems. So recall that K-curling of a graph is to curl all parts of the graph so that any two adjacent parts receive different currents by using at most k-currents. So we take all proper k-curlings as a set of features solutions. A curling as a set of feature solutions and choose regarding a single vertex as a solution. Then, this is a yes instance like this. So, we first regard this vertex from blue to red. And then regard this vertex from green to blue, and finally regard this button from yellow to green. So, not that so we cannot. Note that so we cannot regard this but X from yellow to green directly because we have green here. So we first, so we have to follow this order. So of course there is no instance like this when k equals 2. If we have only two curves and this is a k too quick and then so we cannot change any curve. But this is a yes instance and the can be changed. Instance under the can be changed duration. Although I with details so can change, but there are some talks in this workshop in this way. So the legibility depends on the choice of the adjacent situation. So in order to define a reconfiguration problem, so we first define a solution graph to be considered, namely the set of features solutions and Set of feasible solutions and adjacency relations. And once we define a solution graph, we can ask natural digitality or connectability questions. So the most well-studied variant of reconfiguration is the digitality question. So that is, we are given two nodes in the solution graph and ask the existence of a path in the solution graph joining the two maxes. Two nodes, sorry. And as a generalization of the reachability question, shortest question is computes the shortest length of a path in the solution graph. Namely, we want to compute the minimum number of recomputation steps required for transformation between two given nodes. And we may also ask the connectedness of the solution graph itself. So, connectivity question. Connected question asks the asks whether the solution graph consists of a single connected component or not. And diameter question computes the diameter of the solution graph that is maximum shortest length of path between any two nodes in the solution graph. So, note that the configuration is basically a decision problem. So, we simply output yes one node or simply output an integer for shortest variant. And so, actual reconfiguration sequence is not required. So, this is because in the examples, such that even shortest deconfiguration sequence requires superponymal length. Bipolymer length. So it would be impossible to output actual sequence in polynomial time. So of course the solution graph itself can be an exponential size with respect to the imp size as a previous example. But the difficult point is that so we evaluate the running time of hardware. The running time of the algorithm with respect to the input size. So, this means that we need to output the answer without constructing a solution graph explicitly. And my original motivation to study reconfiguration was algorithmic analysis of power distribution systems. So, at that time, there are few known algorithmic research that can Algorithmic research that can be seen as reconfiguration. So there are many things long time from a long time ago. There are many things researched as a they are didn't use a deconfiguration, but quite related question and research was done. But so from the for the algorithmic research, I think so like a set of reconfiguration, game and puzzle and kernel reconfiguration was there. In ISAC 2008, we propose a framework for algorithmic study of reproduction. And after the 15 years, as far as I know, more than I think recently, nowadays we have 150 papers were published from all over the world. And so I think this topic. And so I think this topic has grown to become a new trend in graph theory, I believe. And so in 2015, as I said in the introduction session, we started the international workshop on computer reconfiguration. We are very happy to have such many papers nowadays. And so again, we are very happy to welcome you. That's a great number of parts. Has a great number of participants to this fourth workshop. So, from now on, let me explain some technical part on the configuration, but not so much details. So, similar puzzles, many recognition problems are not to be pieceless complete. So, first, I briefly explain the P-space completeness. Just a brief explanation. The complexity class P-space is a set of decision problems that can be solved in performance space. So, we only care space and don't care the running time. Note that the class B space includes class NB property and not yeah, yeah. and and not uh yeah any included class np and uh and hence we can if we and if we can solve a psp problem in polynomial time then we can solve all np computer problem in polynomial time too therefore uh from the viewpoint of algorithmic designer if we can show that a reconfiguration problem is piece that is complete then it implies Then it implies that there is non-polynomial time algorithm for the problem under the assumption of p equal not to np. And in addition, we can say that there exists a yes instance whose shortest length sequence requires super polynomial length under the assumption of NP not equal piece test. So this is because if a short test decomposition she test is also Shortest decomposition sheet is always polynomial length for a piece-based compute problem. Then we can use it as a weakness for NP. And it is known that many decomposition problems belong to the class P space. So how about the basis hardness? So as you know, there is a well-known flow of LP hardness injection. So this flow. So, this flow is not for reconfiguration, but for typical such problems. Then, for many MP computer search problems, if we consider about the reconfiguration variant of such problem, we can show that the deconfigurations are piecepace hard by following almost the same deductions. The most important result is Is uh Goparan et al. showed that three sat reconfiguration is P-space complete. And so we can use three-sat reconfiguration as a source problem for deduction. But however, we have to note that these deductions preserve whether we have to note that whether these deductions preserve the digitality of the solution class. Let me show. Let me show you one example. Okay, so for example, constant can be hard on S reduction from three sat to the in n set. So this is a not in contribution value, just a such problem. And there are, I think there are several ways to making a reduction, but so consider this one. So we first make a click for each. Make a click for each close. So, for this close, we prepare this click, for this close, we prepare this click, and so on. And we join the vertices correspond to the opposite to vital to preserve the consistency of variables. So, we join, so this vertex corresponds to here x and this negation of y corresponds to this vertex. Of y corresponds to this vertex. And here we have an opposite literature here, x-bar. So we join these two parties. Then, because we are solving the intensity, so we cannot take these two basses at the same time. So, of course, this reduction is correct for NP hardness, which asks only the existence of a feature solution. Of a feasible solution. But we need to be careful when we talk the connectivity or reachability of the solution space. So consider the G2 independence, which are adjacent in the solution space. So because we just write this token from here to here, then we can obtain this independent set. So GO2 independent set are adjacent in the solution graph. Are adjacent in the solution graph. And then, so this independent set above corresponds to the actually two satisfying truth assignment, 001, 000, and 001, because variable Z is don't care button, don't care variable. On the other hand, consider this independent set. Then this independent set below also corresponds to set below also correspond to two satisfying truth assignment 101 and 001. So because in this example, in this case, x is don't care variable. So they have the, each of them has two satisfying truth assignment and 000 and 101 not adjacent in the solution graph for SAT, although these two independent sets are adjacent. G2 independent sets are adjacent. So we need to be careful such a correspondence. But so consider another well-known NP hardness reduction from 3SAT to indens it. Again, this is not reconfiguration variant, just for the NAPIC hardness deduction for such program. In this direction, we prepare a variable gadget for Gadget for each variable. So this H corresponds to variable X, this corresponds to variable Y, and so on. And we press one token here, here, and here. So this clearly indicates, so the variable X is true or false, variable Y is true or false. So every independent set corresponds to exactly one satisfying truth assignment. And so this. And so this reduction preserves the reachability of solution graph. Although I own the detail, but so this reduction also has some flexibility of the tokens. So for example, we can slide this token to here and so on. So actually, so this reduction preserves the leadability of the solution space. So in this way, also we need to be careful be careful about the reachability, we can show that many recognition problems are P-space complete. And let me introduce another important P-space complete recognition problem for computational hardness. So let me fast back to the 15 puzzle. For the 15 puzzle, the digital equation is easy to solve. So we can So we can, this means that we can determine whether a given initial configuration is reachable to the target one without constructing an actual transformation. So to do this, we arrange the integers according to the configurations. So 11, 2, 4, 5. So and also in the same order, 1, 2, 3, 4, 5 here. And we and then And then we draw an arrow between the corresponding integers like this. So here we want to go here, from here to here, and two want to go from here to here, and so on. And then we count the number of crossing, crossing right here, here. So we count the number of crossing of the arrows. And if it is an even number, then the initial contribution. The initial configuration can be reached to the target one, but if it is odd number, then it is not reachable. So this, I think this 15 puzzle instance is a very famous one, where only 15 and 14 is appear in different order. So here, 15 and 14, and here 14 and 15. And as you And as you notice, there is no desired transformation because this configuration has only one crossing, namely an odd number. So for more generalized writing work puzzle, Martin Gardner proposed an open question if there is such an easy calculation of visibility. So this kind of siding puzzle can be seen as a generalized one. Can be seen as a generalized one from the 15 puzzles. And Marcia said, these puzzles are very much want in much in want of a salary. And so today and no one knows how to determine if a given state is obtainable from another given state. And if it is obtainable, no one knows how to find a minimum chain of remote for archiving. Removed for archiving that Z state. It was said in 1964, but this is exactly the content reconfiguration. And about 40 years later, this question was solved in some sense negatively. Han Demein proved that many sliding rock puzzles are piecepress complete. So to prove the piecephalace completeness, they introduced They introduced a recognition program of graph orientations, which they call non-deterministic, non-deterministic consonant logic. So we are given an undirected graph such that each edge has weight one, what, two. Sorry, I already put arrows, but originally we are given. Originally, we are given an undirected graph, and each of H has a weight one or two. And then, an orientation of the graph is feasible if the sum of incoming arc weight at every vertex is at least two. So, for example, here for this vertex, we have two incoming arc and the weight one plus one equal two. And here for this vertex, we have an incoming arc here and here. We have an incoming up here and here, and the sum of the weight is 2 plus 2 equals 4, and so on. And every vertex has at least two, every vertex has incoming accurate of at least two. So this is a feature configuration, orientation. And the address simulation, we can reverse a single edge direction. A single edge direction and also I omit details. So, this is a very powerful tool for PSpace hardness deductions. And several puzzles and games are shown to be piecepace complete using this initial program. So, the point is, so we basically prepare the two or joining the gadget, so three to a three gadget. And so, this is a kind of AND bottle X. kind of and vertex and behaves kind of and behave and behavior and this vertex behaves as or so this means that so if one of them uh direct it as inward then so we can direct it out towards uh the other two anyway so uh what i want to say that i saw here is uh not a detail but uh we want i want to say this Detail, but we want to say this one. So, in particular, by analyzing the NCL problem deeply, the following problems have been shown to show remain pieces complete even for bounded maximum degree and bandwidth and chronograph. So, the problem includes visual equation for independent set, but exclaimer, dominating set, feedback set, and so on. And so, because to leave with and pass with a graph can be bounded by from above bound with so this means that surprisingly, these problems are difficult to solve even when bounding these graph parameters, with graph with parameters. So, but the constants are big for many problems. So, for some of them, so there are very sharp analysis has been. Very sharp analysis has been done, but many problems the constant are very big. So they may be solvable in polymer time for small constant weeks. And then so I try to explain the intuition, just sorry, just intuition, but so why recognition problems are So, why reproduction problems are difficult even when binding graphs with these parameters? So, it is probably a natural idea to try the DP method, dynamic program method for the conflict of problems. So, we are also graph-building parameters usually works. And however, so far, only a few positive results are known based on DP method. So, actually, so I like the programme. And so, my PhD this is almost all algorithms based on PP. So, I like this method, but so far, only a few positive results are known, I think. And so, because that the design concept of DP algorithm is to store information required to solve the problem only, and they shares the information so as to bind the DP table. So, like to bind the DB table within polymer sites. So, for example, if we wish to solve the K-coloring such problem for trees by dynamic programming, so of course it's stupid. So, a tree can be colored with only two colors, of course. But for now, let me try to. So, you have a key colour, and can we color this? We colour this tree by using Kcons. And so I try to solve that problem by a direct programming approach. Then, so it suffices to store only K types of coloring of the subtree, which uses a minimum number of colours under the assumption that the root of the subtree is colored with a prescribed color. With a prescribed color. So, for example, so if we color green for this subtree at the root of this subtree and compute the mean number to color the list of the subtree. If we color this vertex by blue, then so what is the mean number and so on? So, but so if we want to solve the So if we want to solve the reconfiguration problem, so it is important how to store the information about reachability within polynomial size. So consider the, so this is one example. So now I consider about the list card modification so that I can display all the solution graph. So for just four vertices, for Each vertex has a list of colors. So we can color this vertex only by blue or yellow. And we can color this vertex only by blue, yellow, white, and so on. Then actually for this subtree, we have only eight coloring. And this is actually the whole solution. Actually, it's a whole solution graph for the subtitle. And like the previous example for the such program, we focus on the curve assigned to this vertex double. So this vertex is only the vertex which is connected to the outside sub. And so we focus on the color only on this vertex and forget about the other vertices. Then, so G4 coloring assigns blue to W and G four coloring assign yellow to W. And also these four coloring assign blue to the vertex, to the W, but they belong to two different components in the solution graph. So this means that we cannot identify So this means that we cannot identify these four currents from the viewpoint of reconfiguration. We need to store such a religious information within a point size. That's right. And so we need to store such individual information with some point size. So this is a difficult point to construct an efficient algorithm for recognition programs. But so for not tree, but for caterpillar, indeed we can show that the size of the EV table can be bound by a permanent size for caterpillars, not general tree, but caterpillar, and which is a graph of passive one. And DB method was first applied to the, I think the first example was the shortest password configuration on. Shortest possible configuration on unweighted graph. So just as here, shortest means that just a minimum number of edges between two boxes. And yeah, this was given by Paul Bonsman. And he also gave a Polymer time algorithm for K carling reconfiguration for K master connected chordal graphs. K must do connected codal graphs. This algorithm is also based on the direct programming approach. And also, so let me remark that the dichotomy itself is known for graph curling recognition with respect to the number of colours where field resolutions are proper about scrolling using k colours. And here, not camp, but we think about regarding a single part X. Regarding a single vertex at that time as an adjacent relation. So if we take this adjacent situation, so regarding a single partex, then the reachability question is baseless concrete even when the number of currents is at least four, while it can be solved in point time for any graph when k is at most. When K is at most three. So it is interesting to note that. So the original such problem is NP hard, just finding one current. It's just NP hard for even for K cross V. But we can solve the reconfiguration problem in premium time for even for the case K cos V. And this dichotomy results can be generalized. that can be generalized to sacular clarity and I then talk about the shortest reconfiguration so recall that the shortest variant asks the length of the shortest reconfiguration sheets so this solution space for SAT illustrates the difficult point for the shortest variant Point for the shortest variant. That is, so this is the initial truth assignment, and this is the target truth assignment. And then, so even though the variable z assigned zero in both initial target, we need to flip z once for keeping the PGB. So here, both initial target, we are It we assign the variable g as zero. But we first whip this variable to one and change the assignment of x and y and then back the assignment of g from one to zero. So it is required. So because of the other things is in feasible, so this is the only path from here. The only path from here from insert to target. So we need to fill the variable z once for keeping the feasibility. And sorry, and actually, so almost all PS in algorithm for shortest variant touch only the symmetric difference, and hence there is no such unhappy mood. But these like five, seven years, Seven years, there are some examples such that algorithms are developed for shortest variant and capturing the unhappy nukes. So I call this kind of field unhappy. And shortest reconfiguration by Amar Edran and token siding for some graph processes by, I think why is a Yamader and And UH. Top selling is an investment population. And I would like to introduce another example. So because the Hichin puzzle, the Hichin puzzle is solvable in permanent time, as I said before. But interestingly, it is NP-hard to compute the shortest length of a desired transformation. Of course, when we talk about the NLP hardness, then we generate this board to the N by NBA. And we have another example of the same behavior for perfect matching reconfiguration by alternating cycles. So where we take the solution as Physical solution: We take the perfect matchings in a graph as a feasible solution, and as a one step, we can extend the edges along an edge of the alternating cycle. So, for example, we take this alternating cycle and flip the edges along this cycle. Then we have these edges in the matching, and so this is another perfect matching. And we take so another alternative sign here and flip the Alternative cycle here and Philips cycle. So we can change several edges at a time. So if we take the symmetrical difference of two given perfect matchings, then it consists of alternative cycles because they are perfect matching. So we can observe that. So if we take a symmetrical difference, then Take a symmetric difference, then it must consist of the alternating cycles. So the reachability question is always yes. So we can solve the problem in point. In addition, we just take the symmetric difference for the symmetric difference. There always exists transformation of polymer lengths. On the other hand, we prove that the choice deconfiguration is NP-HAD for bipartite graph or parano graph. So reachability is always yes, but if we want to minimize the number of steps for transformation, then it is NP-hard program in general. So it's the same behavior as a 15-puzzle. And as our another result, so we appointment time. So, we get point solvable case for outer paragraph. So, this is the outer paragraph. So, we can solve the whole subject case. And I think so, our solution graph for perfect matching is interesting and important because it is equivalent to the perfect matching polytope. And hence, so the configuration is equivalent. So, the configuration is equivalent to the computer shortest pass program. So, more precisely, in the perfect matching polytop, each node in the polytop, and not solution-specific, but a polytop, correspond to a perfect matching in the graph. So, for example, for this graph, we have three perfect matching like this. And then the point of is a convex hole of this node. Of this node. And Kubatar proved in 1975 that two nodes in the polytope form an edge if and only the symmetric difference, the corresponding path matching is single cycle. So this is exactly our solution graph for perfect matching. And therefore, the convenience shortest path problem for perfect matching. For perfect matching, polytop is equivalent to our source decomposition program. And maybe I don't have enough time, so I'll skip this slide. But so, but I want to say that as a background in Polyphedic Communics, so there's a famous Famous open question, not for perfect matching point of but in general case. And uh, sorry, I cannot pronounce again, but a heavy conjecture it was disproved by Santos, but remains so another variant is still open. And uh, I we saw our motivation for this, uh, considering the factor matching reconfiguration by alternating cycle is uh so. Alternate cycle is so late to this conjecture. Yeah. Sorry, I skip the G part. And yes, and so okay, so and as a last of technical part, so let me explain some applications of reconfiguration. So computer reconfiguration is So, computer reconfiguration is useful, I believe, to understand the state space, understanding the reachability and the connectivity of the solutions. It may give you a feedback to the original such program. So, for example, this is a theorem, not for the configuration, and saying that if a graph contains no cycle of lengths divisible by three, then the graph is three coupled. graph is recoverable. So this theorem is probed by in 1994. And 20 years later, Martin Brofner gives another simple proof of this self using the idea of reconfiguration. So his proof uses only like eight lines. Of course, he uses some words. Use some words from reconfiguration. So if we write down the whole proof, then much longer. But so originally, essentially, it takes only eight lines. It's very simple and interesting proof. And so the proof appears in this paper, although his name is not appeared. So I hear that Machin Brofna wanted to not be listed. It to not be listed, but so here, so his name is appeared in the proof. And another example is from our paper in SODA this year. So in 1960, Nashua Williams proved that a graph is 2KH connected if and only if G has a KH connected orientation. So this theorem was known for K call for K-call for the case K-call one 1939. So very old proof. And we gave our new proof for this cell based on the configuration. Sorry, I skip the detail. And finally, so I will explain the application to the power distribution system, which was my original motivation to start the reconfiguration study. As I said before, power distribution networks have many, many feature configurations so as to deliver accuracy even when some trouble happens. Then, so because we have several choices, distribution loss depends on the choice of the network configurations. And so there are, we can think about two issues. Two issues. One is how to find the optimal configuration. And another one is how to reconfigure the current configuration to the optimal one. And indeed, we showed that it is NPH to find the optimal configuration that minimizes the distribution loss. So issue one is already a difficult problem. So we proposed an algorithm which solved this. An algorithm which sort of dissolves both issues one, two, at the same time. Of course, it is not a polymer time algorithm but runs efficiently for several benchmark data. So, this work done with Akiasiki through attending this rupture too. So, for example, so this is a benchmark data as a standard model of Japanese performance. Of Japanese distribution. Sorry, this is not just a filio. But we actually have a data, standard model of Japanese power distribution network. And that network has 72 sub-stations, power stations, and around 1,000 sections. It's like a house. Like a house or a factory or something like that. And we have 468 switch gears. So we can control these switch gears, these switch gears. And so we can make a switch, this switch on or off, and then so power can cross this edge and so on. And so for this venture, as I said, so we have this huge number. This huge number of configurations. And our algorithm runs efficiently and finds the optimal network configuration together with the searching procedure for transformation in a few seconds. So like it not, we didn't use a supercomputer, just like a user standard disk computer. And even if it takes 205 steps for Five steps for transformation, but it computes like about five seconds. And so we estimate the energy efficient improvement for one year in Japan very roughly. So it's just a rough estimation, but it reduces CO2 emissions by about 6,800 tons, which costs. 100 tons, which corresponds to roughly the amount abused by this number of trees. So, the configuration works also for environment. And let me conclude my talk with sub-advertisement. So, as some of my colleagues said, so I'm now leading a three-year project in Japan. And here, I So we worked about 20 young researchers in Japan work together for reconfiguration. And here we work not only for theory, but also for practice. So tomorrow, Jung Kawhara here will give an invited talk about the solubar for commuter reconfiguration. And we have developed some solubas for commuter reconfiguration. For configuration, and we also open the whole competition. But so we have already developed some solvers for computation and plan to publish solver in Python in the coming months. So we hope it will be helpful also for theoretical study, such as finding a small counter-example and so on. Example and so on. And so, if you are interested, please check our project website. But please note that the solver has not been published yet. So, not now, but later, a few months later. And as Yoshi said in the introduction set, as a part of a project, we will organize one day workshop in ICARP 2022 and it will be held on July. Will be held on July 4th in Paris with an option to participate online. And here is, we are now calling for a complete talk. And any work already not yet published welcome. And we correct only one page abstract. So and that one is Wednesday anyway on us. So you have time. And that's all if you have. And that's all. If you had good results during the workshop, please write down one page and submit. Please. Okay, so that's all. Thank you for your kind attention. Thank you very much, Tejiro. We can all unmute and clap. Is there any question for Takiro either from the room or online? Maybe I can start just to make people feel less awkward about asking the first question. Oh, sorry, Ameria, we're going to ask one. Go ahead. Yes. So first, thanks, Takehiro, but I wanted to ask more about this the actual example of power saving. Like, is this published work? Is this something that has been done on the side? Can we know more about it? Yeah, so. Yeah, so this is a work with a company in Japan. And so we have a Japanese document, and that was published in the area of electricity. But not for theoretical computer science. We only have such a document and we also publish. And we also publish a press release in English, but it's kind of just an introductive announcement. So as a conclusion, answer your question is, we have no such a document. Okay. Understandable. Any other questions? Any other question for Tequijiro? Preferably a less difficult one. So Kimbi, let me ask just a quick general question. So what would you say are the big open questions in reconfiguration? You mentioned the polynomial polynomial version of his signature. I expect you count this as one of them. You count this as one of them. Can you mention a few others which you think are the most important or one of the most important? Yeah! Yeah, I don't know, but so recently, so because I'm working with so s several colleagues, so j so for me, so So, for me, so how can we apply the deconfiguration to the several areas? So, as I said, because so from a long time ago, there of course has some research related to the configuration, but so we want to see such a research. Uh, such a research from the viewpoint of algorithmic theory, yeah, so decomputation. So, uh, sorry, sorry, uh, it's not an answer to your question, but uh, so I'm recently interested in such things, and uh, yeah, of course, uh, several people in algorithms too. Yeah, but uh, so sorry, it it's not quite an answer, but it is quite an answer. Yeah thanks. Any other questions for Takehiru? Any other questions for Takehiro? Even difficult ones? No. Maybe just a quick one? Sure, I think. Sorry, let me back to my. You talk quickly about the solvers that you are currently implementing. And could you give us back the link to the web project website? And is there already some documentation about? Is there already some documentation about the server, or is it still kind of similar? No, no, this is just for the project website. And so if you go there, so you can find my nice looking pictures. Okay. Thank you. So I will just wait a few months. Thank you. Yeah, but so once we publish the solver, then so I post an announcement to the mailing list. To the mailing list, uh, owner by Naomi. So, uh, maybe we can uh share the link to the uh NAOMI's mailing list on Discord or something like that. Yeah, later. Okay, thanks. Yeah, thank you. Thanks. Any last chance, question? Afterwards, you might not see Takiru ever again. That's a lie, but anyway, I'm just trying to get people to ask questions. Okay, then let's thank Takehiro again for the very nice talk and nice questions. Thank you, Tonka. I thought you enjoyed our whole workshop. So, now the on-site participants will move on to have a really nice lunch while we will have our lunches and dinners and try not to be too sad. I think we're having another. And I think we're having another talk in a bit less than three hours, so like starting again at 2:20 Banff time. So that's in slightly less than three hours. Maybe so on site participants, there's some tour or something better. Yeah, anyway, so yeah. So thank you. So we meet again 2:20 uh bunch time, right? Yes, yes, okay, yes, yes, yes. Sorry, I said confusing things, so sorry, yeah. Yes, okay, cool. And you will come to hang out in the Discord or whatever, like just interact as you feel like. Have fun.