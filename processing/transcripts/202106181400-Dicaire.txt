Together and adding the FMCS bit at the end of the week. So, my name is Neo Tika. I'm doing my PhD at the University of Edinburgh. And today, I'm talking about localizing monads via subunits. This is joint work with Carmen Consenton, who's a postdoc at the university, and Chris Hornin, who's my supervisor. And this is actually very much work in progress. And so please do jump in. Please do jump in or have some comments at the end if you think of some ways that this connects to other things, or if you have any way that this can be made into useful examples, because we're still working on that bit. So what is my talk about? Well, my title says it's about localizing monads via subunits. So during this talk, I will explain, well, I will talk a little bit about monads, but I will mostly explain what subunits are and how they can be used. Are and how they can be used to provide a notion of localizations on monad. And the first thing you're going to ask is: why? Why should you care? Why is this interesting? Has something to do? Well, monads are used a lot in different contexts and category theory and in programming languages, mostly to model things like computational effects. So, for example, if you are storing some data on like a memory store and you want to Memory store, and you want to access that, that is what monad allows you to do. And the subunits are something, a new notion in monodal category as a sub-object of the tensor unit. And they allow you to consider an intuitive way of considering how to divide a bigger system into smaller subsystem. And so it makes sense when you have this notion to say, okay, well, if I have kind of a monad and I'm modeling some control. And I'm modeling some computational effect on some large amount of memory, for example, can I kind of zoom in into a smaller section and see what kind of model of effects I have there without considering the rest of the system? So hopefully that gives you kind of an idea of why this could be interesting to look at. Now, in terms of the how I will do this, when we tried to do this, we came around two different ways of approaching this. Ways of approaching this problem. So the first way was using a strength, which I will explain later. And the second way is using the formal theory of monad, which I will also talk about a bit later. And so I will end my talk by not quite showing, but at least discussing when these two approaches that I will explain are actually equivalent. So this is the goal of my talk. Okay, so I'll jump into some background. I'll jump into some background. So, obviously, I need to explain to you what is this notion of subunit. Okay, so a subunit, I need to first explain to you what a sub-object is. So, a sub-object, and that is something of an object A in a monodal category C. And throughout this talk, I will be talking about C as a monodal category with the tensor and a unit. And so, what is a sub-object? It's simply an equivalence class of monomorphisms. Okay, so let's have this monomorphism here. Let's call it S. It goes from an object F to an object A. And I need to find an equivalence class with that. So let's have another object, another monomorphism R from R to A. And we will say that R is smaller than S if there exists a map 5. If there exists a map from R to F such that this diagram commutes. Great. And then we will say that R is equivalent to S if and only if we have that both R is smaller than S and S is smaller than R. So this is what it means to be a sub-object, is this equivalence class of monomorphism where the equivalence is defined this way. So what does it mean to be a subunit? Well, a subunit is simply a sub-object of the tensor unit, which means you simply Of the tensor unit, which means you simply replace your A by the tensor unit. Except that we will add one more condition, which is simply that this map here, and this is just for things to work out better later, but it is that this map here will actually be an isomorphism. So if you tensor your subunit S with the identity on the object S, it gives you an isomorphism. So if I try to draw this, To draw this graphically, you can draw the subunit S like this. And so this is the map, and we say this will be an isomorphism. And what this implies is that you will actually have that, well, this map has an inverse. And so if you draw your tensor unit here, you'll get this that you can essentially copy your S. And what this means is actually that S is a co-monode. Okay. Oh, and throughout the talk, if you see an S, I'm talking. Talk, if you see an S, I'm talking about quite a few times. So let's cover some examples first. If I'm looking at the category of step with the Cartesian product and the singleton as the unit, then in this case, the subunits are actually kind of in a bit of an extreme case, but just the empty set or the unit itself. Another kind of extreme but more interesting case is if we have a meat simulation. is if we have a meat semi-lives and we see that as a category, then in this case, the subunits are actually all the elements, all the elements of the lives. In terms of a slightly more interesting example, maybe a family of example, for any Cartesian category, subunits are actually the sub-terminal objects. If we look at an example of what this could be, consider sheaves. So sheaves So, sheaves are these types of things. So, they're pre-sheaves, and we're going to add a few more conditions that I actually don't need to talk about for now. But if we consider sheaves, so they're actually, if we have x locale, but think of it as a topological space, and we're looking at the openness over that, and this is this functor. If we're taking this as the category of sheaf, and we make it in a pretty much straightforward way, monodal category. Monodal category, then in that context, the subterminal objects can be described this way as kind of these characteristic pre-sheaves. And what these things do is they actually describe a different way of having describing the opens of X. And so the subterminal object in this case are actually simply the opens and so the subunits in this. The subunits in this monodal category of sheaves. Okay, one last example. If we look at R as being a commutative unit of ring, and we look at the category of R modules, and we make that monoidal, then in this context, the subunits will be the adempotent ideals. Great. Hopefully that some of these examples at least met something into. At least meant something to you. In terms of monads, I'm assuming that people are familiar with monad. What they are is simply this triple of endo functor with a multiplication and a unit, and these are natural transformations. And this is on a category C. And you can think of them as a way of embedding something into kind of more context. So from a computer science point of view, you can think of if your union is kind of a way of embedding your objects, say, in a computation. Objects, say, in a computation, or if you have the multiplication, then you can think of it as: okay, well, if you have like a computation of a computation, then that gives you a way of kind of coming up with only a computation at the end. And there are a lot of examples of monads in context. For example, the list monad, the continuation monad, the power set monad, the right monad, the sit monad, the reader monad. I cannot go through all of this, but just to give a little bit of motivation into where I'm going with this. To where I'm going with this, let's have a look at the writer monad on set. Okay, so this writer monad, if you take an object A, it will assign to it the product of M, where M is a monoid, and A. And then you'll say, okay, so it's a monad, so you have to tell me what the unit and the multiplication are. Yes, it actually is kind of. Yes, it actually just kind of follows straightforwardly from the multiplication and the unit inside the monoid. So that's not really where I want to focus. And because there's something interesting that we can do with this, and that is when we look at the Kleisley category and we have Kleisley map. And what we will end up with is actually a map where if we have an output, an input, A, and then not only will that map output Will that map output result be? But it will also give you a monod, which you could interpret as kind of a log file of maybe all the different actions that you needed to take in order to get that output B. And this is where it kind of gets interesting in terms of motivation, because I did say this talk is about kind of this. Is about kind of this notion of localization. So, say we have all these friends here, and they're all working together on kind of some input A to get an output B, and they're all writing into this log file the actions that they're doing in order to do that. It would be good if we had a way of kind of saying, okay, I just want to isolate the contribution of this first person inside all the different actions that are being taken. Different actions that are being taken. And I'd like to describe that with a monad that is kind of localized onto only this person. In order to do that, as I said, there were two approaches that we considered. So I'll talk about this first approach. And this was using the notion of a strength. So first, I need to describe a bit of a setting in which I will be able to do that. And this will be by restricting my monodal category to another category. Category to another category essentially on the subunit S that'll call the category Cs. What is the category CS? Well, for the object of CS, it will simply be the same object as the objects of C. Great. However, for the morphisms, we will say that a morphism from A to B, F, is CF, actually defined as a map from Defined as a map from A tensor, the subunit, to B in the category C. In terms of composition, what is that? Well, in order to be able to compose these two maps, which are actually maps from A tensor S and B tensor S, I need to start with an A and an S and essentially copy my S, which is something that I'm able to do. As I said before, I had this. As I said before, I had this S being a commonoid, so I had this inverse map, and this is this inverse map, which is exactly what I'm using here. This actually corresponds to the Cochleisley composition for the comonad this, and I will come back a little bit to this at the end. And then the identity is simply tensoring with the subunit S. So, this is this category CS. Now, I'm going to find something. I'm going to say a monad is localizable. Is localizable, so able to be localized if we have this partial strength that goes as follows. So, a strength, generally speaking, is something that if you have your monad here and you tensor it with something on the outside, it's a map that allows you to put that back inside. So, if you have like a computation, you kind of have the computation of now this entire thing. And this has to set us a bunch of things. And this has to say a bunch of things, obviously. And why am I saying partial is because I'm only asking this to be defined for the subunit S here, not for any other object. Okay, so having defined this and having defined this context, this setting here of the category, how, if I have such a localizable monad, how can I define a notion of small or local monad? Well, Or local monad? Well, it's as follows. It will be defined on this category Cs. And I will say that the object of this small monad for the subunit S, well, the objects are the same. So that doesn't change. However, in terms of morphisms, in order to define this, this is actually something in Cs, which means it's defined from the object T of A tensor S, and it has to go to T. S and it has to go to T of B. So I'm using the strength in order to be able to apply F, which is also map from A to S, and I can apply T of F here. And then by tensoring with the subunit, I can also define the unit and the multiplication of my monads. So this is my first notion of my first approach to define opal monads. And essentially, what it gives you is if you have kind of a big lice of subunits. Kind of a big lice of subunits, it gives you a way of kind of zooming in on all the different levels defined, all the different categories CS and having a monad defined on all these different levels. So let's look at what my second approach is. So the second approach uses the formal theory of monad, which was actually discussed by Rowan earlier today. So I'm glad that happened. But briefly, the formal theory of theory is the theory of the But briefly, the formal theory of monad is essentially redoing the theory of monads, so Allenberg more closely, categories, algebras, all that, for an arbitrary two category. And this is also what I'm going to talk about in a second is also somewhat related to the formal theory for grid monad, published somewhat recently, but I don't have time to go into too much details of that. Let's have a look at what this approach is. So if we choose our two categories, So if we choose our two category to actually be its functor category from I sub op, which I'm defining to be the lattice of subunit as a two category, and this as the category of small categories. And so in order to define a kind of a formal theory of monad with this category C, I need to define a monad in this kind of Define a monad in this kind of two-categorical context. So, what does this look like? Well, I start by choosing a functor on which this will be defined. I say functor, but I actually mean a zero cell in this two category. But this happens to be a functor. So it's a functor from IOP2CAT that assigns to each subunit this category, C restricted to S. And then on this, I have a, well, a natural transformation, which is actually a one-cell indices. Which is actually a one-cell in this two-category from C to C, and this is the equivalent of my monad in this larger setting. But what this corresponds to as a natural transformation is actually a family of filters from Cs to Cs for every S. Similarly, by defining this monad in this context, I'm defining these maps, these Finding these maps, these two cells corresponding to the multiplication and the unit, and these correspond also to natural transformation for every S corresponding to the multiplication and the unit. Great. So this is very similar to what I had a minute ago about kind of these different levels of TSs and monads for every subunit. For every subunit. So, obviously, this brings the question of how are these things connected? And essentially, my conclusion is that they're equivalent and we can have a way of going from one to the other. So, if we start with the formal theory of monad on this specific two-category here, we can, by defining a strength, obtain a localizable monad with this. Again, this was. monad with this again this was a notion defined with this partial string and then by using how I can define these small monads I can get back here and this will be equivalent so just a few extra details I will discuss a little bit briefly how this strength is actually defined and give you some of this context that this all this theory lives in so I want to define a strength to say that I'm actually looking at the Say that I'm actually looking at the largest subnets I have, which is the unit itself, the tensor unit itself, and I want to define this monad I'm calling Ti as a localizable monad. So I need to define this strength here. In order to do that, I will look at kind of the context where all of this lives. And actually, I started with this category C, and this category C. And this category, Cs, actually constructed such that it is the co-Kleisley category of this co-monad here that corresponds to the tensoring with the subunit S. What this means is I have this pair of adjoint functors here. And how are they defined? Well, G goes from C to C. There's nothing on object. And on maps, it actually And on maps, it actually is simply the precomposition with the subunit S. F is the one that actually provides a tensor ring with the object, the subunit. And the morphism are simply mapped to a pre-composition with the action of copying your S, and then you can simply use the F that you have. Okay, so in this context, your strength, you can context your strength you replace this expression of the strength using uh one minute thank you using the adjoint functors um and then you can use the fact that well actually these objects are not quite exactly the same um but you have these isomorphism between them i'm calling phi um and you can use the inside um ts you can use the unit of the adjunction Use the unit of the adjunction, and then you can use the co-unit in order to essentially start with T tensor S, get an T of S in here by changing this to an X, and then changing things back to T1, and then removing this S. So that's the essence of how you hear. So that's how I define this trip. But what I would get like you to remember from What I would get like you to remember from this talk is the following, that we provided a way of localizing monads and very importantly, using this notion of subunits, that we had two ways of doing this, and that they are actually equivalent. So I will leave it at that. If you'd like to know more about it, I recommend reading Tensor Topology. And if you want to know more about how this connects to formal theory for graded monad, this is the paper to read. Um, this is the paper to read about that, and that's it. All right, thank you, Niok.