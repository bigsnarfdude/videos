Thank you. Shall we thank the organizers at the beginning? I've not been here before, but it's fantastic. Yeah, okay, so the conference is called Fundamental Limitations to Quantum Computing. And I didn't, I interpreted that as meaning like things that mean quantum computing is impossible, and I didn't really know. And I didn't really know what to make of that. And it like Scott Ironcy gives you $100,000 if you come up with one pipeline. So I don't know if we're trying to game that. But then I was talking to Yi Hui last night and she said to me, no, no, fundamentals, just like, you know, the stuff that's always there, like noise and things. I said, oh, okay. That makes more sense. So I could talk about noise. So I'm I'm gonna talk from from from what I interpreted the title of the the the conference, I I didn't want to say fundamental limitations, but Didn't want to say fundamental limitations, but I maybe I'm going to talk. I have some ideas of what I'm going to talk about, but I'm doing it on the board so people can steer me a little bit if they want me to talk about something else. But maybe what I should call this would be more like challenges in, and I would even say the theory of the QEC. And I'm gonna, so yeah, it's a tutorial, so I want to say a bit about some new things as well as some basic things. I kind of want the things I'm gonna tutorial on to maybe point to some loose threads that could be problems. So I don't Could be problems. So I'm talking outside the open problem session. But yeah, I hope in the end to make point to one. Okay, so I think my idea is I'm speaking for two hours and I am gonna I think for the first hour my idea is I kind of want to talk about quantum error correction but more as a process. But more as a process. And by that, I mean I kind of want to talk about how alt-tolerant quantum computing really works in the space-time picture. So I want to talk about how, not just quantum error correcting codes, but I want to talk about how circuits implement codes and how we should really be thinking about error correcting processes when we run these circuits. So, a big part of that. Um so a big part of that is going to be space-time and the circuit model. And I might say a little bit about floquet codes. Uh the reason I want to put these together is because well I feel these floquet codes, they're these big thing, and they're an excellent discovery to help us with like practical implementations. With practical implementations of building quantum error correction. But I feel rather than thinking of this big new discovery, I feel it should be kind of integrated in maybe older conventions in quantum error correction. So I'd like to try and put all those things next to each other. And yeah, so what I want to get to at the end of this first hour is I want to sort of draw this space-time picture and show that it's like familiar in lots of different places in quantum error fraction. And it's sort of what I'm Quantum error correction. And I sort of want to propose, like, for an open problem at this point, sort of what I want to propose is something more like a, I don't know, like a stabilizer formalism for the space-time picture. And now I'm not saying that thing doesn't exist. I think it kind of is in the literature in various places, in various different languages. Like, for example, in measurement-based quantum computing, it appears. I've seen papers where they describe error correction in terms of tensor networks where it appears. I'm not saying this is a big open problem that has to be solved. Saying this is a big open problem that has to be solved. I'm saying it's like the pieces and the loose threads are there. But the problem, the challenge in the theory of here is kind of making this unifying theory in a way that is accessible and easy to use and what, say, the stabilizer formalism is easy to use. Here we have this nice language to describe quantum error correcting codes that lets us describe them in a very even-handed way. It's very, very precise. It's a very easy tool to work. Very precise, it's a very easy tool to work with in the sense that it's just a bunch of commuting polymatrices. So we can do calculations with them very easily, run simulations with them very easily. And it would be nice if there were. Yeah, so the goal of this tutorial is I'm going to talk about error correction, running error correction with circuits, so error correction processes, a little buck for pay codes. And I hope by putting all these things together, or showing the Or showing them all together, that kind of you'll understand what I mean: that there is like a familiar picture that everybody's working with, like just looking at slightly different languages. Okay, so I suppose the place to start would be just with the stabilizer formalism. I don't want to talk about that, but that's a good place to start. So, but if we want to talk about quantum error correcting codes, we tend to start by talking about the stabilizer formalism. So yeah, with error correction is a quantum error correcting code is just a subspace on a larger physical Hilbert space. And we specify, we encode quantum information in special subspaces of this Hilbert space in such a way that it's difficult for Uh in such a way that it's difficult for the environment to manipulate this uh this encoded space. Um so uh the way we describe this subspace is well okay so we have codes made out of n qubits typically and they encode k logical qubits and we have some code distance d and this code distance it's some number for that tells us how That tells us how much does the environment need to work on this physical Hilbert space in order to start manipulating the logical subspace. Okay, so the stabilizer formism is as follows. It's an abelian group, an abelian subgroup of the Pally group. And it stabilizes S-vidin there. There. And so I'm interested in, maybe I should say that's over n qubits, because that's how many qubits I'm working with in my code. And okay, another important thing is the stabilizer group doesn't include minus one. That's not allowed. And that's kind of obvious from what the stabilizer formalism is. So we're specifically interested in this subspace, psi. That's the common plus one eigenstate. That's the common plus one eigenspace of all the elements of the group. So stabilizes for all, that is, for all that stabilizes living in the stable. Right, so this is how we talk about code. Yeah, so this is specifying a subspace. So this is specifying a subspace. There's the common plus one eigen space of all of these operators. And this subspace is where we put our logical keywords. Okay. What's more to say about that? Okay, so this is a nice mathematical, that's it, that's how we describe these subspaces where we encode information. But it's also very practical to talk about error correction this way because these Pali operators that we're writing now. Paleoop rats that we're writing down, they're also permission measurements that we can make on the system. So, this is kind of going towards the error correction process. So, not only do we have just a list of operators or a group of operators that specify the code space, but we have a bunch of operators that can actually check to see if errors have occurred. So Full it. I'm making a very useful space. Okay, so as I say, we put states in this encoded space. There's some logical qubits in there. But we might be worried about some errors having occurred. So this E, I'm going to assume, is a Pali operator. And there's a good reason. There's a good reason for that. That's because, okay, so as I said, I'll get back to why I did that in just a minute. But as I say, so the code is specified as the plus one eigenspace of a bunch of Paleo operators. So if it turns out that something happens to the code that kicks us out of this plus one eigenspace, then we know an error is okay. So that's why these stabilizers are useful for detecting what's gone wrong. So if I measure this stabilizer, psi, and it turns out that I get the minus one measurement outcome. This is a signature that Solero has okay. So and this will come about because S. Come about because S doesn't commute with events who commute because they're pally, so they either commute or they don't. Right, so this also tells me why, this is why I'm just defining the eigenvalue-widgets pally errors. That's because, yeah, so if I want to check for any possible error, I would measure at least a I would measure at least a generating set of the stabilizer group to work out where I am in this Hilbert space. And I would recover a whole bunch of plus or minus ones. And this is going to be some signature of whatever has occurred. We call that the syndrome, this list of stabilizing measurements. This tells us what may have occurred. And yeah, we have to use that to try and interpret. We have to use that to try and interpret what this error is, or at least we have to, yeah, more specifically, we're supposed to work out what to do to the code to recover the encoded state, which we don't quite have to work out what E is exactly. In fact, that's not maybe possible. Okay, but yeah, so why am I assuming this E is a Pally? Well, when we've measured all of these stabilizers, we project on. We project onto some eigenstate. And it turns out that measuring all of the stabilizers projects you onto a Pally operator that's acted on the code space. So in general, if I project onto some syndrome of this code, maybe experience some noise. Kind of like this. Then the output of this would be something more like, yeah, so it's going to be some Paliara acting on some state. And let me say psi dash. And these are palearas of the emissions itself. Now I've put side dash. Now, I've put side dash here because there is room for there to be some rotation in the code space when we make this projection. But an assumption we tend to make in quantum error correction is that this rotation to the code space is going to be quite small, assuming a local noise model and a code with high distance. So if the noise model only acts locally on physical pieces of the system and this code distance D is large, and I'll talk more about that. Lash, and I'll talk more about that later. Then a local noise model shouldn't have too much access to the code space, and so we tend to assume that the psi-dash is very close to psi. But yeah, essentially we've projected onto the original code state with a Pali error acting on it. What happens if you don't measure all the generators of the stabilizer group? Just like measure one of them? Well uh I mean you then yeah I I I suppose you're still stuck in some more general noise state, but you you can't really conceive, I don't know how you would stop doing, solving the error correction problem without having done that. So I'm just going to assume that I do have the ability to measure all of the stabilizers and that's what I'm going to do. So I've either measured them all or I haven't measured any. Would you treat blocking codes later? Sorry? Sorry? Will you treat 4K codes later? I plan to, yeah. Sorry, pi is a syndrome measurement partner, right? Yeah, that's a projector onto some syndrome space. So like some configuration of plus or minus ones that be stabilizing. Can you arrange this? Could you reiterate why it's substrate to find you? Oh, well I put this sigma here just to kind of, yeah, that's a sigma. And I put that there to Put that there to indicate that there's some configuration of plus or minus ones. Yeah, that's the error channel acting on some code state. So that could be a more general noise. But I'm going to assume that I'm going to project onto, by the measuring the stabilizers will project by general noise model, which I suppose I'm assuming is local, onto the PALIA acting onto codes. On for code stuff. But yeah, there have been some numerical results as well that kind of verify that once the code gets sufficiently large, that this is a pretty good assumption to make. So the syndrome is just like if you measure the stabilizers, all the plus and minus ones that you get. Yeah, yeah, the syndrome is just exactly a big list of. Yeah, that's right. So you should ask. Maybe it's a question, but so um So, how essential is this assumption that you actually project onto this? You have like faulty measurements, and maybe I have a real fault model where something that I want to measure and just doesn't do anything. So, how essentially CCT4? Well, oh, you can there are fixes for this, but yeah. Sorry, you're saying that maybe a state. Sorry, you're saying that maybe a stabilizer doesn't work or something. Yeah, maybe it doesn't project or to any hit, the forward version, I mean that's a good question. That's something I've been kind of curious to know the answer to. But yeah, this is for the sake of the tutorial. I mean, my impression is things should still work. But I think there's an interesting project trying to prove that. Okay. So maybe, yeah, okay, so I'll use the tarot code as an example because that's a good, it's a quantum error correcting code that everybody knows, or if you don't know, I need to. So I'll introduce the So, I'll introduce that later to you. Okay. So, this is the Toriko model. It has qubits on the edges of, it could be any kind of tessellation of a manifold, really, but here I have it on a square lattice. There's a qubit on every single edge. And as I said, you need a stabilizer group. So, the stabilizer group here is. So the stabilizer group here is generated by what we call star operators and the k operators, what we p. And okay, so a star operator is associated to vertices of this lattice V, where you pick a vertex and the Pali stabilizer associated to this is Pali X on all the edges that. Pali X on all the edges that touch vertex V. So it's called a star because you can see it's got sort of rays coming out of this vertex. Okay, and then we have plaquette operators, so a plaquette or a face, this is the base of the lattice, and we take the product of z on all of the Z on all of the qubits that touch the boundary of the face. So you can see that these stabilizers commute. Well, the two I've drawn here, they don't share any common support, so they must commute. But you can see if I take a vertex and a very close together, then they have two common qubits, and xx commutes with zz. So these lasers commute. Okay, we also have, so I didn't mention when I was introduced. So, I didn't mention when I was introducing the stabilizer formalism, but we also have logical operators. So, logical operators are operators that commute with the stabilizer group. So, that's the centralizer, but they're not themselves members of the stabilizer group. So, we have this particular surface code here encodes one logical key bit. I have more colours I can just. I have more colours, I can just give you more colours. So, one of those is Pali Z, the product of Pali Z terms on all the edges from the left boundary to the right boundary. And this will anti-commute with all the x, product of x's on all of the edges. All of the edges through a line of the dual lattice. So this guy is X bar. We put bars on logical pally operators like that. So I would call this Z bar. And you can see that logical pally X can commute to logical Pally Z because they have one qubit in common. And it's just quite easy to check that these logical operators commute with all of the stabilizers, which is what we need. What we need. So here we have one qubit. Okay. So then so how do we error break this code? Well, if you remember, I'm going to assume a pally error. So for now, I'll just assume E is just a Pally X on some qubit. And so I'm interested in the state. And so I'm interested in the state psi with this error that's occurred. And this can be the qubit where the error happens. Well, if a PALI X occurs here, again, the syndrome is really just the commutation relations of my stabilizer group with the error that's occurred. And you can see that a pali exon. And you can see that a pali exon this qubit here will anticommute with a plaquette here and here. Because this is a Z, Z, Z, Z stabilizer, and so too is this one. So these, you know, we have, there are all kinds of words for this. We say these are detection events, or sometimes I would just say that they've lit up, like indicating that some arrow has emitted. So sometimes if I'm drawing pictures, Sometimes, if I'm drawing pictures, so Victor told me not to be too archy about it. And this is the part where I start doing that. So, there's an interpretation of this error that it's really just a string. So, if I were to choose, hang on, so this is where that's about to happen, and he doesn't like it. But I like it, he doesn't like it. Okay, so we say these two stabilizers have lit up like this. And the goal is to correct the error. And the goal is to correct the error. So, what we do is, assuming that errors are quite uncommon and there's probably a very low weight error, we would look at where these defects are and we would try and correct in between these two defects to break the error. Okay, so more generally, these errors actually behave like strings. So, for example, if my error was, I don't know, I added an error on qubit two. Arrow on qubit 2 and then qubit 3 or something. And then we put them close by, like here and here. Well, now this plaquette still anti-commutes with the error I made, because it shares one qubit here, but now this one, this commutes again, because it shares two X errors with this plaque. And likewise here, but this one is now violated. So that stabilizer is lit up. So this is. So, this is what I mean by a string. So, you can kind of see this as being a sequence of x errors. And the job of correcting this error is pairing these. So, errors look like strings. And the dilated stabilizers, they live at the endpoints of these strings. So, the trick to error correction, so when I, so I'm going to, yeah, this is the ID picture, what I'm trying to. This is the item picture, what I'm trying to. So the goal of error correction is to. So this is now my error. These guys are violated. And if I want to correct this, then I have to take these endpoints and pair them back up again. I need to find, the goal is to find some kind of a correction C such that C of E lives. C of E lives in the stabilizer group. Because if C and E lives in the stabilizer group, then it's writing the things I say. Then C and E, acting on my code word, just give me my code word back. That's just the definition of the stabilizer form that I gave at the beginning. Right. So one thing I could do is I could find, sorry, somebody asked me this. Wait, did you ask me this question? Somebody asked me this question. Asked me this question? Somebody asked me this question about correcting. Maybe I imagine that. Okay, okay. So one thing I could do is I could make that if my correction was exactly equal to e, this would work because these are how the operators and e squared is just identity. But it doesn't happen. You're never actually going to figure out what the error is. There are lots of different ways I could have made this syndrome pattern with different Made the syndrome pattern with different errors. So it would have been good enough if my correction were to say here, here, and here. So I make another string that connects those two defects in another way. And well, you can see that this is a stabilizer because if I take the product of all the star operators living on the interior of this region, well then. Well, then I get the error plus the correction is the product of all of these star operators. There's one star operator here, which makes an x. There's a star operator here that makes them x squared, so there's nothing on the interior. So you can see that the product of all the stars on the interior of this loop are equal to the error plus the correction itself. And that's in the stabilizer group because I can generate these loops with a product of two stars, and that's good enough. So back in. So back in this picture, like that, and because I can colour in the interior of my error plus the correction, I'm good. Error correction starts going wrong when errors start getting bigger. So maybe what could happen instead is, say, a string runs like this. It's a bit too long. And then what I might, a correction I might choose instead would be to. Correction I might choose instead would be to try and pair these defects to the boundaries, which would also be an allowed correction. Now, this is not a good correction. I've made a non-trivial string this way. It's non-trivial in the sense that I can't color in the interior of the correction plus the error. So this would lead to a logical error. That would be bad. Yeah. Yeah, you can also see it's a logical error because if I were to take my Pali X logical operator, so maybe which maybe looks like a string of x's on all of these qubits, you can see that my logical power x will anticommute with this correction because it crosses over with the correction. Okay, so I haven't gotten anywhere near to the things I wanted to start talking about yet. Right, so I'm gonna, now's a good time if there are any more questions, because now what I'm about to start talking about is what happens when I actually want to measure these operators in a circuit and uh and other efforts. And then other errors, you have to consider other errors like what happens if your measurement apparatus experiences errors as well. And you need to find a way of dealing with that. So am I good just to move on? I've not lost anybody. Or everybody who wants to be lost is do where they are. Again, we should also mention that people are online are also welcome to ask questions. I'm monitoring the chats and I'm happy to get the questions. Yeah, okay, that's a good idea. Thanks. Good idea. Thanks. Nothing, nothing. Okay, there are a few people. Sure. Okay, so yeah, so we have to measure all these stabilizers. So I'm just going to concentrate on one paquette for now. And let me label the qubits around this paquette: 1, 2, 3, and 4. And yeah, so we have to measure this weight forecheck in a non-definite. This weight for tech in a non-destructive way. And there is a lot of theory around different ways of doing that using things like flag qubits, but I'm just going to show you the easiest way, which is where you would add an extra qubit. People who make this on a device, they tend to imagine this extra qubit lives in the middle of the plaquette. I would call it M for measurement qubit. This is one, two, three. This is one, two, three, four. And the goal is to measure a, and this one's qubit M. The goal here is to measure this four qubit z parity check. So the way I can do that is I initialize this qubit zero, and then I do control NOT gates like this, at one, that one, that one, that one. And then finally, I measured this guy. And then the output. I measure this guy. And then the output of this measurement will tell me the value of this ZZZZ stabilizer. Right, so this, yeah, some kind of stabilizer. This is a stabilizer, yes, I guess. I don't know what I'm talking about. Okay, but this introduces a new problem. Like, we have a way of Introduces a new problem. We have a way of realizing these codes in the lab with just standard C naughts and compared qubits and Pali eigenstates. That's nice. But it's possible that this is now possible that this measurement qubit experiences an error. Or maybe the measurement device that clicks when it's not supposed to, or misses a click, or anything you like, where maybe just a pally error occurs on this extra qubit that I've just added to the system. Just added to the system. And well, so there are all kinds of fancy solutions to this, like single shot error correction that maybe I end up getting to or saying a little bit about, but that's not always available. And at least a way of dealing with these measurement errors that works generically is to build in this space-time picture. So let me draw some. These are my four qubits at the These are my four qubits of the Placaga. And here is my extra qubit that I prepare in zero. And then I read out the end. But these are the CNOT gates that I've drawn. Does that picture make sense? Here, here I've prepared, these are my qubits. These are the same qubits over that. One, two, three, and four. I prepare my I prepare my extra m qubit in zero. I entangle it to the four qubits of the plaquette, as I said, and then I read it out. And there's a chance that some measurement error occurred. Some physical error occurred on this qubit here. And for now, let me just assume it happened close to the measurement of x. And what will happen in that case is we get the wrong outcome. The stabilizer was supposed to show up. There's no error, but an error up here. Show up there's no error, but an error appeared. And that's a little bit difficult to deal with in the stabilizer code, just the way I've described it, where we just, you know, some error occurs in the static picture, we measure all the stabilizers, what I've been assuming so far is perfectly, and then we try and look at what error has occurred. No, we could get the wrong syndrome, that's a problem. So, what we do instead, the obvious thing to do is we repeat the measurement. So, we reset this measurement keyboard. We reset this measurement qubit in zero again. We tangle it to its neighbors. And then we read it off again. Now, if this measurement gave me the right outcome, I would probably expect this one to agree or not to agree. I kind of wish I'd have drawn this a little bit bigger. Okay, so I'm going. A little bit bigger. Okay, so I'm going to get artistic again. So these are my qubits, okay, and all of this stuff here, like that, I'm just going to draw that. Okay, so that means I made a plaquette measurement on those four qubits. Those are qubits one, two, three, and four again. And then I just measured them. And in practice, if I want to check, if I want to be really sure about If I want to check, if I want to be really sure about measurement errors occurring or not occurring, well then I just repeat this a lot of times. And, okay. Right, so now how do I deal with the measurement error? Well, let's say that this guy, this one, experienced the measurement error. I'm not really that interested anymore in the absolute value of the baquettes. What I do is I define well I define what's getting referred to quite often these days as a detector, which is where you don't look at the absolute value of a single measurement, you tend to compare one value to the other value, like here and here. And you look at the parity of those two measurements, the same measurement repeated twice over time. Now I do the same again here and here. So say none of my qubits experienced an error. I just got one measurement error on the measurement qubit. Sorry, when I say that, I mean the code qubits or the data qubits. The code qubits or the data qubits. None of those experience an error. Let's assume that that's all right. Just one measurement error occurred on one of my measurement qubits during that measurement circuit. Well, what that will mean is this stabilizer, the absolute value of the stabilizer should probably be plus one. This one should be minus one, and this one should be plus one again. So if I compare the parity of these two guys, then this one will give me minus one, and this one will give me minus one. But you know what? One, but at earlier and later times, all of these will give me an even parity again. So here I have even parity, here I have an even parity, and so on and so on. Right, so now I can kind of redefine what I mean by a stable uh violated stabilizer or a lit-up stabilizer. I would now maybe call this a detector, which is a detection is the comparison of two adjacent stabilizers in this case. Adjacent stabilizers in this case. So I would say that this guy is violated, and this guy is violated. So when time is running upwards, so what this measurement error has done is it's kind of made a string traveling in the time direction rather than the spatial direction. Okay. Let me also just compare that to let me also show you what could happen. That's exactly what I'm about to do. Okay, so let me so the picture I'm now going to draw the picture I want to show is this one, where I have two placettes and exactly as you say, a physical error occurs right here. So they're now So there are now too many to count seven qubits. One, two, three, four, five, six, seven. And this one's going to be qubit number four, where the middle one where the error occurs. And I want to kind of get into this artistic picture again, where so this is a blue stabilizer, just like this one. Just like this one, where I draw, that's that blue stabilizer measurement. And then I have my that's this stabilizer. So this circle is just a picture to represent some extra qubit entangling to its neighbors and then reading it out. But the outcome is yeah, the the value of that stabilizer. So I do that a few times over sp in in my space-time picture. In my space-time picture, like this. So then, say the error occurs right here on their shared qubit. Well, now what should happen, assuming no measurement errors occur, is that, well, these stabilizers give me plus one. This one will give me plus one, because no errors occurred. Time is traveling up the page still. Running up the page still, of the board. But now, as soon as this error has occurred, the values of these two stabilizers should flip. So now they change to minus what most of them do. And because I don't do anything to fix this error immediately, then it's still going to be there when I measure the stabilizer again on the next repetition. So these guys give me minus one as well. Okay, so now I have to look at where. So now I have to look at where, again, I'm interested not in the absolute values of the stabilizers, I'm interested in the detectors. So here is a detector, and I got plus one and plus one, so this pair is plus one. Maybe I should, it's the same is true over here. If I would have drawn this blue one at a slightly earlier time, this will give me a plus one. But you can see, as soon as the error flips the state of these stabilizers, I get an alt parity. I get an odd parity at that time. So now I have a minus one here. Likewise, here, that's a minus one. But now, later on, I don't see any more violations because I have minus one and minus one repeated. So their product gives me plus one again. And the same is true here. So the violated detectors are the comparison between this this check and this check. So I kind of draw an endpoint here. So I kind of draw an endpoint here. And likewise, there's one here. Draw that. And you can kind of regard it as a string. Like that. You could also have errors across the 80 qubits. Yeah, that can happen too. That can happen too. So in general, you want me to add a measurement error now? Somewhere? Error now, somewhere? No, I guess I trust you that it all looks like it. No, we can do it, we can do it. It's a tutorial. So, yeah, in general, though, these things compound. So, if there were a, we can add a measurement error here as well, say, and what you see is a string that goes in the space direction and in the time direction. So now, okay, there was a measurement error here. So, this one actually gave me a plus one. One, which says that plus one and plus one, this isn't violated anymore. This detector is fine because it sees an even parity of errors. It sees that physical error on this data qubit, and it sees a measurement error when I made this measurement. But now this is violated instead, right? Because now the absolute value of that pliquet was plus one. The absolute value of the measurement of that pliquette was minus one, so I got an up. Applicate was minus one, so I got an odd parity when I compare those two. So you can see now that the union of a measurement error and a physical error, it's probably a string that goes this through here, and that doesn't show up. Turn this into a stabilizer code with a title like these images. Yeah, yeah, I'm going to talk about that. That was the thing. That's what I said I wanted to kind of bring up. Yeah, no, this is these. Yeah, no, these things are really very, very similar. And would that code have a single shot arrow correctly? You could recognize it and said. Yeah, if you built a, if you built this whole cluster state in 3D. Yeah. Yeah, yeah, that's right. But let me kind of get to that later on, and I don't want to distract too much. Okay, but the yeah, the what am I saying here? The punchline for now is that there's For now, is that there's we have this other space-time model, so let me let me try and draw a bigger picture. This is how am I for time, by the way. 17 minutes. 17? Yeah, because we started we started a bit I started a bit late? I mean, you did start late, we started late. We started late, but yeah. But we're expecting more of us. Expecting more or less. Yeah. Yeah. There is a big planet. Okay. I think I can. Yeah. I mean, I think also people would mind to remove the property if we want an extra 10 minutes. But if I say they have to stay here, they have to stay here. Okay. Right, so the picture here, so I, yeah, the stabilizer code picture I gave you was really, you know, we had this 2D code, and I assumed pally errors and perfect measurements. And the job of error correcting was to look at these strings, and then to my correction was. My correction was supposed to join them up in a trivial way, such that they formed by trivial loops. And by a trivial loop, I mean I could contract them continuously to a point. Rather than a logical failure, which would be bad, which is when my error gets too big, and I maybe prefer to try and pair it to the border. This is non-trivial because I can't contract it to a sidecar. When I learned about this, When I learned about this in the in my PhD, it's like uh um icing on a donut. Like uh if if you can it's trivial if you can ice it. But yeah, if I had to try and draw this as a boundary, I can't color it in not on the taurus anyway. Forget about that. Okay, because uh the the this the space-time picture that I gave you, it's very much like this this 2D picture I gave you, but now it's it's just a little budget, right? But now it's just a little larger, right? So I kind of the picture you can kind of try to imagine is yeah, so I have the Tauric code is these are in these pictures I've been drawing here I've been focusing on just two placettes or one placette, two placettes side by side. And I've I told you what happens if one arrow shows up, say the arrow shows up here. Say the error shows up here. I see a little two strings like this. Time is traveling up forward again. Or if a measurement error shows up, this has an error, then I see a string like this. And in general, like the compounding of physical and measurement errors are strings that run in the time direction, which are measurement errors, and spatial direction, which are physical errors. Direction, which are physical errors, and still the goal is to try and close them up in some trivial way, such that I can take the error and the correction and I can contract them onto a point. That implies that the action of the error and the correction altogether is trivial. Uh-huh. Is there a different notion of codistance? That I hope I can get onto in the yes. But it doesn't make a whole lot of sense. But it doesn't make a whole lot of sense when we're just talking about memories. So this is kind of a, I would also say, a bit of a loose thread. So it's level now, so then you talk about this one. Yeah, like this, it makes a big difference. Measurement errors can cause a big problem when you start talking about logic gates. Like when you do logic gates, you start making extra check measurements where you really need to know the values. You might need to repeat that a lot of times. Times and it that some measurement a lot of times in order to do a gate correctly. And if some measurement fails for some large number of times, then if there's no gate, you can have like an arbitrarily long string time correction. Yeah, yeah, that's possible. If you're just running a memory, it doesn't it's it's quite yeah, it's difficult to explain why that should ever be a problem. But uh if I get onto gates in the next halo, then um yeah, that would be good. Oh, yeah, that was pretty good. Okay, so there's a space-time feature. Now, yeah, so I think are measurement errors only errors where you get the wrong outcome, or can it be that an error happens in between your four C lotots? Yeah, so that's another thing. I don't want to talk too much about it, but it is a good point, and people do talk about this. What happens is you end up with things called hook errors. So let me redraw that. So let me redraw that circuit I drew. So this is one stabilizer check. I think, Palo, that was a good question. So these are my entangling gates on a feather sensilla. So it could be the case that a bit flip error shows up there. And as well as causing a measurement error, this CNOC gate will also propagate it to here and to here. And this is kind of And this is kind of interesting too. So now you can see that one, the occurrence of one physical error on one of my qubits has now caused two of my data qubits to experience errors because of the way I run these circuits. So this is what we would call a hook error. And there's quite a lot of research involved in making sure these are as benign as possible. Now, in the case of the surface code, people have thought quite a lot about how to make sure, they're very precise about. They're very precise about what order you should entangle your CNOTs, your measurement qubit, to the data qubits in order for this to occur. Because what people tend to prefer to happen is they would maybe like their errors to spread maybe like this. Like I said, we don't want these long strings like this, but if there's a two-body error and you can kind of steer it around a corner with an appropriate choice of circuit, then like Circuit, then that can mitigate the effect of this. So, typically, this order is for the case of the service code, the order is chosen such that these hook errors steer around corners in not such a harmful way. For more general codes, this can compromise how many errors you can really tolerate when you come to deal with this. There's a lot of work in, I'm not really an expert on these things, but things like flag qubits, people, what a flag quit. like flag qubits. People, what a flag qubit is, is you make a check on your check. So I could check for this flag error occurring by making, this is my flag qubit, and I entangle this to here, and then I read it out. So this one tells me what errors have occurred on my data qubits, and then this qubit tells me if an error has occurred in a bad place, such that the hook error is spread. And there is a big theory around this that is more technical than I know how to explain beyond this. But yeah, dealing with that's an important question. So the option is that with these circuits, I mean you can just like from one error just like a higher weight error. But I mean it's still like one error that fits into the more. Yeah, yeah, yeah, yeah. So weight is maybe large. So that's kind of like the expression but yeah, so but I mean it's kind of a problem. So like we uh when we design error correcting codes, like we know uh so the the the code distance is that's how many errors I have to flip such that or how many how many errors have to occur such that my code fails. So you can kind of tell because just because of these types of events that it's not quite as straightforward anymore as just counting how many qubits have to get flipped to cause an error. An error. But we know that if we have a code with distance d, if we have code distance d, then we should be able to tolerate d divided by two errors due to the decoding path. Right, and if you assume some noise model, like a circuit noise model, where every gate you run, or every time your physical qubit idles, then Time your physical qubit idles, then some error credits would probably be p, then you sort of hope to get the full value for money out of all of your qubits, then you hope your logic lab rate is going to fall up like p divided by 2. But now if these hook errors introduce a higher weight error than 1, and you've not done anything to account for that, either with maybe decoding software or with a smart choice of circuit, well then this D on two could go down and your logical error isn't going to be as good as the Clarity isn't going to be as good as it should be. Okay, so if I okay, so I still got about what, six or seven minutes? Yeah, that should be five now. Okay. So then let me speak to what David asked about too, because I want to add to this FaceTime picture, which ends up kind of looking the same. And so I thought I was going to get to Floque Code. So, I thought I was going to get to floquet codes in this hour, so maybe the stuff I was going to talk about in the next hour is now just going to be floquet codes. That's okay. I'm going slower than I thought, I think. Okay, but let me just tell you a little bit about this measurement-based model. That's enough space. So, there um So, measurement-based quantum computing, if you know about it, that's good. If you don't know about it, it kind of gives you a way of mapping the time of a circuit model into some physical qubits. So in the circuit model, I would draw a qubit running like this. In the measurement-based picture, I would draw a graph. I would draw a graph. So, in the measurement-based picture, we talk in terms of graph states where physical qubits are compared in plus. So, all of these vertices represent qubits compared to the plus state. And if I draw an edge connecting two qubits, then that means I applied a CZ operator between them. So, this thing is really a circuit where all of these, so that qubit is this wire, like this, like this, like this. This, like this, like this, like this, and I do CZ between them, and that gives me this diagram, which is the graph state. Now I can use this graph state to teleport information along, so it's measurement-based in the sense that I now measure these units in the Pali X basis. And you can think of this as just being like a big fancy teleportation of. Of where whatever state I put over here is going to get teleported along the chain to the end of the chain, and I have to use these measurement outcomes to do the appropriate poly correction at the other end. Okay, so these pictures have really been these have been variable studies. And we have so So, some people just call this the Rassendorf model. But the original paper was by Rassendorf, Bradley, and Harrington, where they build this three-dimensional plus-state built around, so I haven't drawn any qubits yet, I'm assuming, again, it can be any kind of cellulation of a 3D manifold. And you put a qubit on. And you put a qubit on the face of every you put one qubit on every face of this cellulation, and you put one qubit on every every edge of this cellulation. Like this. Now, and then for every edge on the boundary of a face, we entangle it with a CZ8 using this one. Let me use another colour. Using this one. Let me use another color the way because that cube is just there for to help visualize what I'm drawing. So we kind of have a model like this. And we have a big piece of this. So what happened in this probably Rasenbill-Patterson paper is they built this big 3D cluster state in this volume. And then And then what you do is you measure all of these qubits in X. So, okay, hang on. So, this model has a stable group. Let me start by saying what the stabilizer group is. So, the stabilizer group for a cluster state is for every vertex, you have an x, and on its neighbors, on all the neighboring, all the qubits, neighbors of this vertex, you have a z. So for example, I have this stabilizer here that looks like x, z, z, z, z. And this is a stabilizer. So this is, let me call it C for cluster stabilizer. Okay, and so what's nice about this is living inside my stabilizer group, I have you can generate other stabilizers. You can generate other stabilizers from your stabilizer generators. So, if I were to take the product of all of these blue vertex stabilizers, I get this term that looks like x times x times x on the front of my cube and x on the back as well. So what happens is, rather than teleporting one qubit from here to here, roughly what RBH said and and in their paper, this is for around two thousand five, I'm away. 2005, I'm away, is instead of teleporting one qubit, I can effectively teleport a whole surface code from here to here. And you do that again just by measuring all of these qubits in the PALI X basis. Now, right, so because when I made this plus estate, I prepared all my qubits in the way I did. I had these guys with a plus one. So now, uh-huh. Any questions? I mean, that's maybe a really stupid question, but I mean, it's utterly plausible, but is it obvious that you must go to three dimensions to make such an embedding? Or whether there's a kind of two-dimensional local embedding of a fortune cluster states that would... I mean, you can prepare it over time. So I don't need the whole part of the philosophy of these things when they're invented as well, right? Things when they're invented as well, right? That even though I'm going to teleport this long distance, I only need to maintain two or three qubits at a time. Yeah, so one way I can make it two-dimensional is just by having a small slice of yeah, but let me just talk about it in three deep because I want the measurement picture to look a bit like the space-time picture. Okay, so I made this cubic stabilizer model with pali x's on all the bases. But this looks just the same. So now let's say one of these errors occurred. Now, let's say one of these errors occurred, or one of these errors, one of those errors showed up on one of the faces of this code. Well, now two of my stabilizers are violating it. So, let's say it was on the top of the cube. Well, now, in my measurement-based picture, this one was violated with a, it'll be a Z error because these are X stabilizers. So, this cell got violated, and this cell got violated. This cell got violated. And so I make a string again that's running through the faces of this model, and defects were created in the, let me call them detection cells again on the two cells, the stabilizers, that I prepared in this plus state. And likewise, you know, if there are an error, say, on this space, these strings just compound again. So now this wouldn't detect anything, because this cell saw two errors. Paris and yeah, my strings just run through the faces of this model. You might be wondering, I've just looked at the blue qubits, but the green qubits can be treated equally because the green qubits live on the dual ice of the blue qubits, so there's an equivalent argument I can make for both cases. But if you were to ask me, this is what I'm trying to get across, like these space-time pictures. These space-time pictures. Here in this measurement-based picture, I have this 3D picture of measurement-based quantum computation where there is a very clear way in which you can interpret one of those three dimensions as a temporal direction. And in the circuit picture, I have a two-dimensional code, but measuring the circuit over a long time gives me this time-like direction as well. And these things all end up being, well, at least from a theory perspective, they end up looking very similar. They have been looking very similar. And yeah, if I talk about ploquet codes in the next part, let me think and the break what I want to go on about. But what ends up happening is error correction in all these models ends up looking very similar just up to some choices of geometry and maybe how the code is implemented. But yeah, as I say, lots of people are talking about these things in lots of different ways. Lots of different ways. You get this exact same graph out in kind of people, people who tried making tensor network versions of these kinds of codes as well. I don't know much about ZX calculus, but they make the same diagrams of it meaning the same thing. And Andy Bauer had a paper recently on these types of things. Yeah, Flamier and Dave Bacon, and some of his, some of their colleagues. Some of his some yeah, some of their colleagues they wrote these space-time codes, and they also have a similar flavor to this. And it's not that the pictures aren't there in the literature, it's just I feel I kind of want to show them all thing in a little bit discrete and kind of show you that they're also kind of the same. I feel there's there's got to be some room for like some formalism that everybody's using that's nice, like the stabilizing formalism. Yeah, we can use it and work with it and design codes with it, and sort of something nice and malleable and easy to calculate with, but that's also capturing the circuit details that really implements a code rather than just some formalism that's only describing a code that's static there by itself. How much this intuition really carries over to the more general space-time quote picture given those can be non-geometric protocols? Um um well I mean if if if you were I it would be I I mean there would always be a circuit to measure the the stabilizer the um you know whatever code you want like it may be that the CNOT gates have to go over a long distance or something but you can still You can still describe a time-like direction of the dynamics of measuring the stabilizer circuits. Now, it's because I've concentrated on topological codes with some nice local geometry, everything's very nice. And it lets me draw these diagrams the way I do. Yeah, I would hope for formalism to capture that as well. Why I'm looking for kind of a general formalism for A general eponym for describing how codes are implemented at a time. Or like a dynamical stabilizing phonetism or something. Something like this. Maybe we could ask some questions over the coffee break, I guess. But maybe let's thank him for the If we you can be in 20 minutes, right? Thank you. Yeah, yeah, yeah, and always buy it, right? I thought I was having a lot of pleasure. Oh, that's good. I think I have a last note. Oh, for sure. By the way, I said you're just checking. Yeah, I'm going to. As soon as the tutorial is done, I think this is trying to prove that it's a possibility. I might be kind of just telling you a little bit in the next one on my geometrical stuff here as well. Well, I was going to say this is how completely. Yeah, I'm trying to find what I'm thinking about. He's kind of finishing up he's in kind of finishing high school stuff and then he gets to go on to start doing college stuff and high school. There is a class on quantum computing. I want to do linear algebra as much as we can. Quantum is like linear algebra still. Basic sources of algebra from the person telling you something a little bit, they can tell it to you from linear algebra terms. We're doing layout where you look at this. Oh. I'm an artist or yet. So I'm looking at this and I'm like, that's about what somebody who didn't take winning off the purpose would have also said. I took it along the verified deck. It's nice to meet you, guys. Me too. So, I'm going to go ahead and do this. I think it's downstairs. I think it's downstairs.    I can tell. I think it's not a little bit of a places. Thanks a lot. Like early. 