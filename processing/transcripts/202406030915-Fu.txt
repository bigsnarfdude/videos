yeah go ahead everyone this is frank and uh uh frank you're at uh the university of uh south carolina yeah i always forgot which it's south south carolina uh yeah it's right up there uh okay so frank is going to start us off uh frank has kindly agreed to uh be the first talk on monday um that's always the hardest talk on he's going to talk about reverse control uh and with computing and protein And with computers and protocol. All right, go ahead. Oh, good morning, everyone. Yeah, so I've only been to South Carolina for about a year, so fairly new there. But it's nice to see all of you here. Yes, I'm going to talk about reverse control and with computing in Protocol. And this is a joint work with my co-author, Kohen Kishida, Neil Julian Ross. Neil Julian Ross, who is here, and Peter Singer, who is also here. Great. So, first of all, I would like to give you a quick background on Protocol. So, it's a family of standalone languages for programming quantum circuits. More specifically, one of its goals is to give formal. To give formal semantics for various features for Cripper. And Criper is a language that is embedded in Haskell and it supports a lot of big and practical algorithms. So and it has many, many interesting features. So we would like to study those features in a more formal setting. So there are many developers. So there are many developments in Protocol. So I'm personally involved in only several of them, which are incorporating dependent types in Protocol. And fairly recently, we also study how to incorporate this feature called dynamic lifting in Protocol. But today, I will try to focus on the reverse control and with. On the reverse control, and we computed these three constructs in purple paper. So we all know what reverse and control are, right? So here I'm just give you a brief review on what it is. So for example, reverse, if we have a circuit G, has input S going to the output U. Of course, reverse corresponds to taking the adjoint. Correspond to taking the adjoint of the circuit. So we have a circuit that goes from U to S. So operationally, how this is done is that we sort of represent the quantum circuit as a list of gates, right? A list of basic gate. And to reverse that circuit, what we can do is that we first reverse the list. And then for each gate in the reverse list, we take the edge. Lit, we take the adjoining for each gate, right? So that's how reverse is done, sort of operationally. So that also means that, well, if we happen to have a gauge in the list of gates that is not reversible, then the operation will fail, right? So oftentimes, this is detected at runtime, meaning that you only get the error when you try to generate a circuit. You try to generate a circuit, you realize in the middle of the circuit generation that, oh, here I'm just reverse, for example, like a measurement gauge. I'm just trying to reverse that. Then you get an error. Then that's how you normally see the error. But in Proto-Kiber, we try to detect this kind of error as early as possible in the sense that when we try to compile. To compile the program, we get a type error saying, Oh, you're trying to reverse this circuit, but it's actually not reversible, rather than you get the error when you try to generate a circuit. Anyway, that's reverse. We also have control, which again, it's yeah, it simply adds a control to the circuit. What's the difference between compiling the circuit and generating it? This is a different phase. This is a different thing. Uh, compiling a circuit and generating a circuit because you see, yeah, it might be somewhat different, uh, right? So, when I say generate a circuit, I mean the process that you go from a program to the circuit that represents that program. Whereas compiling a circuit potentially could mean that you have a circuit already, you want to compile it to a certain specific gate set that that might be. That there might be what people call compiler circuits. What in the point he was talking about compiling a circuit, but compiling a program, the program which you then run, and it updates a circuit. Compiling in computer science means you input the source code and you output an executable program in itself. So the point is that we want to catch the errors at compile time. Right, so here generates circuits, yeah. Anyway, that's good, thanks. Uh, right, so uh, we also have the usual control operation where we can, uh, if we have a circuit with the same input and output of type U, for example, then we can control the circuit. And again, the way it's done is that operationally we Operationally, we simply look at as since the circuit is really a list of gates, we simply add control for each gate in the list of gates. Again, if one of the gates in the circuit happen to be not controllable, then again, that's an error, right? So there's also a choice of whether you see this error when you generate the circuit versus when you see this error when you try to compile your program. You try to compile your program. Okay, so that's control. So, the next thing I want to talk about is this operation that appeared in Cripper, which is called with computed. What it is, is kind of representing this kind of circuit pattern, right? We first do a circuit G, and then we follow by another circuit F, and then we follow by the inverse of G. By the inverse of Q, so G-dagger here, right? So that's the miscomputed circuit pattern. It's a fairly common pattern. You see that all the time, right? When you program reversible circuit, when you want to do some computation and later you want to uncompute your computation, you also use this kind of pattern to program your circuit, right? So you So you might wonder, or one might wonders, that, well, isn't this with computed just a sequence of composition, right? We can just, rather than defining this with computed as a construct, we could just define it as this composition, right? So why? But here we are really interested in defining with computed as a construct. The reason is that We want to support this kind of optimization, right? So, say we have this computer circuit and we want to control this circuit. Well, what we are going to do is we will control all the gates in the circuit GF and G dagger, right? So, but this we know that is actually equal to this circuit rather than controlling. Circuit. Rather than controlling everything, we can just choose to control the circuit in the middle and leave the G and G dagger untouched. So, this is a very nice optimization in that, well, now we don't have the burden of the need to control G and G lagger. And another thing is that it's actually more general in some sense, right? Because we don't actually require all the gates in G to be controllable, right? Controllable, right? We and most of the time they are actually not controllable. Think of G as some kind of qubit initialization. In that case, there's no notion of controlling an initialization. That's not the thing. Yeah. So just a quick question, I guess, like you say initialization. So can I think of the G is on like having like having different output in this outputs? Yeah, yeah. So so in yeah, yeah. Yeah, so so in yeah yeah so yeah so we want to support this kind of optimization and uh and that that's one of the reasons that uh we rather than uh defining the with compute as just a sequence of composition we we define it as a construct like a primitive operation. Um this just means G does not need to be unitary, you can have any linear level uh June. G need not be unitary, but it might still be invertible in a sense of you as long as you are able to take the adjoint of G, that's good enough. So, in this particular case, if you're taking G and G to dagger to be conventional circuits, then this is just a unitary channel that you're applying. So, do you think it would make sense to talk about kind of maybe a broader primitive that? Of maybe a broader primitive that would describe the action of a channel on a particular object because then you automatically get the kind of symmetry property that you're taking advantage of here to simplify this. I don't quite understand what you mean by channels. Well, any. Oh, never mind. You can, for example, think that this F is a density matrix and they are conjugate. Oh, they are conjugated here by the unitary. So, this is an action of the unitary. Oh, yeah, yeah. So, uh, it's a good idea. Sorry, I also. Yeah, we indeed it will be looking from that angle in a moment, but uh, it does have this behavior of action on this kind of unitary thing. And uh, yeah, sorry, I don't want to. Yeah, so I don't want to derail things, but what about cases when you don't actually want to apply the adjoint of G, you want to apply something else that implements the adjoint of G. And that I imagine wouldn't be captured by the G. I see. Yeah, right now it wasn't captured. But yeah, indeed, there are situations where this G need not be the exact same G as here. So you seem to suggest that G could have, for instance, some preparations and like ancilla preparations. Would G dagger then have like an assertion? Yeah, yeah, yeah. For example, right, the edge end of that initialization here, we take it to be assertion. Is that going to be true automatically, or does that depend on the app? Yeah, it sort of depends on the computation. So in the language, The computation. So, in the language level, we don't really have a way to check that. So, yeah, so one of the benefits of viewing with computed as a primitive is that now we can even specify equationally what the WISC computed looks like, right? Indeed, it has this kind of action structure. For example, if the G is. If the g is an identity and then we do a biscuit of identity over f, it doesn't change anything, we get f. So it's sort of like the identity action, group action over a set f, for example. And similarly, if we have a composition of g1 and g2 and action f, then we do the action of g2 first and then we act g1 to the result. And then the optimization. And then the optimization that I showed you earlier here can be captured by this, the third equation, right? Which is if we have control over this with computed g and f, what we can do is that, well, that's equal to the with computed of g tensor, a bunch of identity wire, and then acts on the control version of f. So this corresponds to controlling the f in the middle. And so it seems that you're using like So it seems that you're using like the reversal idea you were talking about previously. So, would you require if you were to try to compile this, that if you were to enter a G that isn't reversible, you're wanting now like a compile time error? Yeah, I'll get to that in a moment. But in B, we do sort of, here we sort of relied on the fact that everything is well defined in the sense that when we try to reverse it, it's actually reversible. But we'll try, I'll explain. We will try, I'll explain how to try to reinforce that economic in a moment. But yeah, another equality would be when we try to reverse this thing, we simply reverse the F in the middle, right? So that's one of the nice thing about this computer is that we can specify equation like this to understand its behavior. So, yeah. Yeah, so that's roughly the three constructs, right? Now, I talked about we want to detect certain error at compile time. So how are we going to do that? Here, we use a notion we call modality here. We think of it as some kind of annotation, right? They denote, for example, here a modality is defined to be 0, 1, 2, one of the three elements, right? Three elements. So each of the elements represents certain meaning for your circuit. For example, we write the number two to mean that it denotes a circuit that is both reversible and controllable. And we use the number one to denote that a circuit that is reversible but non-controllable. So well, an example of a circuit that is both reversible and controllable will be your usual unitary gate or unitary. Unitary gates or unitary circuit like Hadamard gates and so on, they are reversible and controllable. Whereas reversible but non-controllable examples for that would be things like initialization and termination or persertion, right? And then the number zero here just represents some generic circuit that is non-reversible and non-controllable. So a potential example would be like measurement. So we have this. So we have this three, and of course, note that there is no three in a sense. We don't really have an example that is a circuit that is not reversible but controllable. There isn't such thing. So we only have three modalities here. So then in ProtoPeeper, the way we use modality is that, so this is a circuit type in ProtoPeeper. The circuit type in protocol creeper, right? Circle of SU simply means that we have a circuit with input s and output u. But to incorporate the reverse control and miscompute it, we add this modality alpha to the circuit type to indicate the property of the given circuit. So the nice thing about this is that this kind of modality, we can Modality, we can calculate the resulting modality of a circuit composition. So, for example, say we have a circuit S to T and we want to compose that circuit with some other circuit from T to U. We know the resulting circuit will go from input S to the output U, but then the modality of the resulting circuit will be can easily be calculated by taking the joint. Calculated by taking the joint of alpha and beta. So here by joint is really like the minimum number of alpha and beta, right? You might have said this already, but is the reversible, the non-controllable modality, is that for like non-unitaries, like you were talking about. Oh, yeah, the information is the example? Yeah, like initialization would be an example of reversible but non-controllable. And why couldn't you have controllable but not controllable? Then, why couldn't you have controllable but not reversible? Controllable, but yeah, because when things are controllable, potentially it's already like a unitary. But it isn't necessarily, you can have channels that you can define very easily that would, you know, if one qubit is zero, act as the identity, but otherwise do some crazy thing, like a controlled measurement, say, on the system. So, if you're thinking more broadly, I really think that you know, Think that a lot of this stuff makes more sense in the language of general CPTP maps or things like that. Yeah. But yeah, I personally also don't know an example of controllable but non-reversible one. Would be interested if you know any example. I guess you could cook one up, but it's whether one is actually useful for programming. Also, wouldn't like a controlled state prep or something like non-reversible control what get like a controlled state prep or something like that, like trying to control up like a funnel wire and doing a state prep. Yeah, I guess the difficulty is when we say control, we already assume things are unitary in some sense. Anyway, yeah, so that's that's but I think that you know, if you're talking about this up here, you've got to drop the notion. Here, you've got to drop the notion of unitarity completely because you can't think about things like initialization as a unitary paradigm, right? Right. That's true. Yeah, maybe, yeah, that makes sense. So, reversible means taking the adjoint, but initialization definitely has an adjustment. Okay, okay. Yeah, so we know how to calculate the modality of the The modality of the resulting circuit when we compose them, right? So then we can give types to these three operations in the following way. For example, control can be given this type. Then the circuit with modality two with same domain and codomain. And then, of course, sorry, control is parametrized. Is parametrized by another type S. So here S, you can think of it as like tensor products or identity wire. Right, so we take a controllable circuit and then when we control it, the type now becomes u tensor S, where S is the controlling wire. And then we have the type for the reverse operation. Here we only Here we only require the modality alpha to be greater than zero. So meaning that it has to be reversible. So that's reverse. And with computed now has this kind of type, right? So we have some G and F, and then we return a controllable circuit from U to U. So that means that when we take a wis computed on G and F, the On G and F, the resulting circuit is also controllable, provided that the F in the middle is controllable and the G only need to be reversible. So here alpha can be one. Yes. So a question. So you have like CERT2UU. So in there, the input, the parameters are the input and the output of the circuit. Is that correct? Yeah. So am I reading that correctly? That like CERT2SS would be an. SS would be an identity circuit. It has the same type as identity circuit, but it may not be an identity circuit, right? It's just some circuit with the same input and the same output. Maybe we should just give examples of like what's new and SR. Yeah, yeah, I will show you some examples. But yeah, that's roughly the thing I want to talk about. We also have an actual formal type system and operation. An actual formal type system and operational semantics, categorical semantics for these three constructs in our upcoming paper. But depending on how much time I have, I can show you what it looks like in programming, but probably not much time. It's like 10 minutes plus five minutes questions. Okay. Kadrin? Why is this thing in the middle with computer activity? With computer have to be convinced. You mean why is this have to be true? Yeah, because we still want to control the with computed circuit, right? Well, in that case, you might just want to use the usual composition. But if you want to use with computed, it does require the f in the middle to be controlled. I guess the x would be a billion to be. I guess the axe and the billionaire is V2. Yeah, yeah, yeah, yeah. Okay. Usually we also have tensor product for composing a circuit. Like where can we find that thing in the concept? Oh, good question. That is definable through other mean, like we can unbox the circuit, it will become a function type. And in the programming language, we do have a pair construct. So when you pair two circuits together in a certain way, you get a tensor product. So can I substitute you with another circuit? Can I substitute you with another circ? Like no, no. So here you just like some, you can think of it just as a tensor product of qubits, for example. It's not any type. Okay, so yeah, I want to show you some example. Let me quickly try to switch to the code. Oh, I don't know what happened for the black thing there, but it's probably fine. But it's probably fine since we only need to look at the actual circuit, right, rather than the code. But anyway, so here is your typical protocol code. What I want to show you is an example that sort of show the with computed pattern. Let me see if I can find the interpreter. So, so here I want to show you a circuit that looks like this. Yeah, it's really weird that. Yeah, okay, so we are not missing anything here. So, here we have a circuit that. Can the zoom post? How you can zoom host? Can you get rid of both boxes, please? That I believe is on your end. If you unshare and then we share, that might fix it. Oh, oh, oh, I see. Yeah, you might be on my end. I think it's control, all shift page. Yeah, that's showing these things up here. Can I hide it? Maybe to do that. Okay. Okay. Yeah, let's see how this looks. Okay, now it looks wait. Yeah, now hopefully it looks slightly better. So here we have a circuit that looks like this, right? We have a bunch of ancilla that is initialized, and we have a sequence of Initialized and we have a sequence of C naught that calculates a certain sum of numbers. And then we apply 7T gauge, and then we do the inverse. And so this circuit sort of implement a tofali gauge, for example. So the way we, this circuit is actually constructed from this particular program called myTropoly. Not sure if you can see it. Can see it. Maybe I should just enlarge this. So, this is the circuit that we just saw. And the way it's constructed is the following, right? We use the with computed here. And then this is our G, right, which is a bunch of C naughts with the initialization gate. And this is our F, which is a parallel application of T gate. So now we can. So now we can control this topoly, right? Which is this particular fragment of code, we apply the control to my topology. That's roughly what this does. We apply the control to it. And then let me show you what the circuit looks like now. Control my top copy. So uh So, this is the result when we try to control it, right? So, we did, because we are using the WISC computed, we do not really need to control the G here. And then, where the sequence of T gates now is now all controlled by this controlling wire here. So, whereas Whereas, if we try to, so this my topology prime is another version of the circuit, except it's not defined by the, with computer, it's simply defined by the composition, right? We do g followed by f followed by g dagger. If we just do this composition, then we wouldn't be able to control it, right? Because if it's defined using the with computed Single is computed primitive. That means that when we control this particular composition, we need to control all of the things, but we know that initialization is not controllable. So controlling this will fail. So let me uncomment this part of the code. So this part of the code is trying to control this portfolio prime circuit. So now let me try to reload the file here. So now, if I reload it, it will show you that we will get an error saying that basically the modalities say that the totally prime circuit is not controllable and we are trying to control it, right? So there's a typing error there. So we wouldn't even. There. So we wouldn't even be able to compile the program. Yeah, so that's an example of computed and the controlled. It looks like there's three modalities there. What do those? Oh, yeah, yeah. So internally, in the implementation, the one, two, three is actually represented by some binary code. So yeah. So yeah, and this usually we can just use two bit to represent the reverse and control, but but this actual bit is for the another feature called dynamic lifting, which happened to be the cell another modality. But yeah, so this is more like an implementation detail. Thanks. So here you have like you've got this like GFG agile construction. And what's happened here is that you've tried to Tried to, your Gs haven't been, you applied the controlled, like with controlled, when the G's aren't controllable, and you get a compiler error. Does it also happen if my G, for example, is not reversible? Yeah, yeah, if you try in our yeah, so for example, if we try to reverse say a measurement, we yeah, that that will be an example of. That there won't be an example like it seems like in with controlled, it seems that there was like an implicit check for the need for something to be regressive. Is that like done in the compiler? Yeah, it is. So for example, if we look at the time of the control, well, the thing is that we do not really represent the modality when we're programming, right? So there's no modality here, but There's no modality here, but here is the type for the control. So it takes the unitary-like circuit A to A and then it unpacks it as a function such that this function is using its second argument as control. So the modality is hiding behind somewhere so that when we write program, we can just write program as usual. But when we try to compile or pie check our program, Or PyTrack our program, the compiler will sort of track the modality behind the scene and see if there's a modality error, it will actually show you. But if everything is working fine, you do not see any error. And at what point do you encode the modality when you consider? That will be in the type checking algorithm. So when we load a program, there's a type checking mechanism to check if everything is well defined, well composed, and so on. Well, composed and so on. So it's also at a compile time. I don't understand why initialization is not controllable, because can't you imagine a subroutine that brings in auxiliary qubits and then gets rid of them and controlling that on something? But then that's exactly what this is doing, right? Then this is what's enabling that. Because then the width controls when you have that adjoint structure, I guess, right? Yeah. Where you compute and then uncompute later. And then uncompute later, then the whole thing globally is controlled. Like if you just initialize. Yes, yes, yes. That's that. And I think. For an individual page to be controllable, it has to have the same type as the identity, the same number of entries, right? Because when the control is up, you know, like what you do with an initialization when the control is off, right? And well, it has to do nothing, which means. Well, yeah, it has to do nothing, which means the identity makes sense. If it has one input and one output, then that's why sometimes the whole sequence of gates might be controlled in regards to the visual data of the sequence being controlled. I'm just curious if you, I mean, I don't know what's time up, but if you have a slide, can you show what the type of judgment looks like? Yes, yeah. I can show people after the talk. Maybe this is more of a question about proto-equipper. Like, what are we looking at now? Like, so when we see the code, when you're running the code, is this a full-fledged kind of parser and type checker that has been written in Haskell, or is this a kind of a hosted language like QuickBur is? Like Quipper is, uh, yeah, uh, well, Protocol is a standalone language, so it does come with its own parser, type tracker, and so on. So, yeah, it's not the same as Cripper in the sense that, whereas Encripper is actually like a Parscore program. Okay, yeah, I think that's that's my talk. Uh, thanks. All right, we have time for a few more questions if anyone has any more questions. So you mentioned that there's an uncompute process and like do you know what state the qubits are recovered to? Like do you have memory to keep track of? Like after uncompute? Yeah, after uncompute, like how do you know what state your qubits are? We well at the language level. Well, at the language level, we do not really know. So it's really up to the programmer to ensure that when you uncompute a qubit, for example, it's programmer's job to ensure that it's actually in the intended state. Yeah, so in some sense, the type checker will not help to check whether your circuit is an actual unitary circuit. That's too hard to check. Do check. Yeah, I'm like thinking a little bit with your example. I'm not sure whether my question makes any sense, but so in some cases, what might happen is if you have a part of the circuit in this structure that you want to control and then do this entire thing, right? But then you want to do like a double control, so you want to control that thing. A double control, so I'm just controlling that thing, yeah. You can do that, you can do that. Then, yeah, so my question is: is there like a mechanism that maybe helps find the same type of old structure into the new controlled structure? So, in the example that you had yourself, you got these control T gates that you can then split into C naught and a T gate, and because they're all controlling on the same qubit, then you can move those into G, even though they were part. Into G, even though they were part of F. And then that thing then creates their only single computer controlled instead of W controlled. Not sure if I understood for you correctly. So are you saying when we control this, we can move this somehow to the if you decompose that, it becomes a C naught, two C nodes and a T gate, and then each of the C nodes, they have the. And then each of the C nodes, they have the same GSG structure, and then the G, that, that G can then go into the biggest G. Yeah, that would be a very good optimization. Yeah, because then all of a sudden this thing becomes much nicer. Yeah, so here we can already implement another optimization like that. In which circumstances can you even do that specifically? But like in this case, it's really. Specifically, but like in this case, it's really nice and a really cool optimization because then suddenly making these huge ass control controls becomes correct. How are we also in photo river? This would happen. Like if if you control the circuit and then decompose the control gbits and then you control it again, well it would internally do so with computed also when it constructs the also when it constructs the the surface for the control cheek it so and would it personally it would only control whatever it has would it be able to like like recognize that it doesn't need to control like part of it because like you have to define like in here now you have to define which part is the the thing that will be reversed and if the the your f contains the same with computed structure without being defined as a with computed structure then uh you're going Then you're going to still run into the same issues. So, whoever wrote the code for you proposing a control T gate should have used. No, yeah, okay, yeah, sure. Yeah, exactly. Yeah, yeah. Yes, thanks. Okay, I think we're going to have to move on to the next talk, but one quick question. Can you say in one sentence what the categorical structure of these features ends up being? Yeah, yeah. It's just impossible to say in one. Yeah, yeah, it's a possible scene. So the modality behind the scene, the categorical semantic for the modality will be monad, basically. That's the one-sentence answer. But there's very special kind of monad that work in a way that is well-behaved. And what is the special kind of monad? Like they commune with each other and they Yeah, I think we can chat about that later. For the computer thing, I think it's basically a pair of categories, one juncture from one to the other, and some action of one on the other. Oh, no, right, satisfying the appropriate factions, but that's not honestly a one-sentence answer. What contemporary theory is ever one-sentence? It's just all right. Well, let's thank Frank again.