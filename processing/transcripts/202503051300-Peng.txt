With the CMU and the Waterloo, and he's going to give us a tutorial talk on second-order dynamic graph algorithms. Okay, Richard. Okay, everyone can hear me fine? Yep. Cool. First of all, sorry for cutting everyone's lunch break short. And secondly, I'd like to thank the organizers for letting me talk about this. My own background is. Background is kind of coming from computer science. Actually, my own background is more kind of in client's computing and data structures. So, a lot of the things you hear from in this talk are kind of, they're going to be framed a little bit more from the kind of the efficiency point of view. But I feel I'm learning a lot about these kind of configurations from the talks that have happened so far. If at any point something's not clear, please stop me. I'll be happy to kind of go into more details about it. It's meant to be. Going to more details about it. It's meant to be a fairly kind of high-level description of what kind of thing happening when one looks at the kind of efficiency matching algorithms. So, I mean, the first side is something that we're probably all familiar with. This is just bypassed matching. I love the bipartite graph. I want to find the maximum number of vertex-disjointed edges. This has a lot of many bottle connections, and it's also kind of a proofing groundwork.                                                                                               