This is, I was delighted to get this invitation because this is a little project Eric Rechner and I have been working on for the last two years, give or take. Just for a little bit of background, my affiliation is listed there as University of Washington, but that's really just kind of a fun little retirement. Just kind of a fun little retirement gig for me. I have taught classes there for the last three years. I've taught three different classes in computational linear algebra. I'm having a blast. The course I have been teaching is the linear algebra class is, because it's a computational class, is a prerequisite for about six different. Prerequisite for about six different majors at the university: mechanical engineering and data science and financial mathematics. And so you get this really diverse group of students with diverse interests. And it has been really fun to just do a very application-focused, fun, hardcore computational linear algebra kind of class. Algebra kind of class. Prior to that, I had a 35-year career at the Boeing Company, which all came after writing a PhD dissertation in Splines. So I have been doing Splines a very long time, all throughout my 35-year career with the Boeing company. Eric is a student of Harry McLaughlin, who some of you may have met. Who some of you may have met, a computer graphics guy at RPI. Eric and I were colleagues together at the Boeing company in the early 1990s. And he left Boeing about 1995 and became an executive at Microsoft and did a whole bunch of interesting things in software architecture and software development and training. Development and training of software architects. And he had a very successful 25-year career at Microsoft. We stayed in touch the whole time. And as things turned out, we retired, he from Microsoft and me from Boeing within three or four months of each other in 2020. And we're both talking to each other and community. Well, what are you going to do now? What are you going to do now? And Eric had an interest. And Eric had an interest in Boolean operations for solid models. And I had an interest in spline tools. And it just kind of all came together here in this BSP package. This is the first time I've been able to give a talk to an audience like this where I can share everything that I have been working on. You can have copies of this software. It is available for download. It is available for download on the internet. I can help you even get started with it in the next few days if you want to get this installed on your laptop. I can't go a day without playing around with this a little bit. It is just a fun little package. Here is a, this is a site called PYPI. It is the Python Package Index. So pypy.org. If you go there and if you do. go there and if you do a search for projects b spy the bspline package in python and search for that you will see there it is b spy 4.1 a library for manipulating and rendering beast blind curves surfaces and whatnot there's a little button there to yeah you can download it and once you've got it you just do a pip install b spy and your python All bSpy in your Python environment on your laptops, and you are up and running within a couple minutes. So, everything I'm about to show you is our things that you could get running on your own laptops this afternoon. And so, with that, let's just kind of dive right in. I've got at least 90 minutes worth of material here. So, I am going to go until I To go until I promise to stop by 12:45. And we can, if whatever is left over, I can show you one-on-one if you're interested, or if you're not interested, you'll get out of this by 1245. This is going to work for everybody. All right. So, what I've got here, this is a Jupiter notebook. So, this is So, this is alternating sections of markdown. This is tech-like stuff here. So, this is all just source code. So, you see here, this is a way of formulating all of this, and I can execute that. And then alternated, mixed in with Python code blocks. And I think that I've got this blown up enough so that you all can see it. You can see it back there. We are good to go. So, we're just going to. Good to go. So, we're just going to dive right in. This is seven lines of Python code here. The first six lines are all standard Python stuff. The package depends on NumPy, which is basically a computational linear algebra package in Python, and SciPy, which gives you quadrature and ODE solvers. This is all standard open source. Standard open source Python stuff. And then Matt Plotlive is a standard plotting package. We're going to use some of that. vSpy has its own 3D renderer, which I'm going to show you part of what we do. And then some of this other stuff are some additional Matte plot line things that enable animation. And I'm going to show you a couple things using that. And then finally, you get to this very last line here, line number seven of all of this. Number seven of all of this import the Beast Buy package. So this is just an add-on to all of this other standard Python stuff that hundreds of thousands of people use. And then we can add our own little BSP to the end of the thing. And it's all B-Spy is designed to just kind of interact and play nice with all of this other stuff. And you'll see that as we dive through here. That as we dive through here. So, I'm going to execute that code right there. It's going to import all of these packages, and we are ready to go. The environment is up and running. So, Hendrik talked about all of this stuff. I'm going to blow through this because you're all familiar with what splines are and what the usual spline setup is. This is spline functions, and we talk about matching conditions and matching. About matching conditions and matching derivatives. And because you're joining polynomials together at points, because you're tying those things together, you call them knots and you all know all of it. So there's no form and no point in dwelling on it. And then in one variable, splines always have a standard basis that is a very good basis to use. That is a very good basis to use B-splines, so that any spline function can be represented as a linear combination of B-splines. Again, you are all familiar with all of this stuff. There's no need to dwell on it. So let's just dive right into the code here. The spline class is a Python class, and if I want to create a spline class, And if I want to create a spline function, there are some ingredients. Now, b spy is designed to work with tensor products of univariate splines. So I specify for my spline function how many independent variables there are and how many dependent variables there are. So think of this as a vector-valued function of some number of variables. What follows then is a list of the polynomial order in each independent variable. I only have one independent variable for this example, so there's only one number in the list. It's order three, that is to say quadratics. And then I also have the number of beast lines in each of those independent variables. In this case, it's five. And that follows then with a list of all the knots in each of the independent variables. In each of the independent variables, I've got eight knots right here. There are two interior knots. So, this is three polynomial pieces. It's the usual, this is a C1 quadratic spline with two interior knots. And then lastly, all of the coefficients. There are five. This is a spline space of dimension five, so I specify the five coefficients for these splines right there. So this line of coefficients. Right there. So, this line of code right here says: create for me a spline function this way. And then numpy, linspace, this just says give me 101 equally spaced values of equally spaced numbers between 0 and 1. So I'm going to get 0, 0.01, 0.02. 0.01, 0.02, all the way up to 1. I'm going to store that in an array. This is a NumPy array right here. And then this is part of the way that BSPY is designed to play nice with NumPy. Then I'm just going to say, hey, plot for me these 101 values of t and the values of this spline function at those same 101 values. At those same 101 values of t. So I'm going to b2 is this spline that I created. I'm going to evaluate it. I can enter a vector of places and it's going to evaluate it for me at all those spots in a way so that this works really nicely with Madplotline. So this is just going to plot this function that I created right here. And then I'm going to plot some additional things. These are some vertical lines. Things. These are some vertical lines that, in fact, are dashed lines. And when I plot all of this and show this, you're going to immediately see what this is all about. So that code right there generated that plot. Okay, those lat, those dashed lines are these guys. Well, I'm just showing you the location of the knots. And this, in fact, is a quadratic beast line. Not surprisingly, because I just said it. Just said it: this beast line has value, has coefficient one, and all the others have value zero. So, I'm just showing you a plot of that one beastpline, and I created it that way. Okay, simple, simple. Well, here's a slightly more complicated version of the same thing. I'm creating now the same spline function. Same spline function, except I'm specifying all of the b spline coefficients to be zero. And now I'm going to go through a little for loop where I'm going to say, okay, set the ith1 equal to one, plot that function, and then set it back to zero. And I'm going to loop through that for each of the spline coefficients. And then again, I'm going to plot these green dashed lines. These green dashed lines here. This is going to be a very similar plot, but you see this time, in fact, what I'm going to get are all the B-spline functions because I went through the little loop setting each of the coefficients of my spline to one. Okay, not much to it. You showed the same plot yesterday. All right. Forging right ahead. As I said, B-Spy is designed to work in any... Said BSPY is designed to work in any dimension, including dimension zero. So I can say, okay, create for me a spline function with zero independent variables. You actually can also specify zero dependent variables, which is interesting because it gives you the framework for a function space using splines without worrying about any of the coefficients. But you can represent But you can represent points as a zero-dimensional spline, and curves as one-dimensional guys, and surfaces with two-dimensional guys, and volumetric solids as three-dimensional guys, and time-dependent volumetric solids as four-dimensional guys, and time and deformation-based things as five. There's no limit. There are practical limits because it's a tensor product, and the curse of dimensionality bites you pretty quickly. You pretty quickly, but there's nothing in the software that inherently limits the number of independent or dependent variables. So, we've got this going on. All right. There is a method in the spline class that says, create for me a zero-dimensional spline of that particular vector. And so I'm going to do that. And then, because this thing is a spline function, I can evaluate. Function, I can evaluate it. This thing, in fact, has zero independent variables, so evaluating it, it doesn't take any argument. It's a function that can just be evaluated. And we do that. And sure enough, I evaluate. My point is a V-SPY splying object. I evaluate it. And what comes out is a NumPy vector. That is those three values that I put in. That I put in. All right, well, so far, nothing real interesting or exciting. We can forge ahead with some maybe additional methods here. I can do basic data fitting with the least squares method. So here I am defining in Python a function, which is one plus one quarter of the cosine of six pi. Of the cosine of 6π. I create that little function. I'm going to say, okay, here is a vector of values of t, 51 equally spaced points between 0 and 1. And then I'm going to create another vector of values, which are that function evaluated at t for all of the values of t in that list. And that's going to give me this function. This function tabulated over 51 points. Now I'm going to call the least squares function and say for those independent variable values and those function values, do a fit to tolerance. So what this is going to do is it's going to do a least squares fit with no interior knots, a simple cubic polynomial fit to those 51 data points, then check the error. Points, then check the error at each of the points. And if it's if the error is larger than 0.001 at each of those points, insert a knot someplace and do the fit again. And continue to refine and insert knots until all 51 of these data points are within that tolerance. And this and create, once everything's in tolerance, return the spline function that you get from that. So I've got these. So I've got these five lines of code here that are going to create a spline approximation to this function right here. And then I'm just going to say, hey, show me what that spline is once you've done that. So we do that. And what you find is that you get a spline that's got one independent variable, one dependent variable. It's a cubic with 22 spline coefficients. And this all over here, these are the knots. It decided to. These are the knots. It decided to stick a knot in at 0.0625 and another one at 0.125 and so on. Inserting enough so that you have a spline space of dimension 22. And then you get all of the B-spline coefficients that correspond to that function. Okay, that's fun. So now let's come up with 201 equally spaced points between 0 and 1. Between zero and one. Let's evaluate that function, my function at all 201 of those points. Then let me grab the not sequence out of this spline. Yeah. So this is a little Python ease here that is just saying omit that high order knot at the very beginning and the one at the very end. Just create for me the interior knots that I used. Evaluate the spline. Evaluate the spline at those interior knots, and then plot the function. Plot with green dots, the data points that I use to fit the function, and then put a little red plus sign at the knots themselves so that we can see what we got. All right, and we got that. So the blue curve is, in fact, the spline approximation. In fact, the spline approximation to the least squares fit to the green data points and the red plus signs here. Can you see those back there still? Are the knots of the spline? So I have a cubic polynomial here and a cubic polynomial there. It's interesting to me that I've got four knots fairly close together right here. So the least squares fitter ran into a little bit of trouble trying to achieve tolerance. Trying to achieve tolerance in there, but that's what it ended up doing to get me a spline model to within three digits of that function that I started with. All right. Any questions about any of this? Because we're going to ramp up. Yeah, go ahead. So, how do you decide what you can? Well, as I said, having done this for four This for 40 plus years, the simple things work best. You, you, it's while it's tempting and a lot of people get tempted to stick a knot at the location of where you found the greatest error, I've always found it better to just split the interval. In part because the thing that's driving the error, you just Error. You just talked about all this stuff. It's big O of H to the K. So the way you're going to hammer away at that is to cut H in half someplace, not try to play games, trying to guess where in that interval you can go. Just split it down the middle. And so that's why you're seeing knots that are at places like 0.0625 and 0.125, because it's just simple. The other thing that goes on. Thing that goes on when you get into surface lofting is that you've got a whole sequence of curves. And if you fit them this way, you want those curves that you're fitting to have all the knots in the curve direction lined up. And if you are zealous about always splitting so that the denominators of the fractions of all the knot locations are some power of two, then you're going to have a whole bunch of knots and all the different curves line up so that when you fit. Line up so that when you fit them in the other direction, you don't get this explosion of knots. So there are a whole bunch of practical reasons why just doing something that on the face of it seems almost brain dead to go for it that way. All right? Are we having fun? All right. Now, here's just Now, here's just one thing to I want to emphasize that this thing called my spline that we constructed by calling that least question, it is a function. And it can be at this point and as far as treat it as a function. So in particular, you can evaluate it. Python is rigged up so that if you pass arguments into this thing, what it's going to do is evaluate. thing, what it's going to do is evaluate this function at that value of t. Or there's a method called differentiate. My spline is a piecewise polynomial function, so its derivative is a piecewise polynomial function. And so therefore, I can implement a method called differentiate that will take this piecewise polynomial function and return the piecewise polynomial function, which is its derivative. So if I do these two So, if I do these two things, you'll see, yeah, sure enough, there's the value of my spline at that particular value. It's again a numpy vector. And then here is the spline, which is the derivative of the spline that I got. And of course, it's not surprising. Instead of it being a cubic spline, it's a quadratic spline. Spline, it's a quadratic spline. It's going to have the same knot sequence, but it's only going to have 21 B-spline coefficients instead of 22. And so this, I can do that. There's an integrate method. I could take this thing and integrate it back up and get the, well, to within whatever constant of integration we're dealing with, get the original thing back. There's for most of the options. Most of the operations that I can apply to splines that return splines, an awful lot of those things have been implemented and are available so that you can just treat this function object that you've got as the real live math guy that you're dealing with and do these very high level operations on the whole thing. Okay? In particular, here is Here is a command that generates an approximation, a spline approximation to a circular arc of radius one. It's in fact only the first 90 degrees of a circular arc. And yeah, this section method, we'll talk about this just a little bit. The section method is in fact how this is implemented. This is going to be a spline approximation to a circular arc that is good. Circular arc that is good to, I think by default, it's good to 12 digits. It's really quite a good approximation to a circular arc. Well, this is a spline function. It's in fact a spline function, the circular arc. What you're getting are spline approximations to the cosine function and the sine function. So this is a spline that has two dependent variables. It is a vector-valued function. Valued function. This, well, my spline was this thing that we just created that was the approximation to a quarter, one plus a quarter of six cosine of six pi t. I can multiply those two things together. And this is all implemented in the B-SPY package. Oh, this is a spline file. Well, this is a spline function, and this is a spline function. This has one dependent variable: that is, it's a scalar-valued function. This is a vector-value function. I know what multiplication means in that context. So the asterisk here is implemented in b spy, and I can multiply these two functions together, and my curve is going to be a vector-valued spline function. Spline function. Whatever this is, it's got a B-spline basis and a B-spline representation. And so this little purple asterisk, though, the multiplication, does all of the stuff that it needs to do to get the degree right, to get the not sequence right, to get the beast blind coefficients right. It's all in there. Well, now I can just generate that thing and let me go ahead. That thing, and let me go ahead and evaluate that over my plot vector of 200 points. I'm just going to go ahead and plot this curve. Okay, so you can kind of see it there. Here is the circular arc right here, quarter circle. And I multiplied that thing by that other spot. By that other spline that I had, that was the approximation to cosine of 6π. And so now I was able to generate basically this fun little curve. All right, well, let's have more fun. Now, let me take this curve right here. We have implemented surfaces of revolution. So I'm now going to take this curve and To take this curve and revolve it around the y-axis. And that's going to now generate a spline that has two independent variables. And so what I'm going to get when I do this revolve operation here is, and I'm asking to do it for a full 360 degrees. And now I'm going to pop up the V-SPY interactive view. The VSPY interactive viewer and say, okay, let's go ahead and create this surface and then draw it for me. And then it's going to enter a little interactive loop. So I'm going to do that. Okay, and here is my viewer right there. And sure enough, now what I have is a 3D model of. Model of that surface that I got just by. So, I mean, this has only been about three lines of code to create this thing, right? I needed to do the least squares fit to get the other thing, the circular arc, multiply them together, and then the revolve operation to get what is in fact a fairly complicated and but nevertheless quite interesting spline surface. Okay. Surface. Okay. So far, so good. Any questions about this? Yeah. Yeah. Is this done with periodic spines or? No. No. No. One could as a, let me think, circular arc, circular, I got the endpoints right. The effect will be exactly that because the Because the revolve operation, the way it is put together, is exactly interpolating what is happening at the join points, both in terms of function values and derivatives and curvatures. So even though it's not explicitly a periodic spline, the matching conditions at the seam, it is essentially It is essentially curvature continuous across that scene. Yes. And the viewer is Python viewer or you implement. Oh, thank you. Eric, of course, is an expert in computer graphics. And so he and I talked about this. And what I'm really delighted by about this is I said, let's not, I said to Eric, let's not do the dumb thing of dis. Dumb thing of discretizing the spline and sending it off to the GPU. Let's, why don't you implement a shader that takes a spline and send the spline to the GPU so that now when we zoom in on this thing, which I can do, it is adaptively resampling so that you get a pixel accurate rendering of the Pixel accurate rendering of the spline. So this is a neat thing. We're not sending a discretization of the spline to the graphics card to see it. We're sending the spline to the graphics card. Not busy yet. That's a fair point. And you know, I can't be entirely sure. You might be right. Yeah, yeah, you might be right. You might be right. Okay? But you get the Bayesian thing just by doing knot insertion, right? And it's not a big deal. All right. Plowing ahead. All right. So let's talk a little bit about the section method here. This was. This was something only you and I talked about this method boy probably almost 25 years ago. I'm just resetting again, just like walk over there. Does that work? Okay, great. Suppose I have a couple of four tuples, X, Y, Theta, and Kappa. Y, theta, and kappa. I suppose I have two of them. Tom Hogan and I, 20 years or more ago, published a method that will generate a degree four polynomial that interpolates the point. This is a 2D thing. X and Y will interpolate the values. It is set up in such a way such that the vector. Such that the vector, the derivative vector, the tangent vector at zero is parallel to the theta direction and the curvature matches. And you do that at both ends. So you've got these really four or eight interpolation conditions, and there are enough degrees of freedom in a quartic that enable you to do. In a quartic that enable you to do this for all consistent data sets in a way in which the spline is a continuous function of each of these inputs. And when we did this for Boeing, making the spline a continuous function of its inputs was a very important thing because we're trying to do design optimization. You want to wrap a You want to wrap a numerical optimization scheme around the whole thing and be able to have the optimizer specify these inputs to these curves to achieve the right kinds of shapes. When we did this, Boeing applied for and received a patent on this particular method, but the patent expired last year. So I grabbed my paper and implemented this method. And so now And so now here's a, this method is now accessible really in a piece of software to all of you for the first time. Okay. If I go ahead and pass in more than two points, oh, and the other thing to keep in mind is that this only works for consistent data sets. If you have, if the data are implying a curve. The data are implying a curve that is convex, you're guaranteed to get a convex curve. You aren't going to get any inflection points in this. And I can specify sequences not of two points, but of n points. And because the matching conditions are for tangent and curvature continuity, the curve that the spline curve that you end up getting out of this is essentially C2. C2. Um, the individual functions aren't C2, they are only C1 when you stitch them all together, but the curvatures do match at the knots. And the extraordinary thing to me about this is that if you're chopping this up into n pieces and let h be 1 over n, this method is big O of h to the sixth in the data. Sixth in the data. And so it's big O of H to the eighth in the data if the data are taken from a conic section. So that circular arc method that I used earlier actually samples a curve, a circle, at a known number of points to achieve the 10 to the minus 12th error and takes advantage of this big old h to the eighth bit to really get you. To really get you a highly accurate approximation of a circle in a relatively small number of polynomial pieces. All right. So I'm going to go ahead and construct one section right here, x, y, theta, kappa, x, y, theta, kappa, and then another one that I'm going to call outer section. Another one that I'm going to call outer section. It's got x, y state of kappas. And then again, I'm just going to generate some plot points and plot these two things. Okay, there they are. This guy was what I called outer section. This guy is what I called intersection. And if you look at this right here, this point is 1.3 and 0, and it's got a And it's got a vertical tangent right there and a curvature. And if we go ahead and look at what here is 1.3 and 0, and the direction was 90 degrees with a curvature value of 1. And you can check all four of those points and see that that all matches more or less what we're looking at right here. Okay? Okay. Now let's have some fun. Now, let's have some fun with this. There's a ruled surface method that says, okay, I've got these two curves. Let me go ahead and connect the corresponding points on those curves with straight lines. Well, this is all happening in the plane, in 2D. So, when I do that, I'm going to end up with a tensor product spline map. With a tensor product spline mapping that has two independent variables, but only two dependent variables. It's going to be a 2D region, but it's going to be filled in. What I'm going to get is a mapping that maps the unit square into the region that I get filled in with all of that. And so here you will see, this is going to pop up my viewer again. There is that 2D region. If I flip this thing around, Region. And if I flip this thing around, you will see, yeah, it really is completely flat. And the viewer is a 3D viewer, and it's taking this 2D thing and treating it as if it were a 2D thing with a, I'm sorry, a 3D thing with a zero Z component. All right, that's fun. Well, the surface of revolution thing doesn't actually Of revolution thing doesn't actually. I discovered this many years ago that all I needed to do to make the surface of revolution command do things much more interesting than just was to delete the error check to make sure that the thing was actually a curve. There's nothing that prevents me from in the exact same construction of taking a 2D region and revolving it around. And revolving it around the axis. And when I do that, well, now I'm going to get this deformation not of the unit square into the 2D region, but of the unit cube into this very interesting 3D kind of object right here. And so if we take a look at this, this is the thing that we got. This is getting to be a kind of an. Getting to be a kind of an interesting, there's a lot of complexity in this. And this was just, this was a few, literally four or five lines of code to construct a 3D object of this, a 3D solid of this complexity. There are some animation buttons on here. This is translucent so that you can kind of see. So that you can kind of see the front surfaces and the back surfaces, but there are some other rendering options here. I can say, all right, let's just turn animation on. And with respect to the first independent variable, let's just go ahead and treat that first independent variable as if it were time. So that now what I'm drawing is a surface which is time dependent. Which is time dependent, and this is how that surface would vary with respect to time. I could change that to be maybe the second independent variable, and I'm going to get a different time-dependent surface out of the whole thing. Or I could look at the third guy, and that's going to give me yet a third way of thinking about this 3D volume. 3D volume in terms of time-dependent surfaces. All right. Okay. Or I can just turn animation off altogether and think of it as the 3D volume again. All right. I now have a good 45 minutes worth of. 35 minutes worth of examples involving really interesting and fun things that can be done with contouring. I'm going to table all of that and hope that you're going to beg me for more. I'm just at this point going to skip all the way ahead. There are, I want to, I'm going to do this right here. This right here, this is a dir is a Python command that says, Hey, show me all of the methods that are available in any kind of object class. So I'm going to do that. And you can see that this is all the stuff that is in the spline class. You can see that there's a method for putting splines into a common basis and various ways of generating integrals of common. Generating integrals of compositions of functions with splines and a contouring method. A ruled surface, revolve, reparameter. There's just a bunch of stuff. Here's section. Here's solve ODE, which enables me to solve an ordinary differential equation using beast blinds as finite elements. I was very interested in your talk because a couple of months ago, I actually Of months ago, I put in a posteriori error estimator into this thing so that you specify a tolerance, and by God, it's going to refine and dial that in and get that for you. So there's just lots of fun stuff in here. And there are a great many things left to be done. One of the things that's getting real high on my priority list is to. Priority list is to create a version of least squares here into which I can pass an arbitrary function box and have it do without you having to sample the function and then call least squares, put the least squares method in control of the sampling so that now you can really do a neat number on approximating any black box function to a tolerance. You always run into issues with how smooth is that. Into issues with how smooth is that function, that black box, and so on. But this is a very useful method. We need to add in STEP and IGES support. We're working on mass properties, but there's still a bunch to go. I would love, Angelos, maybe you and I need to talk about this. I would love to see what could be done about bringing in some tensor product spline ID. Some tensor product spline ideas and solve some PDEs within this package. I want to do, because I'm a retiree with hobbies, for the home retired applied mathematician market, I think that there are some fun things to be done with MC machine tools or 3D printers in one's. Or 3D printers in one's basement. And then this is a brand new thing. And Eric and I were putting our heads together and we came up with this notion of a spline block. And it is in parallel to what's going on in NumPy. In NumPy, you can create a matrix by saying, okay, I've got this matrix and this matrix. Okay, I've got this matrix and this matrix. So think of a KKT matrix where you've got one of the blocks is zero, one of them is an identity matrix. You specify, you make a call that's got, well, you could do exactly the same thing with splines. Rather than creating a big matrix, you could create a spline with blocks of these smaller tensor product splines. In principle, this would enable. In principle, this would enable you to do something like create a tensor product spline that's got 10,000 independent variables. That's not anything I've ever even dreamed of. And yet with the spline block object, now if you've got just certain, if it's got the right kind of sparsity, you might be able to go after some interesting machine learning or AI examples with splines as the under. So, any of you are interested in. Any of you are interested in even thinking about this? I've only begun to think about this. I would love to talk to you. And then finally, the last point for all of you, anybody who wants to put some favorite gadget or tool or capability or anything into BS BY, talk to me. We're not too proud to take. We're not too proud to take good ideas and useful pieces of code from anybody and fold it all into this environment. All right. Again, I've got easily another 45 minutes or hours worth of stuff to talk about in contouring more of these kinds of examples to just give you an idea of what can be done. But let's have lunch. Thank you, Panchen. Thank you for that. Very inspiring talk, showing the software. Are there questions, comments? Yes, I'm the one. I love it, and I love the viewer. I love the viewer. Just one question. Since it's purely Python, right? Right. And so... Purely, but there are performance issues. So, okay. That was, in fact, the primary motivation of creating this spline block object. Creating this spline block object. It turned out that we can internally goose a lot of these methods along in terms of performance by leveraging them this way. So that was our motivation, but now we're saying, well, we've got this. And now maybe this needs to be something that users could exploit. But your question was. Your question was. Yeah, so thanks. That's one point. But my question is: now you can plug it into Pythons. You can auto-dip it, auto-differentiate it. In principle, sure. I have not tried it. I have not tried it. But if anybody wanted to, boy, I sure would like to see what happened. I've never been able to figure out, for example, Out, for example, what the derivative of the section command is with respect to. I want to know: okay, I've got 10 spline coefficients that are functions of those eight numbers. What are the derivatives of those 10 B spline coefficients with respect to those eight? I want to see that 10 by eight matrix. And I've never, except with finite differences, I've never been able to get a handle on that. Been able to get a handle on that. And conditionally, you can use the framework in neural networks. You can do all the all that stuff. All that stuff. I assigned a final project to solve an ODE using spline collocation to my undergraduate class of 85 students at the University of Washington. I got mixed results with that. The things that they The things that they struggle, but they all installed this package on their machines, and most of them actually got, I didn't give them the solve ODE method. That's my implementation of what I was asking them to do. But for the most part, they got it to work. Jorg Peters has had a whole class of his first-year graduate students, and I think that's maybe only 15 students or so. 15 students or so. They have been installed this package and they've used it for their coursework. So I haven't actually had a full debrief with Yorg yet to understand how his experience with it went, but seems to be okay. What we did discover in my class is this viewer does not work on MacBooks. And it's really too bad because. It's really too bad because it and it's not anything we have control over. It's Apple's implementation of the Tkinter open GL package that is flawed. And so it is something that Apple has to fix, and Apple has just shown no interest in supporting that. So this will work on the MacBook as soon as Apple invests the effort. Invest the effort to fix that package on their end. But everything else works on MacBooks, including the animations and the interaction with Matplotlib. So you're not completely dead in the water on a MacBook. And do you host it on GitHub? Yes, we do. So you could check it out, check in proposed updates. Check in proposed updates to it on GitHub. You can get the installer right from pypy.org. Yeah. I saw you, well, you showed a surfaces of revolution and ruled surfaces. I wanted to know if channel surfaces are supported. Now, tell me exactly what you mean by that. Like you have like a smooth curve and you use the normal. And you use the normal and binormal vectors to kind of define like kind of circular arcs, I guess. The short answer to your question, there is no channel surface method, but there's nothing to stop you from implementing one and giving it to me so that I can include it in the package. That's the short answer to your question. The more nuanced answer to the question is: once I get To the question is: Once I get this thing going right here, now all you need to do is to create a black box function that is an evaluator for a channel surface. And then you can take that evaluator for a channel surface that just follows the construction, feeds that to the fit to tolerance thing, and voila, you've got something that gives you a spline approximation to the channel surface. Thank you. Yeah. Yeah, okay. Other comments? If not, let us thank Tom again.