The paradigm is that the uh we should have a way of going between uh objects in arithmetic geometry, like elliptic curves, and L functions, so complex functions that arise from them, and objects from the automorphic world like classical modular forms. So, we want to provide a bunch of information about these kinds of objects so that people can. So, that people can see the links between them and hopefully discover ways to generalize those connections into other realms where they're less well understood. So, in order to do that, there are a lot of supporting objects. So, in addition to L functions and modular forms that go into the name of the database, the L of FTB also includes a huge amount of other kinds of information. Kinds of information. So there's a large database of number fields. Number fields show up for many of these kinds of objects as base fields, as kind of coefficients in modular forms, etc. There's finite groups, which is what I'm going to be talking about today. There's Dirichlet characters. So you'll see some of the parts of the LMFDB when I do the demo. So I want to mention briefly that much of this work is collaborative. Much of this work is collaborative. So, the finite group section was developed along with Jen Paulus, John Jones, Lewis Cohns, Sam Skibone, and Minami Roy. And the K3 surfaces doesn't exist yet, but there was a workshop this spring at ICERM. Imre was there, and some of the stuff I'll be talking about today is coming out of his perspective. And then many other people, I'm not going to name them all because there were 20-history people at the workshop. So why finite groups? Well, from the point of view of the LMFDB, finite groups arise in various ways connected to the objects of central importance. So they arise as Galois groups of number fields and of other kinds of field extensions. They arise as Sautertate groups that show up in the Sauter T conjectures and show up in for elliptic curves, but then also in higher genus. Curves, but then also in higher genes. They arise as automorphism groups of lattices, as we saw in the last talk. They arise as automorphism groups of curves. And modular curves show up, and you can build a correspondence between subgroups of GL2Z mod n and modular curves. So finite groups show up all over the place within the LOFDB, but also they show up in other areas of mathematics. So one of the Mathematics. So, one of the goals for this section of the LMFTE is to be a useful reference to other people. So, I think more than many of the other parts of the LMFTE, finite groups show up everywhere. We were motivated to a large extent by Tim Dockschitzer's website called groupnames.org. If you haven't checked it out, it's very cool. So, that provided kind of a framework for what we were. Kind of a framework for what we were trying to do, but we wanted to make it bigger. We wanted to have more groups, more information, and in addition, we wanted to make it more searchable. So the groups that we include in this database mostly come from existing databases and groups. So to a large extent, we didn't go and compute new groups, right? We took groups from the small groups database that exists in Gap and Groups database that exists in Gap and Magma, from the transitive groups database, from kind of the known groups of Li type. So sporadic groups, et cetera. So what are the new features that show up in this database? So I'll show you some of them. But one of the main ones is that you can search. So you can search for groups with certain properties that you might be interested in. You can search for subgroups. So we compute a lot of invariants. So we compute subgroup lattices. So, we compute subgroup lattices for mini group groups. We compute character tables and store them in a way that's more accessible than what you would find in Gap or Magma small group database. Some of the invariants that we compute are non-trivial and take some amount of time. So, the subgroup lattice is certainly an example of that. I'll talk about some more as I show you the database. The database. And one of the perspectives that I've gained working on this project is that groups can be small in various ways. So when you want to say, I want to build a database of groups, well, what do you mean? They're infinitely many finite groups. You're going to have to stop. So how do you choose where to stop? Well, you want some metric of complexity. And there are different ways of measuring the complexity of a group. Ways of measuring the complexity of a group. So, one way is certainly the cardinality. Another way would be if it arises as a permutation group in small degree, then we might think about it as simple. S47 acts on a fairly small set of elements, but it's a big group. That's the largest group that's in the database. If it arises transitively, so with a transitive permutation, if it arises in a linear way, so as a Linear way, right? So as a matrix group in small dimension over some specified ring. So one of the things that this database does so far, and we hope to extend it further, is it takes different sources of groups and puts them together to say, right now we're interested in groups up to abstract isomorphism that show up as small in some direction. And then we'll try for each of those to figure out how. Those to figure out how small it is in each of these metrics. So, if I have some permutation group that's of small permutation degree, what are its linear representations? If I have some group that I added because it was an interesting kind of showed up in GL2, what are its permutation representations look like? What's the cardinality all of these? All right, let's do a demo. I can find that now. So yeah, so Myanmar had something like this, probably on a smaller scale. So can you compare what they have? What do you mean? So they they have access to some small groups that people call. So I imagine it has its own database. So how does it compare to the thing you're doing? Yeah, so I would say Magma has the small group database. So we include a subset of that. But in Magma, you can't. In Magma, you can't search for give me the small groups with solvable length 3 very easily. You have to iterate through them one by one. You have to compute that. You have to compute that. You have it on the table, though. So one of the things that we provide is that we've computed a lot of these invariants and we put it in an SQL table, which means you can search for things with a certain name. Another thing that I think is valuable. That I think is valuable is: I mean, when you think about things categorically, you think about objects and morphisms. All the existing databases are basically databases of objects. And by computing all these subgroup lattices and storing them in the way that we do, we're starting to get access to the morphisms in the category of functions. So you can't do it yet, but one of the things that I would like to be able to do is you give it two groups and it tells you: here are all the homomorphisms between those two groups. Homomorphism between those two groups. I don't think that's something that's, I mean, to do that, you have to know what the subgroup lattices basically are in those and how they connect. So that's something that's possible with the data that we have with a little bit more work. And there's some other benefits that I'll talk about. Any other questions before I get to the demo? Apparently, Acrobat let me anyway. So this is the LMFDB. Um over here on the sidebar, you can see all of the different sections of the LMF DB. The different sections of the LMFDB. So there's a section for classical modular forms, this is a section for look to curves over the rational numbers, the section for L functions. So if you want to pull out your computer and follow along, I encourage you to just poke around. This is all I can experiment with things of interest to you. And down here we have the abstract groups. One thing I'll note is that there's the, this is the basic. This is the beta version of the LMFTB. So I went to beta.lmftb.org. Find groups are currently in beta. We hope that they will be out of beta in the next month. There's some data issues that I'm currently fixing that we wanted to make sure that were correct before we put it into production. So you can see the scope of the database. So we have about 544,000 groups. Groups. They come from a lot of different places. So I told you where some of those came from. I would say the bulk of them are either from the small group database or the database of transit groups. Transitive groups are important for the LMFTB because those show up as GALA groups. But we couldn't just take transitive groups and throw them in there because you can have transitive groups that are distinct as permutation groups. As permutation groups, but become isomorphic when you think about them as abstract groups. So I'll talk about that a little bit later. But this is just abstract groups then. At the moment, this is abstract groups. So the notion of equivalence here is of abstract groups. So essentially, the Gao groups section here is group permutation groups, right? And they're linked together. And linear groups we're working on, but it's not there yet. We're working on, but it's not there yet. We've also computed a whole lot of subgroups, so 275 million subgroups across all of these 500,000 groups. Now, and then characters as well. All of the subgroups are also abstracted in your database in Actually? No. So many of them aren't. The problem is that, so, first of all, So, first of all, we have S47. We are not going to add all the subgroups of S47 because there are a whole lot of them. Secondly, if you want to, as many of the groups as you can, add lots of subgroups, and then add those groups to the database, you have to stop somewhere, right? So there are space constraints that simply That similarly, like there are also processes where you take a group you want its automorphism with. That can be bigger than the group itself. So it's very easy to show that if you take the pair of take automorphism groups and take subgroups, you get all finite groups. So it is not the case that for every subgroup, the corresponding abstract group is in the database. When it is, we try to identify it. Is we try to identify it and link those two. We do not always succeed, and I'll come back to this when I talk about this on the channel. One of the philosophies of the LMFDB is that it should be a useful resource both for people who are beginners and for people who are experts on the subject. So all of us are beginners for some part of the LMFD model. For some part of the LMFD model. And some of us may be experts as well. So it should be a resource where, if you know nothing about this type of mathematics, you should be able to click around, explore, and learn something. And there are a couple of ways that we do this. One is that each of these home pages for a section of the LMFDB has a browse area at the top, where if you know nothing, you can just click, oh, look what. You can just click, oh, nilpotency class. What does nilpotency class 2 mean? And then it will go and it will show you a whole bunch of groups of nilpotency class 2. And the second is that, okay, what does nilpotency class even mean? I can click on this and it will give me what we call a null. So a bit of context-free definition of what does it mean? What does null potency class mean? And then maybe in here, there's some other term I don't know, so I can click on solve. Out now, so I can click unsolvable and it will open that up and tell me what solvable is. So we try as much as possible to make this accessible for people who are learning the subject. This doesn't mean that you could go come here as a high school student and understand you need a certain amount of background. Another way that we try to make it friendly for people who are new to a topic is that there's a link for interviews. There's a link for interesting groups. So we've collated some of these 500,000 finite groups and said, here's a reason that you might want to look at that. So if you click on this, you can see that there's 20 or so of these. And you can click on this and say, oh, this is the symmetries of bioclassic group. That's something that maybe you care, the reason you care about this group. Or this is the first group where. The first group where the automorphism group is smaller than the group itself. So that's a question that you might have. Does this happen? Or a famous result that you might learn in elementary group theory is that the commutator subgroup is the subgroup generated by commutators. It is not the subgroup of commutators. Where does that first arise? In order 96. So here are two examples for that choice one. You can also click on random. You can also click on random groups. So let's see a random group in the database. This is a random group. It has order 655,360. How do you know? It says. It says. There's just a random group. So what's notation for the structure of the group? That's a great question. I'll come back to that when I talk more about it, but it's roughly that we've. We've uh we've yeah, uh, magma has a command called group name that Tim Dotch. Yeah, yeah, yeah, I think that's the fun of this, but I don't understand that. Oh, like what it means. So colon is a semi-direct product. Dot is a non-split extension. I see. And then it also has wreaths product, I think. It also has wreath products, and then there's sort of direct products, of course. And then there are sort of the foundational building blocks. Of the foundational building blocks that you're probably familiar with. And it's an interesting question of trying to find the best name you can for a group. So Magma's group names has an approach where they just say, all right, we're going to try a bunch of things to try to make it as good as we can and eventually we stop. We take that as our foundation. But if we're computing the whole subgroup lattice, then that allows us to improve those names sometimes. Those names sometimes. Sure. And so we do that. I will warn you that. Is there a link to a description of that location? And does it tell you which automorphism is the central, is the central pilot? It does, yeah. So if you go down to the constructions, at the moment here, it doesn't, because this group is big and we didn't understand. But for smaller groups, it will tell you all of the ways that this group arises as a semi-direct product. Group arises as a semi-direct product. And so you can see for this particular one, it arises from that particular subgroup and reconstruct a little bit of that. Okay. So browse is great. It lets you kind of poke around and try to understand what's going on. But maybe you're interested in some fact about groups. You want to know: is every Is every nil button group solvable? Is every solvable group nil-putton? Is whatever, right? So there's also a way to search. We have a bunch of search fields. So you can say, all right, what are all the groups with center, a cyclic group of order four? You look up the label for the cyclic group of order four, and then you can search for groups where the center is that group. Or I want to know all of the I want to know all of the non-abelian simple groups. I want to get a list. So you can search for groups with certain properties. Here you'll see that we have 570 non-abelian simple groups in the database at the moment. You'll see your familiar friends, and you'll see a whole bunch of BSL teams. But you get there's A8, here's M12, you start seeing some of those, some of the sporadic groups. Seeing some of the sporadic groups. I'll note that this is only a subset of the search options you can use. So you can also click advanced search options. It will give you even more. Can you also have more complicated queries where you have a range or a list of exponents that's allowed? So, for these text boxes, they have like a gray thing, which is a suggested input. Any input that takes integers, you can have combinations of ranges and commas. Different of these text boxes have different kinds of underlying processing modes. So, like that, if you look at order statistics, one of the ways you could try to identify a group is say how many elements are there in. Group is say how many elements are there in the group? And so if I know that for a given group, then I can try to put that in here in order to find it. We'll talk about how you might find a group a bit later. But yeah, you can do lots of queries. If you're querying, and there are 500,000 groups is a fair number, but it's small enough that even if you build a complicated query, it should succeed. It should succeed because it can manage to do just a sequential search through the whole thing even if it doesn't succeed at using an index. If you're searching on subgroups, that doesn't always work. 275 million is large enough that if your query doesn't work with the indexes that we've built, it may time out. Is it possible to search for a group that fits in some exact sequence? Yeah, I'll come back to that. That's not this search input. That's not this search input. So here you have an abstract search for groups, but you can also search for subgroups. So this is a subgroup search, and you can say, I want the subgroup to have a certain isomorphism class. I want the quotient to have a certain isomorphism class. I want it to be semi-direct. So, for example, you're in a talk and they say, I'm looking at the certain subgroup. The certain subgroup of sp43 of order 820, or whatever, I think, 723. That's a more likely order for sp43. So you can go and you can say, oh, how many of those are there? Which one do they mean? How do they specify it? And find the exact number. Yeah. So I guess those of us who have done AI-related things in math, I mean, we use such embarrassingly simple AI constructions. I mean, a professional would be embarrassing. Would be in the best. So, here, regarding your database, is it also rather simplistic or is it actually top of the line? I don't know how to answer that. But I didn't understand the question. Well, so is it like to support such a thing, is it something that a Google engineer will be impressed, or is it at that level considered simple? In terms of size of the data, this is certainly much smaller than what Google is dealing with. On what Google is dealing with. I mean, this is terabytes Google is dealing with much larger scale. I mean, also, Google has thousands of employees. So I think we're using reasonable technologies. So one of the first things that I did when I got to MIT was switch the LMFDB's backend technology from Mongo to Postgres. Postgres is an open source SQL implementation that's, I would say, the best option out there. I mean, there are others, but it's very Out there. I mean, there are others, but it's very good. And given your resources, given our resources, I think the project is doing well, and I feel comfortable recommending the solutions that we've had to other people. Yeah, I mean that using an open source database server is a great idea. You don't have to worry about something changing. I guess in terms of data-based design, this isn't the challenging this isn't particularly challenging except for the structure of our data. I guess this is one of the things that's very interesting about our database that's different from a lot is that our data changes very rarely. You look at a lot of people's data, the way they think about it, is you have some data. The data's coming in all the time, you need to update and insert and various. The other thing that's weird for us. Queries. The other thing that's weird for us is that we have no idea what queries we're going to run the loader. So, most professional databases, you have some workflows, and so you know what queries you're going to be running. We are exposing our database to users and letting them design queries, right? That's the whole point. What's the query? So, it's basically the combination of text boxes that you can put in here. It'll generate an SQL. In here, will generate an SQL command that will give you a set of rows from the database, a set of groups. And that makes some things challenging because you want those queries to be fast. You want the user to be able to... That was my next question, because if you have, I don't know, 200 million subgroups, then for some queries, I imagine that we I don't know what hardware is behind this. Hardware is behind this. It could take quite a while before it doesn't come back. Yeah. So the web server, we have a 30-second timeout on. So if the query takes longer than 30 seconds, you're out of luck. You're out of luck for the front end. So we build indexes for the queries that are most common. But the subgroup table has been a challenge, and we have not solved it yet because there's about a hundred and I think just 100 and I think just under 200 gigs of data, but when I tried to build enough indexes to support the queries that we've got a half terabyte of indexes alone, and so we had to scale those back. So currently at the moment, various queries you might try on the subgroup table are going to time up. So we're still working on how that's going to go. You can connect an SQL database directly, in which case you don't face In which case you don't face the timer. So if you want to work on that a little bit, not through the web interface, but through Python, you have an ability to do that. Anyway, I'm going to be interested in the website showing the actual query. You can. Oh, the SQL command? Yeah. Yeah. So if you're So it it wouldn't be hard to do. It is already there to an extent. So in between SQL and the web server, I wrote a Python library that lets you convert Python dictionaries into SQL queries. So the way that this works is you have all these input boxes. It goes through those input boxes one by one and builds the query as a dictionary. One by one and builds the query as a dictionary gradually, and then it executes that the SQL command from that dictionary. That dictionary is on this page, it's hidden. So you look to the source, you find that dictionary. It's an interesting idea. We should talk about it later. Other questions? Just a quick one. So the rest of the questions are the most important. So the the the REST API then is sending HTML, so there's no way to get this JSON from uh yeah it's a great question. So uh there there's a couple of things you can do. So here you have search results. You can download those search results. I'm not going to do that here because there are 275 million of them. I didn't put any constraints here. But maybe I'll take the suggestion and look only at the subgroups of the group 120. Of the group 128.207. So now there are only 140 of these. So now maybe I want to show some more columns. So I guess here it's displaying everything by default. And then I can download. At the moment, these are the options for download. So I can download to text, I can download to CSV, which is something you could upload pretty easily. And then I click download, and oops, I accidentally hit it twice, but I get a download file. Twice, but I get a download file and it looks like this. So that's one thing, that's one thing you can do. If you're looking at a particular group, so here this is 128.007, this is that ambient group. I can go over here and look at the underlying data. This is the data that's coming out of the database. So I'm going to talk about this a bit more later, but there's multiple tables that's creating this. So this is the group table, but then So, this is the group table, but then there's also a conjugacy class table, and then there's a subgroup table. And this you can view in HTML or in JSON. So, you can click on this in JSON, and it will download it for all the things related to 1.8 and 1.7. So, there are various ways to access the data, kind of at different levels of directness between kind of human niceness and computer niceness. And the API is a reasonable way. Is a reasonable way. Personally, I think the Python interface is a little bit easier for a lot of things you might want to do with it. But if you wanted to write something that wasn't in Python, then the REST API, the JSON APIs. Yeah, so this is a picture of the group. So a lot of parts of the LOFDB have a picture to sort of give you a visual of the group of the objects. Of the objects. So, for elliptic curves, it's easy. We show the real points. For elliptic curves over number fields, you show the real embeddings. So, here we take the conjugacy classes, and each of those dots is a conjugacy class. The size is proportional to the size of the conjugacy class. Which ring you're in is the number of prime divisors. So, there's a white conjugacy class in the middle that you probably can't see. That's the identity. That's the identity. And then the first one, that first ring are the elements of order 2. You can see that there are 7 of them over here, and there are 7 of those little dots of order 2 conjugacy classes, and then these guys are the order 4, and then the outer layer is the order 8. The color is determined by the order of the conjugacy class. So this conjugacy class is, and this is the two groups, so all the groups are sort of reddish. But if you go back. Back here and flip another end group. This is a 2N3, so the blue dots are order 3 elements. Order 6. So I mean, there are lots of questions here. I'm happy to talk about that. So do you have something like a plug? Plug into some computational algebra system. One can then do your computational algebra and go to this thing and fetch things. So you're talking about the other direction. So we've talked about that for the LOFDB at various points. At the moment, I don't think there's anything that's easy to use. I don't think it would be that hard to build some of. Think it would be that hard to build some of this. So, various people have talked about doing it in Sage. I think Sage is probably easiest to do it in. You have the Python library that interfaces with it, right? You can have all the library from Sydney. Yeah, so because, yeah, so if you're in Sage, I can literally do this. But if you want to construct a Sage finite group, you have to go through some annoying steps. Right? So, yeah, you can query the data, but if you want to get the But if you want to get the object that corresponds to this mathematically in Sage so that you can do further computations with it, at the moment, that's not trivial. But what I will say is that if you scroll down here, you can show commands. So on the front end, this is a command in Magma that will let you construct this group. And this is a command in Gao. So we're And GAAP. So we're in the progress of working on this. This particular feature, I think, was enabled over the weekend. So that's not part of the download button? At the moment, that's not part of the download. So there's downloads of search results, and then there's downloads here. We'd like to have download to Gap, download to Magma, download to Sage. Those existed last week, but they were kind of broken, so they got disabled over the weekend. Again, we're working on it. But the. Working on it. But the ideal is that if you have a particular group, you can download something that will have all the information for that group in a format that you can just load as a file from Agma or a file for Sage. There's a separate feature request, which is you're in Sage and you want to get the group 128.207 out of this database, together with all of the information that's been computed about it. And that's not And that's not present. It's totally a reasonable feature request. The main difficulty there is that you have to figure out how all the things here correspond to the corresponding structures in Sage and reconstruct those in a useful way. And that just takes some work. Yeah, so not to sort of go into it. We have such a thing for magma and our various volatile. Our where is volatile already and uh one one of the issues is that uh it comes out as text and then you type it and then all the work you go out. Yeah, it's really good. Yeah, I mean this is I would say this is definitely a problem that a lot of people have been thinking about. It's like you have these different systems. I mean here we have a database system, you have computer algebra systems, you'd like to have ways for them to talk to you. You'd like to have ways for them to talk to each other and send data between each other. And that's just hard, partly because there are lots of systems, partly because they have different internal representations of things. So there's ideas of trying to have one kind of representation in the middle that you can go through to reduce the combinatorial explosion. That was something that was kind of investigated as part of the Open DreamKit grant. Open DreamKit grant grew up from 2012 to 2020, something like that. But I would say it's a hard problem because these things are moving targets, partly, and partly because it's complex. In the prehistory of Sage, this was actually one of the design features of Sage to help solve these kinds of transformations. Yeah, I mean, when I first got into Sage, I started working on Sage because. To Sage, I started working on Sage because I've been writing bash scripts to move data from Singular to Magma and all the right out to file loaded. I mean, we've all seen this. Yeah, so I mean, one of Sage's features is that it connects a bunch of open source software in ways that you can just type magma dot, give it a string, or even like give it a Sage object, and we'll try to convert it to magma. And it works okay. I mean, there are a lot of things that it can do, but just the scope of the features. But just the scope of the features that you need is large enough. And as we were talking about yesterday, the reward for people working on this is very small. I'll include it as well. So while I'm on this page, I guess this was another random group, I'll highlight a couple of other things. So we've computed the automorphism group together with the auto-automorphism group. Here, Here, the outer automorphism group you managed to identify, so that's a particular, this is a link to another group in the database. But the outer automorphism group turned out not to be in the database, so we knew it was a group of order 10,000. And here you can click and find out the generators sort of as automorphisms. We have a bunch of Boolean properties that we've constructed. We decided that a table with 30 rows of yes, yes, no would be very unenlightened. Yes, no, would be very unenlightening. So the Boolean properties are summarized in sentence like this, and ones that are implied by other things. So this is a C group, and that implies that it's solvable, super solvable, monomial, metacyclic, metabelian, et cetera. What's going to happen to all those Brilliant students that had to do the finite group thing? It's not possible to examine them meaningfully. They're just going to go. Don't let them use the internet. Don't let them use the internet anymore. When I talked to Tim, he said that he felt like one of the main ways that his group names Davis got used was students in inter-algebra classes looking at parody table. I mean, they're going to do that for their own. That's just what they do. So you just have to ask different phones so that they use this database. Well, I mean, yeah, or just give them tests in a room without. So, one of the things that we have is if you click on hints, it will tell you the various implications. And one of the cool things here is that there are a lot of implications between Boolean properties of groups. But you can also get that the reverse implication doesn't hold, and you see a bunch of examples. So, that's one of the cool things for teaching with this database: is that all super-solvable groups are monomial, but not all solvable. But not all solvable groups. So there are examples of solvable groups that are non-monomial, and it just takes you to the search results of groups that are solvable but not monomial. So I talked about the picture. You can browse through and find cool-looking pictures. That's pretty fun. I found one. I think it's PSL216. Can you show us? Can you show us it? Yeah, let's see. How do you browse a picture? There's no good way. You click random group. Oh, you go back to the random group. Yeah, it's also a little annoying because you have to go back to click on random group. Yeah, yeah, yeah. I mean, the pictures, the pictures are generated on the fly because they're just coming from very simple data. And so there's an algorithm that produces that picture from the sizes in order for the quantum classes. But that's a great idea to have a picture. But that's a great idea to have the picture. I mean, it could have been an algebraist to draw the picture. Those guys have become a class. I don't know. I consider myself an algebraist. So up to which size of group do these pictures? The pictures stop when the number of conjugacy classes is larger than 2,000. So that's the rule. That's the rule. So, we have groups in here where the number of conjugacy classes is larger, and the small looks better. But a lot of big groups that are in the database don't have that many conjugacy classes, especially the ones that people are interested in. And the simple groups have very few conjugacy classes. People are not interested in absolutely randomized interests because they have particular structure that they're bringing to daily life. So, they have a lot of interesting structures. Structured KSO. Yeah, yeah. So I'll come back and let's see. Alright, SL216. This is your favorite creature? This is not my favorite, but I came across this a week or two ago and I thought it was cool. It just is very symmetric, and it's sort of surprising, right? I mean, it tells you something about this group, which is that. It tells you something about this group, which is that, all right, there's the identity in the middle there that you can't see. But aside from that, all the conjugacy classes have almost the same size. And that's a feature of a lot of these really kind of almost simple or simple matrix groups that you can just visually see here. And then you can go, you can look at the description of the comprehensive class and say, oh yeah, the ones in order two are 255, order three, they're 272. They're a little bit different, but kind of the Little bit different, but kind of in terms of scale, they're about scale. So those pictures are probably good input for a machine learning algorithm that needs to learn things by graphs. Could be, I mean, or you could just give them minutes, right? Like the order statistics. So I guess I just used a feature that I hadn't told you about, which is that if you have a particular group you want to get to, there's a box at the bottom where you can type in the name of that group. Can type in the name of that group or the label. So at the moment, that will work reasonably well. If you have a group where everyone knows it's SL216, it will work fine. But I think if I typed PSL216, it won't currently work. I think that is something that we can fix, but I think it will get a little bit more forever. Something I haven't talked about yet are constructions. So groups have different ways of being Groups have different ways of being represented. And the way that you might think about groups from an intro-algebra class is with a presentation, right? You have generators and presentation. And if you take arbitrary presentations, it's a very bad way to compute with groups. I have a t-shirt about the unsolvable word problem. You can construct groups where it's not possible to tell whether an element is the identity. So, if you have a solvable group, on the other hand, there's a certain type of presentation called a polycyclic presentation. It's basically a filtration by normal suffers, where each of the quotients is cyclic. And that turns out to be very computationally nice to work with. And so, for solvable groups, we'll have that as a description. This group is not solvable, so it doesn't show up. Groups of Lie type, there are a whole bunch of shows. Groups of Lie type, there are a whole bunch of exceptional isomorphisms here, right? That you can see that this is SL216, but it's also omega-4, 4. And so that's one of the features that you get some of these isomorphisms of groups of Li-type. Permutation groups are another great way to compute with groups. Kind of the best option we've got for a lot of these non-solvable ones. So we try to give the minimal degree permutation representation. Permutation representation. Magma has a command called minimal degree permutation representation. I'm not 100% convinced that it's bug-free in producing the minimal one, but it usually does produce a permutation representation. I found some bugs that I think have been. And then matrix groups in various ways. So obviously this one is SL216, so we should have a matrix representation where you can see it. Representations as transit groups. This links to the Galager database. Galager database. Let's go to another group that has a little bit more. I suppose a matrix representation has one, react as one. Yeah, so it could be more than one. Yeah, we'll come back to this. So the ones that are multiple presentations are over different rings. So for example, if we have a representation as an integer matrix with integer entries, we'll show that. With the integer entries, we'll show that. Or over FP or over FQ. So if we have one over F3, we don't also show one over F5 at the moment. We will not. So right now, each of these groups has sort of a dictionary of smallest representation of a given type that we found. So it'll store that we have a permutation representation and the polycyclic representation, etc. We don't at the moment have Have matrix representations systematically for all these groups. We do have character tables, but for example, we don't yet have Brouwer character tables. We don't have much modular representations there. A lot of these groups did get added to the database because they showed up inside GL2 of F5. And so we have some amount of that, but that's something to find. So I was going to try to. I was gonna try to show you another example. So let's look at also. I'm happy to just mostly talk about this demo, but I do have more slides. There you go. Ilian, no. Right, I looked for simple groups of order 32 and it said they weren't it. Uh Uh a bunch of groups for thirty-two. I hadn't particularly played this one to seven. So here you can see more matrix representations. You can also see that. You can also see that it will show you all the ways that this group arises as a semi-direct product. Or that this is not a direct product, but in other cases it will be. Or that here are the non-split descriptions of this group as an extension. This group happens to be a wreath product. This arises as an automorphism group of another group in the database. So because we store the data in an SQL database, Store the data in an SQL database, you can query that and easily find that out. We compute the subgroup lattice. So here, this subgroup lattice is getting a little messy. They get much, much worse. One thing I wanted to highlight is that sometimes the subgroup lattice gets a lot nicer when you look at things after automorphism. When you look at things up to automorphism. So, this is an example of that. So, if I look up to automorphism, now it's much more manageable. It's because a lot of these subgroups were not conjugate, but they became the same up to automorphism. So, an extreme example of this, look at C2 to the 10th. It has a whole lot of subgroups up to conjugateism. It doesn't help me at all. But of course, up to automorphism, there are just 11 of them, right? So we try to compute as much as we can. We try to compute as much as we can. So we came up with a set of groups that we thought were worth adding, that were interesting in some way. And we had a set of things we'd like to compute about them. And then we just went and tried to compute each of those things for each of those groups. Some of the time we failed because it just wasn't possible. Does my computer compute something when I'm playing around with these databases? How much is done on your end that is done? Nothing is done in the browser. There are no actual mathematical computations. So there are no actual mathematical computations done in the browser. Some groups are done in, some things are done on the server. There are a lot of groups of order 512. We didn't add all of them. There are 10 million of them, I think. It's much worse for 1024. But what we do do is these groups do have labels, so small group IDs. And so you can compute some. And so you can compute some amount of information on the server just using GAP. So that's what's done here. So it gives you a warning at the top that says this is not in the database, but I'll do what I can. I'll compute some of the information. So it doesn't have the full subgroup lattice, but it's able to compute the company C classes. It's able to compute some maximal subgroups, some information. See, it's got the picture. It's able to produce a picture of all of those classes. Less than 10 minutes. Is it also possible to see? Less than 10 minutes. Is it also possible to see what you've done with the K3 metal? Yeah, sure. I'll stop on this. So I'm happy to talk more about all this. Let's go back to the slides. Demo. Just briefly, hashing. So we came up with an isomorphism invariant hash that worked really well. So that was a cool outcome. So that was a cool outcome of the project. Here's the highlight: we were able to compute the hash for all the groups of order, 1536. There were 400 million of them, and there were not many coins. And that's a big help when you have some group and you want to know what it is. You can compute its hash, and that lets you match it up with possibilities. Or you have a whole bunch of transient groups and you're trying to oil them down up to isomorphism. Instead of doing pairwise isomorphism tests, you compute hashes. I think she's got an smaller question. I think she got a bit smaller questions. I talked about conjugacy versus automorphism. There's various challenges. We ran into lots of bugs in Magnum. But that's inevitable, right? Absolutely. And I think it's one of the big features of doing a database project because you find these bugs and you report them and they fix them. And sometimes fail. Yeah. So I'll talk more about the challenges later. So, K3 services. So, first of all, I'll say a caveat, which is that I I'll say a caveat, which is that I'm not the most expert person in the room on K3 services. I haven't really worked with them much until this workshop, but I got involved in this workshop, and I think they're cool. And I think that they're, if you're looking at kind of frontiers for arithmetic geometry in terms of database stuff, we've got a bunch of stuff on curves. We've got some things on abelian surfaces. K3 surfaces are a natural kind of next step. And they have a whole bunch of interesting things about them. Of interesting things about them. So there's people approaching them from lots of different directions. So because there's nothing in the LMFDB yet, I wanted to tell you kind of basically one lesson that I took away from our workshop. And that is that there are lots of ways to think about K3 surfaces, and it's worth thinking about that before you, as you design what your database should look like. You design what your database should look like. So, what I'm thinking about building a new section of the LM FDB or building a new database, the thing I start with is what is the schema? What do the rows correspond to? And what are the columns that I want to confuse about each of those things? So, for these mathematical databases, often the rows are some object, right? There's some, each row is going to be a K3 surface. Now, for K3 surfaces, this turned out to be particularly challenging because it's different than. Turned out to be particularly challenging because different people had different notions of, all right, do I, is it a particular equation? Is it an isomorphism class of unpolarized K3 surfaces? Is it a lattice polarized family of K3 surfaces? Is it a toric K3 surface? So the slides here, I'm going to try to tell you some people's different perspectives. And then you take those and you try to think about: all right, how do I design a schema? What do I want to compute? For those things that I want to compute, Those things that I want to compute, what it is, what do I store? Like, literally on the computer, I'm storing, I need to boil things down to a list of integers or a string or some set of floating-point numbers, right? What do those mean? How do they connect? So that's the output that I was focused on in our workshop in February. And that'll get refined as you write code to compute these things. You realize, oh, I can't actually compute that. Oh, I can't actually compute that. I don't know how. And then you write a paper about it, or you talk to someone who knows how to do it. But that's the kind of my organizing principle behind creating kind of a new database like this. So I wanted to show you some of the complexities that came up with K3s, because I think they were interesting. So I know we just had a talk on K3s, and I'm low on time, so I'm going to skip this slide. But K3 surfaces are particularly K3 surfaces are particularly a nice kind of surface. One of the reasons that they're nice is that they connect to arithmetic in the form of lattices. So every K3 surface has a neuron-silveri lattice, and then you can break that lattice up into particular parts. And conversely, if I start with a lattice that embeds inside some particular rank 22 lattice, then there is a fair. There is a family of K3 surfaces whose neuroinceratory lattice contains that. So, this is most kind of most studied at the extremes. So, when that lattice is very small, if that lattice is rank one, then all you have is the norm of the vector. And the norm of the vector is going to be some even integer. And then the k3s that contain that particular lattice. That particular lattice are going to correspond to the various kind of traditional families of patient systems. So the lattice polarized family for the lattice, the rank one lattice, vectors of square norm two are the double covers of PTP branch along the cycle. If you look at a different lattice inside, you get the cortex hyperinsojes, et cetera. On the other extreme, if your lattice is very big, sort of as big as possible. Is very big, sort of as big as possible for the algebraic part of their insevariology. Then the moduli space is zero-dimensional, and you just get a bunch of special K3 surfaces, the CM, the CA K3 surfaces. So a lot of people, when they think about K3s, they think about this. They think about what is a K3 surface? It's basically a lattice. It's the kind of a moduli space of K3 surfaces thought about in this way. You can also use this lattice to find elliptic. Lattice to find elliptic vibrations. So the signature of that big lattice, ranked pointed T lattice is 319. But you cut that down because not everything is going to be algebraic, so you get 119. And so if you have a 1, 1, you have a hyperplane, or not a hyperplane, you can split off a piece of that, split off a U, and that exactly corresponds to elliptic vibrations. So you get a negative down. You get a negative definite lattice, and the number, the kind of the set of possible elliptic vibrations, essentially corresponds via genus theory to the genus of that negative definite lattice. And so you can use this to study elliptic vibrations as well. What about unpolarized surfaces? So this kind of that having that lattice gives you some kind of polarization. A lot of the time we think about polarizations. But if you want to think about A3's up to sort of very abstractly, this was Emery's. Abstractly, this was Emery's perspective, that we should think about their periods. So we should look at the period map and take the Hodge structure and look at where these land. So if I have a particular concrete K3 given by an equation, I could try to construct its period lattice. And that would allow me to determine that maybe two K3 surfaces that on the face of it look very different actually are the same. Abstractly isomorphic unboxing. Abstractly isomorphic with unboltized surfaces. So that's just another perspective. And these two don't really belong in the same table, right? So you want to have maybe two tables: one for your lattices and then the information that comes with the lattice polarized families, another for the elliptic vibrations, and another for period map. These unpolarized K3. In the physics literature, K3s come up as a two-dimensional analog of Calabiat, and there, they think about them. And there, they think about them, the reason they're interested in them is with this mirror symmetry. And that mirror symmetry relies on them being hypersurfaces inside a torque merry. And so there's a classification of three-dimensional reflexive polytopes. There are 43, 19 of them. And you can think about K3s inside there. And so you get certain special families of K3s with a mirror symmetry relationship between them. And for a lot of people, that's what they care about when they think about K3s. And so this doesn't really fit. And so this doesn't really fit into any of the previous perspectives. So you need to have, think about how are your p-feries related to lattice politopes, which ones, how do these fit. So we created a schema. I can't click on it. It's also kind of complicated. So much of the work that I was working on in February was taking each of these perspectives, trying to write down: all right, what are the eight Trying to write down, alright, what are the 8 or 10 or 20 things you want to compute about these? How do they connect? Well, this label needs to match up with that label. All right. So, I mean, there is another issue. So, I'm sorry to be generic, but I sort of wonder. Because you can't expect you to put everything in one way, like that every. You will need many tables. And then, in the end, there is some structure that if the tables have some common columns or whatever, you can plug them in and make another table. I don't know whether I call it an opera, okay? Yeah, there's some data to normalization, yeah, like fully normalized or something. For the LOFTB, I think our guiding principle is coming from the search. Coming from these search interfaces. So, our mission is to provide an online search interface for people to be able to search for objects of interest with certain constraints. And so, that helps design our tables because you think about what do you want your interface to look like when you want to search for groups. Those are the columns you need to have in your groups page. So, that helps us. But even there, sometimes you abstract things out and you take some of the data in order to make your search small, in order to make your search. Your search small, in order to make your search table smaller and more performant, you extract out some columns. And also, some people will think of some other things that they want to do. And you add some columns. Or tables. And then if people want to do research with this stuff, they will arrive. Whatever echoes now, will have to be. Yeah, happy to talk more about this. Oh yeah, yeah, yeah. So, I had some bonus material. Since I didn't get through my oral material, I'll skip it. But one of the things that I hope to get from this workshop is talking to people who are also interested in building their own databases. So, if that's you, come talk to me. I have thoughts and resources I want to. Output transcript So there were lots of questions already. We interrupted Dick a lot. I don't know if we need to answer questions. Yeah, let's yeah. Yeah. Yeah, one one question. Uh my collaborator uh Simon Manhos and um Tomio Tomi Hoffmann have made a database of faithful actions of finite groups on K3 surfaces that brings both. Have you been in contact with them? I haven't. I mean the K3 is still a very early stage, but yeah, we'll have to be contacted. But yeah, we will have to be connected with the groups. Yeah, I mean one of the things that you get with these groups is that you get group actions from the group action. And so. So this is a question, right? That the philosophy here has been that recorded questions, you stop recording. And that gives people the freedom to speak off the record. Sorry. The record. Sorry. I don't know if that's meaningful or we've got this. It doesn't affect me. I don't mind. I don't know what people think about this. People watch more impacting will not speak up like that. Yeah, we just wait for the after I have minutes. They can ask their questions. It's fine. So, in answer to your question, I haven't been in communication with them. So I would say that the finite groups database were still trying.