Oh, this. By the way, the recording will go live screen, and then anyone may apparently there are a lot of research from the Law of Board's website. All right. Okay, so Okay, so yeah, I got a great setup from Jank and also yesterday. So we can be very brief, but like background. So I'm going to be mostly talking about inferring migration instruments for metastatic cancers. And there's like three stories I want to focus on. So the first story is the Machina paper. So how do we infer parsimonious migration histories for state cancers? So this was work that I did. So, this was work that I did as a postdoc with Nara Fao and Greta, who's here in the audience. It's also an author on this paper. So, let's talk a little bit. I can skip this. We all know what inatom hygieneity is. But what I want to talk about is metastasis. So, that's the spread of tumor cells from the primary tumor to distinct anatomical locations. And it can also be spread from one location from one metastasis to another metastasis. So it's important to realize that most cancer patients die because of metastasis. So it's actually super important to understand what is the battery spread. Can we reconstruct what happened getting sequencing data of a primary tumor and also metastases resected from the same patient? So, you know, ideally, we would be able to observe the evolution. Observe the evolution of a tumor in real time. And if we would do that, we would be able to infer this cell tree. So basically, you know, cell division is binary. So we have on one side, you have two daughter cells. We can track which mutations were introduced, and we can also track the location of the cell. So this is the primary tumor. So here we had a migration from P to M1. It was another migration from M1 to M2. So this is the cell tree. But we don't have technology that does this. Have technology that does this, so the best that we can do, and you've seen a lot of algorithms already about this, is infer this phylogenetic tree that is kind of like a coarse-gray representation of what actually really happened. And in addition, we only see this typically at one time point, at the present time. So for the leaves, these are the accident clones that we observe. We know their locations. So that's what I'm indicating here with colored boxes. With colour boxes. And what we're trying to do when we want to infer the migration history: so, if you look at a cell tree, we actually, you know, we know the location of the ancestral cells, but when we do tree inference using data from the present time, we don't know their ancestral locations. So getting a migration history actually revolves around labeling these internal nodes, which correspond to ancestral clones, with location. With locations, anatomical locations. And there are many ways of doing this. So typically, so this is again a key principle that we have in Compile. If there's many different solutions, we typically would prefer a solution that is the simplest, the most parsimonious. So that's basically what we want to do here. So we want to identify a vertex labeling that leads to the fewest migrations. And so here's an example. So, here's an example solution. So, we have three migrations. So, this goes from green to red, red to blue, green to blue, and it corresponds to the cell tree. So, what I just showed you here is a problem statement. And if you actually squeeze a little bit, you can see that this actually corresponds to a very classical problem known as the small maximum parsimony problem. So, this was first observed. First, observed this notion of inferring migration histories by Malbin as a small maximum parsimony problem. It was done for the first time, as far as we know, by Slatkin and Madison. So it was in the context of evolution of corporations. So why parsimony? Are we meaning that is? So if you don't know what happened, it's actually, you know, you should look at simpler explanations. You know, you should look at simpler explanations first before concluding something really complicated. So that's the key principle. And this is a very fundamental principle that's used in a lot of problems in computational biology. And I'll get back to this. So you could actually think about is parse money always the right thing to do? Can we think about other signals that we could use to assess whether our migration is makes sense? Yeah, let's get back to this. Yeah, let's get back to this. So, for now, we're just going to stick with parsimony. I mean, parsimony is not a principle of computational biology. Parsimony is a principle of the algorithmic side of computational biology. We're going to have religious arguments. Okay, okay. I mean, I think you should have multiple solutions, including ones that are near multiple parsimony. That's actually a good point. I will show you an example where parsimony will fail. So I'm not saying that parsimony is holy and don't look at the other solutions. At the other solutions. So that's actually going to be like the third topic of my talk. I'm actually going to advocate for looking at the entire solution space, including sub-optimal solutions. But it's actually good to think about a problem, just to simplify it a little bit. Think about parsimony first. So in a small maximum parsimony problem, so basically what we're trying to do is literally what I just described. So we want to label the intonal vertices of the tree. The internal vertices of a tree, and we are given the leaf labeling, and we want to minimize the number of changes along the edges of the tree. And this can be solved using dynamic programming. There's two algorithms, the Fitch algorithm and the Sankov algorithm. So these are classical algorithms. And they solve this problem in polynomial time. So this is an easy problem. If you go back to Schenck's description, this problem is in P. So this idea of using This idea of using parsimony to think about migration histories for metastatic cancers was actually first done by the group of Sorak Shah in a paper in 2016. And they applied this to ovarian cancer. And here I'm going to illustrate the solution they got for one patient. So this is ovarian cancer patient one. And this is the tree that they inferred using the Senkov algorithm. Using the Sankov algorithm. And you can actually extract a migration history on this tree. So, what did I do? So, I only looked at the edges that correspond to migrations. So, there's a migration from green to orange. So, here in this migration graph, the nodes correspond to the different anatomical locations. And I'm basically just moving the migration edges to this graph. Okay? So, what you see over here is a migration graph with three. Migration graph with 13 migrations. Now, going to this point about solution space. So, this is the sole solution that was reported. So, there's a danger here. So, you don't want to report only one solution. You want to think about the space of solutions. So, if you look at just the optimal solutions, there's four more solutions. So, here the right ovary was the primary tumor, and there are four. Tumor, and there are four other solutions where the left ovary is the primary tumor. And if you just look at it, some actually look very, you know, look simpler in a sense. Like here, you needed a small bowel, it's kind of like a staging location to see the other locations. But here it's kind of like directly from the primary. So that basically led us to think about this a little more carefully. So, can we think of another criterion to distinguish these solutions? And what we What we found was this really cool paper where they observed experimentally that in the bloodstream of animal models, that tumor cells migrate in clusters of hundreds of cells. And in this particular paper, they actually were able to see that such a cluster of cells was composed of cells from two distinct clones, two distinct lineages in the tree. Tree. So, this is big. So, basically, what this means is you can have co-migrations. So, for instance, these three migrations from green to red, from the right ovary to the left ovary, they could have happened simultaneously. Could have been a single cluster of cells that co-migrated. So, this is a co-migration. So, co-migrations, if your graph is acyclic, they just correspond to the number of multi-edges. Correspond to the number of multi-adges. So here we have 10 co-migrations for this solution. So if I go back to the four other solutions that we inferred, so this is what was reported. So 10 co-migrations. And then if I look at these two solutions over here, they only have seven co-migrations. So this is another criterion that allows you to disambiguate different solutions. So this is from the market paper. So there's actually a trade-off between migrations, co-migrations. Trade-off between migrations, co-migrations, and the pattern of migration. So, let's try and understand what's going on here. So, this m is the number of locations that we have in our data. So, it includes the primary tumor. So, the primary tumor doesn't need to be seeded. It already is there. So, every other location, m minus 1, needs to be seeded. So, this gives you a low bound of you need at least n minus 1 migrations. So, that's basically this vertical line over here. And go migrations. And co-migrations are grouping migrations together. So the number of co-migrations is at most the number of migrations. So that's kind of like what you see over here. And in the simplest scenario, every location, every metastasis is seated by a single clone. And that corresponds to this monoclonal single source seeding. And you can make it more complicated. So you can get a directed acyclic graph. A directed acyclic graph where a location is seeded from two other locations, or you could have even cycles. So this is reseeding. So this actually allows you to classify different seeding patterns just by looking at migrations or co-migrations and how they occur in the clone tree. And actually, if you look at the representation of migrations in a migration graph. So the problem that we posed in the Machina paper is this parsimony. Is this parsimonious migration history problem? So we're given this phylogenetic tree T, and we're also given the locations of the leaves. And we're trying to find a labeling of all the internal vertices that minimizes first the number of migrations and then as a second objective the number of co-migrations. Okay. So that's that's what we're trying to do here. So that's what we're trying to do here. And there's an additional knob that there's an additional parameter that you can use. You can actually specify what do you want the graph to look like. Do you allow only single-source seating? Do you allow multi-source seating? Or is you know, do you allow anything? So like you see the bottom. So the less restrictive you are, The less restrictive you are, the better the number of migrations and co-migrations will be. So, this is an example. So, don't you need a trade-off between the middle and the medium? Gamma? So, yeah, so which one is better, 6.2 or 5.3? That's hard to tell. This is a multi-objective optimization problem, so there's not clear. So, you could actually argue that you could look at the gut. That you could look at the gap, like how many additional fewer migrations do I have if I allow a more complex pattern? So, here it's just, you know, you pay, you only get one fewer migrations. So, you could argue maybe it's not, you know, maybe the pattern is too complicated and you don't get much back. So, there's like low returns. So, this is something that an end user has to decide. But what I'm arguing here is you just need to look at multiple solutions, but also think about what are the different patterns that you have. What are the different patterns that you have? And that's kind of like your solution space. So it's kind of, it's a little bit unfortunate. So ideally, you would just get a single solution and that's it. Like, that's ideally what end users want, just a black box algorithm and then one solution. But the data doesn't support that. So in the Markina paper, we actually looked at two extensions. So one extension is, so both extensions have to do with clone tree ambiguities. To do with clone tree ambiguities. So, if you remember the cell tree, I told you that every cell divides into two daughter cells. So, the cell tree is this binary tree. So, here in the clone tree, we actually have polytomies. So, these are vertices that have more than two children. So, this doesn't jive at that cell tree because the cell tree is binary. So, the reason why we get polytomies is we're only looking at data at the present time, so we don't track cell division longitudinally. Cell division longitudinally. And our data is also of limited resolution. So we have to cluster mutations together. So there's a lot of signal that we lose. However, if you actually look at these polytomies, so if you don't, if you just leave them intact, so the best solution that you can get here is something that's polyclonal single-source CD. So it has full migrations and two co-migrations. However, if I look at this polytomy over here, If I look at this polytomy over here, it has four children, and three of those children are actually labeled by red. So, what I can do is I can just connect, insert a new node, and assign those three children as children of this new node. So, this is going to reduce, so instead of having three separate migrations from green to red, I only have one migration from green to red. And this will give you something that is the most parsimonious explanation. The most parsimonious explanation you can get for any type of data, which is monoclonal, single-source CD. So every metastasis is seeded by a single clone. Okay? So that's this PMHDR problem. Is this actually solving the issue of us, for instance, not observing small subplumes in certain samples? Is it solving the issue of us observing Us observing not, well, not observing small subclubs in certain samples, or we're just having some sampling noise that we missed subclub that was present there? It could be, so essentially what's happening here is we're saying that, if you look at the solution over here, we're saying that this clone, this green, that this clone that had the diamond, was present in a primary, but we did not observe it in metastasis 1. Wait, let me check this. I can move carefully. No, that's not what it's saying. No, the reason why we had these polytomies is, you know, actually there were no additional mutations that distinguish these two clones that we have here. And that could be because of resolution, or it could also be because nothing happened in between that we could actually observe. Okay. Yeah. Can you I mean, can you resolve that by like labeling your internal nodes with two states? What are the two states? Green and red. But that's what we're doing here. Or you mean like a single node labeling by two additional characters doing the tree surgery. Yeah. Doing the tree search, just doing surgery on the clone tree to fix it. That seems awful. Yeah, just hold that thought. That's actually going to work when we think about it. That's actually going to work when we think about enumerating solutions first. We do like this multi-labeling. Okay. Yeah. Good. Okay, I'm going to speed up a little bit. So I'll skip this. I'll also skip this. All I'll say is there is another version of this problem that works directly using CCFs. And you can actually do tree inference together with migration history inference. So what I want to talk about now What I want to talk about next is the oral consistency. So this is joint work with my PhD student, Miramoy and Sagi from the University of Paifa. So this is work that's currently under review. So let's talk a little bit about this. So what exactly are co-migrations? So I gave you this hand-wavy definition. Co-migrations are migrations between the same pair of locations that happen simultaneously. That's what I told you. So in the absence of receding, So, in the absence of reseeding, the number of comma gadgets equals the number of multi-adges that you had. That's an important statement. What is an important statement? In the absence of reseeding? Yes, yes, that part is important. That's an important statement. Yes. So if there's reseeding, things are more complicated. So let me show you an example. So here we have this very simple graph. So there's only two locations, blue and red. So blue seeds red, red seeds blue, and blue seeds. Red seeds blue, and blue seeds red again. So, if you look at the migration graph, you have a cycle. So, if you just count the number of multi-edges, so there's one multi-edge from blue to red with four migrations, and there's another multi-edge from red to blue. So, you would conclude that the number of co-migrations is two. However, this is incorrect. And the reason why is if we would conclude that the number of co-migrations is two, we would actually say that these That these and these happen together simultaneously. But that's not possible. So to actually have W, W is a descendant of V. And to get V, this migration must have happened first. So there's something weird going on there. So what we did in a marking up paper, we actually had this definition that defined co-migrations as migrations between the same pair of sites. Of sites, and the migrations have to be on distinct branches, on distinct lineages. Okay? So that basically means that you cannot group these two and these two together because they're on the same lineage, on the same branch. So you have to split it. And the way we did this in Machina, we actually proved that the minimum number of co-migrations that you can get respecting this condition. Respecting this condition is very simple. All you have to do is you look at two locations. So we look at migrations from blue to red, and we look at all root to leaf paths. And we count for each root to leaf path. How many migrations do I see from blue to red? So each root to leaf path will give you a different number, and we take the maximum. So the maximum, that's precisely how many coma gauges you need. You need. Alright, so that's basically what this is saying in words. And you can actually extract the co-migrations very simply. Just from this number, you can actually do a tree traversal. You sweep and you get the co-migrations that way. So what we start thinking about with SAGI is, is this actually okay? Is this a sufficient consideration? Okay, is this a sufficient condition for temporal consistency? So, what do I mean by temporal consistency? So, let me just illustrate this over here. So, here's an example tree, and we see a branch that has a migration from red to green and from cyan to orange, and another branch where the same two migrations happen, but flipped, they're reversed. So, according to our definition, the number of co-migrations from red to green. Co-migrations from red to green is one because this branch has one migration and the other branch also has one migration from red to green. And similarly, cyan and orange is also one more migration. So we would basically say that these happen together and these happen together. Yeah, and I see people already shaking their head. That's not possible, right? So there's something broken in that definition. So that's basically what we wanted to study. What we wanted to study in this work. Like, how can we fix this? So, in fact, if you would do this correctly, if you would try to actually time your migrations, you have to break one of the two co-migrations. So, either you break psi into orange, which is what we did over here. So, this one happened first, and then these happened together, and then this one happened over here. But that leads you to one additional co-migration. All right? So, what we did here in Machina. But what we did here in Machina, it actually gives you a low bound on the number of co-migrations that are temporally consistent. But that number might not be attainable, actually, in practice. So the next natural question that arises is like, when is a co-migration, a set of co-migrations, temporarily consistent? So what we did is precisely what I described over here. So essentially, what you want to do. Over here. So essentially, what you want to do is each co-migration in this set of co-migrations C, you want to be able to assign it a timestamp. And there are two conditions. So migrations that are part of the same co-migration, they must receive the same timestamp. And the second condition is that time, you know, as you traverse down the edges of a tree, moves forward. Okay? That's basically what we want to have. So, this leads to this problem. So, given a rooted tree and a set of co-locations, can we find timestamps such that this set of co-locations is already consistent with tau? So, here in the solution is yes, and these will be the timestamps. And for this input instance, the answer will be no. So, this is a decision problem. Well, yes. So, basically, it's kind of like saying, do there exist timestamps? And here's the answer: these are the timestamps, or no? These are the timestamps, or no, there's no such timestamps. So, how do we solve this? So, I'm going to speed up a little bit. I think I'm running behind. So, we introduced this notion of a co-migration graph. So, a co-migration graph, this is different than a migration graph. So, in a co-migration graph, the vertices correspond to co-migrations. So, here we have five different co-migrations. So, notice C four over here. So, C four consists of two migrations, and the other co-migrations each consist of one migration. Consist of one migration. Those become the vertices of the graph. And there's a directed edge if the co-migrations succeed each other. So there's an edge from C1 to C3 because we have C1 happening and then immediately C3. So you get this graph over here. And it turns out that there exist timestamps if and only if this co-migration graph is a DAG, is a directed. Is a DAG, is a directed acyclic graph. And if that's the case, you can actually do a topological sorting and you get an ordering of the nodes, and the nodes correspond to congregations, and they will actually correspond to timestamps. So over here, if I look construct a congregation graph, I have this cycle. Over here, I just have this acyclic, directed acyclic graph like that, and a temporal and a double. Temporal topological sorting gives me the time stacks. Okay, so this can be solved very quickly. You can do this in linear time. All right, so good. There's something going on here. So this definition that we had in Machina was not quite right. So we want to kind of like replace, make the problem a little bit better, actually include temporal consistency in the problem. Actually, include temporal consistency in the problem, in the migration history inference problem. So, we have two different versions. So, in the simplest version, I'm actually given the vertex labeling. I'm given the locations of each internal node of the tree. And I'm trying to find a set of co-migrations that is temporally consistent, and also that is the smallest. So, I'm going to use parsimony here. So, this problem, I won't have time to go into the details, but this problem is NP-hard. Okay? So, what that means is it's actually really hard to solve. It's really hard to determine the smallest number of co-migrations, even if you're given the vertex label. And you might ask, what is Machina doing? So, Machina might give you an answer that is temporally inconsistent, but the answer that it Temporally inconsistent, but the answer that it gives is actually a low bound. So, in practice, to make it temporally consistent, you might need more co-migrations. So, this is a simplified version of the problem. This is not what we're solving in Machina, so we're actually only given the leaf labeling. So, there's a third version of the problem where you also want to infer the vertex labeling and maintain temporal consistency. So, but a long story short, So, but long story short, we actually implemented this algorithm that maintains temporal consistency, and then we ran it in two data sets. We ran it on the ovarian cancer data set by Sorb Schaub, and we also ran it on prostate cancer data set that Peter spoke about on Monday. And it turns out that everything that Machiner returned was temporally consistent. So, in practice, this issue that I showed you here requires reseeding. Okay? It requires reseeding and it requires It requires reseeding and it requires very complicated patterns of reseeding that you don't see in practice. So it's kind of like there is a gap between theory and practice, and we're kind of like seeing that here. So that's actually good news. And it's especially good news because when you implement, when you maintain temporal consistency, so this is an ILP, you need additional constraints, additional variables, so it's much slower. But you don't need it in practice. But we do have a way, so the contribution of this paper is a So, the contribution of this paper is a way to check whether the solution returned by Mark and SMPOR really consistent or not. Just a quick question. I mean, these are based on copy handle products, right? No, these are SMBs, mutation clusters. Oh, yes, yeah. But the number, the total number is relatively small, and the clusters are kind of big. Yes, yes. So that's exactly. So if you want to get this scenario, so we actually have simulations, and the types of Have simulations, and the types of tree that we had to simulate had many clones. And, like, you need really complicated clone trees to be able to get to this scenario of the core ecosystems. Yeah. I mean, the question I had is, and as you know, we have been looking at single cell, especially in methylation. Yes. And we observed that you don't get cycles in this. Yeah, I totally agree. The recent is rap. Receding in this rep, especially if you think about the data that you're looking at, that it is, you know, if you try to fix errors, you can always typically find a simpler migration issue. Totally. Yes. Yeah. Good. Okay. So how am I doing on time, actually? Very bad. I'm going to take like five more minutes. Let's try. Okay, perfect. Okay, because this is a really cool collaboration with Nikki and. With Nikki and Simone. And it's about what I promised that I would tell you about enumerating the solution space. So, just very quickly. So, the problem that we're focusing on is this PMHTR. So, this is allowing refinement of polytomies. So, in Machina, we only returned a single solution. I'm going to skip the hardest part. I think Shannon did all of this. So, in Machina, So in Machina, we only returned a single solution. And as we were trying to scale this to the trees that we got from Miki, which are amazing, they're really huge, Machina was running into runtime issues. It just didn't scale to that size. So that was a second issue there. So what we did is, this is still work in progress. We have a newer ILP, and this LP actually also has the ability to enumerate the solution space. So what does it mean to enumerate the solution space? It means to enumerate a solution space? So there's a couple of things. So you have input, and what you want to do is you want to enumerate all possible solutions. And in order to do this, you actually want to find a compact representation of your solution space. So you want to be able to have a representation that allows you to uniquely determine each possible solution. And there shouldn't be any redundancy in this representation. So we came. We came up with this vertex multi-labeling. I think we heard that here. Why would you just label the nodes of your clone tree by multiple locations? That's precisely what we're doing over here. So that's very good intuition. And also this augmentation of the migration graph. So together and some additional constraints, conditions, you can actually prove that there is a bijection between this representation, subject to those conditions that I haven't mentioned, and the solution space. And the reason why you want to have a Space. And the reason why you want to have a bijection is because we want to run our LP and we want to tell the LP to enumerate all solutions. And we want to get unique solutions. We don't want to have redundant solutions by the LP because that would just blow very quickly. We have to do a lot of post-processing. So that's kind of like what we're trying to do here. What's this augmented migration graphing talk about? It's basically representing so every so the local so the nodes correspond to locations and the edges correspond to To the migration that you would have given this value. Yes. And there is something here that you see. So this B goes from red to green. So this actually tells you, and then if you look at B over here, there's two colors, two locations. So that's how you resolve this polytomy. So is that a mutation graph that you're showing? That your clone tree is a mutation graph then? Or whatever, it doesn't matter. Yes. Yeah, they're clones, and I just labeled them. And essentially, what you have here, like a traversal in this. Have here like a traversal in this mutation graph following this multi-label. So, the multi-label in this kind of like input output that you want to infer, you can actually get this refined philanthropy with the vertex labeling. Okay, and you don't have to resolve polygonal in that circumstance. They're resolved for you by this representation. Yes, exactly. Yeah, so there was a lot of thinking here to make this work, and also a lot of theory to actually prove that it works. So, I want to talk about real data, finally. So, this is a patient from the non-small cell lung cancer tracer X cohort. And this is a mutation tree that I'm showing you here. So you see how big this is? This is huge. So, there are actually the different locations that we have over here. And they zero. And day zero, the lung, I think five different regions from the lung were resected, and also the lymph node. And there was a relapse at day 467, and the patient died at day 857, and these are like post-mortem samples. So, when you do parsimony and use this algorithm that I described, you actually find 12 solutions. Describe, you actually find 12 solutions, and they have 12 migrations and 7 co-migrations. But there's something very weird going on. So there is this LUN2 over here. So what I'm showing you here is a summary of the solution set. So these are, so the edges correspond to migrations between locations, and the number is in how many solutions did we see that migration happening. So in all 12 solutions, we had a migration from LON to LON2, but more importantly, from LON2 to RealA2. More importantly, from LON2 to relapse one. But LON2 appeared at day 100 almost, you know, C was at the final time point. And relapse one, it's kind of like this middle time point. So that's kind of strange. So parsimony can actually lead you astray. So there is something in the clone tree that would actually allow you to have fewer migrations. So if you, you know, change, so the beauty about LPs is you can just add constraints, you can constrain it more. Constraints. You can constrain it more. So if you constrain your LP to first to only allow CDO from these two locations to every other location, this location to every other location, but nothing like reverse in time. So if you do that, you actually get, you pay one more migration. And this is the solution space that you get. So just very quickly, I'm just going to. So if you're curious about the solution space, so I have About the solution space. So, I have links in my conclusion slide. So, this is a tool that we're currently developing to kind of like explore the solution space. And you can actually look at the clone tree and try to figure out the different solutions that you're having. Why is that? What changes? And what do the different solutions look like? So, I'll post a link to that at the end. But yeah, so that's basically what I want. So that's basically what I wanted to say about TracerX. And in conclusion, to wrap up, so there were three stories. So we started with just Machina. And we're using, so I showed you how to use migrations or co-migrations to infer migration histories in three successive problems. And I also talked about temporal consistency. So the conclusion there is it might happen in theory, but we actually don't see it yet in practice. Don't see it yet in practice. And the third story was about enumerating the solution space. So, with that, I'd like to thank my group, in particular Mermoy on the Vicram. And Mike and I started when I was a postdoc at Princeton. I also want to acknowledge Sigi, and I want to acknowledge Nikki, Simone, Abby, and Ariana from UCL Council. Thank you. So we say, I'll pass this to you. Thank you. Let me take questions to the coffee break so everybody can have a break. Please come back and we can