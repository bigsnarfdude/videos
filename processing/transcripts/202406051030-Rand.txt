Of the dwelts this morning, and we're starting with Robert who's going to talk about verifying graphical quantum calculi in a proof assessment. All right, thanks. Is there a way to make the extra little way or? Do you need to end or is it a whole laptop? Maybe that helps. Oh, good. Thank you. Cool. Yeah, so I'll be coming back to verifying graphic and work with my graduate students and undergraduates at Yushika. My graduate students and undergraduates at UChagago, Adrian Lehman, Ben Caldwell, Faki Shaw, William Spencer, and Laura Zownsey. So, and by verifying graphical calculi and a proof-assistent, I really mean verifying the ZX calculus. Given that Alex Kissinger is in the audience, as are a whole bunch, Simone and a whole Sarah and all of these ZX experts, I recognize that most of a fair percentage of this audience knows ZXP. A fair percentage of this audience knows ZX very well, but it's not in the workshop title at all. So I figure I should at least introduce it. So we'll, you know, thread the needle by satisfying nobody and boring some people. So that X looks like you have low battery. Do you need to have it? It's that that has low battery action. Which is bad because it seems like it's. Thanks. Yeah, so ZX calculus is this graph-looking alternative to the quantum circuit model. Nice thing about it is that we can do diagrammatic rewrites on it, changing one ZX diagram into an equivalent one. Diagram into an equivalent one. And there's a small and complete set of rewrite rules that allows us to rapidly change one diagram into another. So why do we want to verify it? So, well, one thing is that it's useful. It's used in a wide range of useful software, including optimizers, which is our particular thing that I'm interested in verifying in general. It allows us to guarantee the validity of To guarantee the validity of existing rules, this might you might say that that's not really necessary. We know that the ZX calculus is totally right, but it also allows us to verify and extend all of these rules that have been added onto the ZX calculus. You have all sorts of things. You have ZH and Zw and ZXW and Z star for every possible value of star. You have Bang boxes. You have other ways of extending ZX calculus. So ideally, we would be able to just verify. Would be able to just verify that all of these new things have the various rewrite rules associated with them. So why do we want to do this in COC? So COC is this proof assistant that we've used for a variety of projects. One of the most successful things that's been done in COC was the COMPSERT compiler. Was the comp cert compiler. This is a pretty much complete C99 compiler that's been verified to match the C specification. And the C specification required some clarifications as this process went underway because it turns out that when you specify things on paper, they are almost never complete or correct. Reasons we like Coq in particular is that we've been using it for a long time and we have this nice library. Been using it for a long time, and we have this nice library called Quantumlib. As I said, there's an existing optimizing compiler that we built in Coch called Vox, and Coch has the ability of extracting code that we can then execute. So, as I said, I'm going to briefly talk about ZX calculus. ZX calculus is this graphical language. It has green spiders and red spiders, which generalize the Z and X rotations that you would see in the standard Z. See the standards. One key point, and sort of the point of frustration in trying to verify things, is that only connectivity matters. So this nice diagram over on the left is the same as the somewhat hideous diagram on the right. And we can make it as hideous as we wanted to, basically, as long as the connections remain the same. And famously, the ZX calculus. And famously, the ZX calculus has an equational theory, one that's been shown well to be complete in a variety of ways if we add the right equations. And so, the goal of this work, when I say verify the ZX calculus, I mean that I want to verify that all of these rewrite rules are valid with respect to the semantics of ZX diagrams as quantum processes. So, this is a soundness result. A soundness result: We will verify a complete set of rewrite rules, but we will not try to prove that they are complete because there are 35 papers that do this, and all of them seem like they would be work to actually verify. Yes? Aiden, you have them written as proportionals? Are these equations up to scalars? They are up to scalars. I don't remember which ones are up to scalars, but in general, like ZX rules are. Zx rules are proportional rather than equal. And we could have little, and in fact, I think we can make little gadgets that will make them equal, but there's no real reason for us to do this. We're satisfied with proportionality. So in order to do all this verification, first, we're going to have to break down ZX diagrams into real, like their core components, which are these caps and cups, swapping. Cups, swapping, well, basic wires, this box which is called a Hedamard, which technically doesn't need to be treated as a basic component, but people find it convenient to do so, our spiders, and both sequential and parallel composition. Right, so this is, this doesn't look very graph-like, but this is how you can build a ZX diagram, and that's going to be important for giving it semantics. So, what are the semantics of the ZX diagram? It's worth starting. The ZX diagram, it's worth starting first with the spiders themselves because they're the sort of quantum part. So a spider with n inputs and m outputs takes all zeros to all zeros and all ones to all ones plus a phase. And note that it kind of throws out everything that isn't all zeros or all ones. And similarly, the red spider does the same, but in the x-basis rather than in the z-basis. Then we can get semantics to the rest of the diagrams. Can give semantics to the rest of diagrams. A cap is a bell state. Again, we're going to ignore the coefficients here. A cap is bell measurement, and a swap is your standard swap matrix. Sequential composition is matrix multiplication. Parallel composition is the tensor product. And note that. The tensor product. And note that in this talk, we're going from left to right as opposed to up to down, or bottom to top, or right to left. So there's a tension here already, which is that the semantics I just gave assume that we have things in this nice compositional form where we've stacked and sequenced a whole bunch of things and all of And sequenced a whole bunch of things, and all of the numbers of wires and such lined up. And whereas the presentation that you tend to get of ZX diagram is they're just this large graph. And as I said, we're only connectivity matters. So we shouldn't care about all of that detail. But I do want to give it semantics. So what I'm going to do is, and what we do in the proof development is we bite this bullet. We say, okay, we're going to want to get the greas. Okay, we're going to want to get the graphs where we're going to start off with this simple inductive structure, which precisely corresponds to what you saw on the previous slides. So we're going to have Z spiders, they're parameterized by their numbers of inputs and outputs, and by a rotation. These things have to, the arides, the number of inputs and outputs, do have to match wings of something like composition. So here we're going to have a mid number of Number of wires, and in order to compose, these two numbers have to match. Of course, for tensors, nothing has to match. We just have to be able to, we're going to add the number of inputs on the first set X diagram and the number of inputs on the second set X diagram and likewise for the outputs. And hopefully, the rest of this seems intuitive, seems like what you would want. So. So now we can take those, what we have, and give them basically the semantics we expect. I'm presenting it slightly differently because we're going to use the matrices from quantum lib, but Z spider is a matrix that is basically all zeros, except we have a one over here, and we have an e to the i alpha over here. And x spider, we're actually For simplicity's sake, we're just going to surround that by Hadamards, which gets us what we want. And also, we'll make proving rules involving surrounding X spiders with Hadamards really easy because two Hanamards in a row cancel out. So small design decision there. And then the rest of it is exactly what we would expect and basically what we've seen on previous slides. So So, Matt already brought this up, but we're not going to have strict equality here. We're going to say that two diagrams are equivalent if they are proportional to one another. And that means that there is some non-zero C such that the semantics of the ZX diagram Zx1 is equal to C times the semantics of the second ZX diagram. And once we define this kind of equivalence relation, and obviously it's an equivalent. kind of equivalence relation and obviously it's an equivalence relation. This means that we can actually do rewrites in the cockpit assistant using this notion of proportionality, which is a nice feature that's been built out in talk over the past few years. So once we have this structure, there's kind of three ways that we might try to prove something about a ZX diagram, often the equivalence of two diagrams. Equivalence of two diagrams. The first is appeal directly to the semantics, and that's where we're going to have to tend to start because we need something. You know, that's sort of the ground floor of things. So for instance, it's well known that if you have a green spider with a zero rotation in it, with one input, one output, that's just a straight wire. So that's the kind of thing we could appeal directly to the semantics, and it wouldn't be hard to show. Sometimes we're going to have to do. Sometimes we're going to have to do inductive proofs. So, if we have M wires connecting A and B, we can just collapse those all and fuse the two nodes. And we would want to do that by induction on this M, the number of wires in the middle. And finally, once we kind of are in a place where we have the cores of the ZX calculus, we should stop doing any of those other things. Those other things, at least, you know, until we introduce something like a bang box or something that is inductively defined and isn't as simple as that X diagram. And we should be able to prove everything diagrammatically. So I'll show you examples of these. So as I said, the first one is really trivial, or at least the example I've given you is trivial. These three matrices are all the identity because, well, either the zero. identity because well e to the zero is one and um h times the identity times h is h times h which is the identity so that was you know we could just say you know run a arithmetic solver and solve this um well a special complex number solver but um so the second thing we might do is an inductive proof An inductive proof. So things start getting messy because we don't actually have graphs here, right? So we have some large term that consists of a whole bunch of composes and stacks and so forth. So we quickly ran into the problem that our proofs and, in fact, our goals were completely impossible to read. Possible to read. So we built this little tool called ZXViz, which is a visualizer for the ZX diagrams we have in COP. And this one is not trying to be exactly like the ZX diagrams because there's still information about associativity and where the stacking is happening, where the sequencing is happening that we need to know. And so instead of having this nice spider, we're going to have this square. We're going to have this square, and the square is annotated by the n inputs and outputs. So now we can kind of see how we would look at this lemma in the proof assistant. We will get the gibberish text, but we'll also have a nice little window with these boxes in it. And this is our lemma that we want to prove. I note that I've said one plus m instead of m, but that's fine for the zero case. Well, for the zero case, this doesn't actually work. We want an m greater than zero. So we can prove this by induction over n. There's a very simple case where there's one in, one out. Here we can solve just using the semantics of matrices themselves. It's a fairly simple equality. So we're going to jump to the more interesting. We can jump to the more interesting case where we have one plus one plus some smaller m, and we'll have an inductive hypothesis then. So, what we need to do is we need to split out some nodes so we can reduce the size. So, this is the same thing we had before, but now I have two extra little spiders that are doing a little bit of branching, right? Now I'm going to have to reassociate things a little bit so I can deal with those spiders. Those spiders. Not too hard. And now we can fuse those small spiders as well as this large identity in the middle. And finally, I get this. And this, of course, is going to be my inductive hypothesis, which says that for all smaller values of m, I have this identity already true. So I can now apply it and I will be done. Yes? Two questions. What is like the underlying data type? What is like the underlying data type being used to represent these structures? And then, two, like, are these pictures like a GUI that a user is actually interacting with? Or is it just like a visualization of what you'd be doing in text in the proof of the system? So, so I'll answer the second one first. So, it's not, we've thought about, you know, actually making it interactive, but right now it is meant to represent the state of your proof. So, it corresponds. Proof. So it corresponds to the thing that will, there will be some mathematical equation that you're trying to prove, or really some proportionality relationship probably between two sets of diagrams. And this will be rendered using boxes. What those look like are basically they were on, I kind of I kind of gave it using this slide. We have some, like, you know, we can say we have a symbol for cap and cup. And, you know, you can say Z of something instead of Z spider, but it is like a whole bunch of, and there's, you know, a symbol for composition and a symbol for stacking. But what it's going to look like is a whole bunch of stacks and composes of smaller ZX diagrams. Set X diagrams. So yeah, that's basically what the proof state looks like on the main buffer. Yes. How is this different from quantum? How is this different from quantumatic? So quantumatic, I don't believe. So quantumatic is sort of naively deals, I don't mean naively, I mean natively, deals. Naively, I mean, natively, deals with these as graphical structures, it cares about the connections. We are, in our case, it is not a graphical structure, it's an inductive structure that is using this sort of block-like form. And the reason for that is that we want this to be, we want to prove the correctness with respect to just straight up linear algebra and talk. So we're going to need that structure there. Structure there. We also want this to interface with other libraries in Koth. So we don't really like Quantumatic and now Chip are really cool and powerful tools, but in terms of interacting with, you know, a, you know, the large amount of mathematics that's been formalized in something like the cock-proof assistant or the lean proof assistant, I think it's rather more challenging. So that's sort of the key difference. So, where was I? So, we just proved this absolute fusion. So, finally, once we kind of have the key, you know, once we've proven the basic functional theory, we should stop doing any like direct mathematical reasoning when we should use the equation. Mathematical reasoning, and we should use the equation theory, right? So, here's a well-known proof of Bell pair preparation. So, here's your sort of circuit way of preparing a Bell state, and here's your just your, you know, your cup, right? And here, I think, is one of the instances in which this proportionality won't be exact because this C naught introduces a Introduces a constant. So here's where it's looking nice. Here's it looking less nice. So our first step is we know that a red node followed by a Hadamard is a green node. So let's simplify that. Did we do anything more there? Well, we removed this identity at the bottom, yeah, because we can do that. Right. So So now, what we can do is we see that this green thing is next to this green thing. This red thing is also sort of next to this red thing. We want to be able to fuse both of those, right? So first we've kind of expanded that red out to cover the, to replace the identity. So things should be in a position where we can now fuse the green. Now we should be able to. Well, now we have a small problem, which is that we have one output from the red and two inputs to our red at the bottom because we don't have the option. Here we're treating the green as if it came to the left of the red because we don't have a way of saying there's a vertical wire, right? Wires have to proceed from the left. Right, that's standard in ZX calculus. Yes. Should I be interpreting all of the? Yes. Should I be interpreting all of the dotted boxes? So the dots are showing you the associativity information. So if I had associativity like this, which would be impossible because these don't match up, then things would be easier. I would just immediately be fusing these two reds. But my associativity is I have two parallel spiders here, and I have two parallel spiders here, and then I'm sequencing them together. Yes. But how you apply the associativity to your search. You apply the associativity to your circuit is not unique, right? So, given a circuit, you can have different representations of your block-like diagram. How do you know which one do you use? So, often we have to think about that. So, I'll try at the very end if I have time, which I won't, talk a little bit about some automation that will help with that. But you're right, that like there's multiple equivalent things up dissociativity. And, you know. you know and the other thing is so in this diagram it's very uh it's a simple diagram because you have really low connectivity of each spider but what if you have one spider that is connecting to many different spiders but then you only have four orientation on every block how do you kind of like represent your circuit diagram using this blocks which has only limited orientation so in general like are you going to slice it Are you going to slice it into like an article? Like, you know, like many, or I think it's the programmer's choice, right? Yeah, the way you're going to work because it's built into your data structure. You just make a choice as to which are the inputs and outputs. I mean, there's any number of ways I can decompose this into a large, you know, bunch of stacks, bunch of composers, right? We can always do this with the ZX diagram. It's very easy to see that. You just slice it however you want to slice it. So the slicing here is up to the programmer. The slicing here is up to the programmer. Well, but is it possible that the programmer choice is not very like you decide on the presentation, but that presentation makes it less obvious to apply certain inductive proof. Yes, certainly. So, if I have time, I'll talk a little bit about how we try to automate some of that stuff to not have to worry about associativity. But is there It's a hard problem, no question about it. So, anyhow, just to complete this proof, I'm going to have to change things, add a little bit so I can do the free generation, which is going to involve splitting off, well, breaking up this diagram a little bit such that I can merge this into that. And then I have a bunch of simple things that I can get rid of. Simple things that I can get rid of. These, I have pretty much identities everywhere. So now I have this, which I know is equivalent to a bell pair the same way that I proved the identity wire rule at the beginning. So you're right, this becomes messy. So basically, what we did was we verified the soundness of a complete. The soundness of a complete set of ZX calculus rules. This is by, in particular, we used the set by Simone and collaborators from 2018. We allow ingestion of quantum circuits so you can convert between the squire, small quantum IR, and physics. And we built and we're really building automation to make all of these rules practical. Cool. I know we started a few minutes late. How much time do I have? We started late, so you can see you've got like five minutes. Five minutes? Okay, so I'll very quickly talk about what came out of this. So why did we start with the next calculus? Don't worry, we thought about it. So, you know, there's a great paper by Peter Sellinger, which is about a survey of graphical languages for monoidal categories. And it shows, it says that all of these different monoidal categories have these nice string diagrams, and there's this very close relation between one and the other. And of course, the way we were decomposing, really, Zx is an instance of one of these categories along with these two Z and X generators. So why did we bother jumping to ZX instead? Did we bother jumping to ZX instead of doing something that was more general? Well, because we were excited about ZX, but we can kind of take a step back and say, let's get rid of these. Now, so we get rid of the ZNX spiders. We're going to add type classes that correspond to various categories. We're going to add some automated rewriting. Some automated rewriting to these categories because there's various rules that are associated with all of these Brayden monoidal, symmetric monoidal, and so forth categories. And we get something called Bicker, verified categories with automatic rewriting. And then once we've done that, we can go back and rebuild physics on a nice foundation of category theory where we're taking, we're saying that showing that physics is a Showing that physics is a symmetric monodal category with these two X and Z generators. And then we have physics again. And we also have the potential of building new things that are not specifically symmetric minoidal, but can use a variety of categories and still correspond to string diagrams. And then on top of that, we can build a visualize. We can use our visualizer. We can extend it to visualizing these variety of categories. Visualizing these variety of categories. So the recipe here is: you're going to the structure you're studying, instantiate as this whatever monoidal category, assuming that we've created that type class already. You're going to prove some coherence conditions, unlocking the automation that we provide for these categories. Install our visualizer along with the Kalk language server. And then suddenly you should have a much. You should have a much better experience dealing with a wide variety of things of categorical structures. So what's next? So as Sarah's been pointing out, associativity and distributivity seem really confusing and problematic. So how can we deal with this? So an approach we've been working on for a bit is e-graphs. These are equivalence class graphs. Are equivalence class graphs that basically allow us to sort of start with a given CX diagram or category diagram and find all of the, you know, create an expanding set of equivalent ones using the rewrite rules we already have. So that has a lot of potential for allowing us to do things like fusing spiders that are fairly disconnected by just finding the path from where we are to the spiders that we want to fuse. To fuse. An alternative approach, which we're also looking at, is: can we actually convert between our inductive structure and graphs? Which we would like to, and we can do it. The problem is that showing that the semantics are preserved because the graphs, the semantics for ZX diagrams are not defined on graphs. They're really defined on the inductive structure. So what you have to do is give semantics to the graphs in terms of the conversion to inductive structures and then show that this is like involutib or at least that you know if you keep In volutiber, at least that you know, if you keep round tripping, you'll get the same semantics that you had originally. And we want to build some verified software using VISIX. We're at the beginning of doing that. And for Vicker, there's a lot of categories in Peter's paper, so we haven't yet formalized them all. So we're actually giving a bunch of talks on this in the near future. So hopefully I will see a lot of you at QPL in Buenos Aires. So that's going to talk about physics and specifically some of the eGrafs work. Victor is going to be, I know some of you are in Oxford. There's this applied category theory conference in June, so coming right up. And the undergraduates who actually did almost all the work on Vicar will be giving a talk there on, you know. There, on you know, the more general category visualization, and there's an e-graph workshop at PLBI in Copenhagen this year. Hopefully, I'll see somebody there as well, where we'll be talking specifically about how you can use eGrafts to reason about these associative and distributive structures. Also, there's a lot of cool quantum stuff going on at PLDI. And if anyone wants to talk to me about quanta, about software-defined networking for quantum networks. For quantum networks, I'd be happy to. So that's it. Questions?