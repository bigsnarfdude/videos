He's in Göttingen, and he's going to talk to us about TREFT4 unfitted finite elements. Christophe, the floor is yours. Okay, thank you. Is the audio okay? Yes, we can hear you very well. Okay, perfect. Okay, so yeah, thank you very much for organizing this workshop. And I'm a bit sorry to not be with you in Mexico. In Mexico. Nevertheless, it's nice to have the opportunity to speak here about draft and unfitted financial methods. So, this is joint work with several people. So, Fabian Heiman from UCL London, Erich Risinger, former master's student here in Poland, as you just mentioned, and Henry van Waard, who's in Hidan right now. So, and in contrast a bit to some of the previous talks, so the motivation for Previous talk. So, the motivation for this talk is not primarily doing trafts for wave equations, which was one of the claims of Elene yesterday, but instead rather considering the trafts concept to a larger class of problems. So this is kind of a theme that I essentially kind of followed together with Paul when he was here for a postdoc position in Göttingen. And yesterday you saw what came out. So the embedded drafts approach and then now also the approach and then now also the the stokes uh stuff and and also kind of now we also kind of have some some um ideas on how to do this with unfitted methods yeah and this is kind of more the direction that that this uh is going to take uh in this talk um okay so let's see what what are unfitted final element methods so the idea of unfitted final element methods is that you you separate the geometry um that is involved in your pde problem from the Involved in your PDE problem from the computational mesh. So, this might be interesting if you have time-dependent geometries when you want to avoid remeshing. So, also situations where you have bubble breakup, topology changes, things like that. Or you could also think about just avoiding meshing in the first place. You want to work with structured meshes or whatever. So, in the remainder of the talk, I assume that we agree on having a motivation of doing unfit discretizations. Of doing unfitted discretizations. Of course, this is debatable depending on your context and whatnot, but let's assume for the moment that there is indeed a good reason to do so. Then, yeah, if we want to do fine elements in the setting, then we kind of buy in some problems, some challenges. There is the first thing is that we have to deal with arbitrary small cuts. So essentially, what we do is, yeah, we get this background mesh here. Yeah, we get this background mesh here, for example. And if you want to solve a problem now on the one domain, omega one, you have kind of elements or cut elements that have this very small contribution to the element, to your domain. And this can, of course, degenerate even more than in this picture now. And in these situations, you will, in general, might get stability issues. So you will have to deal with this kind of in a non-standard. Kind of in a non-standard way compared to body-fitted situations. You also have to think about how to implement boundary conditions because, obviously, you don't have degrees of freedoms now associated to your domain boundary anymore. There are other issues that I don't want to discuss too much in detail, but of course you have to think about geometry description, doing numerical integration in this configuration, time integration, linear solvers, and so on. The type of PDE classes that you can consider are essentially, let's say, subdivided into three classes. The one is you just solve a PDE. The one is you just solve a PDE on one domain. So let's say on omega one in this sketch. And this will be kind of the first part of the talk. I just want to solve a very simple fictitious domain problem. Of course, you can also then extend this to interface problems where you have a PDE on both domains, and then you also have an interface condition that couples the two subdomain problems. I will not discuss this in this talk, but of course, this is doable. And then the second part of the talk, I want to concentrate on surface PDEs. Talk: I want to concentrate on surface PDEs. So, assuming you have a PDE here essentially on the surface, so in this red line and in this 2D sketch, in this unpitted configuration, kind of how can you deal with that? That's kind of the setting. Okay, let's start with the simple problem. So, we are in a volumetric domain. We solve a Poisson, want to solve a Poisson problem, and we now have that the geometry description is independent of the mesh. So, we buy in this mesh issues potentially. Mesh issues potentially, we denote by th the active sub-mesh of an underlying background mesh, and we construct the final element space based on this corresponding mesh th. So here's a sketch. You see essentially you have a rectangular background domain. However, the physical domain that is of interest is the one kind of in this area, so left of the red curve. Of the red curve. And for example, we use a level set description perhaps of the geometry here. Now, with respect to the background domain, we get the active mesh by taking all the gray guys here. So especially you have some elements with very small cuts, obviously. And now we want to do discontinuous Galerkin discretizations. You can also do something H1 conforming. But here, of course, we want to go to TreftsDG later on, so that's why we start with discontinuous Galerkin directly. Looking directly. Of course, imposition of boundary conditions is also special in this configuration. And here we apply a Nietzsche discretization, which is pretty much in line with the DG approach for the inter-element continuity anyway. Okay, so the standard approach would be in symmetric interior penalty discretization, as you might know. So this looks pretty much, as you might know, from the volume. So this is. As you might know from the volume, so this is just the discretization of the Laplace operator. Now, the important difference to the usual situation is that we have here these intersections of elements k in your background mesh with the physical domain omega. That of course poses some problems on the numerical integration, but also it is a problem kind of with the problem formulation. Yeah, because we have these terms like the normal gradients involved. The normal gradients involved, which are typically kind of bound with the jump terms and the help of inverse trace inequalities, assuming shape regularity. But now, of course, because of these intersections, we don't have this shape regularity on the trimmed meshes. So effectively, we do discretization at the moment, not on the background mesh, but rather on the part of the mesh that is inside the physical domain. So on this part. And of course, the corresponding And of course, the corresponding trimmed elements can be now arbitrarily ill-shaped, and that leads to issues. So, in general, this discretization that we have here on the slide will be unstable. And what you have to do then in unfitted discretizations very often is to have to add some type of stabilization mechanism. And the most popular one is the ghost penalty stabilization. So, you will see this ghost several times in this talk. And a different approach that I will. And a different approach that I will only briefly touch upon is also kind of repairing your mesh by kind of a cell merging strategy. Okay, let me briefly explain the idea of the ghost penalty operator. This is now a ballinear form that we have here, which is now taking place on a facet patch, which we see here in the sketch. So, and this is an integral over the whole facet patch, so over all the two, these two elements here, and we get. And we get here a jump of u and jump of v, but the jump is a volumetric jump, so it's nothing happening just on the facet, it's really happening in the volume, and it's defined as a difference of the two polynomials interpreted as a polynomial in Rd. So if you have two final element functions, left and right, then essentially you can measure the difference between the two polynomials, and this is kind of what you get as an expression here. So effectively, you can characterize this ghost-balanced stabilization by taking a look at the Ghost balance stabilization by taking a look at the kernel. So, the kernel of such a contribution on one element is just the global polynomial on the patch. And what does it give? The benefit of this discretization is this inequality. So you can now essentially control the L2 norm or any other norm that you like on one element by the corresponding norm on the neighbor element plus this ghost penalty type stabilization. Ghost penalty type stabilization. And this is kind of what one often applies then in order to borrow stability on cut elements. So if you have, if you imagine you have a very bad cut in such a configuration, so you have physically relevant only this small portion in T1, then you can still control the final element coefficient functions, the final element solution in the element T1 here by essentially controlling the one on T2 plus the Controlling the one on T2 plus this cost penalty stabilization. Okay, so in the past, I mean, you can do that. And if you do DG, often you want to reduce computational cost. And one of the kind of my own history kind of lies in doing hybridization whenever you do DG in order to reduce the computational complexity. But in this case, this doesn't harmonize well. Here, effectively, we couple all degrees of freedom from one element with the neighbor. So we cannot reduce things to the facet of something because... Reduce things to the facet of something because obviously the jump really involves the whole polynomials. And in that sense, the hybridization does not really work here. Okay, so side remark, you can also find different kind of versions of this Gauss-Penny similarization, but the important thing is that you couple essentially the whole polynomials left and right, and that the kernel of this operator is the whole polynomial. So this is what you do on one facet patch, but kind of the question of course says which facet patches do you use here in the sum? Do you use here in the sum? Now, you don't take all in the mesh, but you can kind of make a selection. And here, essentially, there are two choices. On the left, you see essentially what you could do is you can just stabilize on all these blue facets. And these blue facets connect the cut elements with the non-cut elements so that you can always kind of borrow stability essentially on the cut elements by the uncut elements. Okay, this can be done. Then, of course, the kernel of the corresponding operator would just be. Of the corresponding operator would just be the polynomial, the global polynomial on the whole patch, on the whole, sorry, on the whole region here. So on this large region. So you have one polynomial that is in the kernel there. Alternatively, what you can do is you can find smaller patches that are disjoint and only stabilize on facets within the patch. Now, so this still allows for a cut element like this one here, a very small cut, obviously, to go from one facet, from one element to the other. To go from one facet, from one element to the other through this facet, and then from here to here with the other facet to borrow stability in that sense. So, this is sufficient, but now the patches are decoupled, and the kernel of the global ghost plant stabilization is a patch-wise polynomial. So, that makes it a bit weaker and let's say a bit less prone to locking-type effects. Okay, so this is now how the final formulation then looks like. The final formulation then looks like. You do your standard interior penalty type discretization plus this ghost penalty stabilization to fix the shape regularity issues that you might have. And now we can do this and combine this with trifts. So, okay, we would do now traffic as we would do this in the in the fitted case. Yeah, so we take for the Laplace problem, for the Poisson problem, we just take the corresponding traffic space that is in the kernel or respectively the affinely shifted space to your. Shifted space to your data. The nice thing is now, what you could not achieve with hybrid DG due to this coupling, you can now achieve with trafts. So you get this dimensional reduction in the polynomial degree from K to the D to K to the D minus one. This is because the coupling pattern is pretty much compatible with Strathogen and the ghost penalty stabilization. Okay, so that's kind of a nice achievement. And now, okay, you can do the analysis. It's not super fancy and interesting. Fancy and interesting, so I'll be quite quick about this. So, you get H1 optimal error estimates, you can do the same in L2, and the analysis components are pretty much what you are used to from the TREFS community and from the unfitted community. So it's not super complicated. Okay, so now you can combine different variants. So on the left, you see essentially how we went from DG to TrefCG. You can also care about geometry exactness or not. So we'll skip this here in this talk. This here in this talk. But we also consider different types of stabilization measures. So we took a look at the, let's say, the global ghost penalty method, the patch-wise one. And now there's also another version, which is called the element aggregation approach. And this you can obtain from the patch-wise ghost penalty by considering the stabilization parameter essentially going to infinity. Yeah, then you essentially get in the kernel of your stabilization, the piecewise, the patchwise harmonic polynomial. The patchwise harmonic polynomials now, and these you can then use directly essentially in discretizing the previous approach. And now here's a nice thing. You can do this element aggregation, so this patch-wise merging and the construction of harmonic functions in the sense of an embedded TRAFCG method in a unified way. So essentially, on each patch, you set up this bilinear form here and you essentially just extract the kernel. You essentially just extract the kernel of this operator and use this as your Anzatz function in the discretization. Yeah, so here you essentially get functions that are obviously harmonic due to this term, and they are also patchwise polynomials due to the ghost penalty stabilization. Okay, that's kind of a nice trick where these things go well together. Then you can essentially use your routines from standard DG setup, combine this with the embedding to get kind of The embedding to get kind of the reduced system, solve the reduced system, and represent your solution in the DG space afterwards. You can also optimize this by not kind of relying on an underlying global DG setup, but that's perhaps a detail here. Okay, this is what we've done with Fabian Heyman, Paul and Henry van Waile. You can, of course, also extend at least the methodology also to non-Poisson-type problems. So, here's a kind of a convection diffusion equation. Convection diffusion equation example comparing DG and Trafs CG. Okay, so the second part of the talk, I wanted to discuss PDEs on surfaces because this also gives us another nice second application of the Trev's idea. And here I will concentrate on the simplest things, so scalar Laplace-Veletroni equation on a surface. We'll also briefly discuss later on extensions of that where you go to vector Laplace or even Stokes and Navier-Stokes equations. Even Stokes and Navier-Stokes equations, where you have a vector unknown and you impose a tangentiality condition on top. But now let's start with the Lafass Veltromi equation first. And here's essentially a sketch about the situation here in terms of the discrete geometry. So you have some background mesh again, you have some discrete geometry gamma H in there, and you have a mesh now consisting out of the corresponding elements of the surface elements in a sense. Of the surface elements, in a sense, yeah. So you have the volume elements in the background, and you have now the cut elements, so the surface elements, and you will also have edges. And yeah, the corresponding notation is TH is the volumetric background mesh. We have the KH is the surface mesh, which is, of course, now, because the cuts are arbitrary, is irregular. And then EH is the edges, edges in 3D. Of course, for the sketch here, the edges are actually just the vertices here connecting. The vertices here connecting the lines onto neighboring elements. And we still have kind of on the background mesh the facets that connect two volumetric elements in there. Okay, now let's first take a look at final elements. So if you want to do what is called unfitted final elements, it's called then trace final element method. So the idea is that you use a piecewise polynomial space in the background and you just restrict this on the surface whenever you do your variation formulation. Formulation. So, yeah, so what you can do is straightforward. You just essentially take the We Laplace, the Trami operator on the surface here with the surface gradients involved for U and V. Okay, and that's kind of the idea of the trace fine element method. Yeah, so you have a background fine element space, but you just essentially have this acting on this k, so on the surface gamma h. The problem, of course, is at latest, if you take a look at the linear algebra. At latest, if you take a look at the linear algebra, is that this has a large kernel because all the functions that have that evaluate to zero on this on the surface are on the kernel of this operator. So yeah, it's hard to kind of solve this problem. Also, there, you typically add some stabilization, and the idea is as follows. So you have the PDE acting in tangential direction of the surface. Now let's just add an equation for the normal direction. And here, we essentially just do a diffusion in normal direction. So it gives us essentially So it gives us essentially an equation in that direction, complementing, let's say, the equations for the whole volume. Okay, with a properly chosen civilization parameter and n gamma being the quasi-normal field. So it's kind of an extension of the normal vector at the surface to the volumetric neighborhood. Okay, so the nice thing about the stabilization is it gives us control for the volumetric background mesh domain based on the surface L2 norm. Based on the surface L2 norm here plus the stabilization. You can also extend this then also to H1 type norms and so on. And then with that, we get optimal error estimates and condition numbers. Okay, so far that's for the FEM, but now let's do the DG. So for the DG, again, interior penalty here, and we have these problematic guys that need to be bounded, but of course, due to missing shape regularity, yeah, we essentially are getting unstable. We essentially are getting unstable. The stabilization parameter that we have to choose here, we cannot bound, and that's not good for the method. Okay, so also here we do some stabilization in virtue of the ghost penalty stabilization as before. Now, because of the surface PDE character, we don't need to penalize the whole volume polynomials, just need to control the traces and the normal derivative traces. But okay, apart from that, the same kind of strategy. Strategy. Now we want to do traffic. Okay, and now we do trafts in a different way than usual. We take a look at this type of stabilization in this gradient normal derivative stabilization and consider the case lambda n going to infinity. Then this would mean that the discrete solution is in the kernel of this corresponding bilinear form, which is nothing else but saying that it's constant in normal direction. It's constant in normal direction, it's in this quasi-normal direction. And that's a good traffic space. Okay. But of course, if n gamma is non-constant, well not non-piecewise constant, it's not trivial. And you can have that the kernel is essentially just trivial and you get locking. So that's not nice. However, if you take a look at the analysis, you can relax this normal gradient stabilization by adding a projection here, which is similar to the weak draft approach that Paul presented. weak draft approach that Paul presented yesterday, that is sufficient for stability and has the nice property that it indeed has a non-trivial kernel while offering for this corresponding operator. So here's the normal gradient, let's say the relaxed normal gradient stabilization by adding the projection here to this, let's say, diffusion or normal diffusion operator. Then the kernel is just essentially this. Then the kernel is just essentially this one here. And due to the projection on the space Q, where for Q we take the space pk minus one, so polynomials of one degree less, we can indeed control the dimension of this kernel. Okay, and now we can take a look at discretizations essentially of three equivalent solutions to three problems. The one is we do exactly what we started with here and choose the Choose the parameter going to infinity and kind of observe that there is no locking now, and we get a limit that is still reasonable. Equivalently, we can just impose this here in a saddle point problem as a constraint. So essentially, this is what implemented now is this BHI here. Or we do what we are kind of going for, what we want to do, is the Trafts approach. So this is that we directly go set up the kernel of this stabilization. Set up the kernel of this stabilization and then solve the corresponding elliptic problem on the kernel of this stabilization parameter. Okay, so this is kind of what we've done in the project. And yeah, what you obtain is essentially quasi-best approximation results as you would expect. The nice thing now is that what you gain is that you go from the volumetric polynomial space on the background now to something with the draft approach to With the draft approach, to the dimension of this draft space being essentially the polynomial space of a dimension lower, which is kind of fitting, obviously, because for the fitted DG discretization, if you have a surface discretization, you would expect, let's say, if you are the 2D on a 2D surface, you would expect a two-dimensional polynomial with the corresponding dimension. But with a trace-unfitted approach, you essentially have the higher dimension to choose to start with in this kind of. To choose to start with, and this is kind of what we can solve with the kind of drafts projection here. So, this is the same sketch that you saw yesterday, perhaps already in Paul's talk. So, what you can get with this weak draft space is essentially here for a 2D example, we take this as a velocity field. So, this is essentially giving us this quasi-normal field and gamma. And these are now the Andzas functions for polynomials up to degree. Degree four, where essentially you see these functions are almost constant in this corresponding vector direction. Okay, that's kind of the nice application. With that, I also want already to come to the conclusion. So what we've seen here, what we see in kind of in these approaches, is that the idea of the Trafts method of going essentially to a subspace or the proper space of your The proper space of your fun element spaces, possibly not only relying on the PDE but also on other properties can be quite helpful. So the first, I would say, easier step is here what we did for the elliptic PDEs, where we see that doing TrafsDG as a reduction mechanism for DG harmonizes pretty well with the ghost penalty stabilization, which is in contrast to what you see with a hybrid DG. So there are See with a hybrid TG. So there are some people doing this, but they have to trigger around with the mesh and actually not do the, let's say, the vanilla unfitted approach. But with Traft, this is pretty nicely doable. Then, yeah, the side remark essentially was that the idea of implementing the embedded traffic or traffic with the embedded traffic approach and the aggregation FEM or aggregation DG, which is also popular in the unfit community, they are very similar. Unfitted community, they are very similar in virtue and they go hand in hand in some sense. And the follow-up question is: of course, can you also impose other conditions like interface conditions, boundary conditions into the space instead of doing some standard other tricks? Perhaps even a bit more interesting is doing traffic now for the surface PDEs. So, here the key was that using this projected normal gradient stabilization, if I Effectively, the civilization keeps the degrees of freedoms at the surface. And now we do this in the traft sense by directly essentially setting up the final element space so that we have effectively just polynomials on the surface, which are extended more or less exactly constant in normal direction. Now, that reduces essentially in a 3D background mesh the computational complexity from 3D to 2D, and then in 2D, of course, to 1D. Now, of course, To 1D. Now, of course, the follow-up question is: can we do the standard trafts approach on top? So, can we combine, let's say, this functions that are at least in some weak sense harmonic, harmonic on the surface? So, the La Pas Vercharmi of the function is zero and is constant in the normal direction. That would, if this works essentially, would reduce the complexity from 3D to 2D, to one. 3D to 2D, to 1D, so we have two-dimension reduction and then from 2D to 0D. There you have to be a bit careful that you probably need some nice relaxations to avoid locking in that sense. Okay, now the potential is even higher if you go to vector Laplace or Stokes equations, where you have a PDE that you can use for doing the Traffs idea. You have the normal extension that you use in the trace DG context, and you have Trace DG context, and you can also impose the tangentiality condition into your space. So, as a side remark, for all these discretizations of tangential fields on the surface, typically what you do is you take the full 3D ansats, and then you add some penalty to go back to the surface, to the tangential things. And this, of course, we could also, with this mechanisms, try to implement in the draft space in the first place. The TRAFT space in the first place. Okay, so this is kind of what I have. So, these are some, I think, interesting ideas on how to apply the TREFS methodology in a slightly different context than you might be used to from the other talks in this workshop. Thank you for your attention. Thank you very much. So, do we have any questions in the room or online? No? Okay, well, if you have any further questions for Christoph, maybe during informal session discussion sessions, you can reach back out. So, thank you very much, Christophe. And to remain on time, we're going to take our coffee break now. We're going to be back. Take our coffee break now. We're going to be back after coffee for the session.