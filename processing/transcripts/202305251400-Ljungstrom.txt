All right, cool. So, yeah, thanks for having me. So, I'm currently in Pittsburgh at another conference. It's a shame that I can't be here, but there with you. Yeah, it's a tragedy. But nonetheless, so I haven't been able to follow many of the talks. So, there's a risk that I'm just going to repeat a lot of stuff that Flores has already been talking about. That Flores has already been talking about today, but well, you probably need to hear it twice, anyways. So, okay. So, I'm going to talk about cohomology theory and Bruni numbers in the cubical aggravation. And actually, sorry, just one second. Okay. Great. Right. So this talk is about cubical Agda. So cubical Agda is a proof assistant which is slightly different from, well, it's quite different from Lean and Koch, but it's also slightly different from standard Agda in that it implements something called cubicle type theory instead of say homotopy type theory. And what cubicle type theory is, is a fully computational flavor of homotopy type theory. Type theory. So, the main difference between cubicle type theory and homotopy type theory is that paths for us are not inhabitants of some inductively generated type or some inductive type. They are instead functions out of a primitive interval type i with two endpoints, i0 and i1. Okay, so you can just think of this as the real, the usual real interval from zero to one. From zero to one. So I have a definition here of the type of paths. So, first, if you take two points x and y in a type A, the type of paths from x to y is denoted x equals y. I'm writing it with a triple bar. And it consists of elements that are functions from the interval, this primitive interval, into a, such that p applied to i0 is strictly x and p applied to i naught. Strictly X and P applied to I1 is strictly Y. So I think, I mean, I know there's a lot of classical people in the audience, so I think you should think this is quite reasonable. This is how we do it in classical topology, right? So it's a bit different from hot, but in general, it's very similar to hot, apart from this particular definition. Okay. So one advantage of cubicle Agda is that it supports higher inductive Supports higher inductive types. You might hear me call them hits. Yeah. So a higher inductive type is a type which allows you to construct cell complexes, essentially. So here, for example, I have the AGDA code for the circle, S1. And I'm just declaring the circle to have a base point, base, and a loop, which is an identification of base with itself. So here I drew a very nice picture in MS Paint, I think. picture in MS Paint, I think, which illustrates this idea. So it's literally just the cell complex. And what's nice is that Agda will automatically detect the reasonable induction principle for such types. So that whenever you try to write a map out of S1 in cubical Agda, it's automatically going to be a continuous map. So you can really only define nice continuous maps. Nice continuous maps. And this is the only thing you can do really with S1. Yeah, okay. So yeah, here's an example of a map. So this is what it looks like in Agda. So here, for example, is the double map from S1 to S1. So I'm just defining it by saying I want to send the base point to the base point and the loop, instead of twisting it once, I want to twist it twice. So I'm just sending loop to loop compose with loop. And it's as easy as that to define this map. As easy as that to define this map. So, this is the standard map of degree two. I think it's a pretty nice and compact way of writing functions. Right. Okay, so probably already mentioned the univalence axiom today, but let me mention it again. So the univalence axiom says that the canonical map promoting equalities of types to equivalences of types is an equivalence itself. Is an equivalence itself. So, in particular, you get a function ua taking equivalences of types a and b to equalities of types a and b. And this is an axiom in univalence mathematics, but what's cool with cubical agda is that this is actually a theorem. And as you know, or as you may know, I guess people here aren't logicians, but constructive theorems are algorithms. Theorems are algorithms. So, what this means is that we can actually use univalence to carry out computations in our proof assistant. Right. So, yeah, let's see an example of this. So, in homotopy type theory, it's very easy to define the winding number of a loop in the loop space of S1. So, it's of this type. So, it takes loops in S1 and sends them to the integers. The integers. And here's the definition of it. It doesn't matter if you don't understand what's going on here. I just want to show you that the definition in agda of the winding number sends a path P to something something univalence something something. Oh, this is also wrong because yeah, this is wrong. But there's univalence appearing in here anyway. Okay. Ha. Okay, interesting. Okay, interesting. Okay, yeah, so this P should be somewhere on the right-hand side, obviously. Either way, this map uses univalence. So what's kind of cool in cubicle like that is we can actually just call this map on a concrete element of omega s1, and it's actually going to compute. So I can check in cubical agda, I can ask, is the winding number of the canonical loop in the loop space of S1 equal to one? one equals to equal to one and I can just plug in refle, which is the canonical path from one to one. So it's literally going to compute the left-hand side to one. So here I have another very nice picture that I also spent a lot of, so you know, when you prepare a talk, it's very easy to procrastinate. And I wanted to draw this little picture here to compare with other proof assistants that support some version of homotopy type theory. So here you So here you have the winding number going from omega s1 into the integers, and the map here goes via univalence. I mean, it's crucial to use univalence to define this map in homotopy type theory. And for other proof assistants like Agda, Lean2, and Coch, this computation is just going to stop. Like you can ask Agda, you can ask Agda to run this computation, but it's not going to spit out. This computation, but it's not going to spit out anything. Whereas, if you use cubicle like that, you're actually going to get something concrete out of it every time you run this. It might work for a very, very long time, but you are going to get something concrete out of it. So, this is an advantage of using cubicle like that. Okay, what's kind of exciting, at least to me, about this idea is that it opens up a new kind of proof technique, which we used to like, I like to call it. Like we like to call, or we like to call proof by computation. So I have some form of informal theorem here or idea. So in order to prove a theorem x, we first reduce theorem x to some form of identity. For example, some identity x equals n for some fixed numeral n and some element x that we're interested in. And we just normalize x in cubical agda and we just plug in refle. And we just plug in REFL, say that x is equal to n trivially, and we're done. So we should be able to, we can actually, the idea is we can reduce many advanced mathematical theorems to just simple computations in cubicle Agda. And we shouldn't have to do anything. The computer should do the proving for us, essentially. And this is something that's possible precisely thanks to the fact that cubical Agda is a fully constructive proof assistant. So here's a toy example. So here's a toy example. So if you want to prove, for example, that the canonical loop in omega s1 is the group generator for omega s1, what you really want to show is you want to show that its winding number is one, right? And what you would do traditionally, of course, is prove that the winding number of this loop is equal to one. But in cubicle egg, we just plug in the winding number of loop in cubicle eggda, we press enter and it returns one, and we're done. And it returns one, and we're done. So, in essence, we didn't have to prove anything. That proved it for us by just computing it. So, this is very cool. Now, of course, computing the winding number of the canonical loop in S1 might not be that interesting because it's very easy to do by hand as well. So, here's something about something completely different. Here's something about the Bruner number, which is a far more crazy example. More crazy example of this idea of proof by computation. And this is going to involve a little bit of cohomology theory. So don't worry, there will be cohomology theory appearing soon. Right. Okay, so this is actually where this talk is sort of the beginning of this talk. Okay. So in his 2016 PG thesis, Guillaume Bernry proved in homotopy type theory that pi 4S3 is isomorphic to Z mod 2. To Z mod 2. And his thesis consists of two parts. So in the first part, so chapters 1 to 3, I think around 80 pages, 90 pages, Guillaume Brunery constructed a number, beta, which he could prove satisfies the fact that pi for S3 is isomorphic to Z mod beta. And what do you want to do next? What do you want to do next? Well, you guessed it. You want to prove that this beta is plus or minus two. So, this is the second part of his thesis. And that's another, say, another 100 pages or so, just proving that this beta is actually, or that the absolute value of this beta is equal to two. Now, this should be really easy. Like the second part of this proof should be super easy when you have something like cubicle like that, because again, this is a computational problem. All we should Problem. All we should have to do is plug in this number beta into our proof assistant, press enter, and just have Agda magically return the number two. And you do this, and you wait, and you wait, and then you wait a bit more, and you wait, and I don't remember how many dots I put, but you wait for a very long time. And then around 10 gigs of RAM later, you realize that this number still hasn't actually computed. It hasn't normalized. It hasn't normalized. So, this idea of computation is a very nice idea, but in practice, it's often very hard because the computations involved are just too complex for the computer to actually handle. So, cubicle IDA computes in theory, but some computations are simply not feasible. So, that's a bit sad. So, I mean, we've been trying to normalize this number to prove this number is equal to two by computation. Number is equal to two by computation for a very long time. But at some point we gave up. So does this mean that we should give up the formalization of Brunei's theorem? Well, yes, for a lot of people, but not for me, because I had promised to do so in my PhD thesis. So, well, we have no way of doing it by computation. So let me tell you about how we did it without computation at least. But this idea of computation will come back several times. Computation will come back several times during this talk. Also, when I'm getting into cohomology theory, it's kind of a theme in some way. Okay. Well, that's a big slide. Okay. So let me talk quickly about the first part of Brunery's thesis. I don't want to focus too much on this part because there's not much, there's no cohomology theory going on here, really. But let me just tell you what he does. So, first, what we did and what Bernie did is he defined this. Did and what Bruni did is he defined this number beta. So beta is defined as the this composition of maps. So you go from pi2s2 cross itself into pi 3s2 via the so-called whitehead product. And then you go from pi 3s2 via this psi, which is an isomorphism between pi 3s2 and the integers. So you can define these two maps in homotopy type theory, and we have formalized this. Formalize this. So when you evaluate this composite map on the generators of pi to s2, sorry, on the generator of pi2s2 with itself, so you take the bracket of the generator with itself and you evaluate it using psi, you get a concrete integer. And the theorem that Brunei shows in the first, well, in the end of the third chapter of his these. Well, in the end of the third chapter of his thesis, is that the suspension map from pi 3s2 to pi 4s3, which happens to be a surjection, has its kernel generated by this element. So I'm just mentioning this. This is absolutely a non-trivial thing, but let's just take it for granted now. So, as a corollary of this, and which one is it? One of the isomorphism theorems, the first one, I guess, you get that pi 4s3. You get that pi4s3 is isomorphic to Z mod beta. Okay, so I should just mention. So, we actually for the formalization of this contained quite a lot of stuff that I won't be talking about today, but we had to formalize things like the long exact sequence of homotopy groups, the pointed natural equivalence between the loop space functor and this functor taking types into the pointed functor. types into to the to the pointed function space from Sn into this type and we had to formalize pi 3s2 isomorphic to the integers we had to formalize some version of white head products we had to formalize the blakers massey theorem but this was actually not done by us i should say it was done by a guy called kang ronghi and we had to formalize at least part of this thing called the the james construction so several thousand lines of code but it's not what i want But it's not what I want to talk about, focus on today, at least. Okay, so let me focus instead on the second part of Bruni's thesis. So in the second part of his thesis, Bruni proves that these three chapters are. I'm losing my English now. I'm in the US, this is why. Yeah. Yeah. In the three last chapters of his thesis, he proves that beta is equal to plus or minus two. Okay, so how does he do this? Well, this is done by considering the so-called HOPF invariant, which is a map from pi 3s to the integers. And it's defined in terms of the cohomology ring of certain homotopy cofibers or mapping cones. So since it's defined in Since it's defined in terms of cohomology rings, we're going to need to introduce cohomology finally. Okay. So from now on, I'm just going to focus on cohomology with integer coefficients because they are, first of all, somewhat easier to define than cohomology rings with arbitrary coefficients. It's more to make your life easy, actually, more to make my life easy, I guess. But everything I say and everything that's been formalized here, we have actually also formalized for. Here we have actually also formalized for cohomology theories with arbitrary group or ring coefficients. But let's focus on the case of integer coefficients. Okay, so in HOT, we define cohomology groups using representability. So it's not a theorem in HOT, it's actually a part of the definition. So what we'll need is obviously then either. What we'll need is obviously then Eilenberg-McLean spaces. So these have a very nice and concrete definition for when you want to work with integer cohomology. So the nth integral Eilenberg-McLean space is defined by setting K0 to be the integers. And for higher n, we set Kn to be the n-truncated n-sphere. So just for fun, I have the code here for how we define the n-sphere in cubical aggregate. For how we define the n-sphere in cubical AGDA. So we define S0 to just be the Booleans, we define S1 to just be the circle, which I defined before. And for higher spheres, you just recursively define it by saying that it's the suspension of the lower sphere. And then there's this mysterious bracket around SN. So this is the truncation. So the idea is that. Truncation. So, the idea is that the SN is a very complicated type and has very complicated homotopy groups in higher dimension. And when you put this n truncation around, it's just going to glue on a bunch of cells, killing off all the higher homotopy groups. So, here's actually, okay, so I included the definition, but you can think of it as just being the entruncation as just being the copy, a copy of your type with some extra stuff. So, for type A and Type A and an integer greater than or equal to minus one, you define this entruncation by the higher inductive type, which is generated by first just points, an inclusion of points from the type you started with. And then you have these crazy higher constructors, which essentially say that any maps, all maps from spheres into the type have a contractible image. But yeah, as I indicate here, you may forget about this. It's just the It's just the entruncation of your type is just an exact copy of your type with stuff, higher homotopy groups killed, essentially. But all of this is very concrete and nice to define in Agda. We have the machinery to do so. Great. Okay. And now you can have a very compact definition of cohomology groups. You just say that the nth cohomology group of a type A is the set of maps from A to your. Of maps from A to your Eilen-Merberg lane space. Again, you have to do this truncation thing, and this is just saying we don't want to consider the common group, the whole homotopy type of such maps of this space. We want to consider this space with its discrete topology. So, we want the set of maps without any topology on it. So, as a remark, you can also get reduced cohomology by just Cohomology by just forcing by just asking that the functions here are base point preserving. But I'm not going to use reduced cohomology, but it's nice to see that it's so easy to define as well. Okay, now since we use the representable definition of cohomology in HOT, the idea is that all the operations that we're interested in we define on Eilenberg-Maclean spaces first, and then we will also. Clean spaces first, and then we will automatically get them for the homology groups by just applying them pointwise. So, for example, we're going to want to define addition. So, what you do is you don't define addition on this guy, you just define addition on Eilenberg MacLean spaces. Now, here comes the sort of a choice in design. So, the way that we read this. So, the way that Bunri did this originally was he used this fact that the nth Eilenmark-McLean space is equivalent to the loop space of the n plus one Eilen-Merc-McLean space. And loop spaces have, they already come with a composition, path composition. So you can just use the fact that this space has a composition structure, and then you can just use univalence to transport it over to Kn. To Kn now, this is a very clean approach, but if you actually want to, I mean, I really care about computation in a sense, so I want to be able to actually test my functions and run programs in cubicle Agda. And this is a bit of a sledgehammer approach in the sense that although it's a very elegant construction, the computer is going to be very upset with you whenever you try to run any algorithm using this. Any algorithm using this construction. So, what we did instead, we took this really stupid and painful definition, which is just sort of doing induction on n. So you define plus to be just integer addition when n is equal to zero. When n is equal to one, you just use the fact that s1 is a topological group. And for n greater than one, you use the fact that You use the fact that actually this folding map from Kn wedge Kn into Kn actually lifts along the inclusion from wedge sums into products. So you can do this in a very painful way, in a very explicit way that will make Agda very happy. So actually, the fact that we pick this very complicated approach means that we're actually going to be able to carry out some concrete computations using these constructions in the future. Using these constructions in the future. So that's just something to have in mind when you formalize things in cubicle like that. You might want to go for the stupid approach every once in a while if you care about computation. Right. And inversion you can define very easily. It comes from the fact that Eilen-MerrimackLane spaces are just truncated spheres and spheres have an inversion on them. So you just pick the same inversion. So using this now, you can actually lift these operations to the command. Operations to the COM algebra groups. And you can easily prove that actually this plus and minus operations actually define a group structure on Comology groups. So that's cool. So we have Comology groups. This is not very hard, and this was not really new when we did it either. I guess it was barely new when Bruner did it even. So this has been well known in the community for a long time. So, so far, so good. But remember, what I wanted to define was this Hopfin variant because we're still trying to prove that beta is equal to two, although you probably already forgot about that. So, what we actually need is we need to talk about the ring structure on comology groups. So, this bit of Bruni's thesis was considered to be almost completely unformalizable for many years. Many years. And the issue is that this part of his thesis actually contains a pretty serious gap, which I may or may not talk about later. I can't remember. Yes, I will. Okay. So why is it so hard to define cup products or to define the ring structure on cohomology in homotopy type theory? Well, the issue is that you want a product on this form. You want a product that goes from Kn cross Km. Product that goes from Kn cross Km into Kn plus M. And what you would like to do is, well, you would just like to say that when n or m is equal to zero, well, you're done. It's just a left or right z multiplication, right? Because we define kz to be just integers. And when n or m are, sorry, when n and m are both positive, this map should really just come from the canonical map, the corresponding. Canonical map, the corresponding map on spheres. So you have a canonical map from the N sphere across the M sphere into the N plus M sphere. This is the map that induces the homotopy equivalence between S and smash, Sm and Sn plus M. This is very easy to define in type theory as well. It's a sort of a, you do it by recursion. It's almost a one-liner, I guess a four-liner or something like this. But the issue is, so. But the issue is, so so you can't actually do it this way. So what you would like is you would like to say, okay, I have this map from Sn cross S M into Sn plus M. And I have this quotient map going from the n plus m sphere into the n plus nth Eilen-Merg-McLean space. If you take the, you compose these maps, you get sort of a pre-cup product from Sn cross Sm into the n plus nth Eilen-Merg-McLean space. And then when you would like to say that. And then you would like to say the following. So you would like to say, aha, but if I quotient Sn cross Sm, I get something in Kn cross Km. This lift should exist. If this lift exists, we're happy. We know that this gives you the cop product and we know that this is actually going to behave the way we want the cop product to behave. Because if it exists this way, it's going to inherit all its properties from the corresponding map on spheres. The corresponding map on spheres. But the issue is that this lift doesn't exist in general. So, if you're a type theorist, which I guess not everyone is, but the idea here is that there's a truncation level mismatch. So, basically, this guy is not truncated enough for this lift to exist in general. So, you're kind of stuck. So, the way that Brunri solved this. So, the way that Brunri solved this was by just, it's a kind of a standard thing to do, I guess. You just replace all the products by smash products. And you draw the exact same diagram, but with all the products now smash products. And actually, the lift is going to exist. Now, the issue with this is, I don't know if this is as difficult. I don't know actually what you have in, for example, lean on Smash products, but in hot. On Smash products, but in hot dealing with Smash products is something that's very difficult. So, when Bernie did this, he also introduced implicitly a lot of bureaucracy because this definition of the cup product is going to be completely unworkable unless you know quite a lot of things about SMASH products. So, in particular, what you need is that you need to know that SMASH products are symmetric monoidal. And this is actually something that was open in HAT in general, although floor. In general, although Flores almost proved it in his thesis, a very nice argument, it was still open and hot until actually just maybe two months ago. So, and even if you assume that you have this symmetric monoidal structure, in my opinion, from the point of view of formalization, most of the proofs will still be rather sort of big and nasty diagram chases, which for me at least were technical to formalize. At least were technical to formalize, and from a computational point of view, defining the copper act in this way does not give you a well-behaved copper act from a computational point of view. So, for example, this diagram will not commute strictly. It will only commute up to a homotopy, which gives you very bad behavior when you try to actually compute something using the cup product. Okay, so what we did with we have this new So, what we did was we have this new approach where we, instead of working with maps out of a smash product, we define the cup product using this right-hand side of this adjunction between maps out of smash products and by pointed maps. So these are maps that are pointed in both arguments. So, the idea is that it's very easy to define a map like this. So, I call it diamond. It takes a point in the n-sphere and it returns something in this pointed function space from km to kn. From km to kn plus m, you can just define this by induction on n. So now instead of drawing the previous diagram, we draw this diagram. So we want to lift this diamond operation across along the quotient map from Sn cross kn. And now this lift does exist. So the issue before was that the space we were trying to map into was homotopically two. Topically too crazy on high levels. Whereas this guy is actually n-truncated. So for this guy, all n plus one-dimensional structure and higher will be trivial. So this lift actually does exist now. And that defines the cup product because, I mean, the copper act is supposed to be pointed in its right argument, right? So it's a very reasonable thing. And if you want to show that this is n-truncated, what you just do is there's a very nice. What you just do is there's a very nice argument by just you slam on the n plus one loop space, or if you're more classical, the n plus one homotopy group, I guess, and you just you notice that it vanishes. Yeah. Okay. Now, a priori, actually, if you do this, you require the codomain to be pointed, this pointed function space, you actually do introduce quite a lot of new bureaucracy that you might have to to take into account. That you might have to take into account. But I want to kind of brush that under the rug and just say that this doesn't actually matter in practice. And if you're interested, check out the argument. Oh, theorem X, shit. Oh, yeah. Ignore that. There's a theorem somewhere. Okay. But anyways, what I wanted to say was: well, we get a definition of the cup product in HOT, which is remarkably compact because the Remarkably compact because this definition here is very easy to define. This map is incredibly easy to define, and showing that this lift exists is very direct. And in fact, if you do it this way, it also makes this triangle commute strictly, which is very nice when you want to work with your copyright and prove things about it. So we could actually fill in this gap. There was a gap. This gap, there was a gap in the hot take on cop products for a long time, and we could actually prove that this mesh product, sorry, that the cop product is left and right distributive, it's associative, and it's graded commutative. So, this was open for a long time. In particular, the associativity was open for a long time. But by using this alternative definition, everything became incredibly easy to prove. Well. To prove, well, okay. The gradient commutativity was not that easy to prove, actually, but I'm just pretending this is not an issue. Um, okay, and what you do is, okay, you have the copyright defined on the Eilenberg-MacLean spaces, and you have proved that it satisfies all the axioms you want it to satisfy. You just lift it to Commodore groups where it's going to satisfy the exact same laws, and you're done. Okay. Okay. And yeah, so if you have an appropriate construction of direct sums, you can actually also construct cohomology rings, which we've done. Of course, now I'm realizing I'm talking to people who are not constructivists necessarily, so they might think I'm an absolute idiot for even mentioning the difficulties of defining the direct sum. But from a constructive point of view, the direct sum is a bit nasty. But anyways, this copyright works. You can make it into, you can, you can. Works, you can make it into, you can show that it induces a proper ring structure on the direct sum of cohomology groups. And voila, we have cohomology rings in hot. So that's nice. But the nice thing about this definition of the cup product is that it's not just easy to work with, it also computes well. So you have this typical textbook example of proving that the wedge sum of Proving that the wedge sum of a sphere with two circles is not homotopy equivalent to a torus. So why is this a popular example? Well, because these are the cohomology groups for both spaces in dimensions. Yeah, I mean, they share the exact same cohomology groups. So they're the integers in dimensions 0 and 2, and they're the integers cross-the integers in dimension 1, and trivial. Dimension one and trivial otherwise. So, in order to differentiate, what you need to do is you need to consider the cup product structure on these two spaces or on their respective homology rings. And what's kind of cool is, okay, so when you try to formalize this, you realize that what you really want to do is you want to consider this composition. So, you have a map from Z cross Z, and you map X Y into X X X X X you map xy into z cross z squared so you map x and y to x zero and zero y and then you send this guy to to to h1 of your space x and you take the cup product into h2 of your space and you go back into the integers via your isomorphism actually if you want to prove that the copyright behaves differently for your two spaces all you really need to do Two spaces, all you really need to do is consider this composite function. And this is a function from z cross z into z. So you can just define this in cubical agda and try to run it on concrete numbers. So this is something we did. So we defined it for the torus and we plugged in one and one and we got zero out just by pressing enter, which is very nice. Uh, which is very nice, and we tried it okay, Mickey, so it's for the Mickey mouse space because it's a wedge sum with a circle and yeah, with two circles and a sphere. So, we tried to do the same thing on this space, and we got zero back just purely by pressing enter and waiting a few milliseconds. So, that's very nice. So, this is actually a computation that does work and gives us a non-trivial theorem. So, you know, maybe something like this could come in handy when formalizing Bernoulli's proof. Although the original Although the original Bruneri number didn't compute, maybe something else could compute. Okay, right. Okay, so where were we? So after this digression, let's return to Bruneri's proof. So okay, so now we have cohomology groups. We have a cup product. And remember, we have this element beta in the integers whose absolute value we want to know. So recall now that beta is this isomorphism. is this isomorphism psi between pi 3s2 and the integers applied to the white head product of the generator of of the of the pi2s2 with itself product with itself so we want to uh to evaluate this number now i never told you how you construct this isomorphism psi and i won't either uh because the idea now is that you can since such isomorphisms are are Such isomorphisms are unique up to a sign. This is a very direct lemma, by the way, from the univalence axiom, if you're interested. You can just replace it by any other isomorphism, hi, such that the absolute value of h i applied to this bracket is equal to two. And you want to do it such that this is actually now easy to show. Okay, so we're just going to take our psi and we're going to construct a new isomorphism. A new isomorphism. And this isomorphism, HI is the Hopf invariant that I've mentioned before. And this is stated in terms of cohomology. Before I can define it, we're going to need one small lemma. So if you take a map from S3 to S2, remember this is an element of pi 3S2, you can consider its homotopy co-fiber, which is just this homotopy pushout. And if you take the, so it's the homotopy. And if you take the, so it's the homotopic pushout of f along the map into the unit. And if you take the homology groups of this, you get the integers in dimensions 0, 2, and 4, and you get 1 otherwise. And so using this, you can define the Hopf invariant in low dimensions, at least. So if you take a function f from S3 to S2, so an element of pi 3 S2. So, an element of pi 3s2, and let's let's let en denote the choice of generator of the nth co-module group of this co-fiber up here. So, the cofiber of f in dimensions n equals 0 to or 4. You can define the Hopfin variant of F to just be the unique integer such that the Hopf invariant of F times the E4 generator is the cup product of E2 with itself. Of E2 with itself. So, very sort of, I mean, I'm sure a lot of you have seen this before, but if you haven't seen it before, it might look strange, but it type checks. Now, the sort of remarkable thing is that this is actually defined, it's actually a homomorphism from pi 3s to the integers. So, this is something that Brunri proves and that we've actually formalized in Cubicle Agda. And you can also prove And you can also prove with a rather, you know, annoying but doable argument that the Hopf invariant of this element that we're interested in has absolute value two. And both of these proofs are essentially just exercises in linear algebra. I'm not going to go into detail. But so, what's the missing ingredient now is just: okay, we know that the Hoffman variant of this element that we're interested in. Invariant of this element that we're interested in is two. All we need now is that the Hopf invariant is actually an isomorphism. Okay, so what does this mean? So let's take, let's let H from S3 to S2 be the generator of pi 3S2. Of course, the Hopf invariant is an isomorphism if the Hopf invariant of this generator is equal to one, right? So again, we see we have come to a place. We have come to a place where we can solve our problem by a simple computation. So, this time we want to run the following function. So, you take, you go from the integers to the second Comology group of this co-fiber of H. And then you just take the diagonal going to this group product with itself. And then you just take the cup product, land in H. And then you just take the cup product land in H4 of your co-fiber, and you take this isomorphism with the integers again. So, this again defines a function g from the integers to the integers. And that's precisely the type of stuff that we can evaluate in Agda. So, we get a lemma. Of course, now if you evaluate this at one and you get that it spits out one again, you've essentially proved that the cop product is non-trivial, which in this case will mean that it's that the Hoffman variant of H will is equal. That the Hof invariant of H is equal to one. So if this, if G applied to one normalizes to plus minus one, then pi four S3 is isomorphic to Z naught two. So it's another time, another stage where we've actually reduced a deep mathematical statement to a single Qt computation in cubicle Agda. But of course, this is maybe not a great sales pitch because we can't even run this. We can't even run this, we run out of memory as usual. But at least, if this would have worked, we could have completely skipped formalizing the last chapter of Bruneri's thesis, which we now had to do by hand. So, if you're interested, what we formalized was the Gazine sequence, which is a tool you can use to manually prove this fact. So, it's a long exact sequence for a nice vibration sequence of this form. So, you get a So you get a sequence like this. I'm sure Floris talked about the SERIS spectral sequence because this is a consequence of the SERS spectral sequence, but we formalized this from scratch, so to speak. And using this long exact sequence, if you apply it to this vibration sequence from S1 to S5 into the co-fiber of the generator, you get the desired result with a little bit of algebra. And the topologists in the room will recognize this just as the usual computation of the Commodore ring of the complex projected plane. Anyways, I mean, it's annoying that we had to formalize it, but I guess it's also good that we got to formalize it because now we have it. And it was a fun thing, I guess, to formalize. But finally, we get the theorem. We get pi for S3 isomorphic to Z mod 2. Isomorphic to ZMOD2, which was a sort of a big milestone in the hot community, at least. I'm not sure you would consider it a big milestone in your communities, but for us, it was a cool thing to have done. Okay. So let me summarize. So what we've done is, well, as I said, we formalized Pi4 S3 isomorphism to Z mod 2 in cubicle Agda. Now, what I didn't tell you. Cubicle Agda. Now, what I didn't tell you was that we've actually formalized a couple of different proofs too. So, actually, this different proof is a very direct proof of this theorem, which doesn't use any cohomology, which is also why I thought it would be inappropriate to talk too much about it in our workshop on the formalization of cohomology theories. But I just want to mention that it exists and it's a nice thing. I would be interested if it could. I would be interested if it could be carried out in other settings than homotopy type theory as well. In particular, we've formalized a lot of cohomology theory. So we've formalized cohomology groups, rings, Gaussian sequence, the Gaussian sequence, and many other things. I guess I also want to mention that we haven't just formalized cohomology groups and rings, we have actually computed quite a few cohomology groups and rings of elementary spaces, just to check that our theory works. Theory works the way it should. And we've actually verified the Eilenberg-Steenrod axioms for our theory as well to make sure that it's a good cohomology theory. Everything formalized, of course. Now, I also want to remind you that in several places, we saw that this idea of proof by computation could just completely trivialize large parts of the formalization. So, this is something that I'm very excited. So, this is something that I'm very excited about. And even though it's not working great right now, cubical Agda is still a very young proof assistant, and cubical type theory is a very young type theory, of course. So maybe in the future people will improve cubical like that. And I know people are already working on improving cubicle like that, or at least developing new constructive proof assistants that makes these shortcuts possible. So I would be interested. Possible. So I would be interested in hearing what people coming from maybe from Leen think about such proofs. They might be philosophically unsettling to some, I bet. But I would be curious to hear what people have to say about this idea. But that's all I had, I think. So thanks for listening. I hope this was okay. I have no idea because I can't see you, but yeah. Questions? Thanks. Can you hear me now? Yeah, I can hear you. Can I actually see you? Is there... We have a camera pointed at us. Okay. So I was wondering, several of those computations you said, like you had to wait for a couple of milliseconds, but for the final big theorem, like how? Theorem, like, how fast is it? So, so like it's no longer 10 gigabytes of RAM, but is it still one gigabyte of RAM or no? So, actually, we haven't been able to. So maybe it's your question, sort of how long does type checking, the proof, because actually this idea of proof by computation hasn't really been working. Idea of proof by computation hasn't really been working out for us, but type checking the whole proof, I think, takes maybe 20 seconds or something. Oh, so I mean, or maybe a bit more actually. I guess it all depends on which modules you've already loaded. It's a bit hard because it's a big library and you're loading a lot of stuff that's not actually relevant as well. But I wouldn't say that that takes too long. The real problem is running these concrete computations. The real problem is running these concrete computations and then Agada just eats up all your memory and you're dead. Okay. Questions? Yeah, so I had a question. So you're saying that all these computations take way too long. Do you think, like, if there are any improvements in these computations in the future, do you think that is mostly on the ACTA side? mostly on the active side like better uh like more efficient like productions or do you think that we'll discover like like more like uh constructions that compute more efficiently uh like where do you think like the gains can be found yeah so so uh i guess i can say so like uh in the beginning when we started this project i was convinced that agda was uh was perfect uh and it was And it was on me as a user to make sure that my constructions are as efficient as possible. So, in a sense, I think this is a nice philosophy to have because it really forces you to be sort of clever about how you define things and actually led us to finding new constructions of old things. But these days, when I'm a tiny bit more mature as a type theorist, I actually know that people are actually already finding places where cubiculita can be improved. Like that can be improved. And there's actually right now, so I'm at this other conference. I think right now I'm missing a talk precisely on this. So some people, so it's Andris McBey from Stockholm and Andris Kovac from Budapest, I think, and Evan Kavallo from Stockholm. They are working on actually have sort of isolated a couple of what seems to be maybe bugs or implementation bugs, at least. Implementation bugs, at least in cubicle Agda, where it seems that Agda is just doing a lot more work in normalizing stuff than it should have to. So I think actually the future is looking fairly bright right now. And they're managing to compute, at least they're not managing to compute everything I've mentioned here today, but some of it has actually been partially computed, I would say, in that some variations of the numbers that I've. Variations of the numbers that I've listed here today have actually been computed in a more modern framework. So, yeah. Okay, thanks. So, one of the main points that you told us about was the formalization of the definition of the cut products for the cohomology defined in terms of the Eilen-Berg and Klane spaces, right? I guess I'm wondering whether you gave any thought to defining. To defining massey products or other higher homological operations. Because the only formula that I know, explosive formula, involves actual co-chains, involves actual chain complexes and things like that. Yeah, so sorry, maybe I interrupted. No, no, go ahead. Okay. Yes, so massive products, I'm not sure actually. So I've Sure, actually. So, I've uh I haven't thought much about massive products, but what I can tell you, maybe uh, well, so at least something like, I mean, so some things we can't define, I guess. So, I don't know if you're familiar with like the cup I product that's used to construct the steenrod squares. Uh, at least in the original construction of steenrod squares, this really happens on sort of on code chain level. Sort of on co-chain level. And these we can't. So if you try to actually state what they should be on LM Mergenclin spaces, you see that they have to be trivial. But what I can say is that we do know in heart at least how to construct the steenrod squares. So that's at least a step in the right direction. But massive products I'm not sure if anyone has thought about this, but it's something that I probably should be thinking about. What I probably should be thinking about. It's a very good suggestion. Thanks. So I noticed that in your definition of Sn, you did this inductively. For zero, you define it to be bool, and then for one you define it to be S1, and for a larger N, you define it to be, you use suspensions. But so why do you choose to define one? Choose to define one explicitly, like S1 explicitly, and don't use it. Is that related to computations? Yes, yes. So we get a lot of shit for this wherever we go. People are really upset about this. I understand. I think it's ugly too. But it is actually. So, actually, this whole project started when I was writing my master thesis. What is it, four years ago now, or something? And then I had no idea of how to make things go fast, but I was desperately trying. And the only thing I found that could make things go faster was this stupid change in definition. So it turns out that if you have S1 here, at least lower cohomology groups or operations on lower cohomology groups will compute quite a lot faster, actually. So there were some examples of computations that I carried out in my master thesis that wouldn't compute. That wouldn't compute with the more reasonable definition of S1, but did compute with this one. So, yeah, that's why. So, it's, I mean, I guess the reasonable thing would really be to even start at defining s minus one to be the empty type and then take suspensions. That would be the most elegant way of doing it, I guess. But yeah, it's purely for computation. Yeah. Okay. Yeah. Okay. Thank you for that. Any other questions?