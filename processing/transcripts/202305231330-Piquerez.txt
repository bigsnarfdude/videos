So, welcome back for the afternoon session. So, we're very happy now to have Matthiel Queres from INRIA, who is going to tell us about the formalization of diagram chasing. Okay, thank you. Yes, I want to talk about a project I am doing with Asiam Abubi about formalization of diagram tracing. So, first, I will recall what I mean by I will recall what I mean by diagram tracing and diagrams and things like that, and what are the motivations towards this formalization. And I say what I want this formation to do. So I want to implement a library to let people do formalized diagram. Okay, so what is the diagram? So first, what is a graph? So for me, a graph First, what is a graph? So, for me, a graph, so it is what it's so in mathematics it's called quiver. So, it's just a finite set of vertices and finite set of arcs. You theorize loops and multiple edges. And the diagram is a decoration of this graph with a category, more or less. So, to each vertex, you will put an object of the category. Put an object of the category to each arc. You will decorate each arc with a map of the category. So, for instance, okay, in the examples, I will use sets for vertices and a function between sets for the arcs. And so, you say that, so for instance, instance here, you have a set A, a set B, and a map F from A to B. And I will say that the diagram is commutative if for any Commutative if for any two vertices and any and for all paths going from the first vertex to the second vertex, the composition of maps are equal. So for instance, the composition of this map and this map and this map is equal to the composition of this map and this map and this map is equal to the composition of this map and this map and this map. Okay. So let me give an example of a proof by diagram tracing. So I guess there are several kinds of diagram tracing. I'm interested in diagram tracing for homological algebra. So if I have two maps, F and G, so I write F and G for the composition of G and F because this is more like the way we go when you follow the path. When you follow the path. So, if the composition is injective, then the first map is injective. So, this is a very simple proposition, and we can prove it with diagram chasing. So, I take a diagram like that, and I assume that the diagram is commutative. So, this means that the map from A to C is just the composition of F and G. Like, going through this path is the same as going through this path. This path is the same as going through this path, and I want to prove that I assume that this is injective, and I want to prove that f is injective. So I will take two elements, x and y in A, and I assume that their image here is the same, and I want to prove that they are equal. But their image here is the same, so I can take the image back G and I get a B here. Get a B here, and so since the as the diagram is commutative, both x and y are mapped to B through this function. But I assume that this function is injective, so they are equal. And so it's what I wanted to prove. So, okay, this is a kind of diagram tracing. You take some elements into the sets and you look at their images. You look at their images, etc. So, another example is if you have a composition which is surjective, then the last map is surjective. So, okay, it's the same kind of proof. I assume that the diagram is competitive. I have an element C here and I want to find an element B here, which is its pre-image. But since this is a subjective, I can find a pre-image A in A, such that C may see it C. C makes it C, and then I can take the image of A by F. And since the diagram is commutative, the image of B is C, and so the pre-image of C is B, and it's okay. Okay, so here the proof are quite different, but in fact, these two propositions are in some sense dual, and there is a kind of dual theorem which says that, in fact, if you have Which says that, in fact, if you have proven the first one by diagram chasing, then the second one is proven too. So you just have to do the first proof, which is not obvious at all. So this is the first motivation towards this formalization. It is to have this GRETI theorem. So other motivation is, okay, so these are just slides who explain that. To explain that diagram chasing is also to explain what is a homological theory. And so, if you want to do to prove theorem in homological theory, you might want to use very powerful tools like spectral sequences. And in general, if you want to define spectral sequences, etc., you will use a bit of diagram tracing like you. A bit of diagram chasing, like you need the snake lemma or maybe the cylinder lemma. Okay, so diagram chasing is very useful in this kind of mathematics. So this is a part of my thesis. So I work in tropical homology and so I have this kind of double complexes and even triple complexes and I had to prove that this And I had to prove that these very ugly things are commutative. So I have 10 pages of full calculation, very technical. And it would be nice if these calculations can be partly done by the computer. And if the computer can tell me that I have not forgotten any cases, etc. So, in fact, this is the first time I thought about doing this formalization. Another example, this is from a book, and so there is this nice corollary, and there is no proof there, it's just written or rather involved diagram chase can be used to show the following consequence. So even diagram chasing, it's a bit technical and it's often not really. It's often not written in the article. So, if something is not written in the article, it might be some errors in it. In fact, more or less, it's a simpler case, but I think it's the same proof. It's a diagram chasing of the previous corollary that I have done in another article. And so. And so, for instance, I want to prove that for so here I assume that the rows are exact, so I will just give you the idea of real diagram tracing in a more complex example than before. So, you don't have to understand what I say just to show you how it looks like. So, I want to prove that for any R here, I have an A double prime here. So, I have a map from this. Prime here, so I have a map from this to this. So, since there is a R here and here it's zero, you can find a pre-image. Then you have the image here, and the image is zero, because here it's a chain complex, and here it's zero. So, you can find a pre-image, which is unique, because here it's zero, and then etc. So, really diagram changing is you have some rules, and you have to play your game respecting these rules, and it's a lot of. it's a lot of hand waving and I want my uh I'd like to have an implementation where you can just play the game like that and behind that there is a formalization which says that okay what you have done is correct okay so let's summary what I want so first I want to formalize it so formal First, I want to formalize it. So, formalize it. Maybe I want to restate what is result about diagrams, about this kind of diagrams in a very simple way, in order to be able to state, for example, the GHT CRM or to do some proofs. So, I want something simple, and in fact, there is this nice. And in fact, there is this nice, so it's a third proof, but which seems to be true. So, every statement about this kind of diagrams, I think they can be rephrased just saying that on these big diagrams, like if these sub-diagrams and this sub-diagrams and this sub-diagram commute, then the big diagram commute with some quantifiers. Okay, but it's commutativity which is at the heart of everything. Which is at the heart of everything. So I will have a more precise statement of the thesis later. So this is the first thing I want. The second one is modularity. I mean, by this, I don't want to impose the notion of diagram because I want my project to my library to be used by very different people on very different projects, like Projects, like there is no single, I mean, there are so many ways to define categories, and even it's a bit hard to define categories, for example, in cook. So maybe someone will have one notion, someone want to do it for one precise category or another one. So if I can not impose a notion of diagram, it will be simpler for the user to use my uh simpler for the user to use my to use my my library so I will just impose a notion of graph but not the notion of diagram so I will ask some axioms some properties on diagrams to the user but not impose a notion and if it it would be nice if it can be if the library can be used in several professors Used in several proof assistants so I have in mind mainly Coke and Lin because I'm using dependent type theory. Okay, so I want the duality theorem. So the duality theorem, so you have seen that we have two propositions and I only have to prove the first one about injectivity and I get the second one for free. And for instance, there is, I think. And for instance, there is I think so I have not looked very into the details, but I think there is this proof of the snake lema in Lin. And in the snake lemma, more less, one third of the proof is just the dual of another third. So if you have this duality theorem, you can just don't prove, just say by duality, I have the second third. So you reduce almost by half the work, and I think in the implementation. Thing is implementation of the proof of the stack NEMA, they don't use this kind of thing. And so if the computer can help me proving these commutativity things, which are just technicalities, which are a bit boring, it would be nice. Okay, so now I will give some details about my thesis and about all these points. About yes, about all these points actually. So, what I mean by I can reduce the statements to statements about commutativity. So, I will give an example. How can I define injectivity thanks to commutativity of subdiagrams? Okay, so here is the classical definition of injectivity. If you have two elements such as which are equal such that which are equal by a z image are equal by h so if h is injective uh h is injective if h of x equal to h of y implies x equals y so this is not a very practical definition for our purpose so I will use the definition in category theory which is not exactly the same but like for the category of sets is the same. Forgetting the category of set is the same. So you say that H is injective if for any two maps F and G, the composition of F then G equals G, then F then H equals G then H, then F equals G. Okay, so it's not hard to prove that they are more or less the same. For instance, you take It's the same, for instance, you take f the function constant equal to x and g the function in constant equals to y. So you have one direction doing that. Okay, so it's colonic in the category because it's not exactly the same as injective. And so I can use this kind of thing. So now I will state what is injectivity. What is injectivity thanks to diagrams? So I said: okay, this is a diagram with just one arrow. And I will say that this diagram is injective. So you have to understand H is injective if for any bigger diagram like this, which coincide with H on this part. So in particular, if I choose a bigger diagram, I have to choose this. Bigger diagram, I have to choose this map F and this map G. So if for any bigger diagram like this, such that this phase commutes, which just means that this arrow is a composition of F and H, and if this map commutes, so this is the composition, and if this outer phase commutes, which just means that this equals this, then the last phase commutes. The last phase commutes. So I repeat everything. So H is injective if for any diagram on this bigger diagram, on this bigger graph, such that this phase commute and this phase commute and this phase commute, then this phase commute. So if you think a bit, we are just saying that if these two things are equal, then these two things are equal. Than these two things are equal. So I can write it. So in cock. So here is my notation for graph. So graph is just a list of arcs. So for instance, A is 0, B is 1, and C is 2. And so this graph here is just a graph with one arrow. And this picker graph is, you have two rows between A and B, one arrow between B and C. B one arrow between B and C and two arrows between A and C. And so monic, so here it's I say that a diagram D on the graph map G, so on just zero, is monic if for all diagram on the bigger graph, which coincide with H, so which the small graph, so this here. So, I mean, the restriction of the So, I mean the restriction of the diagram on this part is H, which commutes on the three faces, then it commutes on the last face. Okay, so I can also state the very first proposition I've shown you. So, I call it Mono M. So, here is this graph, and I said the proposition. And like that, so the proposition is that for any diagram on this graph, which is comm which commutes, if this map, so the second, yes, sorry, I forget to say, but the restriction it just indicates in this indices of the arcs I preserve. So here it's a restriction to the second arc. So if you are injective here, then you are injective here. Injective here. Okay, so here you see I have just used some quantifiers, commutativity and equality of diagrams. So it's exactly my thesis. So here is the thesis. Every statement about diagrams can be expressed in this language, written in cock here. So a term is a diagram. Diagram. So it's either a diagram from the context or the restriction of a diagram to some subgraph. And now a formula of my logic is a quantifier. So a quantifier is decorated with a graph, which means that, for instance, I have a for G this is this means for diagram D on G we have such formula. Or there exists a graph T on G such that such formula, and you need implication, and, or, true, false, etc. But the only things you can say about diagrams, you can ask if they are commutative or you can ask if they are equal, and you need nothing else. So, okay, you can also quantify on graphs, for instance, if you want to say that some category has. Want to say that some category has all limits, you will say for any graph for any diagram on this graph, which is commutative, there exists a diagram on the graph with an apex, etc. So you can also do manipulation on graphs, but the only things you have to say about diagrams is commutativity and equality and some quantifiers. Okay, so this was the first part about the thesis. And now about modularity, so I claimed that I don't really need to define diagrams to impose a notion of diagram. So why? So for instance, I can claim that a diagram on this graph is commutative if it's a restriction. Commutative if its restriction on each square commutes. So if this square commutes, this square commutes, etc. And to say that, I just have to look to the graph and not read to the diagram. So it's a really idea. I just want to work with graphs without knowing exactly what is the diagram. But still, I have to ask something to the user. So I will ask I will ask so even commutativity. I will not ask him why and when a diagram commutes, I will ask something more simple in some way. So if you have a notion of diagram, you can easily give me a path relation a priori. So I call it a path relation. I think it's called a categorical relation. A categorical relation is a literature because it's a good way to go quotient categories. So, what is it? It's you take two vertices in your graph and a path reaction is a, okay, for any pair of vertices, you have a reaction on the path, equivalence reaction, a relation of equivalence on the path going from one vertex to the other for any pair of paths. The other for any pair of paths, and you want it to be stable by concatenation. So, for instance, I have three vertices, I have a path from the first one to the second one, like I have four paths like that. And so, for instance, these two paths can be in relation, and these two paths can be in relation. Then this path here has to be in relation with this path here. Here. So, the main example, of course, is of such a patriotism: equality of composition of maps in a diagram. So, if you have a real diagram, you will say that two paths are in relation if the composition of the corresponding maps are equal. Okay, so let me be more precise on. Ah yes. So I said that the passer. So now to know if something commutes, I don't know what is the diagram, but I know what is the pass ratio, and I can say that a pass relation on a graph G, so now I'm just looking at something on G, commutes if for any pair of vertices, all the paths going from the first vertex to the second one are in a relation, so the relation is complete. It okay, so this is what I ask actually to the user. So, in fact, it's not really okay, so I don't ask him, okay, so I have this notion of universal diagram and I don't impose it, which is I just ask it to be of type type, so it's anything. So, the user give me something, I don't know much about. Something. I don't know much about it. I will just ask this thing that I need. So a diagram is something, a universal diagram, and a graph. So it means that this is just a trick to make the proof easier to be done. Instead of asking a diagram on a graph, you are asking a universal diagram. A universal diagram, and you will decorate it with a graph, and the user knows what it means. The user knows that this pair means that you have this universal diagram restricted to this graph. So, such it's really a diagram on this graph. So, I want the user to tell me how to restrict such a diagram to a subgraph, to tell me when two diagrams are equal. Tell me when two diagrams are equal and to give me the path ratio associated to each diagram. And then, as I explained just before, a diagram is commutative if the associated path ratio is commutative in the sense of path ratio. And I asked some compatibilities. So, here is there is a lot, there are a lot of compatibilities asked. So, I think I have an idea to I think I have an idea to don't ask the restriction, and if you want to use the library, then you just have to give me that and that. And here you have many less things to prove. Uh okay. So now we can go to the JT CRM. The duality theorem. So, as I explained before, surjective is the dual notion of injective, so you cannot see it on the classical definitions, but you can see it's easier to see with the categorical definition. So, here we have already resisted the definition, and more or less epic is the same definition, but you preverse H and F. So you are epic, H is epic if F H then. peak if f h then f equals h then h g implies f equals g okay but it's even easy easier to see if you look to diagrams so here i recall the definition in of injective i said that h is injective if for any bigger diagrams such that this commutes this commutes and this commutes then this commutes so it's objective i just reversed the error I just reverse the arrow here and I said that H is surjective if for any bigger diagram here, so in particular I have to choose F and G which commutes here, so here it's the composition and here it's the composition and here, so they are equal, then this last phase commutes. So the only thing I have to do is to reverse all zeros and then it's exactly the same definition. So it's very simple to define So, it's very simple to define the dual of something thanks to diagrams. And so, I said that Monic is this. And now to define epic, I just take the dual. So, what is the dual? It's just I look at all the graphs operating in my term and I reverse them. I just reverse all zeros. Okay, so the question is: how can I do that in Coq? So, the problem is that I have to. So, the problem is that I have to work by induction on a cock term, but this is not feasible, or you have to use a meta tool which you have to use something outside of cock. But I want to stay in cock as much as possible, so I cannot define it like that. So, the idea, yes, so I want to do that. And I so also want to have a duality theorem. So, if I want to prove the second proposition, like the composition of two subjective. To surjective, but if the composition of two maps is surjective, then the last map is surjective. I just want to use something which is the duality theorem, and then it remains to prove the dual proposition, which is mono-mono-m. So the first proposition I have shown you. But let's say that this is already done. So, okay, it's done. I just have to prove this, and I have this for free thanks to the GATE ECRM. Okay, so how can I do that? Okay, so how can I do that? So let me first explain how I can define Joule staying packed. So the idea is to define so I have already shown you the solution. I have to define a small language inside Coch, which is the language I have shown you before. And then I have this jewel and I can work on this language by induction. And so the jewel just And so the jewel just take a formula and reverse all the graphs in per uh which are in it and I have an evaluation function which transforms a formula in this into a real cock term so now I cannot dualize directly a cock term but if I have a formula which evaluates this cock term I can dualize this formula and then evaluate it. Okay, so with what we have with this language, we can prove this nice theorem, which says that, okay, I can define some function which replace one term by another. It replaces in f the case occurrence of t0 by t1. And then I can prove this nice theorems which say that, so recall that the term is just a diagram. A term is just a diagram, so I can evaluate it to a diagram. If both diagrams are equal, then f is equivalent to where I replace t0 by t1. Okay, it's trivial, but you can prove it in calc, which is quite nice. So maybe we can do something similar for duality, like if the evaluation of f is equivalent to the evaluation. Of f is equivalent to the evaluation of the dual of f, but this is not, this cannot be done because it's wrong, because you can find some notion of diagram in which some formulas are true, but the dual formula is not true. What happens is that the duality theorem are not stating that if f is true, then the dual is true. It's more or less like if you can do a proof by diagram chasing with f to. To prove f, then the dual of f is also true. Or maybe you can use some axioms, but you have to be if you use some axioms and the dual axioms are also true, then you can use them. So you cannot do that directly because once you have evaluated f, you can use all the power of cock to prove this, and there is no way to ensure that you have only. No way to ensure that you have only done a proof by diagram tracing. So you have to do once again proof, but for the smaller language. And so I use this kind of proof, which is just to use tactics. A tactic transform a formula in another formula. And I say that a tactic is valid if after applying the tactic, the new formula implies the last one. New formula implies the last one, and a proof is a sequence of tactics. And then I can prove this theorem if all the tactics I use are valid. And if checkproof F of proof, which means that after applying all the tactics, then I just get the true formula, which is trivially true. Then the evaluation of f is true. F is true. So I'm simplifying F until getting true, and so this is true. Okay, so this is a notion, more or less a higher notion of proof, a smaller system of proof inside Coch. And so now I can say the duality theorem. Some of these tactics can be dualizable if there is a dual tactic, which is also valid and which could be. which is also valid and which commutes with the duality. The the dual tactic applied to the dual F is equal to the dual of the tactic applied to F. And so now I have this duality theorem which says that if you have a valid proof such that all the tactics are dualizable, then the dual of F is true. Okay, so why is it nice? Because now you just have to write your tactics, like you have the basic tactics. Like you have the basic tactics, like your elimination and introduction tactics, which are dualizable. So you introduce these tactics, you prove that you are dualizable, but you can also have more powerful tactics, like you can have one tactic by rule you want to apply in diagram chasing, like what I have done at the beginning. Like if you have this element and then a zero, you can find a pre-image. So this can be a kind of time. Image. So this can be a kind of tactic. And you just have to prove. Okay, so you just have to prove that these tactics are during. So the last one, in fact, you can prove it thanks to basic tactics, which are durables. So it will be during, etc. And once you have written a bunch of tactics, you can just use them and you know that your journey and you don't have to prove And you don't have to prove again that they are jurisable. All you proof you have done just with this tactics verifies the jury this year. Just yes, I just want to say that so with Cook you can just cock will compute everything for you if you write. So this is computed by Cook and you can just focus on finding the proof. If you write things properly, I hope so. For now, it's not so it does not work so well, but I pray it would work. Okay, so as I said, you can use you can add axioms if you want to, for now we don't have if you want to work with abelian categories or things like that. The system of taging lets you add axioms very easily, or you can have. Easy, or you can have more powerful tactics. So, this will write tactic, or so, a Komoto is a tactic. So, this is the last part, which helps you to optimize proofs about commutativity. So, as I said before, a diagram on this graph is commutative if it is commutative on these four subgraphs. four subgraphs and I so I have written an algorithm which is which is commerge so commerge takes as an input a big graph and some subgraphs and its return either true or false if it returns true then any diagram commuting on the all the subgraphs will commute on the big graph and if it returns false then you can find a contra example so So, Commerge only works on acyclic graphs because on cyclic graphs it's an undecidable problem. You can more or less encode the word problem, which is undecidable with this problem. Okay, there is if you just have the big graph and don't want to guess by yourself the small subgraph. yourself the small subgraphs, then you have another algorithm which helps you and gives you the small subgraphs. Okay, so more or less this are the idea in order to have the library and all the specifications. So let me summarize what you have done. So yes, so for now, so okay. So, for now, so okay. So, the idea was really to have something to help mathematicians to do to do proof which are formalized. So it's there are, so yes, it's what is called in abstract nonsense in mathematics. This kind of use of diagram chasing and spectral sequences, etc. It's very powerful, but quite dangerous because they are very technical and you know. Because they are very technical and you don't want to write all the details, so a computer can help you write all the details. Okay, so for now here is a good idea there is the language is written. So more or less the thesis is formalized in cock. So the GOAT theorem also is written. Theorem also is written, and we have this algorithm commercial proven in cock. I mean, the soundness is proven, not the completeness, but okay. So, next step is to prove that, okay, it will work, like to prove this very simple proposition and to use it to use the library for that mode, so the category of Z module in code. Mode, so the category of Z module in Coch, and just to prove that okay, it can really be used, and then we can define abelian categories and the first basic results about diagrams like the five lemma and then the snake lemmas, Salamander lemma, etc. And I'd like to write a pedagogy to Yes, a graphical interface to do hand waving, to do diagram chasing by hand waving, and then maybe adapt it to use it in LIN and then think about more powerful tools. So I have to so for now we have only finite diagrams and that you want to use it to infinite diagrams. You want to use it to infinite diagrams in order to be able to talk about chain complexities and spectral sequences, maybe diraf categories. I don't know much about diraf categories, but okay, so this is the progress of the project. So, okay, if there are some people which are interested in this project, I would be glad to have some beta testers. Have some beta testers, so if you want, so not for now. I think I will okay. If you are interested, you can just tell me and when I think the projects will be so the progress will be far enough. I can tell you and then if you want to test it to prove the snake lima or I don't know what or to implement it for your favorite category. Okay. Okay, this would be very cool. And also, to do exactly what I said, so I know nothing about Lin for now. So, if you want to help me adapt it for Lin or if you know something about graphical interface, and then so I think that like to prove the sec name as etc. I see no no issues. Maybe I will need to look a bit uh above on uh uh look a bit On look a bit the projects that already exist to define chain complexes and spectral sequences and things like that. And so, DRAF categories, I don't even know if so I know more, I have seen the definition, but I don't know if diagram tracing is useful for draft categories. So the thesis cannot be proven, but you can find a counterexample, I guess. Find a conterexample, I guess. So, if someone has an idea of counter-example, I would be very interested to hear it. So, the next point, yes, more or less the basic lemmas about diagram chasing and can be more or less overhearmed by spectral sequences theory. So, yes, if you have formalized spectral sequences. If you have formulaized spectral sequences, you don't even need to do, I think it's my opinion. I don't know, maybe it's wrong, but I'm wrong, but you don't even need to do diagram chasing to prove the snake lemons, etc. But still, the project is still interesting if you have the spectral sequences, because it can help you prove the commutativity, like as I have shown you at the beginning. As I have shown you at the beginning, if you have this big spectral sequence, it can be quite painful to prove the commutativity things. And also, diagram chasing I have shown you at the beginning, the big example. I don't know how to do it with spectral sequences. So still it can be useful. So yes, I don't know. So still in the same question, more or less. I don't know if the dual. I don't know if the duratist CRM can be used to do something useful when you uh once you have spectral sequences. Okay, and maybe the IEDs can be useful for other kind of diagrams. I don't know. Okay, so thanks. I will stop here. Thank you very much. Thank you very much. And for questions, I don't know if anybody can hear us, so if we need to go up, but who wants to start? Yeah, thanks for the talk. So can you hear me? Yes. Okay, wonderful. Yeah, so I was wondering in this language, is there some sort of designable fragment where automation could You're saying, like, this co-merge right. For general graphs, it's undecidable. Okay, and you're saying for acyclics it works. I see. And so something like the snake lemma, would that fit in there? Or how would that work? I think I'm not, there's an existential in the snake lemma, depending on how you phrase it. How do you translate that to a question about community of some? So I'm not sure I get all the question well, but so with the language you can express more as a word program, so it's not a disillusion maybe if you if you if you forbid acyclic graphs you have something which is disillabel, I don't know. This label, I don't know, and maybe you can express everything with acyclic graphs. I don't know, it's an interesting question. For the snake lema, indeed, it's acyclic, so but I mean, if you have something acyclic, you don't have the identity maps, you don't have isomorphisms. Is it more as a question? Well, I think, like, certainly the usual diagram in the snake lemma is acyclic, but but how do you Is acyclic, but how do you translate the existential into a question about community of a graph? And if you can do that, do acyclic. Like the existing structure is just there exists, you mean the existence of the map, the snake map, so it just there exists diagram on the same graph, but with this snake map and my And more or less, if you have, yes, such that everything blah blah blah blah blah blah is exact, etc. And you have also the uniqueness because if you have two such maps, then they commute. You just have the face with the two maps commutes, so they are equal. And here I have no acyclic. We can communicate with our correctly. Yeah, but it's not like the usual statement is not unique. You need like a pretty complicated statement to make it unique to the case. Yes, but it's I mean it's complicated, but in a more simple language. Okay. So is there is this code with the with your first order language, is that available somewhere on GitHub or? Somewhere on GitHub or something? Not yet. I hope it will be available in one month or a bit more. Okay. I can send it to you if you send me your contact. Okay. Great. Sorry, we don't hear you online. Yeah, my mic is right there. Yeah, my microphone directs out. Yeah, thanks for it. Question from our boy? Sorry, we don't hear you. Oh, we lost him. Sorry, there was a person online that was asking a question, but his microphone wasn't working. But his microphone wasn't working. So looks like he's in trouble. Okay. Maybe in the meantime, I also have a question. Do you have any examples where somehow it's not instant? Like I know that you said that the decidable fraction fragment is not all of the problems you might be doing through, but in their problems where you don't hear that works. Do you have any examples where it takes a noticeable amount of time? It takes a new school amount of time. Sorry, I hear it's the sound is very noisy. I don't understand. Did you want to come forward a little bit? Yeah, so I'm not sure if I understood if you have automation for a certain fragment of the problem, but are there some examples where somehow there is automation, but it takes some time rather than being fast? So, an example, such what? Sorry, I really understand. Do you have some questions about the question? Or not? Would it be time-consuming automation or fast automation? I guess. What do you think the difficulty is? What do you think of the difficulty of the computation? Okay, so more or less the complexities of Commerge is something like the square of the number of edges. So it's not so, I mean, you only work with small diagrams in practice, so it's not long. But in fact, Incak is a bit long because things are represent. I'm using that. I'm using nats of code, which is not the binary numbers, etc. So it's still a bit long, but it's okay. Do you hear me now? Yes. Yes. This is Joel Hu from Orsay. So you mentioned the snake lemar, and it's true that in the first proof, the snake lemma in lean, so well, we have six other. Have a six-object sequence, we have to prove exactness at four points. And you said that it's true that if you have two exactness, let's say on the top of the diagram, then the rest can be deduced by duality. So recently, I formalized, I kind of de facto the homology in Leene, and I was able to prove the snake lemma like in only half of it and then dualize it to get the other part of it. To get the other part of it, yeah, and so on. Nice, okay. It works very well, and so you prove it like using elements and things like that, or you have to prove it? I will discuss a little bit of this tomorrow in my talk. Not a full machinery of pseudo-elements, but something kind of kind of very weaker, very low-tech approach, actually, but it's very concrete and Can I just do the video management? So I'm just wondering whether you have any thought to replacing graphs with multi-graphs and trying to do something similar for higher categories. For higher categories, it seems like a natural generalization. So, like multigraphs are like you have faces of higher dimension or something like that? So, yes, I have nothing at all about it. So, if you have, I'm interested in discussing about it, but I don't know. Yes. Okay, thank you very much, Attila. That was an extremely interesting talk.