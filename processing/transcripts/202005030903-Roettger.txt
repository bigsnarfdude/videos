I just want to start off with thanking the organizers. This has become one of my favorite conferences to be invited to, even though this is a strange year. I'm still really happy to be doing this. And it's a really nice community to be a part of. And I'm really happy to be a part of it. So thank you, the organizers, and thank you to Burrs. And I see this. And I see the same community at other conferences too, and I really like it. Okay, I wanted to show two backgrounds I wanted to do for my thing. And I'll say why I rejected the first. And then I thought it was too busy, but I thought it was funny. I thought maybe having a kid dancing for a seven-second loop might get annoying. I don't know if you can see that. Oh, yeah, there we go. That. Oh, yeah, there you go. But then instead, I thought this calm, calm background might be the nice one to go with. And you might recognize it. It's an image of a beach that Hugh and I have just walked along. Maybe it's his own. And you might say to yourself, but there's only one set of footprints. And I'd say it's because he was carrying me. Just like this talk. Just like this talk. All right. Let me share this screen here. Make it big. Does everybody see that? Yeah. Okay, good. Thanks, Renata. Okay. So recently, Hugh invited me to work on this paper. He had an idea, as he often does. Had an idea, as he often does, and I think it was a good one. I lazily stole the title of the paper, and I said, Some primality tests constructed on a cubic extension of Luka functions. Okay, I'd like to say there's a slight lie here. I'm only going to mention one test. I focused on just a sufficiency test. There is a test in the paper that does sufficiency and necessity. Sufficiency and necessity, but I don't do both. Okay. Oh, can I also start with a quick Professor Guy story? That's okay. Mine's very short. I think Bernard might have met this talk. Bernard, do you remember that? Well, this is a funny statement. Slightly over 10 years ago, we were at a talk of Professor Guise, and he mentioned the new result he had. And then he looked into it and he saw that someone beat him to the punch. That someone beat him to the punch. Do you remember who beat him to the punch? To the punchline? Professor Guy. He had already figured out this result in the 70s. When he looked into it, it was himself. And I thought, that was hilarious. Anyways, imagine having done so much that you can discover something and not realize initially that it's you who discovered it. That's not my life. Okay. I'm going to mention the Luka functions. Luka functions, you know them, but I'm going to say a few properties. I'm going to mention a generalization. Certain people here are going to be very familiar with them, especially Renata, because these are the exact same generalization that was in my PhD thesis that you were on the committee. So you've read this fully. But anyways, here's the Lukov functions. Here's a Benet's formula for them with the alpha, beta, zeros of this quadratic. We make these integers p and q relative prime Lukov functions. All right, you know those. I'm not going to dwell on them. All right, you know those. I'm not going to dwell on them. There's addition formulas for Lukov functions. There's also multiplication formulas and other things. I mention these only because I want to say if you have a generalization, you'd expect your generalization to have like things. There's a law of apparition for the Luka functions for the U of N here. So it's able to epsilon's Legendre symbol, and you know that if R sum prime does not divide 2Q, then it divides the 2q, then it divides this term of the Luka function. All right, there's primality tests based on these. Okay, so I want to talk about a generalization of these primality tests, but Luka developed primality tests for these numbers. N. You can see N had this form was plus or minus one. It could easily be factored. In particular, it often was n plus or minus one was a large power of p. So you do a yeah, p plus or minus one would be n. P plus or minus one VN. Luka restricted himself to primes two, three, and five. And then the most famous example, I didn't get into details at all, but I think everybody here is aware, the most famous example is the Luka-Lehmer test or the Prime Minister Sen numbers. So what we're going to talk about today is an analog of this up to here, an analog of the Lukov functions, and then how. And then, how we make an analog of these numbers, and then also have some sort of generalized Luca sequence that does something like this. Historical motivation. Luka wanted to do this. He stated it. This is a translation. He believed higher order recurrences would develop similar tests. He didn't come up with any, like, he died young. So, you know, he wanted it as a good enough reason. It's a good enough reason, so be motivated the heck out of this talk. All right, all right. He suggests a function that would work. This is one part of it, but you'd expect there to be two of them. So he had maybe half the idea here. We didn't have its counterpart you'd use. But we do, in fact, use this something. The notation is a bit strange, but anyways, we do something akin to this. Akin to this. You know, I just realized, fair warning, I only really wanted 20 minutes for my talk, and I prepared a talk that I think I could do in about 20 minutes. And I have a habit of going maybe too quick. So if anybody wants to stop and say anything, no worries. We have the time. All right, this is one more quote. Yeah, theory of recurrent sequences is an exhaustible mind which contains all the properties of numbers. Well, maybe not. Numbers, you know, well, maybe not. But anyway, maybe I cite hyperbole, but again, this is Luka's quote here translated. Okay, so I hinted at one of these already. Luka had one of the two functions you want to generalize, but if you're going to have a full generalization, you'd expect these functions to come in a pair, just like the Luka ones did. Both functions satisfy a linear recurrence. Oh, these are properties of Luka functions, sorry. But you'd want to generalize each of these. So you have a pair of them. Okay. Generalize each of these. So you have a pair of them. Okay. They satisfy a linear recurrence. Okay, so the Luka ones are order two, second-order linear recurrence. One of the functions is a divisibility sequence. The function that Luka mentioned in his quote, is a divisibility sequence. And then you'd want to mention there are addition formulas. I showed they had theirs earlier in the slide, another important feature. And then there's multiplication formulas. These help get the things you need. Okay. Okay. So here's a cubic generalization. I don't go through it much. Generalization. I don't go through it much, but it has all those properties. Okay, so before we had the Luka case, it was baseless quadratic, but now we have alpha, beta, and gamma. And I used alpha and beta again, but this is a different alpha beta. These are the, and gamma, these are the zeros of this cubic. PQR integers, the same way P and Q were integers before. I used lowercase the other slide. Here's the discriminant here. It's slightly longer, more convoluted. We used the C-side. We used the C sub n notation, but this would be similar to what the capital U sub n that Luka mentioned. And then the counterpart, the thing that you needed, we called W of N, and here it is below, and this would be the analog of V sub n in the Luka case. Okay. And okay, so it's hairier, right? I mean, you go up to a cubic. Oh, and when you do a cubic, this is now a six-order linear recurrence. Okay, so this is the generalization. Okay, so, all right, so here's. Okay, so, all right, so here's, I mean, the details don't really matter, but look, both of these, I use X because X could be either C sub n or W n, but both of them satisfy the same six order linear recurrence with different starting conditions. All right, so that's one of the checkpoints. It's a linear recurrence. And okay, there's addition formulas that it doesn't matter if you look at the terms carefully, but notice when you Carefully, but notice when you do C sub n plus 3m, you know, before you just have this doubling, you could just do one previous term, but now you need three terms back. So we have n plus 2m, n plus m, and nm. So you have to go three back. I think that makes sense. It's a six-order linear recurrence. This will be important later when we're calculating sequences. How many previous sequences do we need to calculate the next? Next, if we're using those to calculate. All right, this is also a little bit of a nuisance. There's ranks of apparition. We say ranks, not rank, because it could be the case there's multiple ranks of apparition. It gets hairier, okay? So this is just a definition saying, look, there could be more than one rank of apparition. And it's important to know when. Yeah. Okay. But we have a sense of what's happening. We can classify the primes. Classify the primes we're dealing with following Adams and Schencks here. So here's this would be our quadratic that defines our recurrence. Then we say P is an I prime if this polynomial is irreducible, there's no zeros in F of P or there's one zero in a quadratic, or if it splits completely, you say S prime. All right, so this is how we classify the primes. And then for each, well. For each, well, with this, we can have a law of apparition. So there's only one, you can see here, the S prime case, we can have up to three ranks of apparition. But for the I prime, it's only one, and for the Q prime, it's only one. All right, so if you're going to design a primality test, you'd want an I or a Q. It's less hairy. For our cases here, we're going to make. cases here we're going to make it we're going to make use of the i prime but sort of backwards here i say here's a pq and r and then we say we can do this run this work and say oh uh what is it and we say it's an i prime but to know a priori it's an r prime will take more work that's part of the new results here or we rely on old results but anyways but it wasn't in my thesis uh it's in this new paper because the paper's not published yet we submitted it submitted it to uh fibonacci quarterly uh we're waiting Quarterly. We're waiting. If one of you are reviewing it, don't rush. It's okay. Anyways, but notice the rank of apparition here for the I prime case divides p squared plus p plus one. So it's a square and plus p plus one. That's going to be important in a minute. So just file that away in your mind. Okay. Okay, the next slide. So we're going to look at a sufficiency test, not a necessity. You can bulk it up. And necessity, you can bulk it up, but I programmed it just for sufficiency, for the primality of particular numbers, such that n squared plus n plus one is divisible by the large power of some prime, p. Okay, so notice that n squared plus n plus one, that looks like the q, no, sorry, the i prime case. Okay, this is the other hairier part. If you look at things numbers, or the ones Luka tested, there's always plus. Numbers are the ones Luka tested, it was always plus or minus one, right? Remember, it was like some large power of P, and sometimes there's other tests where you put some value A in front of it. Often it's plus or minus one at the end. Ours is not plus or minus one. The number we're testing is a bit hairier. More work to get at. Okay, so I just want to mention how we get the values of n to be tested. And I do an example, even though it's sort of silly and small just to get there. But we're going to let this lambda n p and lambda bar. Going to let this lambda n p and lambda bar n be the two solutions of this congruence s squared plus x plus one is going to zero mod p the n. And then we're going to solve it for p first, and then and then you can solve it for p squared, p cubed onwards by a Hansel lifting process. Anyways, and then since there's two solutions, we just call lambda n the without with the smaller of the two, lambda n p. All right, and oh, and for this test, we need p's congruent to one mod three, so we restrict. Were it just one mod three, so we restrict that. Uh, for execution of testing, we did uh, what was it? Uh, well, I forget now, seven was the first one for the primes. Okay, all right, so I'm gonna go gamma and one of these two. All right, one of it's either the small one or the big one that's the solution from the previous slide. And if I want the next one, we do these following steps here. This is kappa n, we just solve this, and it's always an integer, and then we solve the next one for a new new n. Is the one for a new new end? It's a little more work. If you're programming it, you can use some like sort of an extended Euclidean algorithm, some step for speed. And then our solution, the next one is gamma n plus one. It's just this gamma n plus p the n times u n. Okay, so we can get the next from the previous. So when you're programming this, you just solve the next one, you run whatever test you want to run, and then you calculate. Want to run, and then you know, you calculate the next, and you onwards, right? You just, and then we're going to run our test for some iterative loop of ends. All right, so this is our number we're testing, and it's similar. Here, we let A be some fixed integer such that P does not divide it. So, this is, you know, there's other tests akin to Luka's where you allow this value of A out in front. But rather than plus or minus one, we're doing this plus gamma n, where it's either one. It's either lambda one or two. You know, there's this lifting process up to some, solving that thing over and over again. Do you see that? And so here, n sub n could be n sub two if you only lift it once, n sub three if you lift it, you know, you just lift it three times. You know what I'm saying? And you can keep going, and each time you do it, you find a new n you can test to see if it's prime. All right, so this is the type of numbers we're testing. This is a really, I mean, this is the most obvious example, as smallest you can. Is the most obvious example, as smallest you could do, just so you can see the steps. If you let p equals seven, you can check that two and four are both solutions to x squared plus x plus one squared to zero, one, p. That's so small you do it in your head. So pick gamma one seven, oh yeah, gamma one, seven, pick it to be lambda one, the smaller of the two, pick it to be two, okay? And then you can solve two squared plus two plus one over seven. Okay, that equals one, all right? So, uh, oops, missing an equals. Oops, missing an equal sign. There should be an equal sign. It should be capital one equal. Sorry. Okay, that's, I'm prone to such things. I'm, I'm, I do that. Okay. And then you want, anyways, and then when you solve the gamma two and you work it through as it had, you get 30. So now you can have, oh, and I just picked a equals one. You can pick anything, right, that's relatively prime to p. So I have one times seven squared plus thirty. 7 squared plus 30 is 79. So we could test if 79 is prime. I did this by hand ahead of time before I programmed it just to make sure, and then that's prime, okay? You can see that, that my test was working. Well, test works. Look, he was very smart, and he came up with some very good tests. When I implemented it, I do very dumb things. So I check, you know, to see if the software is working right. So it's handy to do these little examples ahead of time. Examples ahead of time. Okay, these tests would be useless if you couldn't calculate them in a reasonable amount of time. The fastest way to calculate these terms that we're going to need C sub n and w of n is with these auxiliary functions, x sub n, y sub m sub n, here. And what do I say about this? Yeah, yeah, so yeah, it takes 12k modular multiplications. The modular here is going to be. The modular here is going to be n sub n, the number we're testing. And yeah, we're going to run a double and add algorithm. All right. So here we have some starting conditions. So now I'm saying it, sorry, I should go back. Ah, sorry. There's these F's and G terms, G so one, and then you'd have X one D send. Oh, if you're reading a If you're reading a previous paper I've done, I was clumsy, and even my thesis, when I switched sections, sometimes I would continue to use N for iterative processes. So in this particular portion of my thesis, and even papers afterwards, where I use this, I sometimes have N used twice, and once it's used in a funny way for this iterative process, and once it's used for the sequence. Here I switch one of them to N. Sequence. Here I switched one of them to M because it was my mistake. Yeah, there's a second mistake, but I'll mention it. Okay, so here you have F0, F1, F2, and F3. Okay, so you'd say I mentioned before with the addition that we needed at least three steps back, right? But if we're running a double and add algorithm, either we use F0, F1, F2, and then G0, 1, 2, or F1. One, two, three, or F1, F2, F3 for the double and add step. Okay, so we need these four for each case. And so you have this initial sex stat, SM, and you can calculate, you can either double it, S2M or S2M plus one with these appropriate formulas. And here they are. And these follow from identities working with those sequences. And then you use these auxiliary functions and you build it up. I would also like to state, I made a second mistake. I made a second mistake in my thesis that I never really knew about till now, and a confession, even maybe. Often, when I had to calculate these sequences to think about them or do something with them, I would do it the dumbest way possible. The dumbest way possible is just use the sixth order linear occurrence and plug in the terms, initial conditions, and go through. It's slow, but it's easy, right? Here, our test relies on doing it this way. So, I actually had to program it this way. So, I always had this. Actually, I had to program it this way. So I always had this result, but never really did it. And I'll tell you, actually punching it through and programming it properly makes you learn something. And what made me learn in this case was I had more typos in my PhD thesis. My F of 2M plus 3 and G of 2M plus 3 terms had sign mistakes. And if I were really honest here, I blame Renata. Why didn't you catch these while reading the thesis, Renata? Come on now. Who says I didn't? Yeah, okay. And then they were like a dirty Easter egg from my past that, how to put it? It was like a trap I laid for myself more than a decade ago to look stupid later. So I discovered that if I was calculating sequences that were all doubles, everything worked out fine. But as soon as I did a double and add, I had a mistake. It went all haywire. And it was because of the And it was because of the you definitely use these two n plus three terms. Okay, anyways, those are fixed. We can do a double and add algorithm. That's that's part of the battle. Let me do it for time. Okay, I'm good. Okay. The okay. We want an irreducible polynomial modulo r some prime. This is we want we want the I prime case. Okay. Results of Lamer tell us how. Results of Lamer tell us how to do this. So these are all the results. So if Q some prime is not R is concerned to one mod three, and you have R raised to the Q minus one over three is not coming to one mod Q, then this polynomial for P1, Q1, and R works here. So that's what we want. We want this polynomial. When I was programming it, I just made a big list ahead of time of Q values, and I would test this condition. Values, and I would test this condition and see if it works. And if it didn't, I would just reject it and move down the list. Okay, so I cooked these up ahead of time, all right. And I made a real long enough list that worked for all the primes I worked up to, but I didn't do it in the software. Okay, how's this handy? Okay. If alpha one is a zero in the first little bit, then we can have, we can put this alpha based on a, b, and c here. On A, B, and C here. I didn't want to get too thick into the details. We cannot have B equals C equals zero, because then alpha is not F R, but how to put it. If you do this, and then you solve using what P and Q should be based on this alpha, based on this A, B, and C, you can work it through, and you get values for P, Q, and R for your polynomial for the thing you want to work with in terms of A, B, and C. thing you want to work with in terms of a b and c so now uh i can say once i cook up the q i can just choose any a b c i want such that b and c are not both zero all right and then i have the field i want so that my my my i so i know i have an i prime it's an i prime case right so all i have to do is choose an a b and c the any of them just that b and c the non zero and r does not divide r which isn't that r okay Which isn't that our okay. Okay, two conditions for our test. The first one maybe is obvious, another gamma n or gamma bar n as a divisor of n. If it is, then it can't be prime. Don't test it, right? It's a primality test. The second one is maybe less obvious, but if you solve this, then n is a square and again, not prime. So we start off by, before we run our test, we check to make sure neither of those are the case. Neither of those are the case and they're easy to check. And then, if they are, you stop the primality test. Okay, so those are two conditions that must hold. Okay, and this is the main theorem of the sufficiency test. Okay, DN is this new term I'm introducing. It's just the greatest common divisor of C sub n and Wn minus 6 Rn. This is the sixth order linear recurrences we have to play with. And then conditions one and two. And then we conditions one and two hold, okay, so we know you know it's not that perfect square or gamma n to divide. And then we set m to be this term where h is bound between 1 and n. The little n here is again determined by the big ends of n that we're testing, you know, which step of the lifting we're on. The G C D of N and delta R is one, we check that ahead of time. And so then n sub n, oh, yeah, if n sub n divides these two terms, then it's prime when a is not too big, okay? Less than two as p to 2h minus n, okay? That's the test, okay? That's or that's the theorem, all right. So, but to do it properly, we have to, there's two steps, right? Well, that's really one. Yeah, you have to be able to calculate with the double and add algorithm, those sex sets, and then just interpret results. And then just interpret results. I check to see if your A is too big or not, and these sorts. I check to your initial conditions are good, that the Q is okay. All right, so this is the X and Y we defined earlier as auxiliary functions. These congruences are true. Okay, so H is the least value of I, so this is true. Now, okay, we want I actually to be at least one for our test to mean something, but it could in fact be zero, it could be. But it could, in fact, be zero, it could be three congruent to three and zero right off the start. And for us, that's sort of bad because our test isn't conclusive then. All right, so here's the first algorithm. It's not so bad. You solve for x1. You solve for x1 the same way you solve for, you run the algorithm once with the very, you solve for the initial conditions. Anyways, so you, the double and add algorithm. Run the double and algorithm once you have them. Okay? Or you solve for them. And then, yeah. Or you solve for them. And then, yeah, and then, oh, sorry, you solve, sorry, you solve for x1, you get those, or it's not hard. And then you run the technique once to solve for xw, and xw is just r squared plus r plus 1 over p the n. Later, that r is going to be n sub n during our test, right? But this is just for some arbitrary r, you can calculate it. So you run the double and add algorithm once, and then you check if the first time through it's three and zero. If it's three and zero the first time through, Three and zero the first time through, then your h can't be between one and less than n, like it just doesn't exist, so you stop, okay? Otherwise, you set i equal to one and you calculate it in turn, but now your initial conditions are xw or you know, xpw. Each time you loop it through, and you just loop it through over and over again, running the double net algorithm over and over again, okay? Until you're told to stop. You're told to stop when you get three and zero and h is not zero, and you have. And you have the value h you want. And now, sorry, okay, sorry. You can run this in the sufficiency test. This is just one step. This has to cover two slides. Sorry. All right. So our test essentially is just our theorem. We first check the conditions one and two hold. It's not square. Gamma doesn't divide. Then if it does, if they don't hold, then it's not prime. We're done. You select a Q. I had a whole list of Qs that satisfied those conditions. That satisfy those conditions so we can have an irreducible case. You grab one. You select some triple of A, B, and C such that B and C does not equal zero. So you just, you do them. And then you just get to compute P, Q, and R. So you have the nice irreducible case. And you check the G C D of these things is one. If not, and is not prime, we terminate the test. Okay. All right. Next. If it's the very first case. If it's the very first case xw is 3 and yw1 is 0, our test is inconclusive, okay? And the software, we implement it, we just say, oh, indeterminate case one, we don't know, okay? And I include the values of A, B, and C, which we don't know under. And then if not, you just run algorithm one again. You replace R with n sub n, and you keep calculating until you find this, it loops through until you find this h. It loops through until you find this h. And then, if you recall during the theorem, a had to be less than some amount. If it is less than that, 2 times p to some power, then n sub n is prime. It's sufficient to say that we know this number is prime. If it's greater than, we terminate again. We say, oh, we don't know. It might be prime, it might not. Okay. What do I say about this? These cases do happen. Okay. I'm almost done. Well, this is good. I'm glad I'm almost done. Okay. Well, this is good. I'm glad I'm almost done. Okay, so I was going to, oh, I use Maple. I don't know if anybody's going to ask. I use Maple. Why did I use Maple? I don't have Magma work. We have a license for Maple. I'm comfortable. Does anybody use Maple anymore? Am I the last one? I don't know. It's not so popular as it used to be. Anyways, I like it. Okay, so I used Maple. I wrote a program that does this sufficiency test. And I here, there's tables. Up ahead, this is the case where p equals 7. My initial conditions for a, b, and c are here, 0, 1, 0. And then I have two different starting conditions. Either lambda 1 is 2 or 4 in this particular case, if you recall from the slide of the example. So this is the one where the initial 0 is 2. And then I cook it up from there, okay? So for the different ends, we keep lifting, lifting, lifting higher and higher. We keep lifting, lifting, lifting higher and higher. Okay, so this is a table of all the cases where our test says these numbers are prime. So it's prime here, where A is one and N is two. Well, that's the case where it was 79. That's the one we did by hand. But, you know, these are all prime now. Oh, and I went up to 60 for my values of A, and I went up to, I think it was 500 for my For my values of n. And these are all the primes that it finds under that range for p. Okay, notice here I put round brackets around this one and square brackets around this one. I want to say something about those in a second. The round, well, I'll say this now. Sorry. The round brackets and square brackets mean these are interesting. This is a table of primes without brackets, but if they do have those brackets, it's the indeterminate cases, okay? Round brackets. Cases, okay? Round brackets indeterminate case one, square bracket indeterminate case two. Okay, here's a very, very, very similar table, but now here's a round bracket here, and you can say it's now in three case, indeterminate case one, indeterminate case two, indeterminate case two, indeterminate case two. The indeterminate cases two seem more common, which is actually kind of nice. And then the indeterminate case one. I'll say why it's nice in a second. Here's a different problem. P is 13 now. Okay, fine. P's 13 now, okay, fine, and uh and then uh the lambda one now is three. Here's lambda one bar is now nine, but same thing, different table. Okay, so the computational results are largely what I worked on. It took effort of some sort. Okay, I just want to say one more thing of interest, maybe something interesting. Okay, in the few cases primality is unsuccessful, well, I won't say it as a slide. Well, I won't say this as a slide. If it was circumstance two, every case I had, I just changed A, B, and C, and then I ran the test again. And for all those cases, those numbers are prime. Okay. So it wasn't inconclusive if you just try a different A, B, C. So you just run the test again. However, this was surprising. Sometimes you get surprising things when you actually write programs that you don't see coming. I had a bunch of cases where I had circumstance one. Circumstance one, and if I change the initial conditions, I still had circumstance one. If I change the initial conditions, so circumstance one over and over again. And I thought this was interesting. And I told Hugh, and he thought I had screwed up, which, you know, honestly, good assumption, right? I hadn't this time, okay? This time. He, upon some digging, if you actually look at these numbers, it's hard to tell from the slides earlier, but one's 961, and that's 31 squared. And that's 31 squared. 361 sets off another one, that's 19 squared. And 529, these are all these indeterminate cases. One, this is not that shocking in hindsight. We have a result, even in the thesis, I'm sure Renata remembers every detail, where if you have a sum prime r, if r divides that d1 of some particular sequence, I think d sub r squared plus r plus one, okay, then if it's an i prime, then you also have the r squared divides it, okay? The R squared divides it. Okay, so this takes some work to get from there to this, but it actually makes sense in the end. So you can think of these as some sort of maybe like almost pseudo-prime-like thing happening because they work for all different initial conditions. Yeah. I'm surprised nobody liked my footprints in the sand. Anyways, that's the end. Thanks, guys. Thanks, guys. Thank you, Eric. Are there any questions? I want to ask a question. Did you guys look at all? I mean, is there any hope of kind of analyzing, let's say, the probability of encountering one of those bad cases? I mean, in practice, it doesn't sound like they're a problem because you can always just find different A's and B's and C's and they work. But did either one of you look at this? No, but can't. No, but can I, if you might have noticed all the indeterminate cases wanted for these very small, like not all, but who knows? But they seem to happen early on and not so much later. Maybe it's an obvious probability thing happening there too, but no, no, that's work that someone could do. It's a good question, but I mean, it's there's some funny divisibility going on, I guess, that doesn't happen with big numbers or whatever. With big numbers or whatever. Yeah, yeah. I just want to say thank you again to the organizers. I really appreciate this. My annual report at my job appreciates this. Get to give a talk. And thank you for logging in on a Sunday morning. Thank you for joining us. Eric, can I ask a question? What is the running time of your algorithm? Algorithm? Oh, it's in the paper. Is it here? The test will run in big O log n cubed. But I mean, really, the details is that you only sorry. Here, these things here, a lot of these multiplications are redundant. It's the same one multiple times. So it's kind of buried in here. You can do. It's kind of buried in here. You can do either a double or a double and add, and 12. Both of them are both just 12 multiplications. So, and then since you're doing just a binary expansion, whatever you're calculating, double and add is pretty quick, even though it's a sex set. You have to go three back. It's not so bad. Okay. But that's what dominates the runtime, right? It's basically just this double an hour. This double and out algorithm. Yeah, yeah, it's the bulk of all the calculations is just this thing running, to be frank. Cooking up the Q you can do ahead of time, and you get to choose A, B, and C just willy-nilly and make those calculations so small that it's almost nothing. I guess I should mention that Richard, in his latest years, actually spent a lot of time working on recurrence relations. Working on recurrence relations. And I think he and Hugh wrote a sequence of paper, but they were fourth order. Sorry, can I? I forgot to say that. This paper that Hugh and I worked on is a bit of an addendum to a paper that Hugh did with Richard that I was also a part of. So not only did Richard work on the fourth-order ones, he spent some time looking at these sixth-order ones too. And some of the papers have both in them. So, yeah, so this has a link to Professor Guy in it too, because it's the, yeah, sorry, it's a, yeah, anyways, it was some primal tests that he looted Lucas and he worked on with this. And this, a lot of the results we point to in this paper are in the previous paper, my thesis. Like, I should have said that, sorry. Yeah. I think he was quite intrigued by this idea of multiple ranks of apparition, actually. Yeah. He was. He was looking into that. Because if you get to higher-order sequences, you start getting even more ranks of operation. And I think he was quite intrigued by that idea. Let me stop, share. Thank you again. Okay.