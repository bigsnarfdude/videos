All right, welcome back, everyone. Our final talk before the coffee break this morning. David Marquis is going to be talking to us about computing class groups of quarter number fields using the city. So please go ahead and take it away. All right. So thank you for the introduction for inviting me to talk today. So, this is some work. So, this is some work on stuff related to my PhD thesis. This is like practical algorithms for actually computing class groups really quickly and trying to do that in that quartic. All right, so we'll work in a number field that's defined by a polynomial F. So, usually we'll get up. We'll get up to degree four at the end of the talk. I've got a quarter for most of the presentation. And the absolute value of the discriminator field is denoted by delta. So the problem that we're interested in here is actually computing the class group as well as the unit group of the field, doing that quickly in practice. So what that means is that the algorithm. That means is that the algorithm that I talked about in this talk is something that I'm actually going to be implementing and then testing this approach on discriminants. The discriminant gets really, really large. Of course, the reason that we want to do this is this problem is fundamentally important for many different applications that come up in number theory. So just to pick arbitrarily between class groups and unit groups is often. Given class groups and unit groups is often used for equations, any different kinds of things. This is applicable too, but I just picked one and you write Curie Mailer equations. So if you have an equation of this form, then computing the unit group of a certain number field is helpful for finding the solution for x and y, as well as the positive integers, set of one reset. And then the second application, of course, there's tons of different conjectures that people have made. You have no idea how to prove. And about the structure of different number fields. And so often we want to compute class groups and unit groups as a way of verifying Jackson's theorem. So seeping is an approach that can be used to. Seeing is an approach that can be used to compute the class group. And specifically, seving is used in a particular stage of an overall kind of framework called index calculus. And in the quadratic case, there's an algorithm called the self-initializing quadratic C, which I'll call SIQS. This is by Jacobson. And this is an excellent way to compute the classroom quadratic. The index calculus approach actually computes both the class group and the unit group at the same time. So I'll sometimes just say the class group, and I'm always referring to both the group. So the point of this presentation, I want to introduce you to the self-initializing quadratic seed, how we do things in the quadratic case, and then maybe sketch a little bit of how this generalizes. How this generalizes recording. So there's other algorithms that can compute the class group and the unit group. So why do we need to generalize this self-initialized approach? And the reason is that the algorithms that are out there are just not quick enough for the applications that we want to use. So you'll find this very quickly if you go to compute a magma, the class group of a A magma, the class group of a number field, picks some large discriminant, maybe 100 digits. It will be ready to quadratic case using the self-initializing quadratic C. If you go up to degree four, pick the same size of each one. It's going to take a massively longer amount of time. So, the challenges that exist in generalizing the self-initial C, a couple of them Of them that we run into is that when we're doing this, we want to find ideals that are small and have smooth norms. We want to find a lot of those ideals. And so it turns out that the approach for higher degrees, you have to tweak it a little bit. And also, of course, in quartic number fields, we have prime factorization that there's a lot more cases to deal with in terms of how rational prime can factor. Power rational prime factor, so we have to deal with that additional components. The opportunity for doing this is just by specializing the degree, particularly fixed degree. We hope to get some additional efficiency versus the way that people are currently computing this with version fields. This is something that hasn't been tried before, but it's a very successful approach. Successful approach for what radical is. So I'll introduce you to the index calculus approach and then we'll work towards the quadratic seeding and then the self quadratic calculation. So for index calculus, we define map from a vector of integers like k, the class group. K, the class group, and all this map is just the product of ideal classes generated by some primes v1 through pk raised to the elements of that vector. A few more definitions we need. So a factor base is just a k-tuple of prime ideals where the norm of all of these prime ideals is less than some gamma that we fixed. And a relation is just a vector so that if we take Just a vector, so that if we take the product of primes, so the primes in the factor base, and we raise it to the elements of the vector, then that gives us some ideal that's equivalent to the ideal generated by one. And so you'll see that a relation is just an element of the kernel of the map signal table. And so we have a factor base that's large enough, and it's going to generate. That's large enough, then it's going to generate the entire class group. And using this isomorphism, you can cover the class group as by knowing the kernel span. So the kind of main idea for index calculus, the one thing you should remember from this talk if you don't remember anything else, is that if you get enough of these random relations, then all it takes is doing some linear algebra over the integers in order to recover last week. A couple more definitions that I need. So norm. So the norm of an ideal is multiplicative map A. An important thing with the norm is that we kind of use it as a measure of the size of an ideal. And we call an ideal smooth if the norm of all of its prime factors are less than or equal to the value of b. Less than or equal to the value of b the same b that I have on the previous slide. So a key idea for this index calculus approach is that the smaller an ideal is, the more likely it is to be smooth. So we fix some number B and we want to generate a lot of smooth ideals. So it's very helpful if those ideals are small because then they're more like factory. It's all like factoring the problem. So now in quadratic sieving. So in quadratic sieving, we can take an arbitrary quadratic field and we have this nice representation for it. So we can work with an isomorphic quadratic field where the defining polynomial is just a final. So to do sieving, we're going to To do sieving, we're going to choose some ideal A that's a product of primes from the factor base we chose. And if all of those prime factors have ramification index equal to one, then there's some unique element theta plus b over two that's contained in this ideal, where v here is between zero and a. So a is the norm of this ideal. The norm of this ideal and b is a root of the defining polynomial log. So, now what we do to do seeming, we're going to choose a linear combination of elements in the number field, and then we can construct what's called a norm form. So, the norm form is just a polynomial that represents the norms of all the elements there: xA plus theta plus b1. And this norm form, because this is a norm form of elements in the ideal A, every norm that we get is divisible by A. And so we have the factor of A front here. And then the part of the norm function is a quadratic polynomial. So the idea here is that now that we have this. That now that we have this simply represented as a polynomial, we can use the same sort of approach that is used in the sequel Aristophanes to quickly evaluate this polynomial and to find all the values where it's smooth on a particular interval. So the defines up bound from the C radius, and then we're going to find all the smooth values for x between. which means negative negative C radius and positive and from these smooth values we can easily recover a smooth ideal so that we have the product of our original ideal multiplied by the inverse of this ideal V that we found is equivalent to Is equivalent to the ideal generated by this is just this gives us a relation, just kind of exponents and makes the factor of the product that we have on these two ideas. So now we have a method for generating relations. So we need to know how this is actually going to perform. And it turns out that we're going to generate a lot of relations. Relations, if we're able to control the size of the norms of the ideal speed that we're generating, so we want the sum of that set of norms to be very small. So I'll come back to that in a second. But now for the self-initializing quadratic sieve. So before we were shielding a single ideal, it turns out that you can choose many different ideals. And if you choose the And if you choose the parameters correctly by working with many ideals, you're able to get a faster overall observable. Self-initialization is a particular way of doing that, and it chooses a sequence of ideals so that iterating between each of these ideals, so moving from one to the next, is extremely fast. And at the same time, we're keeping the size of the norms of the ideals that we're generating. So, how this is done, we have a set S of ideals that we choose. And in this set S, I'm going to say that each of the consecutive ideals here are conjugate. So they're both of the distinct prime ideals of P. We just ignore a single time above the rationale P. And we want to control the size of. Want to control the size of the norm of this ideal, which is just equal to the product of the rational primes below the primes in the set s. We want to make this product here equal to the inverse of the seed radius multiplied by the square root of the discriminant of the number field divided by two. And then the ideals that we're going to choose, they're all going to have norm equal to. They're all going to have norm equal to this expression above. Are just going to be for each of the rational primes, we're just going to pick one of the possible prime factors in the product. And so we have two of the t prime ideals in the set S, and so we're choosing T possibilities. So we have two of the T distinct ideals that we're in with C. Distinct ideas that we're conceived in this way. Okay, so in order to do this self-initialization step, there's two tasks that we need to be able to do in order to switch between the different ideals. This is just coming up with the element beta plus pi over two, as well as the norm form that I mentioned. And as well to run this evening slide, And as well, to run the seven procedure, we also need to find the roots of the norm form, modulo each of the rational primes below the primes for families. So, Jacobson showed that we could do this efficiently. This means that we can actually implement this algorithm, and it's faster than everything else. Things are great. And it turns out that when we choose the norms of the ideals, as I showed on the previous. ideals as I showed on the previous slide we can actually work out a bound on the size of the norms of the ideals b that we're getting so the norms that we're getting are just less than or equal to m times some square root of the discriminant and n is just some constant that doesn't depend on the discriminant so um i'll briefly talk about how we generalize this to the quarter About how we generalize this to the quartet case. So, just like in the quadratic case, how we start out is finding a nice representation of the quartic field we want to work with. So, I'll use the measure of the size of an algebraic number beta here. It's just the sum of the conjugates of beta squared. So, in practice, we can quickly. In practice, we can quickly come up with some polynomial f so that the field that's defined by that polynomial is isomorphic to the quartet field that we started with. And the defining the primitive element of that field satisfies the bound that's less than or equal to the constant c times the discriminant to the power one over six. I've written that power as one over two times. One over two times four minus one, because you can also, turns out, generalize this kind of approach, which I have a slide on at the end. And in that generalization, you replace the four here, which comes from the degree four vertic case with a general and fixed group. So then to choose the ideals that we're going to do seeming with. That we're going to do sieving with. So, this slide you'll see is fairly similar to the one that we had in the drive case. So, I'll just point out two differences we have. So, this time we're going to choose two ideals. So, Pi0 and Pi1. They're both going to live above the rational time P, and they're both going to have degree in a ramification index. So, as before, we're going to select a set S where the consecutive primes I've listed on there are both above the same rational prime. And again, we need to control the product. So the size of the norm of the ideals that we're working with. And in this case, the bound that we have is a 3-4 case is a little bit different. So, ignoring the constant out in front, we've again. We begin, we're dividing by the seed radius, and then we multiply that by the discriminant to the power of one over six. Remember, in the quadratic case, it was to the power of another two. And then for the rest of this algorithm, everything proceeds in the same way. We're going to see ideals so that we're only choosing a single prime above the rational prime in the factorization of the ideal. The factorization of the ideal we're going to construct a special element theta plus b that comes from the where b comes from the root of the defining polynomial. We construct a norm form and then we receive egg inverse times the norm form over the equal egg of m to m so all of that is the same. I have a I have a few details on here about how we can actually work out the balance. So it's essentially delta power line resex times front. I'm not going to worry about details though. All right, so for anyone interested in the Uh, so for anyone interested in the kind of remainder of the work for this project, um, so I have to finish an implementation of this uh generalization of the project case. Um, and then also there were a couple of parameters that came up in this talk, and also in the overall index calculus approach, there's more parameters that go into the algorithm. So, for example, I mentioned that C radius for the algorithm that we use. The algorithm that we use, which is going to define the interval that we see over. So, parameters like this have to be kind of determined experimentally. Way to discover them theory alone. So, we use the implementation there to kind of tune parameters and come up with the best possible approach. And then I'll compare this to existing algorithms like the one. Algorithms like the ones that we have on Greek, see how fast this is going to be. So like I said, this approach, I'm doing it for the quartic case because the hope is here that we can gain some speed by specializing to a fixed degree. But the general approach can work for any fixed degree. And in the general case, you have a bound where the discriminant is to the power of one over. Where the discriminant is to the power one over two times two minus one. It's just mainly one by some constant that doesn't depend on the discriminant. And you get a similar bound on the size of the norms that you're looking for. But as you go to higher degrees, it becomes more and more difficult to come up with a product of primes that's somewhat close to this bound that you're trying to approximate. So that's just one of the challenges that we face in that. The challenge based on that from the workers. So that's everything.