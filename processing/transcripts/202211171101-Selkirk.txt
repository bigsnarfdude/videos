twice three times or ten times as well. I will project a little bit better. Please just remind me if I go too soft at some point. Yes, it's great to be here. Thank you very much to the organizers for the opportunity and I'm very excited to be able to share some work with you. This is joint work with my incredible co-authors Clemens Hoberger and Stefan Wagner. Stefan and I are wearing the same Stefan and I are wearing the same outfit, and I'm very confident that Clement is also wearing the same outfit in solidarity. Yes, so this is joint work with them. And I am from the University of Clydenfurt. I'm a PhD student there. There were some questions about the setting. This is our university. A of A 2020 was supposed to be helpful. Okay, so the point of what. And the point of, well, the title of my talk is the distribution of the maximum protection number in random trees, and we'll break that down slowly. But the main thing that I want to communicate through this talk is the method or the theory that we use. And so I would like to spend a little bit of time telling you about this because I think this audience can use this theory. And this is a nice application. The distribution of maximum restricted number is a nice application. Of the maximum restricted number is a nice application, a slightly more advanced application of this theory. So, in 2015, Puringer and Wagner wrote a paper called Bootstrapping and Double Exponential Limit Laws, which I encourage you all to look up and read. And here they noticed some common things in studying certain types of distributions. And so they wrote a paper where they provided some unified framework. Some unified framework where certain product distributions come out. So, there they said it is a very typical situation that an extremal parameter in a combinatorial structure follows a discrete double exponential distribution and that fluctuations in the average occur. And they give a long list of examples. I just summarize some of the simplest ones here, but for example, if you want to study the longest sequence of ones. The longest sequence of ones in a 0, 1 sequence. If you look at the longest sequence of some letter A in a word, A is an element of some alphabet of a given size. If you want to look at the longest horizontal segment in a mosque path, or if you want to look at the maximum out degree in planted plain trees, these all follow the same distribution, and you can also obtain the expected value. So I didn't define any of the So, I didn't define any of the constants that are here, but this is just to give you an idea of the shape. And we'll get back to the Stirma Protinga and Wagner a bit later. But this is just to say, this is what I would like you to take away from this, that there's this wonderful thing, and you can apply it in relatively advanced settings. So, now you can all stop listening because you got the main point of the talk. But this is what we're going to do today. And so, in some Today. And so, in summary, what I'm going to be speaking about, just so that you can jump in and out as needed, what you do, and I'm wondering, this is Make Yes, great. We have some parameter that we want to study. In our case, this parameter is protection number, which I'm going to define later. And we take this parameter and we put it, or we form a sequence of generating functions conditioned according to this parameter. So we have some y. So we have some yh, which is a generating function, where the parameter of interest, in our case it will be protection number, is going to be less than equal to h. And then if the sequence of generating functions satisfies certain conditions, and these are conditions on the convergence of the dominant singularity, and also analytic conditions on the convergence of the generating functions, then we can apply the theorems of Courier and Wagner. The theorems of Frödinger and Wagner, and the distribution follows. And also, maybe at this point, I will say the theorem of Frödinger and Wagner is a very long name, so if anyone has suggestions of how to rename it, I am happy. Please come talk to me afterwards. Okay, so this is just how things are going to work, and now we're going to jump into what actually is a protection number. So, very formally, the definition says that the protection Definition says that the protection number of a vertex V is the length of the shortest path from that vertex V to any leaf contained in its maximal subtree where V is the root. This is quite a long definition and we can just say, okay, if this is our vertex V, we look at the maximal subtree where V is the root, and we look at the distance from V to any leaf in this. So this distance over here is 1, and this distance over here is 2, and so the protection. Here is two, and so the protection number of this vertex is one. But this is, I don't like this definition so much because it's not incredibly intuitive, or you don't, it's not so quick to process. And so, what I prefer is to rather look at it and say, okay, let's pretend we have hackers or something trying to get to the root of our tree over here. We have some worms who are trying to eat their way to the juiciest parts. Eat their way to the juiciest part of the tree, which is the root, as quickly as possible. All of those worms can get to the leaves at zero time steps. They can immediately get to the leaves of the tree. Okay? And after one time step, oh, wrong way, after one time step, they can make it one step further up the tree towards the root. So any parents of a vertex which is a leaf has protection number one. And we've One and we continue in this way. Oh, I always put the wrong. Okay. We continue in this way to get all of the protection numbers within this tree. So you could also think of the protection number of a parent is equal to the minimum protection number among all of its children. Adding one to that and we get the protection number. And then of course what we're going to be studying in our case is the maximum protection number in a tree. Protection number in a tree, and so here the maximum protection number in this tree is two. And this example was also specifically constructed because often when you tell people our protection number, they think, oh, perhaps it's always at the root. But this is a clear example, it's not always at the root. You can put a leaf anywhere in the tree to create a lower protection number at that point. Yeah. So is it equivalent to say it's just the distance of a root of a vertex? Of a root of a vertex to the boundary of the graph, where the boundary should be understood as the leaves? Yeah, so the minimum distance among all of those. So I think that's essentially what this is saying over here. So yeah, the minimum to a leaf. Well, to any leaf that is below it. So you might end up with a situation, not in this graph, I think. You might end up with a situation where if you go up in the graph, it's closer. But we don't look up in the graph, we only build it from the bottom up. Maximal sub-tree does not mean that it's sub-tree which has maximum size. Well, essentially, we mean the sub-tree which is everything that's below the vertex. Yeah. Okay, so now we're going to do some examples of matter. Examples of maximum protection number in trees, which are going to be relatively simple, but they will come up again later. So it's oh, yeah. Is this only defined for trees? Can this be defined for a general graph? I think it's only defined for trees. I'm not sure if there's an analog for general graphs. Can't you define a particular set? So, like in this case, you just had the leaf was the zero set, and you define the Zero set and you do and you define then the root and just moving from the zero set to the root tells you how the initially accessible vertices. Exactly, yeah. So the most vulnerable and that's yeah. The juiciness? Yes, the worms going to juicy root. So yeah, these examples are quite simple, but just to make sure that everybody understands and they will come up later. Later. So, very simple maximum protection number of zero means that the tree is just the root. Additionally, if we look at parts, we get a really high ratio of protection number to the number of vertices. So as you can see here, we have four vertices and we have a maximum protection number in this tree of three. However, if we remove or don't allow all vertices to have only one child, we end up requiring. We end up requiring way more vertices in order to create the same level of protection within the tree. And this will become important later. But for now, we will go into some sort of motivation as to why we're looking at the maximum protection number of trees, apart from the fact that many famous people have worked on it and are in the audience. But essentially, protection number of trees started in Of trees started in 2000, studying protection number of trees, sorry, started in 2008 with Gian and Shapiro looking at the number of vertices with protection number at least two in ordered trees. And then various people started to look at it in other types of trees. And then it progressed to not just looking at protection number at least two, but also protection number at least K. And then also looking at the protection number of the root. Protection number of the root. So, in each of these cases, minimum protection number, minimum protection number, protection number of the root, it's relatively natural to say, okay, well, we looked at the minimum, what happens when we look at the maximum? So, we've defined protection number, and now we're going to define random trees or simply generated trees. So, in case you haven't encountered this before, just a quick summary: that a simply generated tree is a tree which Generated tree is a tree which has a generating function y, which satisfies this functional equation over here. So you can think of it as the tree can be decomposed into a root, followed by some way of generating children, which is described by phi. And these children are each in themselves one of these types of trees. Okay? And as I mentioned, Phi tells us some, well, how we are going to generate children in the Children in the tree. And so something that we note is that if the weight of, well, the coefficient of x to the n is not zero, it always has to be greater than or equal to zero. So if it's positive, it means that the tree can have vertices with that many children. So the coefficient of x to the n not being zero means it can have vertices with n children. Then additionally, we set rho to be the radius of convergence of Of convergence of our generating function, and we also set tau to be our generating function at our radius of convergence. So we have these relationships between rho, tau, and phi. So the important thing if you're watching this talk and you haven't worked with simply generated trees before, you don't have to remember what these formulae are, just that there is some relationship between all of these that we can. Relationship between all of these that we can exploit. Do we want to continue to protect our device? Just checking. Oh, it's just so close. Okay, excellent. I actually can't get the mask onto things. That seems to be a problem. Yeah. Okay, so as I mentioned, the important thing to note is the relationship that we can later exploit. So now we've defined protection number, we've defined simply generated trees, and now we've Simply generated trees, and now we bring them together to now. If we think all the way back to the diagram that was at the start, we had our parameter. We want to now make a sequence of generating functions with our being less than equal to our parameter being less than equal to some value. And I will warn you that there will be incredibly long sentences on this slide. And so, in case anything is not clear, please just stop me and ask. Stop me and ask. So we let yhk be the generating function for simply generated trees, with the h being the maximum protection number in the entire tree. And k is the protection number of the roots, the minimum protection number of the root. And the reason that we don't just create a sequence is because, in order to know information about the protection number of a root, Information about the protection number of a vertex, we need to know information about the protection number of its children. And so this is why we have this K here. Okay, so H, maximum protection number of the entire tree, K, minimum protection number of the root. And so now we set up some functional equations. So the first is relatively easy if we look at trees with maximum protection number h and minimum protection. Number h and minimum protection number of the root being zero. This is the same as just saying, well, let's make the minimum protection number of the root one and add the only tree which has protection number equal to zero, which we discussed earlier. It's just the root. Okay, so that one's quite nice. And then the next equation, if we look at trees with maximum protection number h and minimum protection number of the root being k, this is the same as taking a tree. This is the same as taking a root, attaching children to it in the way that we generate children. And these children's roots need to have minimum protection number k minus 1. So if you remember with protection number, we take the protection number of a vertex is the minimum protection number among all of its children and add one. So here the minimum protection number over all of the children is going to be k minus. Is going to be k minus 1 or bigger than k minus 1, and then we add 1 to it to get protection number of the root being greater than or equal to k. However, there's a little bit of a problem here, and that is that if we want the maximum protection number in the entire tree to be h, we've got to avoid the possibility that the protection number of the root is made into h plus 1. And so if each of these vertices have protection number h, Protection number h. Then what's going to happen here is the root's going to have protection number h plus 1, and the condition that the maximum protection number is less than or equal to h is violated. And so we have to remove that possibility. And this gives us these functional equations over here. Okay, so is everybody happy? I know there was minimum, maximum, HK. Okay, great. So now we have these generating functions and we want to be able to do something. We want to be able to do something with them. And so, what we do is we set our x to be the common radius of convergence of the system for a fixed H. And we also define these eta h k's, which are the corresponding generating functions at the radius of convergence. And from this, we get this system over here, and we can also look at the determinant of the Jacobian filter system, so that's when the implicit function theorem comes. So that's when the implicit function theorem fails to get more information about where the singularity is. And we have this system over here, which we can, if we had what phi was, we could try to numerically solve this and get some values and then be able to get some expression for the generating function. But because we don't know what phi is, we can't really do too much at the moment here. And this is where the serum of Protinga and Wagner comes in that I mentioned earlier. Comes in that I mentioned earlier. And as I mentioned earlier, you can get results about the distribution from this, but I just want to describe very briefly some of the conditions attached to the theorem of Pordinger and Baglin. So you have your sequence of generating functions, they must converge to the generating function of the objects without conditioning them according to maximum protection number. To maximum protection number, or whatever you're looking at. You have that the singularity must be of this form over here. And you also have that the sequence of generating functions or yh's need to have this expansion uniformly in h within this Pac-Man domain. But I cannot, there's many conditions, and I don't want to put three slides of conditions. And so, again, I strongly recommend that the I strongly recommend Bitty looking at this paper. This is the main takeaway. Again. But essentially, now we have a little bit of an idea of the conditions, and we're going to focus on one of these conditions for the talk, because this is the most talk-friendly condition to show. When you say the non-condition YZ, I missed YH, when you take does it mean kinda as having protection? As having protection? Well, I guess this just means that there's no limit on the protection number. Yeah. Yeah, because the maximum protection number, if you remove that, then you can just have anything prediction number in the tree at all. Which conditions are easier or challenging? Conditions are easier or more challenging to get? Yes, the one I will show you is easier and massive for the talk. This one is horrifically difficult. So, as mentioned, the non-horrifically difficult one we will now speak about. And just as a reminder, that's what we need to show over there. And we have this system that we need to try and show this from. And show this from. Okay. And what we're going to do to try and show this is something called bootstrapping. Many of you may be familiar with bootstrapping. But in case you aren't, essentially what we have is this system of equations. And we take some approximation of a solution, we plug it in, and we get a better approximation out. We take a better approximation, we plug it into the system, we get a better, better approximation out. And we can keep on doing this. And we can keep on doing this. And so that's what we're going to do here, and this is what I'm going to demonstrate. So, this system of equations, I of course don't expect you to memorize any of this. And the next slide is also going to be not so more on a meta-level, you should look at it rather than any details. But on this, we can just take note: we have these equations in terms of ρh. In terms of rho h, these etas, and also we have this product here and this sum of products here. So this is the only like not so great looking thing in this entire system. Okay, so the product and the sum of products. So if we want to show this over here, it's not incredibly optimistic to start off by wanting to show that rho h is going to converge to rho. So we start off by busy doing that. Start off by busy doing that, and additionally, because our system also involves some eta HKs, we also show that eta HKs converge to something. And then we take our product and our sum of products, the nasty looking things in the Jacobian, and we get approximations for those. Then from these approximations, we plug them back into the system and we get out better approximations for our row H and our E. rho h and our eta h0. So at this point you should not be following any of the steps, just getting a general idea. And then again we take our better approximations, plug them into our products and our sum of products to get even better approximations until eventually we show what we want to show and it looks a bit nasty but we have our row, we have exponential term to the h and so on. So eventually we show On. So eventually we show what we want to show by bootstrapping, and then with some additional analysis, the dot dot dot is hiding the nasty stuff. We can then conclude that we have this, the probability that a random tree of size n has maximum protection number less than or equal to h is given by this incredibly beautiful formula over here. And just as an example to To show that, well, to make something nice on the slide, I've plotted the lines, the continuous things, I'm just plotting this, and the dots are the actual values. So you can see as we get higher and higher values of n, it gets closer and closer to the correct thing. And then additionally, we can get out an expected value. So there's logarithmic terms, constant terms, and a term which fluctuates. Fluctuates. But this is not all. I didn't really show any proofs, but all of the proofs that I for these two results over here are all entirely dependent on phi prime 0 not being equal to 0. So we often divide by that and so on. And if we think back to what I said about simply generated trees, if phi prime 0 is not equal to 0, this means that the tree is allowed to have Tree is allowed to have vertices with only one child. So you're allowed to have paths in the tree, which means the protection is relatively high. There's a high ratio of protection to number of vertices. And so we have to actually consider the case where you aren't allowed to have vertices with only one child separately. And that's, as I showed at the start, you need way more vertices in those types of trees to get high protection. And so in this case, And so, in this case, instead of having that this term is something like z to the h, it's now doubly exponential. And we have to adapt the theorems of Frdinger and Wagner for this doubly exponential case to then get the distribution out. So, that's all I have to say. Thank you very much. And please, as I said, the main takeaway is read this paper, use this scheme when you encounter some problems. You encounter some problems. I didn't pay her to talk. Yes, Annette is still getting more and more embarrassed. Can you give a sense of what left the one captures in? Not entirely. So here it's essentially just a constant which comes out when doing some calculations to make sure that some things have the error terms that we want. So essentially it's not really having a combinatorial interpretation, I believe. So for this lemma you just say h goes to infinity, but on the next slide your theorem h is around log n. Can you say things for other values of h? Well essentially when h is large enough, so there could be some weird things happening in initial small h values, but when h becomes large enough this holds. And so this is also just to say Also, just to say if you go too far away from these points, you're going to not really get any significant contributions. Is this theorem can you apply it to graphic functions that are not algebraic? I I from one of the slides that you showed, I got the impression that they should be That they should be assuming it like maybe we could ask like names, but I think it should be fine. When you want algebraic singularity, the function doesn't have this. So for instance, can it be used to study the height of a curated tweet, right? I think the height doesn't have that distribution. Oh, I assume it doesn't study that. Specifically here towards this kind of distribution. There are no oscillations in the distribution here, are you? In fact, or um over here? No, but here in the expected value, yes. I have a question. Um, in the first slide, you were mentioning that there were several. Is that there were several instances where you are looking at maximums? But do those groups already use the theorem? Yes, so I would say because I'm not the author, I think it's really nice, nicely written papers, so they start off with some example and then they do the general theorem and then they say, Well, here are many applications of this example. And they list these. And in fact, I think you mentioned at some points that you. I think you mentioned at some point that your recursive trees were gumbo distribution, and Stefan and I had a little bit of a discussion about whether or not they fit into this scheme. Oh, okay, because that was going to be my next question. You saw it in my slides. I think that result for the maximum degree in my prize is from 2005. So I'm wondering when this theorem appeared and it was. It was Chile already. Well, I don't know. 2015 it appeared, but I'm not sure if... So to answer your question, I actually tried to see what you can apply the theorem to your specific theorem. Uh the answer is sadly no. So it's in in spirit, yes. But the actual version of the theorem that's in that paper and error Theorem that's in that paper. The reason is that the generating functions, the sequence of generating functions that you get in your example, they have the right behavior when it comes to the singularities, but the actual singularity type of the changes. So you have changing exponents in the changing exponents in the singular the exponents go to zero and in the limit you get the logarithm singularity. That's why the theorem from the paper doesn't very quite apply. But I think one could adapt it. It's not a straightforward application etc. Would you consider it adaptive I didn't get it. So you say for random trees, we have this approximation. But it's like very like those conditions that you were hiding in your slide that you have to really check what is the type of the generating function and so on to see if it fits for this random tree fits for your model. Yes, so we've done it for simply generated trees, but I think Generated trees, but I think there are many examples of simply generated trees. So I don't think it's so difficult. Well, there are definitely examples which don't fit in there, but yeah, maybe part two. Well, one last one. Thank you. So the lamp one on page seventeen and the lamp the two on page nineteen it could be the same. Oh, yeah. Oh this is a good s bot. Wait, is there a lambda two? Ah, yes. Okay. So this is probably so there's more than one wonderful term that comes out in some calculations. And I'm sorry, I forgot to include the what lambda two is on this slide. But it's. Oh, I don't? Oh, okay, yes, okay. Oh, okay, yes, okay. Oh, okay, so maybe it's also a copy-paste error. I'm sorry. But there is also a lambda one and a lambda two, but yeah, I copy paste. Sorry. Is this only a product? Uh yes, but it does converge to a constant. Because it does look like Yeah, so I think eta h um well as h gets larger it goes to well eta i as h gets or as it gets i gets larger it goes to not zero. Okay, that doesn't sound bad. It converges to a constant. We checked. Okay, let's back star again. 