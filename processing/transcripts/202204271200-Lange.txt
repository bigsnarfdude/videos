The slides this morning. Yes, I had to adopt a little bit because of some things that were said before, some things that weren't said before. So normally one ends with bonus slides. I'm actually starting with a bonus slide. And so here we see second. So what is a camp? So in the talk by Annalena, she was talking about. Analina, she was talking about public key encryption, and that is very typical. So, when we explain it to students or in journal publications, we want Alice and Bob to send messages. So, we explained about public key encryption. And so there we think, okay, they have a message that goes from Alice to Bob, and then Bob uses his private key, Alice uses Bob's public key to encrypt. But in practice, we actually don't know how long these messages are, and we don't send those messages encrypted with a public key. Those messages encrypted with a public key system because our messages might be a video. I mean, what we're doing right now is at the beginning of this, I've done a key exchange with a Zoom server, and now it's just streaming my video, streaming my voice, streaming my slides. And that's a lot of data, and we don't want to do this as public key. So we're using symmetric key cryptography for doing the bulk of the work. So that's the encryption part: gigabytes of data, megabytes, gigabytes, terabytes. Well, it won't be that long, but certainly megabytes. It won't be that long, but certainly megabytes. And so, what we actually want to send with the public key system is just a short symmetric key. And symmetric keys are a lot shorter. So, when we're looking at symmetric key cryptography, what we have there is just on the scale of 128 till 256 bits. But if you look at RSA key sizes, the smallest that are still being used is 2048. Yeah, okay, I know 1024. Yeah, okay, I know 1024 is also being used, but I try to not think about that. In any case, those numbers, the public key, has much more space than the symmetric key actually requires. Elliptic curves are a nice one, which is not so far apart, but with RSA we're seeing a huge difference. And that means we need to take our short symmetric key and somehow pad it up to the full length that the probably. That the public key system would want. Now, padding schemes unfortunately also come a lot with padding attacks. So, when you're doing a search for padding attacks or padding oracle attacks, there's a lot out there. And so, a chem, meaning a key encapsulation mechanism, is kind of a development from public key encryption to a new framework where we speak about, well, we're using public key primitives, but key primitives, but as a just as an encapsulation. So just to send a symmetric key or to agree on a symmetric key and not to send data. So what I have here on the slide, these three algorithms, look a lot like the definition of public key encryption. Except for that ENC now doesn't stand for encryption, it stands for encapsulation, and DEC doesn't stand for decryption, but for decapsulation. But the data flow is very, very similar. Very similar with some differences. So, key generation absolutely is the same. The key generation generates a public key and a private key. That's the same whether it's a CAM or a public key encryption system. But then, where we would, in an encryption system, take the public key of the recipient and the message that we want to send, the CAM only takes the public key. There's no other. There's no other input. And so, from this input, this public key, it produces some key K, that's going to be my symmetric key, the shared key between the sender and the receiver, and some cybertext which encapsulates or wraps this key. So, then in the next phase of this algorithm, the sender and the receiver can use this K for the symmetric cryptography. Symmetric cryptography and the sender sends the ciphertext to the receiver first so that the receiver can then use the decapsulation to also receive the same keyK. Okay, so decapsulation, well then in the data flow is here comes the cybertext, there's the recipient has their private key, and then this combination produces the same key K. Now, if you're thinking of, okay, you're using RSA in order to send this symmetric key, then you're not really sending a symmetric key, you're defining a symmetric key as you go. You would be picking a random message, and then probably you do a random message of full length, and so there is some step to get K, which would require a hash down to 128 or 256 bits. Now, Now, another public key scheme, which is kind of pre-quant crypto, but it's probably well known, is the Diever-Hellman key exchange. So there we have that the public key is G to the A for some known base G and some private key A. And then the Diffie-Hellman key exchange, while the other party picks a random R, computes G to the R and G to the R A. So the shared key, this G to the R A, both of them can compute. RA both of them can compute because well one party knows R and one party knows a and then that they can both recover if they have their respective public keys so the G to the R for the sender and the G to the A for the recipient so what this differ Haman looks like if you if you talk about it as a chem then the chem encapsulation mechanism takes this public key G to the A makes G to the A makes a random choice, that's where the R comes in, computes G to the R and takes the public key from the recipient, that's G to the A, computes G to the R A. Now this is the shared secret. So that's the key K which is going to be used for the symmetric key part. And the C, actually I should have somewhere a device to scribble on the slides, I realize. I'm talking with my hands. Excuse me. So, here, this K here is what we're going to use for the symmetric key cryptography, and the C is going to be the ciphertext. So, that's going to be sent over. Now, the reason I'm highlighting this is because I'm going to use CHEM as an abstraction layer in the rest of my talk. And Amelena was kind enough to explain the MAC-Lee system and the NeedleWriter system for encryption in the first talk today, in the nice overview talk. But I will be using it as a CAM. Using it as a chem. And one extra feature which is good about this, she was highlighting that NindaWriter has this kind of nastiness that you need to find an encoding from your message to a vector of length n weight t, where t is the number of errors you can correct. Now, if you talk about this as a chem, there is no message. You don't need to worry about how you're taking a message which is meaningful and turning it into such a vector. That is just going to be a vector. Such a vector, that is just going to be my random choice. So, in the same way that I'm in the Differ-Haumann key chem picking this R, the randomness I'm picking in the Needlewriter cam is just one of those vectors. And it's a much, much smaller problem to pick a random vector of the right weight and length than to pick, well, a way to encode this. Of course, you can encode it, it's actually pretty easy. It's actually pretty easy. You can write such a scheme, but we don't even need to worry about that. Okay, so then what's next? What I actually wanted to talk about is networking protocols. So the talk is called Code-based cryptography for secure communication. And so when I say communication, I mean like communication on the internet. And so when you visit some web page and it starts with HTTPS, then what you're using behind that is a protocol called Using behind that is a protocol called TLS. And yes, these S are supposed to stand for security, and so there is some crypto going on in the background. What I have on this slide here is the rough data flow of the latest of the TLS protocols. So this is TLS 1.3 and that's well in usage now since like three or four years. It's not used everywhere. Most pages, I mean, they're all still backwards compatible. You can still use one. All still backwards compatible, you can still use 1.2, but more and more also support 1.3. Now it is a pre-quantum system, so all these key generations are going to be Differ Hamann key generations. And so it starts, well, I leave out some of the kind of housekeeping stuff where the client says, hey, server, are you around? I would like to talk to you. And the server says, yeah, if I have to, I'll talk to you. And I mean, like, there's this ping-pong. And I mean, like, there's this ping-pong, like, hello, client, hello, server, etc. I'm leaving those out. I'm concentrating here only on the crypto part. For the crypto part, oops, there is still a spurious C, just please just ignore this one. Well, whatever. So the C there is not actually there. And then, so the client generates a key pair, but if you have one, that's just a G. Pair, but if I Hamman, that's just a G to the R and the R and then sends the public key to the server. The server then goes, like, yep, I can also do that and replies with their own Diffie-Hellman key pair. And so, well, no, sorry, just the public key of the part. So, what I have in the middle here is what Eve is going to see. So, Eve is going to see the public key of the client. Eve is going to see the public key of the server. Now, at this point, they both. Point they both have enough to compute a different Hallman, and actually in TLS 1.3 it's typically used with elliptic curves, not so much with fine field. Like the GTCR is actually R times P for some P on elliptic curve. But in any case, they're going to use a different Hellman where they're using their own secret key and the other party's public key. So the client can compute this. So, the client can compute this and also the server can compute this. And then there is still some extra communication where the client proves to the server that they actually know K. So they have actually done this handshake properly and they have computed the key properly. And so the client proves that they know this key. And then more importantly, well, at this point, how do we know that we're actually talking to the server? Know that we're actually talking to the server. I mean, anybody can do this key generation. Anybody could be just grabbing these network packages and inserting answers, but I would like to talk to my bank and not to some random active attacker. And then the way that my bank makes clear that it's really the bank or Gmail or whatever page you want to visit with HTTPS is that they are known by some public key, which is certified through some signatures, some chain, and then using their And then, using their signing public key, they sign well, basically the whole transcript. So, what they sign is, well, I have seen this public key. And they sign, I have sent this public key. And then they sign also all the bookkeeping information. So, all the stuff that I left out on the top here, where it's going about like, here's a random string, here's a random string, which are not cryptographic, these are just for bookkeeping. But all of that goes into. Keeping, but all of that goes into this everything sent so far. Okay, and so then this cryptographic signature that is using this identification key of the server. And then this goes to the client. Now at this point, the client is sure that only the server, because that's the only party who has the corresponding key here, is able to continue or has been able to make the signature because they're the only. Because they're the only party having the private key for this. Okay, and so at this point, the server can also send, I'm just saying, stuff. I mean, you're connecting the web page because you want something from them. So if it's the bank, you're getting your bank statement. If it's the email, you might be downloading emails, you might be reading them on the screen or whatever. So there's stuff, there's content actually coming. Okay, so this is the data flow of TLS. Is the data flow of TLS 1.3, the current version? Now, what happens when you're trying to move from that to a post-quantum world? Now, we're trying to kind of squeeze this post-quantum crypto into an existing protocol. We recently ran a workshop at the Loewen Center, which of course wasn't at the Loven Center, but virtually online, and we chose this as our poster. So, what you see there is a rather small car with a big elephant inside. That's how it kind of feels to. That's how it kind of feels to try to fit post-quantum crypto into existing protocols. Now, this protocol is expecting: well, this one should be an elliptic curve key, so 256-bit, there's a 448-1, and it's still okay with some fine fields going up to something like 4000 bits. But our public keys are larger than that for all the post-quantum systems. So, well, there could be something. Well, there could be something which sort of fits, so it's possible to squeeze things in if some fit at all. So that's that's one approach. You could say, okay, well, I select by size. Sorry, you're a secure system, but you don't fit in my size field. Another possibility is you actually doing this protocol as it's described here. And then inside this, so once you have actually this channel open, then you do. Channel open, then you're doing another key exchange, which is a post-quantum key exchange. Well, I mean, you're willing to send pictures at that point, so you might as well send your big public keys. So you can work around having this postquant part in the payload, but then you're still having the beginning, the signature, and the original outside key being pre-quanted. There's a concern about speeds and resources. Philippe correctly pointed out that many of the Correctly pointed out that many of these systems are actually faster than their counterparts. However, we're not using them alone. We're using them as a combination. We're using what's called hybrid or combined systems. So we're taking one pre-quantum scheme, one post-quantum scheme. And so with that, well, it's definitely slower than just one of them alone. And it's roughly about twice the time. And okay, if you're using elliptic curve, the space doesn't matter so much, but the time and the memory does matter. Doesn't matter. Now, this doesn't look too bad. So, there have been some experiments and it's fine. And then there's this interface mismatch. That's why I need my first slide where I'm talking about CAMS rather than Different-Hellman. So, TLS 1.3 is very much written with the interface of Diffie-Hellman. And even though I showed you how to turn Diffie-Hellman into a CAM, if you only have a CAM, then your data flow is some. A CAM, then your data flow is somewhat different. It feels sort of less contributing, less symmetric, because one party makes the public key and the other party encapsulates to it. So it's like a one direction. And then for the other way, you would be making another public key and key here and encapsulate to that one. So that's a little bit odd. But okay, you have to deal with it. And so if we're trying to show. If we are trying to shoehorn post-quantum crypto into our current systems, whether it's by the length field or by similarity by data flow, we might actually be prioritizing the weaker system. Yeah, if you're going to validate and certify your scheme, then those are not yet accustomed to public key cryptography, so that's the general problem. But there, the benefit is to go with the combined schemes. So up here, I'm saying, well, it's a downside because we're taking twice the time. Side because we're taking twice the time, but it actually has many benefits. One is: well, if you want to have your program certified or validated, then you can at least get the post-quant at the pre-quantum part validated. For instance, in France, UNSIS, the French agency in charge of standardization, has been saying, okay, well, we'll be happy to take combine schemes and, well, give us a known pre-quantum part, and we'll be happy to take your arguments that you post-quantum. Your arguments that your post-quantum part doesn't make it weaker, and so, of course, it's important that you want to have a scheme which is as strong as the strongest and not as weak as the weakest. So, this is a little bit of an insurance. You're taking a pre-quantum scheme where we have a good feeling of how it's used because, well, sometimes there are these finicky little things I mentioned, all these padding oracle attacks, and so on, and some of those are only found later. And also, several of these. And also, several of these post-quantum schemes have decryption errors. We're not used to that. So, with pre-quantum crypto, well, you encrypt, and then the decryption will get it back. Whereas with some of the post-quantum schemes, where MACLEAS is a nice exception, but several letters-based schemes and also the other code-based schemes have this issue that when you encrypt, there is a fader probability. And so, having something next to it is a Next to it is a feel-good thing. And you should do it in a way that the code quality, like the implementation, implementation, like C implementation and so on of the new scheme doesn't drag down the other one, etc. Okay, so well, this is so far a general. Hey, motivation for post-quant crypto. We need more work, we need new proofs, lots of new code. Code is an implementation. So there's substitute. Now, why do I say that? Now, why do I say that the length fields look, don't fit? So, one part is: well, yeah, there is a general issue, like how big are these things? I was looking at the chat briefly. There was something which was zero times B, but I don't know what that was related to. So, what we see here on the slides, this clump. So, in this direction here, we have the public key sign. Direction here, we have the public key size. It's a horizontal axis. This is log scale, so this is 2 to the 5 till 2 to the 22. And here we have the ciphertext size. So remember, with the CAM, the thing that you have to send is the ciphertext. And the ciphertext goes from the smallest to the 8 to the 1415. Now, what I'm plotting here is all the NIST candidates, but not all of these NIST candidates have the same security level. So this is actually Security level. So, this is actually all of the NIST candidates for camps in round three, and then with all the different rounds. So, for instance, this point, this point, and this point could be level one, three, and five for the same scheme. Now, all of these are sort of on parallel lines, and somehow, you know, on the same line. And these are both the letter space schemes as well as the alternates in code-based. The alternates in code-based scripts. So HGC is there, bike is there, and the lattices are there. What is not there is Frodo, which has larger public keys, or it should be one of these then. But anyway, so those have very similar characteristics. Then we have a different clump down here. Noticeably smaller ciphertexts and noticeably. Ciphertexts and noticeably larger public keys. And so these five dots were, well, some of them are almost looking identical. Those are the five levels of the classic Megalese system. So those are the code-based systems using Gopher codes, binary Gopper codes. Okay, so then for signatures, we don't really talk much about signatures in this talk because, well, there is no code-based finalist on the signatures. Pinalist on the signatures, but just to show you that signatures is also an issue with long length fields, but it's sort of more interesting. So signatures have this weird thing that we have kind of three clumps to choose from, here, here, and here. Now the middle clump is again very similar. So it's about the same diagonal. So these, sorry, these are again the letter space schemes. Now down here with a large public key and a small signature. Large public key and a small signature scheme, signature size, those are the multivariate systems. But as Annalena already pointed out, they have been getting some hits. So both GEMS and Rainbow are significantly less secure than they were designed for. So all of these would have to be scaled up, and that would mean scaled up in signature size and in public key size. So this will still be a separate clump, but it would be. Be a separate clump, but it would be at a less nice looking corner, so probably more like out here. Now, over here, these are hash-based or otherwise symmetric key-based. So, this is picnic and swings, this clump. And in general, again, well, you have a largish signature and you have a very small public key, or you have a large public key and a small signature, or you have the letter space schemes which are kind of intermediate. You could say. Of intermediate. You could say, yeah, that makes them all round. You could also say it doesn't make them good. I mean, it makes them not good in any metric. So, depending on how restricted you are, if you're more concerned about sending public keys, you might be happier with this one. If you're more concerned about sending signatures and if there was a cure, you might be happier there. Or if you have to send signatures and public keys, you would be in this club. Okay, so last slide regarding general. So, last slide regarding general post-quantum issues. So, if you're looking at what the recommendations are, I've already mentioned that I would certainly recommend doing hybrids. So, combine them with ECC. But then the question is, how do you combine them? Do you pick the most efficient system? And then go like, well, look, I mean, it's Google searches. We don't really care whether you search for what you're going to look at next. You're going to look up for CEMS. You're going to look up for cams, you're going to look up for rank metric codes. It's not super embarrassing. Even if you're looking up your kitten pictures or some movie, it's not going to be a big deal if somebody in five, ten years has a quantum computer and finds out what you've been looking there. And probably they won't use that quantum computer for your Google searches. So that is an argument for using the most efficient system, still in combination with something secure pre-quantum, just to ease usage, gain familiality, make... To ease usage, gain familiarity, make it a very convenient way to get in and see whether the internet melts or whether this is just fine. Alternatively, you're feeling like, yikes, the data I'm sending is really, really important. I've been put in charge of securing this, say, health data. You're the person that the health company has contracted for sending all the data. The health company is under a legal obligation to keep everything secret for 30 years. 30 years, and well, there's a good chance that within 30 years there is a quantum computer. It probably won't be used on your health data unless you become president of your country, but the legal requirement is there and you're the person in charge of having to enforce it. You're the person who has to sign a paper saying, yes, this is really secure for 30 years. In those cases, you might want to go with the most conservative system. You want to make sure that. You want to make sure that job number one is the security. And yes, of course, you're going to combine it with elliptic curve cryptography, just have like full belts and suspenders. And if it's slower or if it's bigger, it doesn't really matter. The most important thing is that the data remains secure. And the thing is, when you're doing encryption, what you're sending today, the eavesdropper gets everything. So you can't say, oh, I encrypt today with something which is maybe weak, and then Maybe weak, and then if tomorrow or in a year from now I find out that this wasn't as secure as I thought, then I just re-encrypted. But the attacker will go after the weakest one. They already have the ciphertext. So if you're concerned about the security or the conventionality of the data that you're sending today, you really have to go with the most conservative system. And if in the future you find out, hey, this was way over-designed, we didn't need this, then you can encrypt. This, then you can encrypt it with something faster, smaller, and then set it again. Well, the attacker will probably go for the slightly weaker one. If that is still secure, then you can just delete the other one. So, these are two different approaches depending for two different risk scenarios. So, what we've seen so far, there have been several experiments. So, Google has been running some experiments. Some were actually running this. So, they started with some letter space. So they started with some letters based system called New Hope and checked how this would work between Chromium, so the Chrome browser, and Google Central. So some of the people running Chrome Canary were contributing to the experiments by using this new hope for their connections. And that worked just fine. The internet didn't melt, the servers didn't go like this is too much work, it's fine. So there are some ways you can integrate this. This problem is still that the size of a packet. So, I have talked about TLS. There are other protocols on the outside which are kind of the transport layer. And these transport layers guarantee only a certain number of bytes to go through in one packet. If you have larger blocks, you can split them up in multiple packets, but then you're facing problems such as packet loss or that they arrive out of order and you have to put them. Arrive out of order, and you have to put them back in the right order. Okay, so well, that's where the 1280 bytes limit comes from, and then TLS, as I explained on the second slide already. So there are some issues, so I understand why they were choosing these letters-based systems, but the nice thing is it worked. Then Google did another experiment where they were kind of ramping up, going like, okay, well, what if a kilobyte works? How about two kilobytes? How about three kilobytes? So, not actually. So, not actually doing the encryption system, not using a public key system, post-quantum system, but just sending data of random length. And what we noticed is that even for 10 kilobytes, this dropped. It should have worked, but it dropped. Not everywhere, but there was enough, and so you can click on the UL and the slides are online, there were enough issues that they were going like, no, we can't use 10 kilobytes. No, we can't use 10 kilobytes. So, for instance, out of the letter space schemes, they disqualified Frodo as too large. So, this middle clump that I've shown you with the efficient ones, so with the HQC bike and the structured lattices, those work, but Frodo, which has larger ciphertext and public keys, that wouldn't work. And they also went like McLeese with very large public keys and small ciphertext wouldn't work. Small ciphertext wouldn't work. There are some libraries: there's PQGupto, there's Open Quantum Safe, and there's PQClean. So there's three libraries. There's also something for small devices. So that's fine. And there have been some more experiments by Googling Cloudflare again with lattices. I should actually say Cloudflare also tried isogeny-based crypto. But this talk is about code-based crypto. So how about the code-based function? Crypto. So, how about the code-based finalist? And now I want to talk about MEGLESE or classic MACALES, which is the finalist. So, the submission, or well, now it's a finalist. We'll see. Hopefully, it will be standard. Here's a short summary slide of this thing you can get on the classicmacalees.org page for more details, in particular the authors. We're quite a few authors, which is good because I see this also as endorsers of the scheme. But that means if I'm a Of this scheme, but that means if I would put them all on the slide, that would already eat up a third or a bit more than this. And I figured, okay, I'll give you more information regarding the ciphertext. So when you remember at the lower right corner, there were these five dots. I'm only showing the first of those five dots. There are actually two more schemes. Those three are giving different choices at around the ARS-256 security level. Security level. And this is the AS 128, this is the AS 192 security level. And this is the largest level. What you're seeing here is the N. So the first four digits is the N, followed by the T, the number of errors. So this is 6960. That's the length of the code. N119 is the number of errors it can correct. Here it's 96 errors to correct. Here it's 64 errors to correct. 64 errors to correct. And so these are powers of two or near powers of two. And this one is optimized for being under a megabyte and still having full security. And then these other ones, the next two, which I didn't put on the slide, would be going more with powers of two. So those are different design choices. What is very noticeable is this is really tiny. I mean, we saw this earlier in the overview picture, but the ciphertext size is the shortest. Size is the shortest overall than this competition. So even isogeny-based crypto at the same level of security, their ciphertexts are longer than the MATLAB ciphertexts. Secret key, you could push it even more, but why would you? I mean, this is totally reasonable. Public keys are a bit larger. Key generation time. This is something where I'm showing you the slower timings. We actually have some faster versions as well. The concern. As well. The concern here is to run this whole matrix generation in constant time, where, well, two-thirds of all matrices you pick will not be able to be put in systematic form. And so you have to do this several times and doing it in a way that your aborts don't give any information. And so this is well rather big here. And you can do something which is system. Something which is systematic form, except for you're allowing in a limited range to exchange some columns. So those are same numbers, but then FF. So if you go on the web page, you also find information on those. And then the key generation gets much faster. And then encapsulation, decoupsulation is fine. Okay, so what are the other selling points? Well, it's open source, constant time software. It's nice if anybody wants to try it, it's there. So, try it, it's there. Philippe already mentioned the good security record that this is something which is still the same exponent that Branch had. There's over all these years no degradation. Yeah, if you're looking at the exact security of something, yes, it lost a few bits. But the closed formula, if you're looking at the asymptotics, nothing has changed. All the research over well-prenched was 1962, so now that 60 years of research hasn't actually decreased anything there. So, this is a very concerned. There. So, this is a very conservative system. We're expecting it to last and looking at all the NIST finalists, it has the strongest security track record. All right, so what are the key issues for MakerLeaks? That's actually just one. It's yeah, kind of in your face, it has big public keys. And we knew this, this has never been a secret. McLeese has very big public keys. It turned out that there were some other candidates who are. That there were some other candidates who either already in the submission, for instance, post-quantum RSA, or because they had to adjust the parameters. Ragos, for instance, ended up with larger public keys. But apart from that, McAlise has the largest public keys. Nothing to brag about, but well, live up to it. Now, is it really a concern? A megabyte. I mean, if I look at my mobile or my laptop. My laptop, my mom sends me photos which are four megabytes, and she doesn't even think about hitting sense. And now she got a new mobile and that has better resolution, so her picture is getting larger. So this one megabyte kind of squeezes in a corner of her bandwidth. Also, even though I was highlighting the time to generate the speed, the public keys, if you're looking, your server is doing a lot of other things as well. It's not that slow. It's just the As well, it's not that slow, it's just a small fraction of a second. What I was showing you there was cycles, it was not minutes or seconds or something, it's cycles where you're looking at three gigahertz processes. So it's tolerable. It's not the fastest, but it's totally reasonable. But if you're looking at the TLS datagram where I showed you, the client starts by making a new key and then sends it to the server. And the server has to take that public key because I mean, the server wants to talk to any client. To talk to any client, and now the server has to accept one megabyte. So there's a thing called denial of service attacks, which you probably have heard of from the news, like that some web pages go down because, well, they got too much data. And there is the concern that it could flood your bandwidth. And certainly being willing to accept the megabyte could flood your bandwidth. But worse, actually, in the scenario that we're talking about, the server would need to allocate. The server would need to allocate memory for this one megabyte. And it probably wants to put this into fast memory because it wants to work with it. So, this would actually be a server memory flooding denial of service attack, which then totally takes down the server and it doesn't require as much data as it takes to block the network. So, maybe not so good. So, our goal in the first paper, I have three papers to talk about in the next 20 minutes. Talk about in the next 20 minutes. So, the first goal is to talk about how we can eliminate these attacks by using something that is specific to the codebase cryptography. And we want to ensure that there is no per-client storage on the server. So, data comes to the server, the server does something with it, and then forgets about it. All right, so that requires us to look at the public key structure. And I mentioned already that we want to have our keys in systematic form. In systematic form. So, up here is my stereotypical public key, but when you look at the parameters that we're actually using, this is not a good picture. It is a good picture because it fits on my slides, but it's not giving the right proportions. So what we're actually looking at at the Classimaclees, the 6960, 119, which was the third scheme that I showed you, is that my N is, well, 6960, as I said, and the K And the k if it was a generator matrix, k would be the height. But I'm looking at the parity check matrix. So the height here, the number of rows is n minus k. So this is much, much smaller. This is less than a quarter of the width. So it would be an even shorter matrix. But then you don't see that this is a identity matrix, or I would have to put many more rows. And so, well, okay, this is a picture I'm going to run with. Run with so on the left part, I have my identity matrix, and on the right part, I have the part which is actually interesting. This is what distinguishes my public key from your public key. And now the way that need a writer encryption works is that you have your long vector n, which has t arrows come in, you're doing a matrix times vector multiplication, which means, well, for every zero, you don't take anything for every one, you choose. Take anything for every one, you two do take something. So the ones select which columns to add. So here I'm using the blue columns as the ones that I'm going to add. And let's assume that I don't have anything else. I'm just selecting, say, four of these columns. So I have my length, well, whatever this is, it represents 6960 and weight four vector. And then I'm adding these columns together. And this is just a binary operation. And this is just a binary operation. So that's how the encryption works. And given that I'm talking about cams, I should talk about encapsulation. Now, we know how co-based crypto works. This was just a reminder of what it does. First of all, I don't need to remember this thing. I know there is E identity matrix, so I don't need to send it. All I need to send is just this part. But we're doing this already. So the one megabyte is just this part. So the one megabyte is the This part. So the one megabyte is the 1500 this way and the remaining 5400 that way. So we are already ignoring that part. Now the server would receive this whole mess and well doesn't have to get this part, would still have to get this part. If we would trust our environment, the server could get these columns one at a time. One at a time, and then, well, if this bit was set, take this column. If this bit was not set, ignore it, and so on. So, you could just one at a time and then update this partial sum. But if you're on the real internet and some attacker is there who may interrupt us, who may resend the column, or who may get an intermediate result. Well, if they change, if they find out that my intermediate result changes, If they find out that my intermediate result changed, they know that this bit was set. If it didn't change, they find that this bit was not set. So that would be giving away the one part of secrecy that I have, namely in my length n weight t vector, which positions are set. So I must not do that. However, I can still sort of use part of that idea. So what we do in the Make Tiny protocol is we're chunking up our key. up our key and I'm talking about k prime here so k prime is this part next to the identity matrix so I'm splitting this up into sub matrices where each of them is optimized to fit exactly into one network package so that is what I was talking about the first slide or second slide now this 1280 bytes that is the IPv6 size of what we can send and then what the client is in charge of the client would like to talk to the server so the client To talk to the server, so the client has a task of feeding the server one of these at a time, and then the server does something with it. Now, that is still similar to what I said before, but then when it sends back the partial encryption, this, well, this part times the corresponding part of the vector E here, it can't publish this. But what we're doing is it sends what the internet calls a cookie. What the internet calls a cookie, which means it's an encryption to itself. So the server remembers some temporary symmetric key, but it's not per client. It's just for this time frame. And that allows the server to encrypt to itself, but not having to store the ciphertext. So the server just says, okay, I've done some work and sends it back. And then the client who is interested in the communication collects all these pieces for each. All these pieces for each of these chunks collects a partial encryption, and now assume that you have all these partial encryptions. Well, now you have to combine them. You have the partial encryption from here and there. So those partial encryptions have to be added. Say all of these would fit, the partial encryption would be fitting in one package. So then the client sends the corresponding packages back. These are cookies. Then the server decrypts them. Server decrypts them. This is the symmetric part, adds them up, and again sends them back. So we have a first phase we're sending these chunks of the matrix, a second, well, then the server replies with the cookies, then a second phase where we're combining row-wise, and then we all have to combine, sorry, we're combining columns together, and then we have to also combine the full height. Okay, so at the very end. So, at the very end, the client will get the ultimate ciphertext, but in between that, everything is encrypted to the server with symmetric key cryptography. And of course, there is a whole bunch of stuff around. When we look around, what is happening now, instead of having one big chunk of a megabyte, which has to be split up anyway, we're having several round trips. Each of those has to be sent, and for each of those, a cookie has to be received. And then there is the next phase for the And then there is a next phase for the combination. There's another phase for another combination. So, what we have here is in the phases, so zero, that's the phase we're sending the public key chunks. Then we're sending the pieces for combination. And we're always staying just below the 1280. And then at the end, oh, well, we don't really have much more to send. So, in the three-phase here, it's not filling it up. There's only one packet to send, but it was necessary. One packet to send, but it was necessary to send this so that the server can combine all the cookies. So in the end, we're sending more data than necessary. The client would have to send that many bytes, so that's the public key size, the one megabyte. But okay, it's 10% extra. That's not deadly, given that the alternative is that the server goes and the replies, so what the server sends back to the client is a factor of 10 less anyway. Is a factor of 10 less, anyway. So we implemented this, and what you see here is the time going vertically. So time runs from here down there, and you're seeing the packets sent. So here, this is the first phase. There's a lot of data sent, a lot of data sent, a lot of data sent. Okay, now it's a combination phase. And then at the very end, there's not much data sent, but time goes on because those are the combination steps. And so what is the red curve is the data sent. Red curve is the data sent, the blue curve is the data acknowledged, and then how much space it took to acknowledge this. So the reply packages are much, much shorter. And so if you want to learn more about the MacTiny part, that is mactiny.org. So there you can get the software and also the full paper. This is a paper by Stan Bernstein. The next part I want to talk about is not actually my own work. It starts with WireGuard, which is a modern VPN product. WireGuard, which is a modern VPN protocol designed by Jason Donfeld. And so VPN stands for virtual private network, whatever that means. Okay, so you might have used a VPN with your computer to log into your university or to log into a company. And so what this does is it makes a tunnel from your server, sorry, from your laptop to a server at the endpoint. And then for every And then for every other machine over here behind that server, it looks like your packets originate from here. So your packets basically get injected into this network. So you're getting extra tunnel into this network. So the original idea of VPNs is that you are working from home, say, and you're connecting to your university through this VPN tunnel. But for the university network, it should look like you're actually there. Like you're actually there, and so then you're getting all the benefits, you're getting library access because you're in the right IP range, you don't have to go through extra hoops with logins, two-factor authentication, and so on. So, okay, this is how a user observes a VPN. The important thing to distinguish from the TLS scenario is there's the client talking to a fixed server. You have your VPN server, which is to your work. You might have another VPN server, say if you're living in Russia or in China. You're living in Russia or in China, and the government is blocking your internet connection, you might actually observe use of VPNs as a different tool, namely as a tool to get out to the real internet. So rather than having a tunnel into a company network, you might also be using a VPN to access the normal network, but to tunnel out of your restricted network. So you cannot connect to many places, so you take. not connect to many places so you take from you you can connect to the vpn server and then from the vpn server you go to google facebook whatever you desire but in any of these scenarios you have a fixed server you want to talk to now in wireguard this is a more modern vpn protocol the old stuff that your university is probably using is ipv6 sorry is um is i um and here we're using uh wireguard and so this is why And so, this is fully defined by public keys. So, the server is known by long-term Different Helman key. And this long-term Diffie-Hellman key, when you register with the WireGuard server, you're actually getting this. It's basically like on a business card or by email or something. It's not that you're doing a handshake to get this. It's out of band. It's your problem how you get it. Now, okay, if it's a commercial VPN server, you might actually get it on the web page, but the WireGuard protocol assumes you know it. Assumes you know it. So here's the data flow. So let's start with the server. The server has a long-term, that's what the LT stands for, has a secret key and a public key. And the client, before anything starts, knows the long-term public key of the server. And so the Weiga protocol is fully Different-Hammond-based. So the key generations on the slide are all Different-Hammond key generations, and you see some of the Differ Hammond things. Some of the Diffie-Harman things are explicitly marked the same way that I was doing Diffie-Harman and the TLS explanation. So, what WireGuard is doing is the first step is, well, the client goes like, hey, I want to talk to the server, I want to have a connection. So, it starts by generating a fresh key pair. Then does the different Hermann key exchange between the long-term public key of the server with the secret key that it just generated. So, this is kind of So, this is kind of the semi-static Diefeldhamman situation where this key is fixed and this one is fresh and random. So, that is very much like in a CAM scenario, except for we're going to reuse this one, so it doesn't quite fit with CAMS. But anyway, so we go ahead, we send the public key over to the server. We're also doing something with K1, so there's a lot of housekeeping stuff. WireGuard is using the noise protocol, which basically says at every step. Which basically says at every step, make sure to remember all states, so it's like everything in the kitchen thing you're putting in there, and so there's a whole lot more. But I want to concentrate on the cryptography. So we just send the public key. Now the server can now compute the same K1, well, using its private key and the public key that was just sent here, the client, can check whatever was the something with K1, it can check that. Was something with K1, it can check that, and now we also want key freshness on the server side. So the server will also generate a new DifferHauman key pair and does the Differhamman key change with the public key, the fresh public key on the server, from the client, and its fresh secret key that it just generated. So this gives another key, and then those two keys are hashed together into some K2. Together into some K2. Okay, now the client needs K2. So, what we're sending is we're sending this public key so the client can do a different Hammond. And we're again doing something with K2 so that the client can verify. I'm leaving out the checking steps here. So they just compute this K2. And then they now both have K2 and they can use K2 or keys derived from K2. If we now want to do WildGuard with scams, then, okay, so. Then, okay, so this turns into a CAM, long-term key on both sides. And this would be a key generation for CAM. Okay, so here we now have to do a CAM encrypt. Actually, sorry, now I said it, CAM encapsulate operation. So the CAM encapsulate operation gives us a shared key K and a ciphertext C1. We're going to send the ciphertext. And we also have done this fresh key generation. Have done this fresh key generation here. Now that we have a key, we can use this key already to encrypt this ciphertext. It's not really necessary to encrypt a ciphertext. This is something which is like in WireGuard. Whenever you have a key, you use it to encrypt. So it would be okay to send the public key alone, but it makes more sense in the data flow to actually encrypt it with K1. Okay, now the server needs to get K1. And I realize, oh no, okay. Yep, I totally failed to put in here, and I don't know how that happened. Oh, there it ended up. This is wrong. So this part here should be over here. Sorry. So this decapsulation step is on the server side. Oops, I didn't see that. Okay, so the server gets K1. So the server gets K1, decapsulates the C1 using its long-term secret key, gets the K1, and now with K1, it can decrypt. So these are symmetric key operations, it can decrypt this thing and get the public key. Now it has a public key, so it can do a CAM encapsulation to obtain another, well, the shared key K2, prime, and ciphertext. I'm doing prime here because I will hash those things together to have the actual K2. Have the actual K2. So we can now send the C2 and then we're sending some stuff to verify, or we maybe public key symmetric key encrypted again under the previous key. And this gives us on the client side a K2 prime, again with the Chem decapsulate, now using the short-term server Chem key and the ciphertext C2 that we just got. And then we hash them together. So now we have a K2. So this will be a kind of translation. So, this would be a kind of translation of Wireguard with CAMS. And colleagues of mine in Eindhoven, together with Nijmeg and KPM, the Dutch telephone provider, have actually done a full version of this called post-quantum WireGuard. Now, in this diagram that I showed you, the server is again known by a long-term key, and this well has to be a chem key. And this public key is exchanged out of band. Now, see where we're going. See where we're going. So, this key can be large because we never have to pay for it. This is something that is not painful. This is not, we're not paying for it during the execution. It just happens, well, sometime before the protocol starts. The C1, that is a CAM ciphertext that goes over on the first message. And this should be small. So that's another nice thing where code-based script can really shine because our ciphertexts are small. Ciphertexts are small. Then for the short-term claims and keys. So the server, the client also, or this should be a C. Okay, another issue. So that should be a C rather than S. I'll fix those before I put them online. That short-term CAN public key. So that's a client public key. It's sent and should be small because we're paying there for both the public key as well as the encapsulation to it. So in the post-quantum wildguard, what this shows was the classic McAleese key. Shows was the classic Magalese key for the long-term cam and a lattice-based protocol called Sabre for the short-term cam. So, this is another place where the small ciphertext of classimagrees really pay off, and we don't actually notice the cost for the public keys. Now, the last thing, and I see only have three minutes left, is a protocol that we are working on, which is called PQConnect. So, VPN, I said, is a BPN, I said, is a virtual private network. Now, what we're doing here is a BPN. It's a boring protocol. Because when you build a tunnel, you actually have to bore it. Also, boring in cryptography is a positive word. We like crypto to be boring. We don't want to have any excitement. We don't want to have surprises. And so the background is that we don't want to patch post-code and crypto onto existing network protocols, but we just want to do something new, saying it doesn't fit, so let's do a new. It doesn't fit, so let's do a new layer. We will still be well running on the normal IP protocols, but we don't bother fitting into TLS. And the nice thing is that we can be deployed gradually and we can like have a support which is like a VPN. So we're still talking about tunnels between clients and servers. But unlike in the VPN scenario, we're not talking about client to some VPN server and then to somewhere else, but we're really talking client. But we're really talking client to serve where we want to be. So we do want to have the software be deployed on the final destination. So this is something which we hope that, say, Google will run or Facebook will run. And so the ingredients that we've chosen is similar to the PostgreN WireGuard that we have classic McLees on the outside for the long-term keys as the most conservative post-quadron system. And then for the letter space scheme, we picked Ladder space scheme: We picked a streamline intro prime for the firmware keys, and we're combining everything just curved to 519. This is the Defe-Hauman system, which is pre-quantum. What I think is interesting is our strategy of how we nest things inside each other. So, our motivation was: let's put the most conservative system on the outside, and then, well, it protects whatever is inside. So, what we're doing is on the outer layer, we have the Doing is on the outer layer, we have the MAC-Lees system, and so the outside layer is the CHEM2 MAC-Lease, and then inside this, we're encrypting the Curve2519 key. So, what I showed with post-quantum WireGuard is not, sorry, what I was shown with Chem WireGuard is not exactly how post-quantum WireGuard is doing it, but what we are doing in PQConnect is really doing this. We're actually encrypting the public keys, and so we're encrypting to And so we're encrypting to the long-term public key of the server. We're also having an ephemeral public key at Curve 219 from the client and the server again. And then on the inside, we're hoping it's secure, but if not, it is well padded from the outside. We have streamlined Enterprise. Now the attacker does get to see the long-term curve to 519 key. So that's something which is quite. So that's something which is quantum vulnerable. So they can compute the private key. But if they don't actually know what is sent to it, what the other, what the contribution part from the client is, they can't compute the shared key for the Different Harmon. So even though it is a pre-quantum scheme which could be broken, they can't even use the quantum attack in order to get the benefit there because it's inside the McLease system. MACLES system. So the way that we handle the MAC-Lease keys is: well, these are the long-term keys. They don't change this identity key. And so if you have like your web pages that you see a lot, you'll just allocate this space to those. So you will remember the keys for Google, Gmail, Facebook, Twitter. Your computer knows those, doesn't look them up. What is happening currently with the internet, you're having a DNS lookup, so that's figuring out where you actually want to go. Where you actually want to go, and this normally goes via your internet provider, and they will probably also have some storage there. Now, the Pico Connect will actually use this DNS lookup to piggyback on it because what we're downloading is a hash of the public key and where to download it. And now it nicely wraps together because the split, the tiny key, which I showed you with the chunks of the public key, this is the same. Public key, this is the same that we're also using a peak connect. And then we also, well, okay, it's not exactly the same because we're also sending elliptic curve key, but that's a tiny 256 bits. And then in PConnect, we don't have to typically send this public key. We do benefit from the small ciphertexts we combine with letters-based crypto in order to be fast and balance the sizes. And also, well, we have this nesting. So, if you want to see more, So, if you want to see more, there's so far a student thesis out there. What are we actually working on pay-by-non software? The last thing: if you want to know more about Postbot or other stuff, there's a lot of links and I'm not going to go through those. Thank you for your attention. Thank you, Tanya. Thank you. Hope you can hear the claps, and all the microphones are in the right place. So, do we have maybe a quick question? Yeah, yeah, yeah. Yeah, yeah. Yeah, maybe a quick question for Danielle or two? Nobody asks questions. I'll just keep on blathering. I mean, I hope I. I wish I could ask you a question, Tanya, but you know, I'm quite familiar with most of these things, so it wouldn't be an honest question. But so maybe my question is, this latest project is then a PhD thesis, right? A PhD thesis, right, that you're currently developing? The student PhD thesis, but he continues to work on it, and it's going to be a lot bigger than a master thesis. It's actually eight authors and so on. But I'm really happy to see there are several use cases where code-based crypto that we all know and love is really the right application. It's not like, oh, we're the paranoid ones. We're picking this one because we don't like lattices, but it's actually the best system for the. It's actually the best system for the job, and it's also more secure. Great. And any more questions for Tanya? Otherwise, we'll thank Tanya again, please. And thanks everyone for attending this Code Base Crypto session.