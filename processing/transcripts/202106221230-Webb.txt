Right, so this conference is about not surfaces and three manifolds. So, of course, mapping class groups pop up in the study of surfaces, but they also pop up naturally in the study of knots. For example, if you cast your minds back to the 30s, there's Markov's theorem on braid closure. Markov's theorem on braid closures. So, if you take a braid and you close it up, you get a link in S3. Two braid closures will represent the same link if and only if the underlying braids differ by conjugacies and stabilizations. So the conjugacy problem in braid groups naturally arises in the study of knots. In terms of more general three manifolds, though, in the 60s, Harkin provides. In the 60s, Harkin provided and outlined an algorithm for the recognition problem for Harkin III manifolds. And the conjugacy problem for mapping class groups pops up naturally in that algorithm. And that was shown to be decidable by Hemian in the late 70s, before the work of Thurston. You can look at the history in more details in the mathematics in Latvia's book, for instance. But Hemian's proof of um but Hemian's proof of the that the conjugacy problem is decided is is um leaves a lot to be desired uh it came before Thurston and yeah it it it's you look for conjugators and you could be there for a long time looking for possible conjugators to solve the conjugacy problem so um what we want is a better way of solving the conjugacy problem and since the conjugacy problem does appear Conjugacy problem does appear in a natural context in many different algorithmic problems, it's important to know whether this thing can be solved in polynomial time. So that's one of the main motivations for this talk. Of course, it's also interesting in its own right from a group theoretical perspective. So before I move on to our theorem. So, before I move on to our theorem, I just want to very briefly mention some previous work due to many people. For instance, there's the work of Le Mosia on various algorithmic problems in mapping class groups, including the fact that the word problem is solvable in quadratic time, automatic. There's interesting algorithms in the Bray groups by Benadetti, Gutierrez, and Natetsky built. Benedetti, Gutierrez, and Natetsky, building on the Gausside theory. There's the Best Final Handel algorithm. There's the work of Maiser-Minsky and Jing Tao on showing that the conjugacy problem for mapping class group lies in NP. That's quite an interesting advancement in the history because they use some sort of geometric group theory to show that there exist conjugators that are linearly bounded in the work they. That are linearly bounded in the work length of the inputs, if they exist, and that's how you get that. There's a polynomial size certificate for the conjugacy problem. What else do I want to say? Of course, in very low complexity, the conjugacy problem is known to be in polynomial time. For example, for SL2Z, it's known to be in polynomial time. For the four-strand, Limit time. For the four-strand braid group, Colves and Vist show that the conjugacy problem can be solved in cubic time. And Mark Bell in about 2016 showed that the mapping class group has a co-MP conjugacy problem. Okay, so I should move on. I can't give a comprehensive history of the problem due to time constraints, but here's the main theorem that I want to talk about today and just give you a That I want to talk about today and just give you a brief overview about. So, the theorem states the following: if you fix mean orientable surface S of finite type, so finite type here just means finite genus, finitely many boundary components, finitely many punctures, and you fix a finite generating set for the mapping class group, then the conjugacy problem for the mapping class group lies. For the mapping class group lies in P. Here, P means that the problem can be solved in polynomial time in the word lengths of the words you give me. So you give me two words F and G in the finite generating set. And then I can tell you whether or not F and G are conjugate in the mapping class group. And if so, give you, in fact, we'll give you also a conjugator in polynomial time as well if they're conjugate. If they're conjugate. Now, before I move on and talk about how we prove this theorem, I want you also to note that there's another group working on this from a completely different perspective. And that's the work of Dan Margaliet, Barstrinner, Santayla, and Aiku Yotash. And it's all the same setup. But what they do is in quadratic time, if you go to pseudo anisoff, they find you the correct major. You, the correct matrix whose eigenvalue and eigenvector give you the dilatation and stable lamination in measured lamination space. I'm able to do that in quadratic time, and that really ought to give you the conjugacy problem in that setting. I think it's really great that there are two groups here understanding this problem from two different perspectives, because it means that many different areas of mathematics can be understood at the same time. At the same time, so there are a couple of things that we have in common between these two theorems. The first thing is that they're both in progress. Our papers aren't available yet. We have a draft. We're just adding some new things to it, and it's not either complete. But if you're interested, I can share it with you. Another thing that I want to say that's in common between the two theorems is that we Theorems is that we both use the dynamics of the pseudo-anosols in a crucial way. So we both use the fact that simple closed curves, essential curves on the surface, under iteration by the mapping class F, the Tsudanosov, those curves tend to the stable lamination nice and quickly in the sense that they fellow travel for a long time or in the sense that they are close. Sense that they are close in house door, coarse house door topology. But apart from that, instead of using the measured lamination space, we use instead a more geometric group theoretic approach using the curve complex. So now let's go into more detail into what we do. So what do Mike Bell and myself do? So let me just remind you of this. So let me just remind you of this wonderful theorem due to Thurston, proved by Thurston in the late 70s. So you give me a mapping class. It's either going to be finite order. And if it is finite order, then it turns out to preserve a hyperbolic metric or a fixed point in Titan space. And that will come in useful later. If it's not finite order, then F is instead infinite order. In that situation, Order. In that situation, it either preserves a curved system on your surface. In that case, we call it reducible. But if it's not reducible, then instead it's pseudo-anasov, which means that the mapping class has a nice dynamic representative homeomorphism, which has almost hyperbolic dynamics. It looks like it's just stretching the map one way and contracting the other way by some constant lambda outside a finite set of points on the surface. A finite set of points on the surface. Okay, and now, so what's the game here? The game is: if the map is finite order, then we'll try to compute something that looks like the hyperbolic metric that is being preserved. If it's infinite order, then we try to find a curve system that the mapping class preserves. Or if it's pseudo-anisoft, then it turns out that we won't compute the stable lamination, but we'll do something a bit different. But we'll do something a bit different and is more similar to something that you would do in geometric group today. Right, so if we want to solve the conjugacy problem, we ought to know which of these three cases we're in. So the first thing you do is you can use Moses' solution to the word problem, which is quadratic time, to check whether Time to check whether your given mapping class has finite order or not. Okay, so that's a well-known thing you can do, decide whether a mapping class is finite order or not in polynomial time. And what we do in the finite order case, we compute the quotient orberfold and the deck transformation by F on this reserved hyperbolic metric. It turns out that we can do It turns out that we can do this quite quickly if the surface is punctured. So we believe that in the punctured case, what we do in the finite order situation is that what we do should be done quadratic time and polynomial on the actual surface. And this is implemented in Kerber, which is due to Mark Bell. Which is due to Mark Bell. I just want to say what is involved in our solution to the conjugacy problem in this very specific case. So the overall idea is to find an invariant set of arcs and curves that fill up your surface and are invariant under F. Then you just look at how F permutes the things complementary to the R. The things complementary to the oxen curves to give you this deck transformation. And more or less, you then just fill in the details to check that that's actually going to give you a complete conjugacy invariant. So, how do you actually find this invariant set of arcs and curves? Well, in the punctured case, things are very nice. So, what we do is Do is we show using the existence of the invariant hyperbolic metric that you can get your hands on an invariant arc system by looking at certain surgeries of arcs. Namely, these are we call them unicorn paths or unicorn arcs. And these are picked up by the Hatcher flow or the Moja flip sequences. Sequences which you can compute in polynomial time. If you want to know more details, you can ask me later. In the closed case, though, things are a little bit difficult because you don't have arcs. Instead, in that situation, you have to be a little bit more careful and things are more complicated. But we look at icon surgeries instead. These used to be called. These used to be called double wave surgeries, I think, before unicorns and blicorns were called what they were called. So this is just a brief overview of what we do in the finite order case. Let's now talk about the infinite order case. So in the infinite order case, we either try to find ourselves a reducing curve system. Curve system. Well, failing that, we verify F is pseudoanosov and then do something else. We don't find the dilatation and we don't find the stable amination, but we do something else. In both of these cases, in the infinite order case, we want to use the dynamics of F. More specifically, we look at the dynamics of the action of the mapping class on the curve graph, C of S. And just to remind you, the curve graph is the graph with vertices, the essential curves, the essential simple closed curves, all b s up to isotopy. And edges in the curve graph join two curves off from beta if they can be realized disjointly on s. Okay, and so there's this example at the bottom. There's this example at the bottom, given by these three example vertices and some edges between them. That's how those three vertices look like in the curve graph. Okay. So the curve graph is hyperbolic in its infinite diameter, which was shown by Mazel Minsky. And the way we're going to attack the conjugacy problem for the mapping class group. Conjugacy problem for the mapping class group is going to emulate what geometric group theorists would do in the situation of hyperbolic groups. So if you have, for instance, a hyperbolic isometry of a hyperbolic metric space and you want to solve the conjugacy problem, what you want to do is you want to find some sort of axis for that isometry. And that's what's going to happen in the Sudanasov case. Okay, so if you find yourself in the Sudanasov case, what we do is we try to get as much of the axis for F as we possibly can, and then use that to find a complete conjugacy invariant. So it's very much in common with what goes on with hyperbolic groups. On the other hand, if F is reducible, then Then f preserves a complete subgraph of the curve graph. We don't quite immediately get the canonical curve system, but we can find a reducing curve and just repeat the process. I'll talk about these in a little more detail very soon in a more specific and easy case. So I'm not going to. I'm not going to go into the full details and what our algorithm does in the general situation because else I'll find myself bogged down in details with various definitions of type geodesics and so on. Instead, what I want to do now is explain to you how our algorithm would work if we tried to implement it directly into a very simple situation. And that situation is when you have your surface S being the once-hold torus. Once-hold torus and the curve graph of the once-hold torus is the fairy graph. Just to remind you here, there's a slight difference in the definition of the curve graph in this situation. Two vertices will be adjacent if they intersect precisely once. So in the fairy graph, things that the curve graph is. Very graph, things, the curve graph is slightly defined differently. But it has a really nice, explicit description. It looks like this. And just as example vertices, this vertex here on the right looks like the horizontal curve 1, 0 on the torus. This vertex of the ferry graph on the left looks like this vertical curve 0, 1. And this vertex up here will look like this: the curve 1, 1. The curve 1, 1 on the torus, and this vertex down here will be this curve instead on the torus. Okay, and after a little bit of thought, you might like to see what the other vertices look like corresponding to where you are in this picture of the fairy graph. So, let me just now tell you very briefly how our algorithm works in the reducible case. So, suppose F is reducible. Then you know that F must preserve some mystery vertex V. Okay, and here's V here, which is in red. And I want to emphasize the term mystery because this vertex could be anywhere in the ferry graph april. Be anywhere in the ferry graph a priori, and our job is to find it. Okay, so this mystery vertex V could be over here, and we have to try and find it from first principles. But what we do know is that these mapping classes in the infinite order reducible case have some nice dynamics. And how that translates to the action on the curve graph is that, in some sense, the In some sense, the mapping class or the isometry rotates about the vertex V. Okay, so if you look around the link of V, you've got these nice simplicies surrounding V. And if F is reducible in infinite order, then what it's going to do is it's going to send this triangle here way over to this triangle over here if you raise it to a large enough power. It to a large enough power. Okay, so let's say f to the n will rotate around v quite vigorously, right? Whatever that means. But if you look at, say, the horizontal curve, let's give it a name C, right? Look at how C projects to the link of V. Okay, so if you look at how C projects to V, it comes in from Projects to V, it comes in from some angle. So it might come in like this in this picture. After you hit it with F to the N, this vertex C will start to look like it's way over here, F to the N, in the fairy graph. And it will be, let's see, looking like it's going outside here. Now, this helps us because if we have some sort of canonical path from the vertex C to the vertex F to the N C in the curve graph, then it seems likely that we're going to pick up V along the way. And that's exactly what we do. So, what we want to do is we take this curve C, this very simple curve C, and we compute a sequence of vertices. We compute a sequence of vertices in the curve graph from C to F to the N C. Here, capital N depends only on the surface. And moreover, in this situation, when the surface is small, like the once whole torus, you can pick n to be something like five. It turns out for the ferry graph, you can get a path or a sequence of curves from C to F enter C, you can just use Euclid's algorithm, which is polynomial time. It's quite quick. But for general surfaces, what you really want to use is train track splitting sequences and the work of Egelhas-Thurston, which is in some sense a generalization. Some sense a generalization of Euclid's algorithm. That's how I think of it. In the situation where you've got the once-hot torus, though, Euclid will in fact spit out the vertex V if you pivot around it enough. But for general surfaces, things are much harder. We would need to use some machine learning on type geodesics and Mazer, and some theorems of Mazer-Vominsky to actually fish out a reducing curve system for you. Let's now talk about the Sudan and soft case. So in this situation, what we want to do is find enough curves on the axis for F. So here we are using Thrusten's work here in the sense that we've got some stable and unstable lamination. Stable and unstable laminations, which are like the sources and sinks for the dynamics of the Subamussel from the curve graph. F will have an axis and it will translate curves along this axis. And the plan is to find enough curves on the axis to try and get a complete conjugacy invariant. The trouble is, is that the curve graph is locally infinite, so you're not going to compute all the curves that you. So, you're not going to compute all the curves that you see on this axis. The brief idea is you want to use Eglehas-Thurston again. And that works in polynomial time. It doesn't quite fish out all the vertices that you will see along this axis, though. Because in general, the number of vertices that you would see in this specific axis in the ferry graph would be exponentially many things. Would be exponentially many things. So, actually, quite a lot of this gets thrown away. And so, you end up with some gaps. But the point is to get close to the axis first. And that's what this step does, is to get close to the axis. After you do that, you want to fill in the gaps. So, for the fairy graph case, what we would do if we were to run our algorithm is to look at all embedded paths of length two. At all embedded paths of length two between all curves computed thus far, and what that would do, it would pick up these pivoting points along this sort of axis that you would see in the ferry graph. In general, the picture is more complicated. For general surfaces, we have to look at these things called tight geodesics, which were introduced by Mazier-Minsky. And instead of looking at paths of length, And instead of looking at paths of length two, we'd be looking at paths of length at most L. So I'm down here. Apologies for lack of pressure. For general surfaces, instead of looking at embedded paths, you have to look at these things called type paths. You have to look at type paths of length at most L, where L is some universal constant. So you compute all of these curves. And we're able to do this in polynomial. And we're able to do this in polynomial time. So there'll be polynomially many curves. Where does our complete conjugacy invariant come from for the pseudo-anasovs then? Let me tell you, what we do is for each curve alpha that we've computed so far, we first compute alpha and f to the n of alpha. So that will be some complicated set of pair of curves on the surface, which will fill the surface up. The surface up so it'll cut it up into disks and one bunch of disks. We then turn the pair of curves into some sort of canonical triangulation t. So what you do is you sort of take the curve alpha and you find some nice way of pushing it into a puncher. If you're on a closed surface, you just pick a pretend puncher in some In some nice region, complementary region of the curves, and then you use the other curve f to the n of alpha to fill in the rest of the edges of this triangulation, as I've illustrated here. So, what you would do is you would see where this blue curve crashes against the red one, and then you push it in one of two directions. So, here I went the wrong way, I want to push it in this. Way. I want to push it in this direction, which is going along this way into the puncher. I can then complete it to a triangulation and then start doing things like I would normally do in Flipper. Then I would compute t and f of t per triangulation I get. And this will be polynomially many things. So the punchline at this point is: if you give me f and g, I should compute all possible triangles. I should compute all possible triangulations for both mapping classes and then compute these pairs t and f t prime g t prime and then decide for each pair whether these are homeomorphic on the surface. If they are homeomorphic, then the answer is yes, the maps are conjugate, and in fact, you can give an explicit conjugator by this homeomorphism that sends the pairs of triangulations to the other. To the other. If it turns out, on the other hand, that you can't find these triangulations, then the answer is no, they can't be conjugate. And yeah, I think I'll stop there. But more or less, the rest of the conjugacy problem follows by the combination of these three ideas. Okay, thanks very much. So, Richard, your input was you didn't, you didn't really have structure on your surface, right? You have a mapping class group of some surface, S. And all of the structure you needed, like in particular, of course, finding these triangulations, all of that is part of the algorithm, right? Or did you start with some sort of structure on the surface? Yeah, I didn't go into detail of the Let's go into detail of the computational setup. I just wanted to, in the talk, just talk about the ideas involved, what was sort of new. But what we would do is you would fix a, so what we do is we deal with triangulations in our computational setup. On a punctured surface, we'll just have an ideal triangulation. On a closed surface, we'll have a triangulation with one pretend puncture. With one pretend puncture, which of course is just a marked point which can be isotoped around. Our mapping classes are given to us in terms of flip sequences, flip sequences of triangulations. So if you're given two triangulations, you can get between them by flips or pack namous, as some people might call them. Pack numus, as some people might call them. Okay, okay. So you can encode mapping classes in terms of flip sequences. You can also record curves on your surface in terms of Dinikov coordinates. I think they're called Dinikov coordinates. So you can just say things like: this curve intersects this edge four times. This edge four times. This curve intersects this edge three times, that one once. And yeah, that's how we measure curves. When mapping classes act on curves, though, their intersections can increase exponentially in the wavelength. So all of these algorithms that we do are polynomial in the bit size of these intersection numbers. Section numbers. So things like computing C and F to the NC, computing minimal position between curves on the surface, computing the curves that you see in train, in vertex curves of train tracks, train tracks, bidding sequences. These are all polynomial time in the bit size. Are all pulling on your time and the bit sizes it has. Okay, okay. Actually, I think I would like you to give a summer school class on these issues. Sounds good. All right. We, on the other hand, should move along. In our schedule, Emily, Emily Hamilton will be talking about 