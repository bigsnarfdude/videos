All right, so for our second talk of the day, it's a pleasure to welcome Brenda Jensen from Union College, who is going to talk about an example of the Cartesian differential category from functor calculus. Okay, thank you very much. Please bear with me as I get my slide shared and just kind of rearrange. Rearrange rearrange my Zoom pictures here. Trying to figure out a way to do this, so I'm kind of looking at the camera. Okay, so I'm going to talk about an explicit example of a Cartesian differential category that comes up from the context of functor calculation. From the context of functor calculus. And so that's my plan. And basically, the way I've organized this is I want to spend a little time just kind of setting the perspective, so to speak, providing a little bit of an introduction. And then I want to talk about the particular type of functor calculation. Particular type of functor calculus from which this example arose. That's the abelian functor calculus and the notion of directional derivatives that appears there. And then I'll spend some time talking about how this fits into the world of Cartesian differential categories, and then how this framework enabled us to actually prove a higher order chain rule for this directional derivative. For this directional derivative, I'm going to talk about. But I want to make sure I give credit to the many people who have been involved in this. So, in terms of the development of the abelian functor calculus and the first order chain rule that I'm going to talk about, this comes out of joint work with Randy McCarthy. And in terms of the Cartesian differential category structure in the higher order chain rule, this is a problem. This is a project that's been alluded to in this conference as Bjort, Bjort standing for the last names of the collaborators: Christine Bauer, myself, Christina Osborne, Emily Real, and Amelia Tebby. And one of the things I wanted to say when I got started here was just to kind of reiterate some of the things that Tom said about how it's really been a wonderful conference and it's Been a wonderful conference, and it's been exciting to learn about all this new stuff from very, very different perspectives from the one I usually take. And with that in mind, I thought it was worth kind of trying to get you all inside my head and kind of the perspective from which I'm approaching this subject. So as Tom talked about, one of the features of functor calculus. One of the features of functor calculus is that it's providing a way to approximate functors with annexcisive or more generally polynomial functors. And so it's really we're coming at it from the direction of that aspect of calculus that involves Taylor series and Taylor polynomials. Secondly, in this world, calculus terminology. World, calculus terminology is really providing an analogy for describing these techniques, a very useful and powerful analogy. And bringing the Cartesian differential category perspective into this is quite exciting for a couple of reasons that I'll point out. In some sense, I think of this as kind of validating the analogy with calculus. Analogy with calculus. We're saying in a concrete categorical way that some of these things that we've been thinking about as being analogous to calculus really do fit into a categorical notion of calculus. At the same time, I think what we're going to be seeing today is that this perspective is providing us with new tools for understanding functor calculus and new ideas to explore in functor calculus. New ideas to explore in functal calculus. And finally, this is kind of a caveat here: Tom mentioned this as well. Something that's kind of lurking in the background, and I'm going to try to suppress it for a while, but we do have to come to terms with it, is that the work, the functor calculus is rooted in homotopy theory and algebraic topology, and we're working up to some notion of equivalence. To some notion of equivalence in this context that's weaker than isomorphism. So, homotopy equivalence, weak homotopy equivalence, quasi-isomorphism if you're talking about chain complexes. But that's in the background and it's as you'll see it can make things a little bit more complicated for us, but perhaps that makes it more interesting too. So, my starting point. So, my starting point is basically this result that Tom talked about a few minutes ago that says that if you have a functor of spaces, you can associate to it a tower of functors, a Taylor tower that's analogous to a Taylor series for that functor. Okay, so analogous in the sense that each term in this tower is polynomial. Is polynomial degree n, where polynomial degree n means an excisive. And he didn't, I don't think he mentioned this, but there's a very nice sense in which the terms in the tower really approximate the functor. So if your functor f is nice and you plug in a sufficiently nice space, then f of x and p and f of x. And Pnf of X are going to are going to have homotopy groups that agree in a range that increases linearly with N. So in this very concrete sense, at least from the point of view of homotopy theorists, this tower is going to converge to F. And finally, from a more categorical point of view, these functors are universal. So they're universal. They're universal among an excisive functors with natural transformations from F. So, this is the starting point for this project. This is a quick reminder of what Tom meant by excisive. So, excisive means you're going to take a strongly or a homotopy co-cartesian or push-out square to a pullback square. And then you A pullback square. And then you can generalize this to n-dimensional cubes for n minus one excisive functors. But now I'm going to switch gear. So when we talk about abelian functor calculus, we're changing our context. So no longer am I talking about functors of spaces, but I'm going to be talking about functors between abelian categories A and B. Okay, so abelian categories are Okay, so abelian categories are you think of them as very algebraic categories if you're not familiar with the terminology. They have zero object, they have finite byproducts, they have kernels and co-kernels, their home sets are abelian groups. So they're like the category of abelian groups. And the reason for starting here is that there was Here is that there were hints of calculus in this context. So in the 50s and early 60s, Eilenberg and MacLean and later Dolden Pupa developed things that we would now recognize as parts of Taylor towers. So Eilenberg and MacLean, in a paper published in 1954, defined polynomial degree n functors. Degree n functors in the context of abelian categories in terms of things called cross-effects, which I'll say a little bit about in a few minutes. And then they also defined what I would now describe as a linear approximation for a functor f. So this construction QF. They defined it for the purpose of constructing a chain. Of constructing a chain complex that would give you stable homology of R modules with coefficients in a ring S. And Dold and Pupa defined a functor DF that one could associate with these functors F. They defined it for the purposes of defining derived functors like you would in homological algebra in the case where your starting functor f is not. Your starting functor f is not additive. But you can show that these two constructions are basically degree one polynomial approximations to f in the kind of sense that Tom's been talking about. And so let me say a little bit about cross effects to give you a notion or sense of what degree n means here, because it's not the same thing as the n excisive notion that that was talked about in the That was talked about in Tom's talk. So, this is coming, this notion of degree n comes straight from polynomials. So, let's just think about polynomial functions for a moment. So, a degree one polynomial function is going to have this form, a constant times x plus another constant b. And we can define something called its first cross effect, which is just the difference. Effect, which is just the difference between f of x and f of 0. And so it's just this ax term here in the case of this polynomial. For this simple polynomial, this first cross effect is a linear function. And if I do something like this, I compare the value of this first cross effect on a Value of this first cross effect on a sum with the sum of the first cross effects of x and y, because this function is linear, the second cross effect term, this difference, is zero. And you can play this game with higher order polynomials. If you have a degree two polynomial, you can compute its second cross effect. It's not going to be trivial or zero. It's not going to be trivial or zero in this case, but it is going to be linear in both variables. And if you try to define a degree three cross effect by looking at the second cross effect and looking at its failure to be linear or looking at whether or not it's linear in one of its variables, you'll find that this third cross effect, defined by this difference here, is zero in the case of this degree two polynomial. This degree to polynomial. And so, in fact, you can define these cross effects that are detecting the degree of a polynomial. So, a functor or function rather is degree n. Polynomial function is degree n if and only if its n plus first cross effect is zero. So, the definition of polynomial functor that Eilenberg and MacLean came up with comes straight from this notion of cross effect. Okay, of course. Of cross-effect. Okay, of course, now we're talking about categories and objects in abelian categories. I can't subtract to define my cross-effects, but I kind of do the next best thing in an abelian category. So in such a context, if I plug an object X into a functor f, the value of that functor at the zero object splits off as a direct. Splits off as a direct sum and the remaining piece is what I will call the first cross effect. So think of this as simply the difference between f of x and f of 0. Likewise, I can take the first cross effect and try to understand the extent to which it fails to be additive by plugging in a sum of two objects and comparing it with the sum of the object. And comparing it with the sum of the cross effects evaluated on each object individually. If my functor is additive, this is an isomorphism. So the thing on the left is equivalent to the cross effect at f x1 plus the cross effect at x2. If my functor is not, or if this first cross effect is not additive, then there's something else here. And that's what we call the second cross effect. The second cross effect. So, in general, I'm going to define the nth cross effect as in terms of measuring the failure of the n minus first cross effect to be additive in one of its variables. Okay, so with this notion of cross effect and this notion, one can define A degree n functor in exactly the same way we did for degree n functions. So a functor is going to be degree n if and only if its n plus first cross effect is equivalent to zero. Okay, and so I thought I'd throw in one really simple example here. So let's fix an abelian category, let's fix an object A in Let's fix an object A in that category. Let's define the functor f to take an object x to the sum of a direct sum of a with x. So f of x is equal to a plus x on the one hand. On the other hand, f of x is isomorphic to this sum consisting of f of zero and the first cross effect of f. And of course, f of zero in this case is just a. Case is just A. And so we can see from this that the first cross-effect functor for this particular example is the identity functor. And taking this up a degree, we can look at the first cross effect as a direct sum that's going to be isomorphic to x plus y, or the sum of the first cross effects, which means First cross effects, which means the second cross effect is zero, and so this functor, as one would expect, is a degree one functor in this context. Okay, so with this framework, knowing that these degree one approximations existed classically, and there's a notion of a higher order degree. Of higher-order degree n approximations, we showed that one could actually construct a Taylor tower like the Taylor Tower in the setting of spaces and spectra. So having similar properties. Okay, so the big differences here now are that our functor is a functor between abelian categories. Our notion, our nth term is degree n in this sense that I just described, not Described, not an excisive. If you put some conditions on F and your inputs, there's a sense in which this tower converges to F. And again, you have this universal property where PNF is universal among degree n functors with natural transformations from F. So this is a very quick introduction to abelian. You know, very quick introduction to abelian functor calculus. And, you know, as we've seen in lots of the talks this week, once you kind of get this calculus analogy going, there's all sorts of questions you can ask. For example, what's the correct notion of, say, a directional derivative in this context? So that's what I want to talk about next. So to Next. So, to define a directional derivative, I'm going to use a process of linearization, which a functor is going to be linear if it's degree one and reduced. That is, its value at zero is zero. And we can linearize a functor using the tools I've introduced. So, if you take the first So, if you take the first cross effect of the functor, that's the reduced version of that functor. And then you take the degree one approximation for that. That gives you a linear functor. You can also realize this in the kind of way that Tom was describing by taking a homotopy fiber of the natural transformation from P1F to P0F. So, think of this homotopy fiber. Fiber, if you're not a homotopy theorist, think of this as just the homotopically correct way of constructing the difference between P1F and P0F. And again, this very basic example, if I want to construct its linearization, since it's already degree one, I'm just taking the reduced portion of it. Taking the reduced portion of it, that is the identity functor. Okay, so directional derivatives, we're going to define by analogy. Okay, so just a reminder, if you have a function between Euclidean spaces and you pick a point and a direction in the domain, you can define the directional derivative of f. Derivative of f at the point x in the direction v as the limit of this difference quotient. So our definition just mimics this. So for a functor between abelian categories and for objects in the domain category, we're going to define the directional derivative. Directional derivative. I've got two definitions here. This is the official definition, but this is really how I want us to think about it in analogy with the calculus definition. We're going to compute the difference between f of x plus v and f of x. That's the kernel here. And then we're going to linearize that in the second variable. The second variable v. And so the analogy is you're supposed to be thinking about the kernel here as this difference and the d1v here as linearizing with respect to v, which is somehow, you know, what you do when you take a derivative, you're taking this limit as t goes to zero of one over t times this quotient. And with this directional derivative, This directional derivative, we set up a chain rule. Okay, so we showed that if you have a composable pair of functors f and g, then the directional derivative of the composition is equivalent to the directional derivative of f evaluated at the directional derivative of g and the original functor g. And I've given two teams. Two teams credit for this here, in part because Bjort really strengthened the result. I have here is really the Bjort version in the sense that I've removed conditions that were present in the Johnson or the 2004 version. Okay, and I guess if you remember back to Monday, which seems to be a while ago now, there are been a lot of talks. Now, there are been a lot of talks since then, but just a reminder: this should look familiar. In particular, if you look at the axioms for Cartesian differential category, axiom number what, five is the chain rule, and it really looks exactly like our chain rule here. So, this suggests very strongly. This suggests very strongly that somehow what we're really doing is working in a Cartesian differential category. And this directional derivative is the differential combinator or operator for that Cartesian differential category. But of course, there's always a catch, right? So the goal now is: can we prove that this directional derivative endows a category whose objects are abelian categories and more? Objects are abelian categories and morphisms are functors between abelian categories with the structure of a Cartesian or Cartesian differential category. Okay. And we've got our operator or our differential combinator. The big question is, what's the category? Okay, and this is where I have to start being a little more careful and explaining how we're really doing things. Really doing things. Okay, so let me revisit the context. So, one of the things I've swept under the rug so far is the fact that I'm really working with chain complexes over an abelian category. Okay, so really my functors aren't functors from B to A, they're functors from B to an abelian category that happens to be the category of chain complexes. Category of chain complexes over an abelian category A. Okay, so a chain complex in this context is just a sequence of objects in the category with morphisms between consecutive terms such that composition of consecutive morphisms is always zero. So, you know, that's one issue. Second issue is if you If you were paying really close attention to my chain rule, you'll notice I didn't put an equal sign in there or even an isomorphism symbol in there. I put this little squiggle, the sim E in tech. And that's because we're really only working up to chain homotopy equivalence. Okay, so from our point of view, I'm too far. Point of view, two functors are the same. If whenever you plug in an object X and you get chain complexes, these chain complexes may not be isomorphic, but they're going to be chain homotopy equivalent, which is the next best thing to being isomorphic in the world of chain complexes. So the fact that we're really working with chain complexes and we're really just working up to chain. And we're really just working up to chain homotopy equivalence means we've got some problems. So, one problem is if you think about the chain rule, it's not even clear now how you compose functors. So, I have a functor from a category B to a category of chains on A. I want to apply that to the output of a functor G, but its output is a chain complex in B. Complex in B. You might, if you've never seen this before and don't work with this stuff, think, well, maybe just apply F degree-wise to your chain complex. That'll give you a sequence of objects in B. But the issue here is that applying F is not going to not preserve, applying F degree-wise to a chain complex is not going to preserve a chain complex unless I put some conditions on F. I put some conditions on f. The issue is there's nothing to guarantee that f is going to preserve zero. So, this I have this condition that my differentials have to compose to zero, and I don't know if eth is going to preserve that. Okay, so that option is not good for us. And as I mentioned earlier, our chain rule only holds up to Our chain rule only holds up to chain homotopy equivalents. Okay, so to fix these problems, we really need help from the category theorists. So the way we're going to create a good category here is to start with the category I kind of led you to believe we were working in, the category where the object. In the category where the objects are abelian categories, and the morphisms are functors between those abelian categories. But then we're going to look at a Kleisley category associated to that. So we're going to talk about a monad, CHA, defined on objects in this abelian category by simply taking an abelian category, A, to the category of chain complexes. Category of chain complexes in A. And for morphisms in ABCAT, CHA has to do something a little bit more complicated because it's going to have to take a functor from B to A and turn it into a functor from chain complexes in B to chain complexes in A. Okay, and so we can do this by taking advantage of an By taking advantage of an equivalence of categories known as the Dold-Kahn equivalence, between, this establishes an equivalence between the category of chain complexes on an abelian category and the category of simplicial objects in an abelian category. So again, I'm not quite sure who's listening at this point, but if you haven't seen simplicial objects at this before, these are simply functors. simply functors from a category delta op into the category B. So delta is the simplex category. Its objects are finite sets. Its morphisms are order-preserving maps. Okay, and so because of this equivalence, we can take our chain complex in B, turn it into a simplicial object. Since this simplicial object is simply a functor from delta op into B, we can compare. op into B, we can post-compose with F and turn that into a simplicial object in A, and then apply this equivalence again to get ourselves a chain complex. So this preserves chain complexes, this preserves chain homotopy equivalences, it's a very nice construction. There are a couple of other things we need for a monad. The unit The unit, so this should be a functor now from A to chains on A. This is going to take an object A in the category A and turn it into a chain complex that's concentrated in degree zero. So we'll have the object A in degree zero, zeros elsewhere. And finally, the multiplication for this monad comes. For this monad, comes from a standard construction in homological algebra. If you have a chain complex of chain complexes, or in other words, a bicomplex, you can turn that into a chain complex by a process called totalization or tot. Okay, so with these, we can form the Kleisley category. The Kleisley category, which we call ab catch. And so, you know, if you just track through the Kleisley category definition, you'll see that this gives us a category whose objects are abelian categories, whose morphisms are now the things that I was really secretly talking about, functors from abelian categories to chain complexes on an abelian category. The identity morphism in this. The identity morphism in this category is this degree zero functor. And the composition is coming, is the Kleisley composition coming from the monad. So to compose these functors, which before didn't seem to be composable, I can now start with a category C, apply the functor G to get a chain complex in B, apply CHAF. Apply CHA F to now get a chain complex in the codomain of F, which is now a chain complex of chain complexes, and then apply the multiplication to get a chain complex. Okay, and so we can now say something more concretely about Cartesian differential categories. Okay, so So what we can do with this new category and this old operator, differential operator here is prove the axioms for Cartesian differential categories, but there's still one more catch. As I've mentioned before, I cannot prove this chain rule up to anything stronger than a chain homotopy equivalence, and that carries over into a couple of these. Carries over into a couple of these other axioms as well. But I'm a homotopy theorist, so I'm perfectly fine with just replacing ab catch with this unwieldy name, HoABCACH. This is just the homotopy category for abcatch in which we formally inverted the chain homotopy equivalences. Okay, and so. Okay, and so on this category, this directional derivative is in fact defining for us a Cartesian differential category. Okay, so I think I still have some time, so I can talk about where we go from here. Okay, so this is very nice, and I have to say it was really satisfying at the time when we figured this out, but But this story really started with a different goal in mind. And I think one of the really, really nice things about this whole project was how what we originally wanted to try to do really ended up fitting extremely well into this framework we developed. Okay, so one of the things we were interested in doing was Was proving a higher order chain rule for this directional derivative that mimicked a chain rule that's different than the one that Robin talked about on Monday. So in a paper that was published in the Mathematical Intelligencer, three, I think they're analysts, this is really going far afield for me. So Huang, Marcantonini, and Yuan. Huang, Marcontonini, and Young defined notions of higher-order directional derivatives for functors of vector spaces or Banach spaces and derived a chain rule for these higher order directional derivatives that looked like this. Okay, so right now it's a bunch of symbols, but if your functions are in fact functions of a single variable, this boils down to a chain rule for ordinary functions. A chain rule for ordinary derivatives that serves as an alternative formulation of the Fado-Bruno chain rule. And essentially, what it says is, you know, the nth derivative of the composition of f with g is equal to this nth directional derivative of f evaluated at all the derivatives of g. And so somehow this higher order directional derivative is just kind of Derivative is just kind of encoding all the combinatorics of the Fadabruno formula. And what's enticing from our point of view is that in degree one, again, this chain rule looks exactly like the chain rules I've been talking about so far. So there's got to be a connection. Okay, so proceeding. So yeah, question: Can we do this for abelian functor calculus? The answer is. The answer is yes, and our way of proceeding is by analogy. Okay, so to define higher-order directional derivatives, we're going to follow the recipe set up by the analysts. So that calls for the zeroth directional derivative simply being the functor you started with, the first directional derivative being the directional derivative we've defined. We've defined, and then you start defining higher-order directional derivatives. And if you think about the, you kind of want to define this as the directional derivative of the directional derivative. The directional derivative takes a functor of one variable and returns to you a functor of two variables. So you might expect the second-order directional derivative to Directional derivative to return for you what a functor of two variables times two, four variables. But to make this chain rule work nicely, there's this kind of weird overlap going on here that Wong, Marcantonini, and Young don't really justify. I think it's still a little bit mysterious, but there's essentially this overlap. Essentially, this overlap: what was the direction for the last iteration becomes kind of the point for the next iteration, and then you introduce a new direction. So in general, this nth order directional derivative is going to be defined by a similar process. We're going to apply our directional derivative to the n minus first directional derivative. First directional derivative, but we're going to kind of overlap the inputs in this way. So this is going to be a functor of n plus one variables kind of thought of as two pairs of n minus one variables that overlap in the middle. And we were able to prove our chain rule completely in terms of formula. In terms of formula, it looks exactly the same as the formula in the Intelligenser paper. But I want to say a little bit about the proof because this is where tangent categories and the Cartesian differential structure come into play very nicely. So, to remind you, Robin and Jeff defined Cartesian differential categories. Cartesian differential categories or showed that Cartesian differential categories are examples of tangent categories. Tangent categories come equipped with an endo functor that encodes the essential properties of tangent bundles. And in the case of our Cartesian differential category, this endofunctor is Is given by the following. It's going to take an object A. I got my domain and codomain mixed up here. So I really should, to be consistent, this should be the category B. So it's going to take the input category and simply form the product of that category with itself. And it's going to take an input morphism and return a pair of morphisms. A pair of morphisms, those morphisms are going to be my directional derivative and my original functor. And so we want to prove this chain rule. So this is our goal. And the proof really boils down to a single diagram. On the left here, On the left here, I've buried a lot of combinatorics. So this dn functor from Cn plus 1 to the 2 to the n fold product of C with itself is really encoding this funny overlapping that's going on with inputs as I iterate derivatives. On the other On the other hand, here, on this end, this is simply a projection onto the first factor in the output of this process. In between here is where this equivalence comes from. So the fact that T is a functor means it's going to preserve composition of functors. That's the chain rule, basically. And if I iterate. And if I iterate t, that's still going to hold. And so if I take Tn, apply it to the composition of F with G, that's equivalent to taking TnF and composing it with Tng. Okay. And so then if you kind of roll up your sleeves and work your way through the combinatorics, if you go along the top of this diagram, so applying So, applying this functor to the output from this functor and then projecting, the result is one side of the equivalence, the nth directional derivative of the composition. And if you follow the lower path, so apply the composition of TNF and TN with TNG to the output of DN star and then project. d n star and then project onto the leftmost factor, what you're getting is precisely the right side of this equivalence. And so that's where the proof of this chain rule comes from. And I think I'm out of slides other than a bibliography, so I'll say I'm out of time as well. Thank you very much. All right, let's all unmute ourselves and thank the speaker, Brent Atchinson. That Johnson. So there was a quick question in the chat that has been resolved. But I see that JS is raising his hand. So since he was the one who asked the question originally, I'm going to let him unmute himself and ask his question. Yes, but this is a question. Am I still allowed to ask it? Still allowed to ask it? Yeah, you are. Great. So when you have a Kleisley category and you take, you start with your bump the map from the Kleisley category. Oh. Via the unit, right? You can take that from A to B and then go. Can take that from A to B and then go A to B to B to C to ch of B. Wait, so you're breaking. I'm wondering, you're jumping a bit. Come back to me. All right, I'll come back to JS. I saw that Joff had a question, but he unraised his hand in the middle. I see a few other hands raised. Few other hands raised. So, if Robin, you want to ask your question? Sure. I mean, mine is the obvious question: is how is your higher derivative related to the Fader Bruno higher derivative? So we have some explicit formulas relating, well, relating another notion of higher order directional derivative to. Higher order directional derivative to our notion of higher order directional derivative in which Fadabruno formulas come up. So, so somehow, so the idea here is for another way of defining a higher order directional derivative is to simply differentiate in the in the point variable, the nonlinear variable. And then there's a chain rule that relates those higher. A chain rule that relates those higher, or there's a formula, we have a formula that relates those higher order directional derivatives to these, and it has kind of Fadabruno qualities. So that's one way of answering that, but maybe not a direct way of answering it. Yeah, but I mean, presumably the Fadabruno formula works in your setting. Well, it must work, right? Right. But also, you could do the Fab de Bruno construction as well. So, do you know what? So, do you know what that produces? So, do the FAD Bruno construction in what sense? On your Ho AbCAP setting, right? Right. So, in your sense, right? Yeah, and that's kind of work in progress with Christine and Sarah. Okay. All right. The next question will be Martin. Question will be Martin Franklin. Hi, Brenda. Thank you for the great talk. Can you hear me fine? Yes, I can. Great. You mentioned one of the Bjork results that you have this structure of Cartesian differential category up to chain homotopy in ABCC, in this ABCACH. And then as a corollary, you get a Cartesian differential category structure on the homotopy category of ABCC. Homotopy category of ad catch, right? And that slide is so tantalizing, right? It wants to tell us: well, it's got to be coming from some more coherent homotopical structure. So I'm wondering, is there already a well-established notion of Cartesian differential infinity category, which roughly says that you have all the structure of a Cartesian differential category up to coherent up to coherent equations. And on the wish list, the homotopy categories. Wish list, the homotopy categories should have a canonical Cartesian differential category structure. Is that already somewhere in the paper? Um, I think, I think you should attend Christine's talk. Ah, I see. So it should be part of that framework. Yeah, have you talked, have you kind of identified Cartesian differential infinity categories or just tangent infinity categories? Categories. Sorry, were you asking me? Yeah, or you or Michael or Matthew if he's here. Yeah, I will talk about that in my talk this afternoon. So, from a tangent category, you can produce a Cartesian differential category. And I'll talk about the infinity version of that, which I think is going to answer the question that you're asking, Martin. But it'll take me some time. So, I won't try to do it now. Awesome. Looking forward to it. Thanks. All right. So, I have two more questions. All right, so I have two more questions. I have Jaya's question who wrote in the chat. Basically, if you take a map from A to B, you can bump it up to a Kleisli map by applying the unit of B. So it makes a map from A to B to chain B. And the question is, are these maps linear in the Cartesian differential category sense or functor calculus sense? And if not, what is the derivative of A to B to chain B? Of A to B to chain B? So I think the answer is going to depend on what that map from A to B is. So that, you know, that degree zero map is linear in the sense of this setup. But I mean, A to B could be anything. So if it's like if it's not linear, I don't. I don't know. Does that answer your question, or is that am I answering the right question? Can you hear me? Yes. Yes. Okay, cool. So I fully expected it not to be linear. I'm just curious if you know, like, if there's, if you may see like a general formula of what the derivative of these things would look like. I guess my first step. My first stab at this would be to try to hit it with the chain rule, right? But it's not composition in the Keisley category. It's the problem. Yeah. Yeah, I don't know if I, I mean, I think I'd wanna have to I would have to think about that. I mean, the the thinking thinking Kleisley versus non-Kleisley is still not something that comes very naturally to me. Something that comes very naturally to me. Sure. The reason I ask is because, so in my talk, I said that one of the main constructions of a CDC was the co-Kleisley category of something. And here you're building a Cartesian differential category as the Kleisley, which so which is not automatic. So if one day we want to figure out how to build Cartesian differential categories from class. Differential categories from Kleisley categories, I think answering that question of what is the derivative of A to B to chain of B is sort of key to that. So there's something mysterious going on, and I'm trying to understand it. But thanks for the talk, and thanks for the answer. Thank you. All right. And the last question from Ben McKellen. Yeah, thanks for the talk as well. Just As well. Just actually talking about the same slide Martin was asking about, but kind of even a bit earlier where you construct that Kleisley category. Like, is the Eilenberg-Moore category, like the algebras of that monad? Is that like interesting at all? Have you is it something you've looked at or is it something you intend to look at? It's not it's something I haven't looked at. So. It's something I haven't looked at. So perhaps we could talk later. Yeah. So it turns out that Jeffrey Crotwell has a question or raised hand. And as he is one of the organizers, I'm definitely not going to cut his words. You can cut me off if you want. I was just curious. So, had you proved the higher order chain rules before you sort of took the tangent category perspective? Took the tangent category perspective. I think I've talked timely about this, but I can't remember what the answer was. I've tried to block that out. It was very combinatorial. So, I think it was a combination of the other axioms, which are much easier to prove in this context. And you can reformulate this directional derivative in terms of linearization of cross-effects. Of linearization of cross effects. And then you can start working with the combinatorics of the cross effects as well. So I guess it was a lot easier to do it with that perspective then, I guess. So it depends on your definition of easier. So I think the first method was really brute force. Really brute force, and I think difficult for that reason because there was a lot to keep track of. And so the tangent category's perspective really makes it much nicer. That being said, you know, and as looking over the proof in preparation for this talk, even with the tangent category perspective, there's still an awful lot of combinatorics to sort out in that first arrow. It out in that first arrow and in tracking through the composition of those arrows. Cool, thanks. I was curious. Yep. All right. Please join me in thanking Brenda Johnson once again for this great talk. And we've got five.