I will be talking about differentiable quantum computational chemistry and how to do this using PennyLink. So a little about me. So I work as a quantum scientist at algorithms team in Zanadur and my background is traditionally in computer science along with computational natural sciences. So my interest in my research areas are naturally to develop quantum algorithms for applications related to Applications related to quantum chemistry, biology, and physics. So, I will begin the talk with our mission statement at CRA2, which is to build quantum computers that are useful and available to people everywhere. And in the last seven years, we have been able to have built seven quantum processors, which includes one of the latest one that we had, which was called Corealis, and using which we had seven competitions. Which we had several computational advantages. And we also have developed five software products along with close to 100 research publications. And one of the main software products that we work on is Pennylin, which is an open source Python library for differentiable programming. And our main idea is to have a completely modular workflow and make it as user-friendly and intuitive as possible along with As possible, and along with Piki Candle, it has an educational toolbox for everyone: users, researchers, students, everyone. So, in order to meet that target of us, the first step is to keep the library framework and hardware agnostic. So, stuff that you can do using PennyName. You can directly uh do those, like use our library to do stuff. Our library to do stuff on hardware of different kinds. We provide all the back-end support that will translate all the circuits and everything for you. So you can work on neural lactams, grab lions, superconducting qubits, even our own hardware integrated photonics. You can work with different quantum simulators. And we also support all the popular classical machine learning libraries for building kind of a hybrid workflow so that you can. So, that you can do an end-to-end trainable programming in some sense. So, when, so let me come to the hybrid workflow part. So, our idea is to allow users to build these end-to-end hybrid models, which would have both classical and quantum computational blocks connected to each other. And then you can simply extract gradients, do whatever computation you want, and those. Want and those could be like different libraries connected to each other. So the main idea is to give users as much as features as possible while maintaining this modularity. So when it comes to the quantum computation part in itself, when I say a quantum like a quantum block, so we realize this quantum block as something known as Q node, which would have a device that would Would have a device that the quantum computation would get executed on, and also as a function which I can programmatically define as a like a Python function. In some sense, it has like a definition. It will have all your gate operations that you would want to have and final output that you would want to realize. This could be an expectation value, this could be a state vector, a density matrix, a sample, whatever you want. Whatever you want. And then, so the main idea is: this Q node would have an classical input and it would give your classical output depending upon what kind of output you expect to get it from. And then it would have some parameters, and you can calculate deliverance with respect to these parameters. And then you can kind of define based on output a cost function, and then you can do this iterative manner of variational computing. Minor of various competition. So, apart from supporting different other frameworks, we also have our in-house devices. Basically, the default devices, which allows you to do state vector and mixed-state qubit simulation. And along with that, we also have these Latin family, which, by the name, as the name suggests, these are the faster implementation of the previous devices, mainly based. Mainly based on C. The devices above are mainly built in Python. So, our strategy when it comes to quantum algorithms has been to improve quantum algorithms for quantum chemistry. But right now, our team is mainly focusing on battery applications. So, that's kind of an area that we have decided might be the best suited for gaining an advantage. So, from the insights that we have from the field. The insights that we have from the field that current algorithms are expensive and the hardware very much limited in their abilities to do stuff. So, our goal has been to keep on improving the algorithms while the hardware will take its sweet time to improve and maybe along the way we will find a very sweet little spot where we will eventually reach a quantum advantage. And if unfortunately not, then we will be happy that we made some trends. Then we will be happy that we made some trends along the way. So, for improving and focusing on the target that we have to improve quantum algorithms, we have been trying to ensure that Pennylin works with quantum algorithms for quantum chemistry from all three regimes that have been proposed for quantum computation, namely NISC, which involves these VQE kinds. Which involves these VQE kind algorithms in which you optimize this Virishna circuit and try to prepare a post-Harti-Fog function out of it. And a new regime between the NISC and the fault tolerant, which is known as the ISC regime, in which there are these algorithms based on LINTOM kind of algorithms in which you kind of try to reconstruct the CDF functions for eigenvalue distribution from like a sampling from your A sampling from your time volition operator. And then finally, the fault-oriented regime in which there are QPE-based family algorithms in which you try to estimate the time evolution of a unitary operator. So our aim is to build Pennillion in such a way that it provides all the fundamental building blocks to support all these algorithms, and those fundamental building blocks should be kind of state of the art. And then you can use. The art. And then you can use all these fundamental building laws to compute properties of molecules, materials, and simulate their dynamics. So now I will be shifting my focus more towards how Pennylion provides these blocks to help you do this computation. So our main idea when we try to build stuff is to not give users black boxes. We always try to give We always try to give them the essential ingredients that they require to do stuff and then they can play around in whatever way possible. So we give them that freedom. So it's like cooking. So we give you the ingredients, but we won't give you the exact recipe that you have to cook. That is, you are free to do anything. So whatever I would be telling, most of it is already available as demos and tutorials on a website. Do this on our website, and if someone has already taken a look at our demos, then they can attest to the standard we try to maintain when it comes to our tutorials. So the first initial starting point would be to build a molecule itself. So we have like either you can, so in order to build a molecule, you have to specify its constituents, that would be the atoms, the coordinates for the The coordinates for the atoms and the basis set. And now, if you can either give them directly as you see here, or if you are lazy like me, then you can load them from an external file, standard XYZ file. Or even easier for you, you can just download it from database if the module exists there. And then you can we provide like natively provide support for Like natively provides support for different basis sets like STO3G, S631G and CCPVDZ. But if you would wanna do something more, like you want some other basis set apart from this, then we provide you the functionality to download it directly from the PSCE website with just one simple keyword argument, which is this load bit equal to true. So you can just directly use that. And for example, we don't For example, we don't natively support 631G star star, but now if you use load data equal to true, you can simply download and build a molecule based on that particular basis. Second key ingredient would be fermionic operators. So recently we added support to implement um fermionic operators directly in Peneland. Initially we didn't have such a bit of a straightforward approach to do do so. Approach to do so. But QML.fermi module that has been recently added allows you to do so using these two methods: qml.fermi C and QML.fermi A, which is creation and analyzation operators. So the goal always remains to make such operators should be as intuitive as writing them down on the paper. So if we consider the example of the Hubble Hamiltonian, which looks something like this, you can choose alpha. you can choose alpha as 0.0 and beta as minus 0.02 then you can directly define your Hamiltonian just for VC0 for me A1 and for VC1 for me A1 and similarly for H2 and then you can combine them and you can directly call a Jordan mingler mapping on this that would convert your Hamiltonian from the fermionic basis to the qubit basis and a lot apart from Jordan And apart from Jordan Migner, we also provide mapping for Ravikita. Now, the next immediate step would be to build a molecular Hamiltonian now that we have a molecule object and support for harmonic operators. So, in Penniline, something that we provide is this differentiable qubit Hamiltonians, which would allow you to calculate gradients with respect to the Respect to the parameters your Hamiltonian depends upon. This could be your geometry, this could be your exponents for your basis set, this could be the contraction coefficients, the center of the Causions that you would be using. And if you don't actually care about these differentiable Hamiltonians, you can alternatively use a Pi SCM mackerel to create a single Hamiltonian. It's just that you won't be able to calculate the gradient. Calculate the gradients anymore. And while doing so, you can also provide an active space, three score orbitals and stuff like that. And all of that is possible. Now, along with the Hamiltonians, you can also gain access to auxiliary observables like dipole moments, particle number, total spin and spin projection in Z direction. So we have observables for all these different kinds of Kind of for these different kinds of quantities. So you can directly use them and then use them in your computational workflow, just like how you use a molecular Hamiltonian. Now, now that we have all the ingredients for the building stuff, now we come to the NZAX part of the stuff. So the first thing that comes there would be the gates that you would use to build a circuit or your NZAX. So we have Your antagonists. So, we have like specific quantum chemistry gates that you can use for building such anths for your quantum chemistry workflows. So, one of those two of those gates are these gates based on given rotation, which arose from the like our in-house research. So, these gates basically allow you to implement single excitation and double excitations. And along with those gates, we also provide support for some. We also provide support for some other special goods like orbital rotation, which allows you to do a spatial orbital rotation and for Meonic swap, which you can actually use for implementing a tracker set. And using these kind of gits, we also provide standard templates in Pennylan, so that you can directly use with some default parameters. So these would be some particle conserving templates. Templates. Kate fabric template which was developed by Covestrogroup, which allows you to have a particle number conserving NZATS, which also conserves, I think, spin and is more expressible than the standard templates. And another one is basis rotation, which allows you to implement the single party operation, single-party evolutions. And then we also provide support for UCC family. Family and that. And finally, something, a template that we all like is this all singles and doubles, which is very much intuitive in the sense that they generally require these given skates and is kind of mapped, can be mapped to the CCST formulas. So another idea is to idea is to not just be limited to fixed templates so we also have support for adaptive circuits so we provide an optimizer for this purpose which is known as the adaptive optimizer so that adaptive optimizer would give you a new circuit and it would build that circuit based on the operator pool you'll be finding so if you look at this animation so this is kind of trying to build a Build all singles and double kind of template, but adaptively. So, the way it is done is like you build an operator pool. In this case, we are defining the operator pool using the signals and double excitations. And then, with each, we start with an initial state, which is the hardy fork state. And then, with each iteration of the optimizer, it will check which. Optimizer, it will check which implement, like adding which gate to the circuit would result in the biggest gradient change. So that would be the gate that would be chosen, and that is done iteratively, and circuits are added, like gates are added in an iterative fashion. Another thing is that now that we have built, we have the gradients to build the molecule Molecules, Hamiltonians, and the circuit stensors is the initial state. So many algorithms like QPE and Lind and Tom, a major locking for them is this, like the major requirement for them to perform successfully is to have a good initial state. So initially we used to support a hardware for state in Peninsula, but now we have improved upon that support and allow you to. Allow you to obtain post-RTFOC initial states from PySCF and block2 and then import them using this qml.qn.import state method directly into Tanglen. So we will initialize your state using the like qml.state prep method with that particular initial state. Now applications. So till now what we have done is to we have the ability to compute molecular We have the ability to compute molecular Hamiltonians, to define circuits, and to have initial states. Now, these three things will allow you to perform calculations like ground state energy calculation, excited state energy calculation, PES and reaction rates. But to do something more complex like calculation of response properties, dynamics, you need to require some additional tools. So, one of the tools that you would require would be these. Required would be these energy derivatives. And for that, we provide a differentiable Hartree-Fock implementation. So, based on that implementation, you can compute exact derivatives of energy based on the properties that you give us. So, for example, if you consider nuclear coordinates as your parameter that you want to work upon, so your habit domain will then depend upon the coordinates, and then you can calculate. Coordinates and then you can calculate the forces acting on the nuclei with del V by del R, which can then be used for geometric optimization for the molecule. And the way we support this is in the sense that we allow you to perform a joint optimization over both variational parameters and these system parameters. So you don't have to write a double loop, like double for loop or something like that. So all the optimized in a single for loop. So when it comes to differentiable heart tree fork, so you can directly calculate gradients with respect to the for the hardy fork energy with respect to different parameters that you want. For example, here I show an example for nuclear coordinates. So you can use QML.grad which is which allows you to calculate degradance with respect to the uh live uh with respect to autograd library. Autograd library, and when you specify geometry as your parameter, it will give you the required gradients. And you can then actually do more complex stuff. So, if you need gradients with respect to alpha, which would be your exponents or your contraction coefficients, that also you can do in length all together at once. So, using this functionality, you can This functionality, you can perform a fully differentiable workflow in Pennylin. So, here is an example of simultaneous optimization over different parameters. So, these are nuclear coordinates, basis set exponents, and contraction coefficients for H3 plus molecule. And you would see that the way you define your for your you define your molecule with the alphas and coefficients that you want, and then you provide. you want and then you provide the you then make a degree denser respect to each of the each one of the parameters that you want and then you can directly change or update the each parameter within the same follow and that would basically allow you to perform an optimization like this in like very efficient way Efficient here. Another thing that we, another key feature that we provide is of qubit tapering. So, Pendilion offers like a complete tapering workflow. So, this would allow you to, so first before that, what tapering actually is. So, basically tapering is to transform your Hamiltonian based on the G2 symmetries it has. And this allows you to basically reduce the number of qubits you would require to implement that Hamiltonian. In Pennylion, we In Penelian, we allow you to taper not just the Hamiltonian itself, but also the HydroFox state that you would be working with, and also all the operators in your NCAS that you would be working on based on the symmetry generators from the Hamiltonian. So in some sense, if you have a UCC template and you want to do it in a tapered workflow sense, so then you can taper each individual operator as you go along. As you go along, and everything should work as a normal workflow is supposed to do. A final feature that I would like to discuss would be of that of resource estimation. So Pennylion also now offers functionality to calculate resources required to simulate molecular systems, which is in the human.resource module. So for variational algorithms, the main thing is number of shots. The main thing is the number of shots that you would require to calculate the expectation values. So, for that, we have we allow you to calculate the number of shots and the and the amount of accuracy that you would require. So, either you can provide the accuracy that you require and we will give you the number of shots that you would require to get that accuracy or the other number. For uh the QP algorithms, we provide the support for We provide the support for calculating the number of non-clifford gates and logical qubits. So, right now we support two variants of the algorithm: first in the first quantization with bin wave basis, and second is the second quantization with this double factored formula format as well. And we also have some more exciting features that I would not discuss in this talk, but I would like to still mention them. One is circuit button. Like to still mention them. One is circuit cutting, QSVD, and QSP. We also have support for differentiable pulse programming. And something that Olivia mentioned, we have another new feature coming up, which is already there, but we are in the process of implementing Manilian, which is Catalyst, which allows you to do a just-in-time compilation of hybrid workflows. And finally, we have something known as quantum data sets that would be introducing. Would be introducing in a few moments. And there are many more other things that you can check out on the Pennyline documentation. And to keep connected, you should give us a style on the GitHub, put up your problems on our discussion forum, tweet about us, connect with us on LinkedIn, and finally you can follow our newsletters to get monthly updates. Thank you. 