cover some area some references basic uh considering uh and then physicist Deutsch first developed a quantum algorithm to solve a problem that is exponentially faster than any possible classical algorithm but on the other hand the problem itself is basically useless in practice a major milestone A major milestone came when mathematician Peter Schur came up with a quantum algorithm to factorize a large integer into the product of prime factors, which is the foundation for most public key-based tomography. So in classical computation, information is stored in the bit of strings of 0 and 1. And then to process information, we apply the logical case. For example, here this is a logical case. Here this is a logical end gate. It takes two input bits, A and B, and outputs a bit, Q. And Q is 1 even only if both A and B are both 1. In the middle, this is the logical OR gate. The output Q is 1 even only if at least 1 of A and B is 1. The last one is the NOT gate. It simply negates, flip the bit. Now, in quantum computing, information is stored in quantum computing. Information is stored in quantum bit or qubit, which mathematically is simply a two-dimensional Hubbert space C2 with the orthonormal basis given by this cat0 and cat1. The multiple qubits simply correspond to the tensor product of n copies of C2. By definition, a quantum state is a unit vector in the multiple qubit space that's defined, well defined after scalar multiplication. Here are some Multiplication. Here are some examples of one states. For example, here, this is a zero state, one state. We can also take the tensor product of the basis states. As a notation, I'm just going to write them as a string of unit ones and put them inside a cat. This is the basis vector in the multiple qubit space. And you can think of these as a quantum analog of the classical bit string. But of course, we're in the vector space. We can take the linear combinations of basic states. The linear combinations of basic states. Here we say this state is at the superposition of the zero state and one state. Here, this is a two-qubit state. You can check directly that it cannot be written as the tensor product of two one-qubit states. And we say it is entangled. To process quantum states, we apply the so-called quantum gates, which are basically unitary transformations acting on the model. Unitary transformations acting on the multi-qubit space. For example, here, this is the so-called poly X gate. It acts on one qubit, basically flipping the two basis states. In the middle, we have the Harmar gate, and here, CNR gate is a two-qubit gate. It acts on two qubits. On the basis states, it maps I tensor J to I tensor I plus J mod 2. Similar to the classical logical circuit, we also represent quantum gates as. We also represent quantum gates as circuits. For example, for the poly X gate, if you read from left to right, then a line on the left corresponds to a qubit in the input. A line on the right corresponds to a qubit on the output. So that means the polyx gate, it has one input qubit and one output qubit. Similarly, for the hardmark gate, the CINAHL gate has two input qubits and two output qubits. Now, the last ingredient. Now, the last ingredient in quantum computing is the so-called measurement. It's a way of looking at the quantum states at the end of your calculation. For example, if I have a quantum state psi, which is a superposition of 0 and 1 state, then by measuring this state, it will clapse the state to either the 0 state with a probability given by alpha norm square or the 1 state with a probability given by beta norm square. So you can think of Beta naught square. So you can think of a measurement as a probability operation of quantum states that you have to apply at the end of your calculation because you need to see what you get. At the end, you get a superposition of states, but in the end, you still need to make a measurement to class it to one of the basic states. More generally, a measurement.