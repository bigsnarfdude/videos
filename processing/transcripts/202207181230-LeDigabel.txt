Thanks, Stéphane, and thanks Johan and Charles for the invitation to this nice workshop. So, solar. So, first I want to present the plot for the talk. So, I will first give the context of this work in the introduction. Then, I will go to the description of a simulator called Solar. Called Solar and describe then optimization problems that I call instances and describe after that the different features of this system of instances. So first the contributors of this work, we have very several persons working on it. So but the main one was is Mathieu, Mathieu Lomier Garneau, because this is in fact the work Because this is in fact the work of during his PL master's thesis in 2015. So it's an old work, but we took it back two years ago to make it the solar version we have today. The other contributors are the persons that were testing the simulator mostly. And for myself, I did not code the simulator, but the interface of it as a system of instances for black box benchmarking. And out of these names, three of them: so Mathieu, Miguel Diago, and Emen Guerriby, they are in fact experts in chemical engineering and mechanical engineering, so that they had the sufficient expertise to develop this simulator on a solar power plant. Okay, for the context, we are talking about black box optimization, so I will be quick on. Suggestion, so I will be quick on that. But just to describe the notations here, my objective function may be composed of one of two objectives. So it's why it's a capital F. I have a set of constraints, omega, and I have m constraints. So the space of variables capital X is of dimension N, and I can have up to two objectives. And so because we are in black box optimization, the function Box optimization: the functions, the objectives, and the constraints are given by a black box. So, this is my image of a black box in 2D. So, I have n inputs and eventually p plus m outputs. So, each call to the black box may be expensive. Sometimes the evaluation can fail due to hidden constraints. Sometimes it's not even a function. So, you give it the same x and you don't get the same output. The same outputs, and most importantly, you don't have access to any derivative information. Okay, so I'm going to benchmarking now. So, what are the current issues with black box optimization benchmarking? So, first, it's easy to understand that for benchmarking, we need several instances, many problems, which is problematic in black box optimization because of black boxes. So, testing on two applications. So, testing on two applications is difficult for many different reasons. First, the evaluations are expensive. The codes are confidential often. They depend on external libraries that are not easy to install or that are expensive. It may be difficult to install. If you have five libraries to install and each one is difficult to install, so you are going to be not willing to test it. Willing to test it, and sometimes also the original designers are no longer available because they are dead or not working anymore on this thing. This is the case for many Fortran applications, for example. So usually in the literature, this results in the fact that algorithm developers use sets of artificial functions, analytical problems that are considered as black boxes. Considered as black boxes for testing black box optimization methods. This is necessary. We need to have an access to large collections of problems, even analytical, because we want to tune the methods and to show the efficiency of the methods. But at some point, this is not sufficient. We need access to true and real applications because this is a true target of the work. We want black box methods for black box optimization problems. So real applications. So if you come. So, if you consider only benchmarking methodologies based only on artificial problems, you are going to end up with artificial hierarchies of solvers. So, you need a true application, at least one true application to code your software. So, this is the main motivation of the work. So, the objectives. So, it's to provide the realistic application for true in quote. For true, in quote, the black box obscenation benchmarking with these different features. The simulator must include numerical simulations, not only analytical functions. It must be easy to install, be standalone, and based on standard code. Otherwise, people are going to be discouraged and they will not use it. Must be multi-platform, so it must output the same results independent of the micro. Results independent of the machine, Mac, Linux, or Windows, for example. We want to have the ability to reproduce the results. So if someone gives a best solution to one instance, it must be the same on every platform. It must be also reproducible. And it's fun to have many options. So to test different aspects of a black box optimization. So for example, it should be easy to It should be easy to have an expensive application, something that is running for hours. It's fun to have access to a discrete or categorical variables. Real-world applications have constraints, so we want constraints. Noise in the outputs. Static surrogates. So static surrogates are surrogates that are available with the black box. And multi-objective optimization. Multi-objective optimization. So, some instances must have more than one objective. So, this can define a collection of set problems in order to draw some data profiles or performance profiles. So, for the simulator part. So, this is a CSP stands for concentrating solar power. We talk about a CSP tow plant with molten soil thermal energy storage. Molten salt thermal energy storage. So we consider a field of mirrors that we call heliostats. And these heliostats reflect the solar rays into a tower. And so it's going to be very hot up here. And then this heat is transferred to a molten salt and then to water that becomes steam to operate a generator, a steam generator for producing electricity. You have a nice picture here of the first one of this kind. Of the first one of this kind. This is a schematic of the central. So you can see the sun here, the sun, sunrise, the mirrors here, the heliostats. This is the tower, the receiver. And so this is the point where this is really hot. Here on the left is the molten salt cycle. So the molten salt is going to be very hot here. And this, the salt that is hot. This, the salt that is hot is going to be, it's it is going to be transferred to the to the water on the right and is going to operate the turbine here. So I have written all the steps here. So the thermo the power is exactly by raising the temperature at the top of the tower. It's transferred to the molten salt, which is going to end up in this storage here. After that, it's going to be directed to the steam generator. To the steam generator, it's transferred to the water on the right. And so we have hot steam here. Then it goes, the molten salt goes to the cold storage and it's going to be pumped again in top of the tower. And the steam drives the turbine here to produce electricity. And after that, the steam is transformed into water again. Water again and pumped again into this steam generator. So, in such a system, there are losses. So, in the simulator, these losses are simulated. And now, I'm going to describe a bit the field of mirrors, the heliostats fields. So, because this is one of the parts of the simulator that is the most expensive. So, the heliostat, they are laid on a grid that is generated. That is generated by depending on the geometry of the central. It's the height of the tower and the geometry of each heliostat. And once we determine we have this grid, we compute the most efficient places on this grid and we place a given number of heliostats on the grid. In fact, I have a picture here. So give us So, given a possibility of almost 2000 points, we want to locate 700 heliostats, and depending on the geometry of the heliostat and of the tower, we can end up with different solutions, configurations. So, there is a ranking that is made for each of these spots. And when we want to locate a certain number of heliostats, we locate this heliostat given on this. Given on these ranks after that, we have many different components in the simulator. So we have this sun radiation model, tamer storage model, the load model, parasitic loads model, pumping models, Shellen tubes model for the tubes in the steam generator, energy losses model, power block model, and also from some model. And also, from some model for the demand of electricity and for the cost of everything. So, all of these models, I have no idea of how it's working because it was already done in my master's student student. But he had the expertise for that. And I'm confident that is accurate. I hope so. In terms of a numerical method that are numerical method that are coded in inside the simulator. We have some Monte Carlo simulation for the field efficiency. Newton's method to find roots in certain thermal equations, some smoothing in order to interpolate discrete data, and some iterative method to solve the heat transfer fluid equations. For the code, the solar code, so the solar is the name of the code, of course. So it's a common Code, of course. So it's a command-like application. We already have this application called Steran. I don't know if you know it, but we proposed this simulator a long time ago. Solar is coded in the same spirit of Steran. That's the same interface. It's available on GitHub with a public list license. It's a very simple code of C of 13,000 lines of code, which is very simple for such a code. It's 10,000. Simple for such a code. It's standalone. You don't need to install any library to have it working on your computer. And it's multi-platform. So the only thing that you need is a C ⁇  compiler. So now I'm going to be more into black box benchmarking. So I'm leaving the field of CSP to the field of benchmarking black box optimization. So I need to define different instances for optimization. instances for optimization. So we define 10 instances based on this simulator. So each one of this instance defines what's the objective, what are the variables and what are the constraints. And you see the figures here. So first you can see the number of variables in this column. So the smallest one is five variables until 29 variables for the larger one. Larger one. For these variables, you can see that we have a continuous or discrete variable, and some of these discrete variables may be category. In fact, one of them can be categorical. The number of objectives is one or two. We have two instances that are B objective. Here are the constraints. So the larger instance in terms of constraints is 17 constraints. And we have a last one that has no constraints because That has no constraints because some solvers do not consider constraints. So it's going to be more efficient, not efficient, but more public, let's say, for the people to use this code if they can use their unconstrained solver on it. Just know that the unconstrained version is still under testing, so it's not released yet, but it will be soon. So this is a number of stock. So, this is a number of stochastic outputs in terms of objective or constraints. So, three instances are deterministic. There is no stochasticity. But for the other one, the number of outputs can be from one to six stochastic, meaning that for the same X, you can have a different output. If you have a non-categorical street variable, it's in the order. Okay. It's in fact an integer, okay, as a coding variable, but yet it's a type of turbine. So it's not alterable. Yeah, but you can consider it as an integer, but three is not two plus one. The discrete, oh yeah, this is an integer. The discrete, no, yeah. Discrete, no, yeah. I think we have binary variables, but I'm not sure anymore. The last column indicates if static surrogates are available. So, what is a static surrogate? It's a simplified physics surrogate. So, it's a simplification of the true black box, but less precise, but quicker to evaluate. I will go back to that later. These are the different objectives. These are the different objectives of the simulator. So, for the 10 instances, I don't want to read everything, but just to mention that the second one is analytic. So, if you want to test a method that is adapted to analytic objectives, the Solar2 instance is the one to test. For the types of variables, so every instance has n variables ranging from 5 to 29. 5 to 29, they can be continuous or discrete. So, and for these discrete variables, it's here one of them may be categorical, but none ordered. That's the type of job. Solar 6 and solar 10 instances have no discrete variables, so that the solver that does not consider that can be used. And also, we have some bounds on most of the variables. The following is a table of all the possible variables, the 29 ones, and each instance considers a subset of that except the solar 4 and solar 9 instances, which are the larger ones. So first, the variables related to the field of ideostats. So you can see it's the geometric variables in meters. These ones consist. These ones concern the heat transfer loop system. So you can see temperatures, for example, geometric variables also. After that, we have the variables for the steam generator and the power block, the unit that produces electricity. And at the end of that, the last variable is the categorical one, the type of turbine. So it's an integer in the code, but it's really a categorical variable. It's really a categorical variable. Now, for the types of constraints, so it's the opportunity for me to talk a bit about the taxonomy of constraints that we developed with Stefan. So the set X here describes the bounds on the variables and the discrete nature of some of the variables. So these constraints are unrelaxable. So you cannot violate them in order to get a result of the. In order to get the result of the simulator, the M constraints that describe the set omega are maybe a priori or simulation. So, a priori means that these constraints are analytical and that the code is going to evaluate them at first. And because they are also unrelaxable, it means that any evaluation of these constraints is going to lead to an interruption of the black box. So, it's going to be very fast. So it's going to be very fast, but you will see nothing. Most of the a priori constraints are linear, but some of them are non-linear, non-linear. The simulation constraints, these are relaxable. So it means that if you respect the a priori constraints, the simulator is going to last for a while and give you an output, except if you have a hidden constraint. So hidden constraints is. Hidden constraints. So, hidden constraints is when the simulator fails. So, all the constraints except the hidden ones are quantifiable. So, you will have a measure of the violation of the constraint or of the satisfizability of the constraints. So, the next slide shows the list of the constraints. So, again, I'm not going to read everything, but here are the seven a priori constraints, the 11 simulation constraints. 11 simulation constraints, and for each instance, we need to take a subset of that, and you have your instance. So, for example, here are the linear constants, and this one, the number six here, is not a linear constant, but a non-linear one with an expression somewhere indicated in the code. So, now I'm going to present the code itself: how do you decide which instance to consider? How do you decide which instance to consider? And the different options that you can use. First, the code is available at this address on GitHub. It's a common-like program that is really easy to compile. Just make a make is going to work in theory. So basically, you just run it and it will help you to understand what is going on. And it will help you to understand what is going on. So, if you run just solar like that, you will have a text that explains that. No, you don't use solar like that, you need to provide some arguments. And what you need to provide is basically the problem ID, that's the instance number from 1 to 10, and the name of a file that contains the point that we want to evaluate, the x. So, this is what it typically looks like. What it typically looks like. So, for example, here we consider the instance number six with this point x.txt, where you can find the coordinates of the point to text. And it will output seven values, one objective, and six constraints. Okay, so you have an online app here with this option. Also, in order to ensure that the So, in order to ensure that the solar installation is correct and that it provides you the same outputs independently of the machine, I have an option that is called check. So, you run that. It's going to last for maybe here, it's almost 800 seconds, but it's going to compare your evaluations to hard-coded outputs. So that is the same. It's a nice way to do some benchmarking of your machine also. Some benchmarking of your machine, also, if you want. And I don't know why, but the Mac are really fast for this application. So the Mac of USEF is really the winner so far. Typically, these are the typical execution times for one replication. So I will explain what is a replication after. So you can see that solar five is one of the The hardest ones to terminate, two minutes. And what we observe is an impact of several factors on the time of simulation. If we violate the aprioric constraints, it's going to be very fast. It's going to be a failure right away. But the number of failure stats, the number of mirrors that you want to locate, which is a variable, is going to have a great impact on the time of evaluation. Of evaluation. Okay, stochasticity. So, this is due to the Monte Carlo simulation to locate the mirrors in the field. And so, we provide the controller over a random seed. So, if you want your instance to give you the same results all the time, you just put the same seed. Okay, this is classical. But if you can consider to set this option diff on the seed so that your black bus becomes. The seed so that your black bus becomes really, really stochastic. So every time you hit the button, it's going to be potentially different. And also, I have this replication option, rep. It means that it's going to run the simulation several times and output some average values at the end. So it's a way to, in fact, to obtain a black box that is really, really expensive. But that is no longer stochastic because we time with a Because with time with many replications, the average values are going to be less stochastic. I have an illustration of that. Here is an example of the first instance with 14,000 replications. So it does one evaluation of the black box here with this option does, in fact, 14,000 evaluations for the same point, and it outputs the average value at the end. The average value at the end. And you can see the difference, the variability here for this point, and in the line is the average value and the same for this other point. Okay. We also have this option of multi-fidelity in order to have static surrogates. So this option can be from zero to one. One is Zero to one, one is the true black box, and every other number is a static surrogate, but with a different fidelity. So with that, if you have a solver that considers multi-fidelity, you can give the control to the solver for this option. For example, we have a work with a student. It's called What's the name of the method? What's the name of the method? Of Pierive? Yeah. What's okay? Adaptive mods, something like that. Then the algorithm has the control on the fidelity button. And so at the beginning, typically, you begin with a bad procedure, a bad fidelity, and you want to convert to the fidelity of one. Also, the replication option is also a way to have a static surrogate. If you consider that your true black box is obtained with 10,000 replications, then going to a small number of replications is also a static surrogate. Here is an example of the multi-fidelity option for solar number two. Here you can see the fidelity on the first column. So, this the last line is really quick to evaluate. You can see the time here, so a factor of 100 reduction in terms of time. And here, it's almost the true back box. It's for 14 seconds, and it's 7% reduction of time over the true back box. And here are the values of some of the constraints that are affected by this option. Are affected by this option, and the numbers correspond to the percentage of variation with the truth, with the fidelity of one. So, for example, here you can see that the C3 and C6 option may be obtained exactly with a very low fidelity. You will have access to the true value, so it will be very fast to compute. But for the C2 option, if you will go to a bad fidelity, it will need it will. Fidelity, it will mean nothing. So you need to have at least a fidelity of, I don't know, here, maybe 70, 0.70. Okay. Yes. Three minutes. Okay, so we don't have results with NOMAD or other solver, but just to illustrate what is going to happen if you test a solver on this kind of problem. Should test a solver on this kind of problem. So, Ludovic tries a demultimal method with different options on solar eight and solar nine, the two instances that are B objective. And so you can see the look of the parato approximations. My intern Mona and my master student Xavier recently tried solar one and solar seven with different options. On the left, With different options. On the left, it's a plot that shows the unfeasible and feasible solutions. And on the right, it's a variation with a different seals for the Solar7 instance. So it's just to illustrate that it's a tool to benchmark methods. And that's all. I don't know if I can show the code for maybe five minutes. Please. Okay, thank you. Show the code for a couple of minutes. Show the code for a couple of minutes, but people will ask questions while you pull it up. Okay, so first question and then demo. Sounds great. Okay. Questions for Sebastian? Listen.