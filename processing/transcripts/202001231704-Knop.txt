Or quite close to this. So if you see mistakes, let me know immediately. It would be better than if you tell me about this at the end. So usually when we talk about branching programs in proof complexity, we talk about quiet, low-level proof systems. They're usually somewhere around resolution or cutting planes. In this case, we are going to talk about proof systems. In this case, we are going to talk about a proof system that is more powerful than Frege and somewhere in between extended Frege and Frege. I mean, when we talk about the full branching from the probe system. However, the decision version is going to be around depth 1, depth 2 fragment, which is way less powerful, but still not that big. So I'll start for the motivation. So motivation is The motivation. So, motivation is comes from boundary medicine. In boundary medicine, there is like a line of research where people study theories, proof systems, and complexity clusters together. They form like a triangle. And the idea is that we have this formal theory that connects class and proof system. Like, usually, for example, it's known that it forms some kind of non-uniform uniform correspondence. Uniform uniform correspondence, and the idea between these correspondence is pretty simple. We know that the P-complete problem is circuit evaluation. And if you consider a proof system where each line is a circuit, aka extended fragment, we'll get actually this correspondence. But to make it more formal, we can create a theory such that if something is provable in this theory, an analog of this can be proven in the proof system. In the proof system in polynomial time. And if we have a function from this class, we can prove in this theory that it's defined and total. I'll give a more precise example so that it would be easier. So we can consider the following triplet. The first is a proof system, it's extended for again. Second is the theory which is S12. And we have a class P. As I mentioned before, we can suspect some kind of relation between class P and Frege, and this is formalized using this theory. So let me quickly give something like a definition of a theory. Because as I mentioned, I'm not a specialist and we have only 25 minutes, so I'm not going to give a really formal definition, but I hope that I will be able to explain what's going on to people. To explain what's going on to people who never heard about band arithmetic and tell about the research to people who've heard about it. So let's consider like some formulas over the following vocabulary. We have zero, we have the iteration of adding one, we have plus operation multiplication, we have smash operation. It's not actually matter if you never heard about it, just it should be there. We have length functions and we have division by two and we have two predicates Division by two, and we have two predicates: inequality and less or equality. So the axioms of this theory are standard axioms of this operation like this. More or less everything you can came up with is there. And which is important, induction. It's a typo. I think it's an incorrect induction axiom. And some induction axioms. Some induction external. It's a length induction, it's supposed to be a length induction. So if you know that, I think I'll write it. Yeah, I correct formula. So if you know that formula is true at 0, you know that if it's true for x, it's true for x plus 1. You can prove that it's true for any argument, but here you can prove it only for length values. So it's called length induction, and it's weaker than genuine induction. Yeah. It's a it's weaker than genuine reduction. And the idea now we would like to discuss the connection to proof systems. In order to do this we need to construct some transformation from a formula in the theory to a propositional formula. And this is done using the following idea. Let's consider formula, it's called sigma b0. In other words, it has only bounded quantifiers. And so we can define in a natural way the following aversion. So every bit of x we denote by a variable, we call it x1 to xn and we can use a natural way to define the transformation. If you have a c if you have conjunction, you just get a conjunction of transformation. If a quantifier, you get a long conjunction or disjunction. Long conjunction or disjunction. And so on. The question is how to encode these separations, but it can be done using pretty small propositional functions. And we also may have some free variables that are not x. You can consider some assignment to them. We call it alpha. And the theorem that you can prove is that if you have a universally quantified formula, provable in the theory, then the transformation of this formula is provable in Frege with Palineno size. Extended Frege. And moreover, actually, you can show that there is in some sense equivalence, you can show that this theory proves r the reflection principle for the extended Principle for the extended frame. So, in other words, there is an equivalence between theory and proof systems in the sense that if you have proved something in theory, you can prove it in the proof systems and vice versa. So, again, let's return back to this picture. We've somehow explained what's going on in this part. We need to explain what we mean by this part, and this is a bit easier. And this is a bit easier, I would say. So imagine that we have a function from natural numbers to natural numbers. We say that it's sigma b1 definable in some theory if we can prove that for some formula A it's it defines the graph of the function essentially in the so in other words we can In so w in other words, we can prove that the function is always defined and the value is unique, and we also need a constraint that actually this formally in the standard model of natural numbers is actually something related to the function f. And we can show actually that S1, 2 sigma b1 defines functions from class B. And moreover, we can show that essentially And moreover, we can show that essentially it defines only functions from class P. So there is some kind of equivalence again. And there is, as I mentioned, it's a whole line of research, so there is a dozen of results connecting theories, classes, and proof systems. And I would say that a lot of attention is spent on the classes that are below P, that are weak classes. And that's what we are. And that's what we are interested in. We are interested essentially in these two lines of this diagram. We are interested in classes L and N L. So we would like to construct a proof system. Oh, it's type of. No, it's called also. What? What's wrong? Should be BNC1. Is it right? Yeah, no. Yeah, sorry. That's my call, actually. Sorry. Yeah. Um yeah but you're right, thank you. Uh so yeah, we are interested in these two lines and we would like to con come up with a proof system that corresponds to these two theories and to these classes. I mean you may ask why we are interested if obviously it is already proven and moreover like more than 10 years ago. The thing is in some sense these proof systems are not Sent these proof systems are not quite natural for people from the proof complexity community. I think I have, yeah, so I have a slide about them. So essentially, these two proof systems are, one of them was given by Perron and these are called CNF2 and Sigma Chrome. They have proof systems that have qua over the four the standard sequent calculus for propositional logic. But the thing is, the formulas in this sequence calculus are quantified. The secret calculus are quantified, which is pretty natural. And we wanted to have something more natural. And in addition, we would like to have the connection to branching programs, because as I mentioned at the beginning, usually we have this kind of idea that if you have extended Frege, then we have socket evaluations or something like this. If you have just Frege, then we have formal evaluation, and so on. It would be good here to have something like this. It would be good here to have something like this. And our result was partially inspired by the result of Cook. He, in some presentation, it was never published, and like in most of the troops, proposed an idea to consider Pudlock games or Pudlock bus, I'm always forgetting the order, where over the branching programs. Branching programs. And he proposes to consider it as a proof system and it would give a connection to VLMP and L. But again, this is not a proof system in a standard way. It's a static proof system as a proof system. We wanted a standard line-by-line proof system that looks like Freg, yeah? Yeah, as I mentioned, that's what we want. Yeah. As I mentioned, that's what we want, for through a natural model. Um the idea was to start with decision trees, because decision trees are essentially formulas. They have three-like structures, so you can write them as formulas. And after that, somehow to go to branching programs. And this kind of problem was already discussed, studied when we went from Frege to extended Frege, because Frege. From Frege to extended Frege, because Frege are proof system over formulas, and extended Frege quite often is considered as a proof system over circuits. Nonetheless, that if formally is not a proof system over circuits, it's a proof system over formulas with a special rule, extension rule. Though I think I'm going to mention there is at least one paper that tries to create an extended Frege system that deals directly with circuits. Okay. Okay, so first of all we need to discuss what is branching program. I hope that everyone knows so I'll go quickly. If you don't understand something ask me. So branching program is just directly cyclic graph. Every node of this graph is labeled by a variable. Every sink is labeled by a constant. And it looks like this. So you have a variable, you have two edges, outgoing edges, one labeled by zero, one labeled by one. 0, 1 labeled by 1, and you have labels with the value. And the computation is you just follow the value of the variable until you reach the sink, and that's your value. Also, we could consider non-deterministic branching programs. In this case, we have additional nodes that allows you to non-deterministically choose the direction. Um and as I mentioned, we can also consider non-deterministic decision trees. In the same way, if the graph is a tree, then it's a decision tree, non-deterministic or deterministic, depending on the model. So, yeah, as I mentioned, we wanted them to define as formulas, and it's pretty easy. We are going to write that if you have a decision tree formula A and you have a decision tree formula B, then you can write You have a decision to formula B, then you can write APB, which means that if B, then you need a value of B, otherwise a value of A. And yeah, this is just if then else, and you can see easily that it can form a decision tree if you recursively apply the operation. And if you allow one more operation, or you get non-deterministic decision trees. Pretty straightforward. We can consider a proof. We can consider a proof system which is called LDT. It's sequent calculus over decision tree formulas and you need to have just two rules. One of them allows you to deal with the formulas on left, one on the right. And for L and D T, you will need to extend this set of rules by two more rows, just again. Again, or on left and right. So, this rule is a standard rule of sequent calculus. The only rule that is more or less new is this one. And it's possible to show that actually, I mean, to put these new systems into a big picture, you can show that non-deterministic decision trees are essentially the same as. Decision trees are essentially the same as depth to secret calculus, depth to Fregi. And LDTs, so if you don't have non-determinism, it's the same as depth one, second calculus. And yeah, the standard result puts it, the tree version of them here. Okay? The so results that are in orange are our results and I can try to explain some of them probably. In my opinion, the most interesting is this simulation, which is quasi-polynomial. And this is just, in some sense, follows from the following observation: that if you have a formula that has a short CNF and short DNF, you can write. You can write it as a quasi-polynomial decision tree. And using this observation, we can lift the proof from here to here, but unfortunately, it gives this blow up. How much time do you have? Okay, let me go further if someone is interested in the ideas of these proofs. I can explain them later. Because I know that I'm on the way of you and food. I know that I'm on the way of you and food, so I don't want to be late. Okay, the problem is, as I mentioned at the beginning, DAX cannot be expressed as formulas naturally, at least. So we propose to use extended variables as it was done in extended fregeon. The thing is, we don't allow to use these extended shitten variables in the Certain variables in the middle of the decision tree. We cannot split by value of the extended variable because if we allow this, it would give the instead of branching programs, we would get circuits. And it's undesirable. So yeah, we allow extension variables, but not a course decision literals. Decision literals is the if part. Uh and is uh so yeah, you can think about this like this at each extended variable is just a sub-program you call at some point. Um yeah. So proof in ELDT, E stands for extension, is exactly the same as L D T L N D T. You just supply it with a sufficient number of extension axioms at the beginning. So every time you would like to write a proof, an extended Write a proof in extended in ELNDT or ELDT, you just first decide what kind of extensions you need, you write them, and after that you write a standard LDT proof. As these variables are not interesting. Yeah, so this is an example of this transformation. So for example, so first number is the, I mean, it's EI. It's Eij, and I stands for the level, and J stands for the position on the level. So, for example, this is E31, sorry, E31. And we write that it's the same as 0Z1, like this. This is E20. It's this, I think. Yeah. And it's either E31 or 0. I mean, depending on the value of y. I mean, depending on the value of y. Okay? I hope this is clear. Essentially, you could just write through your branching program for every node, you create a variable and write the value of left and right, where on the left you give the value of this corresponding node, on the right of the corresponding node. One technicality of this is that there are ways. This is that there are way too many ways to write these formulas. You can represent the same branching program as a graph if I write it on the blackboard as something using many different formulas with extension form, I mean there's extension variables. And this is a problem. Like, if I have two branching programs, I would be happy to be able to explain that they are the same, right? So there are two possible ways to deal with this issue. One of them is just This issue. One of them is just create a special rule that allows me to transform one branching program to another. And for example, as I mentioned, there is a paper that tries to study extended Frege where actually lines consist of circuits. It's 2004. And he proposed to have an additional rule that allows you to transform immediately. Transform immediately. So if you have two isomorphic circuits, you can go from one to another without any delay. You just use one transformation and that's it. And our problem is, as I mentioned at the beginning, we wanted to have a system that corresponds to class L. And it's not that easy to compare it to branching programs, if they're isomorphic or not. It's not in class L. It seems, at least, like this. At least, like this. So, our solution was to say that: okay, if you want to transform one branching program to another, you need to prove that they are equivalent. So, you need to step by step modify them until they are the same. And the thing is, apparently you can do this. If you have two isomorphic branching programs, there is a proof in the corresponding proof system that shows that they are the same. Unfortunately, this proof is dead-like, which is an issue a bit. Like, which is an issue a bit because in these systems we don't know the standard fact that tree-like and degree-like are the same. Which is a bit weird, I should say, because we have a two-foot system that have this property, and something between them doesn't. It was very surprising for us. So all the results about this system. All the results about these systems are presented here. So, as we know, as I mentioned, this is a bit bad. So, it should be so. So, we have a standard sequent calculus, which is the same as Frege. It's a bit weird statement because it's not clear what is the difference, because some people define Frege as just sequent calculus. But it's known that it's the same as three-like sequent calculus, and the same is for extended. And the same st uh is for extended Fregi or sequent calculus with extensions. Uh but we have these two proof systems in the middle which don't have this property. However, as usual we have a quasi-polynomial simulation between this and this, just because as I mentioned there is a relation between C and F's and G. Oh, sorry, no, no, no, no. CNF synthetic. Oh, sorry. No, no, no, no, no. This time it's just because ST connectivity has a good algorithm, right? I'm not mistaken. Yeah. Yeah, so these results suggest direct simulations. This result is a bit more complicated. Here we need to use the fact that branching programs can simulate formulas. However, since the rules However, since the rules are a bit different, we need to carry out the transformation between formulas and branching programs. So it's pretty straightforward, but not super trivial. And yes, as I mentioned, we used Sam's result about a steep connectivity to carry out this simulation. Okay, let me quickly then try to finish. Let me quickly then try to finish and talk about the part that is not published yet, which is about bounded arithmetic part, that was the reason we started doing this stuff. So it's going to be about VL and VNL theories. These theories are a bit unusual compared to the previous one because they are two sorted theories. So we have two sorts of objects, sets and numbers. We have pretty small vocabulary, we have constants, we have Vocabulary: we have constants, we have precessor plus multiplication equality that can be used only to numbers, inequality that also can be used to numbers, and we have an epsilon relation that can be applied to a number and a set. So the axioms for this are pretty standard for equality and equality, also more or less standard. But we have additional axioms about the sets here. So, first Sets here. So, first of all, every set is bounded, so they're finite. This is a short for x belongs to A. So, it says that any set has a number such that all the elements are less than this number. Another one says that if you have an element of a set, it should be A of B, but it's, as I mentioned, just a short version of it, then you can find a minimum. A minimal element belonging to this set. These can be used to simulate induction, so it's a pretty important property. And we have a property that we have a comprehension. So if we have a formula that doesn't have any quantifiers of second order objects and all the other quantifiers are bounded, we can transform it into a set. Transform it into a set. And, oops. Yeah, so VL is these axioms plus an additional axiom that says something about class L. In this case, it's the statement that if you have a graph without degree 1, there is a path of any length. Yeah, it can be written like this. I don't propose, I mean, I don't think you need to read it, but it's going to be posted online so you can go and look at it. Okay. For VNL, we need something different. And the idea is to encode the distance function. In this case, it's actually not distance function, but like path length function. And this is encoded like this. So I don't have how much? Have a minute or something? A minute saying? Okay, so. Let me open this. So, you can similarly, like in the case of S12 theory, you can transform these formulas into propositional formulas. This time, the difference is that instead of bits of numbers, we encode the set x using the variables. And it can be shown that if you have a proof of some statement, then it should be universal quantity. It should be a universal quantifier. If you can prove that something is a tautology in the sense of theory, you can prove it in the propositional proof system, in the corresponding one. And yeah, I don't have time to talk about the proof, but there are some issues connected to the fact that negation of a distance function can be done in the theory. However, in the proposition In the theory. However, in the propositional system, negations are more complicated because you have branching programs, non-deterministic branching programs. And if you try to negate them, you get a non-determinist. You can deterministic branching program. So you will need to carry out Immermann-Slip-Cheny theorem within the theory or within the proof system, which is a painful moment. However, fortunately for us, Immanuel Slipcheny's theorem is more complicated than the statement we actually need, so it can be done more. We actually need it, so it can be done more less painful. Thanks. I think in addition to proposition, you also mean something concerning the other direction? Yes, we this is so as I mentioned, this part is a bit in progress. The part I wrote on the slides is the part that we have at least a well-written draft. Have at least a well-written draft that I can do. The part that is not on the slide is part that we discussed. We know that we can prove it, but I'm not that brave to say that, yeah, that's done. We have reasonably good reason to believe the reflection corresponds to this variable. And yeah, reflection pre-so, yeah, there are some works like we can prove the fact that constant number of alternations can be collapsed into one. Um collapsed into one and so on. So you can define similarly proof systems like using alternations and stuff and yeah, using this result we plan it to show that these proof systems are the same. There's of course polynomial size project programs for computing majority threshold functions. Yes. So the question is for such explicit ones do you have the basic properties provable in the We have not tried, but yeah, we can think about it. I'm reasonably sure we do. I think you just get it from the simulations that you get, right? So the sanity check is the simulations we present it. So we can simulate Frege and stuff. Yeah, so if Frege can prove it. I was looking for a natural proof that doesn't use the fact that you can formalize. I think we can, yes. Yeah, I think so. Directly. Yeah, I'm pretty sure that we can try it as an exercise. Try it as an exercise. I mean, the other thing is that if you have that, then maybe you can deal with the monoton calculus and that you don't need to do even marginal at the end. We know that that came up, right? We thought of that. I had not thought about it, but maybe I informed you. I mean, he's a specialist in management proof systems. You use SC connectivity to do other construction. So with the LNDT, if you use underwrited ST connectivity, distributions and that's a good question. But I mean but you will have I mean, you'll have a separate malation anyway. So you cannot do it. No, we haven't tried this. It's sounds like a good idea. It sounds like a good idea. But it would be very surprising, considering that formulas are definitely weaker than branching programs, not to mention basic branching programs. That would be really surprising. So I suspect that even if we do direct at stystic connectivity, we would get still quasi-polynominal simulation. Maybe a bit better, but anyway, everything here is not quite constant. And it's polynomials. Any further questions? If not, let's thank all our speakers for the afternoon. 