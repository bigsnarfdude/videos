I'm going to give this introduction on locally recoverable code and I will specialize on a particular kind of code that I like very much because they have any interaction with the number theory that is my field. So let me start with the definition of log. Uh, definition of locally recoverable codes. So, an end K D R Q locally recoverable code is a linear code over FQ of dimension K, length N, minimum distance D, but with this additional property that if one erases one of the component of any code word in C, then this component can be recovered by looking at at most R. At most, our other component. That is this parameter you see here. And Q here is just to keep track of the base field where the code is defined. So the motivation for this is pretty straightforward. So the situation is that your data is split among servers. Servers encoded in servers and splitted among them. And a user might want to recover one chunk of data in one of the servers, but this server might be unavailable or just rebooting or whatever can make it unavailable. Available. So in this case, these users should be able to recover the data by looking at a few other servers, not many of them. This is the idea. And on the other hand, when in the unlikely scenario of multiple solver failure, you still want to be able to recover the data, but in this case, you allow more. You allow more, you allow the user to look at more servers. And in that case, essentially, you do it with the normal distance. So, this general principle in computer science is, of course, to treat the most common scenario in an optimal way. So, in this case, it's the failure of just one server, but still, you want to be You want to be able to deal with the worst-case scenario. So the locality deals with the most common scenario and the distance with the worst case scenario. Okay, so first of all, we want to observe that read-Solomon codes don't do the job, right? Because read-Solomon codes need to look at whenever any component is erased among the n-k. Is errays among the n minus k that they can correct, then you will need to look at k other components of a code word to recover the missing symbols. It doesn't matter if there is one erasure or n minus k erasure, you still will need to look, essentially reconstruct the entire code word to recover the data in only one corrupted node. Corrupted node, and so this is not really what we want. Okay, so we want that's why we are looking at this particular class of codes. Okay, so let's look at the duality property, the locality property, just to just to understand it better. So, well, the recovery function is the recovery function that allows you to recover to Recover the missing component is indeed linear in terms of the other components you are looking at. So it will look like something, say that you have the code word C1, C2, CN. Then the situation, say that you want to recover C1, well, you will have an equation of the form A1. A1 C1 that will be what you don't know, and then you will have other R, say the next ones, AI, or I that goes from one to R, right? And this depends, of course, on the coordinate you are erasing. So in this case, I'm assuming that the locality set consists of the first R plus one coordinate. So the important thing is that this is. Important thing is that this is different from zero, and the weight of the AIs. I mean, and then there are only R other AIs in the question, okay, for the code. So in terms of the dual, this means that for any coordinate index i, there exists a code word d in the dual. D is in the dual such that D is supported at at most R components T and I is in T. So this is what you really want, this is really what the locality property is asking. Of course, you cannot have the cake and ET2, right? So you must have a relation between these these quantities. Between these quantities. And the relation is one of the relations you can write is this one. This is the singleton bound for locally recoverable codes. So it connects the distance, the length, the dimension, and the locality with an inequality. And this is the proof is slightly more complicated than the singleton-bound proof, of course, but it's yeah. But it's yeah, so um, and then we say that an MKDRQ LRC code is said to be optimal if the minimum distance of C satisfies the singleton inequality. Okay, you have a finer inequality that involves the size of the field that is the Of the field, that is the Kadamba-Matzundar bound. So this quantity says the maximal dimension among all the codes of FQ to DN of distance D. And this quantity, and then the inequality for locally recoverable codes is this one here. So it's the minimum among all T's of TR plus this. of TR plus this quantity evaluated at n minus TR plus one and D. So that's another inequality. This is finer than the singlet unbound because takes into account also the size of the field. Okay, so now let me speak a little bit about what's about some of about some of the codes that are available, some flavor say of locally recoverable locally recoverable codes. So this is the construction that I will treat later on then which is done with polynomial. This is pretty much similar is done with rational functions and you can do it Functions and you can do it also with curves. In this way, you can obtain, say, classical locally recoverable codes with the locality and the minimum distance and not additional feature. I mean, there are, of course, discussed also features such as availability in this paper. So these are some results that deal with the availability. Now, let me tell you what availability is. Me tell you what availability is for a locally recoverable code. So, as we said, we might have the situation is that the coordinates of the code word are partitioned in locality sets, right? So, if one element fails, I can look at other two. Two, say in this case, other two nodes to recover the lost data. But you can organize the recovery set in an orthogonal partition. So, say the situation is something like that. And in this case, whenever a node fails, then you have the option to either look at this locality set to recover it or look at this one here. And this is the code, say, with the availability too, right? So every component belongs to one of two locality sets with intersection. To two locality sets with intersection only one element. And the nice thing is that if two nodes fail in the same locality set, then you can recover them by looking at the other locality sets. So these are very convenient construction. But it's like it's very special because it needs some strong algebra. Algebraic properties of the nodes in some sense, because this is highly, highly non-generic to have this kind of situation. So, another kind of locally recoverable codes are the hierarchical locally recoverable codes. In this case, the organization of the node is essentially the opposite of an orthogonal partition. So, in this case, Partition. So in this case, the nodes are organized in locality sets. And the locality sets are further organized in bigger locality sets. In this case, so what you want in this case is that you want to be able to recover one erasure, for example, One erasure, for example, when it happens in a small locality set. But you also want to be able to recover two erasure from, say, two erasures from the larger locality sets. So say, I mean, of course, if the two erasures happens here and here, then you can use the smaller locality sets. But in the case in which the erasures happen in the same locality set, then you use in the same smaller locality set, then you use. the same smaller localities then you use the larger um the larger hell element in the in the hierarchy and this is like so this is a nice property okay so now let me specialize on the construction I know best that is this one and let me tell you briefly what is the idea from a What is their idea from a number from the perspective of a number theorist? So for any f in F Q of X, we of course have the expansion, the aphadic expansion in basis F. What is the aphadic expansion in basic F? This means like expanding any polynomial. Any polynomial in FQ of X in basis F of X with these coefficients Gi of degree strictly less than the degree of F. And we know that every polynomial can be expressed in this way. This is simply an application of the Euclidean algorithm, but done on the quotient and not on the Done on the portion and not on the remainders. But yeah. So one can consider another space, this space V. This space consists of exactly the same thing, but in which the degree of GI is bounded by the degree of F. of f minus two, less or equal than the degree of f minus two. So strictly less than the degree of f minus one. So we can consider in a sq of x, all the polynomials that expressed in basis f of x have coefficients of degree one less than what we expect. Okay? So and now here is the brilliant. Here is the brilliant idea. So the Q observation is the following. If I have a set of elements S of F Q, where F is constant and of size degree of F, then any map in V acts on S as a polynomial of degree at most degree of F minus two. Because think about it. So you say that you are. So you say that you have a set S where F is constant and the size of S is degree of F. Then when I restrict this map to S, this becomes constant, but now this polynomial, the sum of this polynomial with these coefficients, will have degree smaller than the degree of F minus 2. And I am evaluating. And I am evaluating at the degree of f points. So I can recover the essentially, I can recover this polynomial, a polynomial that looks like this when restricted to S. And this is essentially the key idea. And I will tell you what's the construction. Say, just let me add the sentence here. So if one The sentence here. So, if one evaluation of a polynomial in V is missing, this can be recovered by looking at most the degree of F minus one other valuation, because you will have a polynomial here of degree of F minus two at most. So now let me formally define these codes. So if F is a polynomial, Is a polynomial in Fq of X and L is a positive integer, then F is said to be R L good if the following is satisfied. So F has degree of plus one, okay, that's easy. But then the other property that we require is that there exists A1. A1 AL distinct subsets of FQ such that for any i in 1L, F of AI is equal to Ti. So this means F restricted to Ai is constant with constant depending on I. The size of AI A i is r plus one for every i, and the intersection of two a i's and a j is the empty set, but this follows immediately by the from the other two and the fact that f has degree r plus one. So in this case, we say that a1 al is a splitting covering for for f so um essentially uh what what we are doing What we are doing here, we are restricting to a, we are considering the subset, a subset of FQ, a subset, say a family of subsets of FQ, A1. Say, let me, I think I have a, no, I don't have a empty slide here, so A1, A2, AL. And whenever we apply F, this will collapse. This will collapse to one point. So, this is subsets of FQ. So, you see, really, your F will have two parameters. One will tell you essentially the degree, and the other one will tell you how many of these sets you have in FQ. You might have known in principle, not take a permutation polynomial. I mean, that doesn't have any of these sets. Okay. Of this side. Okay, so how does the construction look like? So, once we have with this idea at hand and this definition, so what we can do is to fix an R L good polynomial f of x over f q with splitting covering a1 a l. 1AL and we fix f less or equal than 1 less or equal than l minus 1 a positive integer. So we consider, as we said, elements of v in bounded degree. So we just take all the expansions in basis f with the property that the degree of gi is less or equal than the degree of f minus two. Two and now we will want to evaluate this set. So this will be essentially the master space. So what are we evaluating? We are evaluating on the union of the AIs. And we evaluate at the union of all the AIs, we evaluate all the polynomials in V. And this is an R plus one times the L S R D R optimal locally recoverable because you achieve the singleton bound. Yes, the E V denotes the valuation of G at all points in set T and now you see this subcode of the Rich Solomon code, so you have the same nice properties, but the point is that when The point is that when any of these polynomials is restricted to Ai, then this becomes constant and this sum becomes a polynomial of degree of F minus 2. Now, because of Ai has size degree of F, that is R plus 1, you can recover a polynomial that evaluates exactly as this one on Ai. AI and then you evaluate that. And to do this, you of course you only need the evaluation at the other elements of AI. Okay, so now how we remain with the following question, right? So how hard now is to find a good polynomial? Well, there are some, of course, like everywhere there are some trivial cases. Well, for example, Trivial cases. Well, for example, a trivial case is when r plus one divides q minus one. In this case, you always can find a good polynomial. And this polynomial, very good polynomial with L equal q minus one over r plus one. And this polynomial is going to be x to the r plus one, right? Plus one, right? Because what happens? So, what are the locality sets of this polynomial? So, remember, what we want here is that L is as large as possible. So, this gives us here the range of parameter, the range of locally recoverable codes, the Tamobar codes we can construct, right? So, we want the desire here is to have L as large as possible. And this achieves what we want. And this achieves what we want, right? Because now which are the locality sets here. So A1 is just, say, the set of the R plus 1 roots of unity. So this satisfy that psi to the R plus 1 is 1, and this exists because R plus 1. this exists because r plus one divides q minus one so if i apply x to the r plus one here i get one but now which has another one well take another element that is not in here so in the coset take the end and and take the coset a a xi a A psi to the r and this also collapse in x, sorry, in a to the r plus one, and you keep going until you cover essentially everything apart from the zero. Okay, and this construction is of course unbeatable because you cannot cover more of FQ, right? But you need this strong requirement. right but you need this strong arithmetic property between um between r plus one and and q let's see another another example in which there is essentially nothing to do so say that r plus one divides q then you can find you can find Then you can find some vector space in FQ. So say that Q is P to the E. So I look at this as Z modulo Pz to the E. So you want to look at this as a F P vector space. And then you can find a linearized polynomial L of X such that L of V is zero. Sorry, I should have said size of V. sorry I should have said size of b equal r plus one and in this case you fix this this polynomial l of x and this is going to be constant on the cosets of v so w plus any element of v will give us l of w plus l of v and this is zero so this will give us l of So, this will give us L of W. And also, in this case, there is nothing to do. Okay, but what about when these conditions are not verified? Then it's unclear what you can do. I mean, what is a trivial construction? I mean, in principle, you expect that in some In some sense, you should expect a bunch of totally split places from any polynomial that is generic enough. So, in particular, what we will be able to prove if we use Galois theory correctly is that if I just fix one, say I write like this. One totally split place, so I fix a polynomial f like this, then forcing at least one totally split place will immediately force many of them that goes to infinity when q goes to infinity with an error term of square root of q. So this is a particularly, you'll find this particularly interesting if you don't know like the Chibotarev density theorem. Say just fixing one factorization pattern will determine its. Pattern will determine essentially infinitely many. So let's see how we can do that. Okay, so I need some setup. I need to change the problem into a number theoretical problem that I can solve. Again, again, let me recall you: the task is finding a good polynomial. So, finding a polynomial f that is constant on as many AIs as possible. So, first of all, let me observe what this means in terms of totally split places. So, if f of x minus t zero is totally split, Then f is obviously constant on these a i's right because f of a i t zero is equal to t zero right independently of i so really the task is to find the number of t0 is to find the number of T0s for which this is totally split. Okay, and this will give us L, so the number of locality sets. Okay, so if here is the setup. So if F is in FQ of X is a polynomial of degree R plus one and T is transcendental over FQ, let me consider the polynomial F minus T in Fq of T. f minus t in fq of t of x. So this is in this is a formal thing, right? So this is just take f with coefficients in fq and consider this polynomial f minus t in fq of t with the round brackets. With these I mean just the rational functions in the variable. Let me construct the time. Okay. Now, F minus T has to be, if we stand the chance that F is R L good, F minus T has to be separable, so must not be a P power. Okay, so there is no, say, F must not be a P power. Otherwise, there is no totally split place. Okay. Now, let me denote by M the splitting field of F minus T over Fq of T. This is essentially encoding how F minus T splits when T is in some sense generic. Okay, so this is the splitting field in terms really in Galvo theoretical terms of F minus. Minus t. So I'm adding to f q of t all the roots of this polynomial, of this formal polynomial. This is fair. You have a polynomial over a field and you can add all the roots. Now, suppose that M has full field of constant. So this means, so equal to FQ. So this means that the elements of M that are algebra. Elements of M that are algebraic over FQ consist only of FQ. Everything else is transcendental. And this coefficient, this is a little technical, this thing, but it's necessary and sufficient for F minus T to have a totally split place, say, T0. Okay, so we need the equality of the field of constant. And actually, this is a generic situation. So this will always happen in practice. And we can also see when this doesn't happen. So it's fine. When this doesn't happen, so it's fine. So here is the claim. So the totally split T0s can be estimated with the following quantity. Q over the size of the Galois group of M over Q of T, that is the Galois group of F minus T, which in turn gives the maximal possible dimension of the Tamil-Barn, sorry, maximum possible dimensional length. Uh, the sorry, maximum possible dimensional length of the Tamil bar code and the estimated up to what error term? Well, the error term is gonna be a big O of square root of Q, and the implied constant is independent of Q and explicitly boundable using the genus of M. Okay, now let me for the people who are interested in number interested in number theory, let me explain why this statement is true. So here is the situation. You have fq of t here and you have you have fq of x where say x is a root of f of x f of big x minus t. x f of big x minus t so x is a root small x is a root that satisfies f of x minus t equals zero just one just one and now I take here the splitting field okay so what do I want I want here T zero to be totally split for For f of x minus t zero, right? So I want this, the one that this splits into linear factors. So I have x1, xr plus one. And then I have, I mean, I have some places lying above the zero, also in M, right? And there will be how many this is the Be how many? This is the entire point. So if this is totally split, so again, I want to count the T0s for which this is totally split. In principle, I don't count, I don't mind about the T0s that are, I don't care about the T0s that are totally split in this extension. But it happens because the theory of functional fields is nice, that these T0s that split totally in here are exactly the same that splits totally in here. Okay, so now let's check now. So, the only thing we have to do is to count those, right? If I count the place the zeros that totally split, that are totally split here, I am done because I'm actually counting these ones. This happens only because this is the Galois closure of fq of x over fq of t, otherwise it will never happen. I mean, it might happen, but it will not. It might happen, but it's not a theoretical. So, so what do I do here? So, I'm counting the totally split places of M over FQ of T. How many places of degree one I have here? basis of degree one I have here? Well, by Acevale, I have Q, right? But I mean, all the places of degree one by the Galois action are all above a certain place of degree one here. So I mean, I can regroup the places of the degree one places of M in groups of size gal. Gal of M over FQ plus some error time that is given by that is given by SE value, right? And that's it. So this is the number of degree one places, T zeros that are totally split now in this extension. In this extension, okay. Okay, now let's see, let's see something in practice. So, how does it work? First, let's do it for a polynomial that we know. So, say something obvious that just to fix the idea. So, I take x to the five minus t equals zero. Minus t equals zero. And now this is already Galois with Galois group C5. So the asymptotic of the totally split places of this one is indeed Q over 5, correct? That's what we expect. No, Q minus 1 over the degree of the polynomial for this one. You can prove that there is no error term because the SVL here as, I mean, this curve as genus zero is the rational function field. And so there is. And so there is essentially, it returns the thing that you know already, right? For x to the five minus t. Okay. Okay, this is good. So this is first three decades. Now the other one is the one I already mentioned. If I fix f product for i that goes from one to r plus one of x minus a i well the fact this Well, the fact this guarantees the existence of a totally split place, what one? Which one? The zero, right? The zero. So, in particular, this means that this condition is automatically verified. Automatically verified because the field of constant is in every valuation ring. So this guarantees that this guarantees that the only hypothesis we have is verified. And now, Gal of F is a subgroup of F minus T is a subgroup of the symmetric group in degree of F. Right? Right, and what does this mean? It means that the size of g is less or equal than n factorial. And so at least, in general, for any polynomial of this form you fix, the number of totally split places is Q over n factorial. Okay. Okay, and now we have, well, maybe first another example, another example, because you see, this is like a little bit, it's not really what we want to see, right? And factorial denominator. So let me give you something slightly better. I mean, a bit better. So we saw how to apply it to a case that we know. We saw it how to apply it to any polynomial, but Q over n factorial is not great. Factorial is not great. So let me tell you how we get a nice result instead. Say that you take F equals G composed with H, with G and H of degree two. In this case, you can push in the theory of locally recoverable code using this dictionary here, you can push the theory of The theory of arboreal-Galois representations because now you see this is the automorphism group of these polynomials, so say gf minus t in fq of t again of x, the automorphism group of the Gallo group of this polynomial is contained in the automorphism group of the Automorphism group of the root of the binary rooted tree of level two. Because what can I do? I can only change this as a very special factorization pattern, right? Because this has H minus alpha F, alpha G, so a root of G times H minus another root of G is the factorization over when I add one root of G. Over when I add one root of G. And then I have to split these two that have degree two, right? So the idea is that here I have alpha G1, alpha G2, and then here I have some other, say, beta one, beta two, beta three, beta four. And so now in this situation, the point is that if I want to send this route to this one, then I also have to send this route to this one here. Root to this one here. And so, in particular, the Galois automorphisms of F minus T preserve the connection in this graph. So, in particular, again, this means that the Galois group of F minus T embeds in the the automorphism group of, say, T two two the test size. The test size, so say the test size eight. So now the asymptotic of the totally split places of f of t zeros is simply q over eight. If you had like a general degree four polynomial, you would have q over 24. That is an factorial. Yes. So this tells you that if you are a little bit careful. If you are a little bit careful with the choice of your polynomial, you can gain a lot from this theorem. And you see, this is completely disconnected in some sense. The arithmetic of the totally split places is completely disconnected by the degree of F because it's enough that you embed the Galois group in somewhere that is small and then you are happy. Okay, this is just the general. The general proposition that yes, that we essentially proved just by forcing one totally split place. Okay, this gives an effective version of existential result. Okay. In degree three, I just wanted to show you how it looks like. There is this mind, there are some minuses here because you have to remove the ramified places. But fortunately, the size of the Galois group also divides. Unfortunately, the size of the Galois group also divides the error term always. This is simply follows by applying the while correctly. Okay, let me show you something that is even finer than the one I showed you before. So let me take this polynomial, x to the 3 minus ax squared. In principle, the Galois group of a polynomial that is a composition. That is a composition of a degree three polynomial and sorry, a degree two polynomial, and a degree three polynomial will have size if you fix them at random, essentially, you will have size probably 72. Instead, here, by fixing this polynomial correctly, we can get only 12. That is nice. Because you see, like, so what we want. So, as you see, like, so what we want really is to minimize the Galois group to obtain many totally split places. Okay, so let me just show you why this polynomial works particularly well. And I might not have time, but yeah. So, I start with this one. So, what is it? x minus ax square minus t. Now, I want to split this polynomial here. So, I get x. here. So I get x to the 3 minus ax minus square root of t x to the 3 plus minus ax plus square root of t. And now you see the you prove that the Galois group of this is S3, but since you have been you did you did right here to choose the polynomial, because now this polynomial is Is odd, right? So now when I plug in the function essentially x in minus x changes a root of this to a root of this, which is like exactly what we want. So now more in general, yeah, sorry, and then why is it the degree 12? Well, because it's enough to add the root of this one that are essentially gives you. That are essentially gives you an extension of degree six. But then, once I add the root of this one, I only need to add the square root of t because then the roots of this can be changed into the roots of this. Okay. Now, you can prove classification results. So, we denote by g n q the minimal size of a Galois group you can get from f minus t over f q of t of x. T over Fq of T of X with F of degree N, so this is an L, so that the asymptotic for the number of totally split places T0 is Q over Gn of Q. So we want, as we know, we want to minimize the Gallo. Well, of course, for N equals 2, I mean, this is just C2. That's nothing else you can get. In degree 3, you can get C3. C three whenever three divides either q or q minus one, that are essentially the case I mentioned before with the linearizer demonomial or six. And these are all the other cases. In degree four, you have 24 for q equals 2. This is highly uninteresting for coding theory because the field is too small. So this just to classify. So so this just just to classify like what what you can get, like the the the the minimal anyway, the Galois group you can get as order twenty-four over F two. But as soon as you enlarge slightly the the the base field then you'll get obviously the the trivial if you want cases with the x to the four and uh uh say uh x to the four minus x, you know, the the linearized polynomials. The linearized polynomials. And so these are Galois groups like either C4 or C2 times C2. Or otherwise, you get degree 8, which means you can always get D4. And we also saw how we do that, right? How we can do that from here. This gives always Q over 8. Okay. And then the degree five is one of the most interesting in my opinion. So you see, you can get C5 as Galois group if 5 divides Q times Q minus 1, as usual. This will always be there. You can get 10 whenever 5 divides Q. Whenever phi divides q plus one, and this is the case of the Dixon polynomial with Galois group D5, with the Dixon polynomial of degree 5. Otherwise, 120. So if you don't have these arithmetic properties, the arithmetic of the totally split places is Q over 120, which is a huge gap, which is a huge gap because. Which is a huge gap because essentially the asymptotic of the totally split place is either Q over under 20 or Q over 10 or Q over 5. And yeah, and this follows because 5 is prime essentially. So the subgroup lattice in some sense is terrible to do this thing. So either you have a strong arithmetic property or you stand no chance and you have to go with the worst case scenario. Scenario okay, and I think I reach. Yeah, these are a couple of references on this Galois theoretical approach, and I think might be done. Thank you. Thank you, Dachemo. Are there questions? So, if please feel free to unmute yourself. I'm also so I Also, so I yeah, in the chat, what we have in the chat is not a question. So please feel free to unmute yourself and ask a question if you have one. Otherwise, I will ask a question. Otherwise, I will ask a question. So, all the examples, all the results, the kind of like classification results that you had at the end were for small values of R, right? So, obviously, large R is less interesting, but how good is your technique for sort of moderate values of R, which are not that small, so that you cannot really kind of go through and Really, kind of go through and do a case-by-case analysis, no? So, I imagine this last results are obtained. I mean, I'm sure there's something to prove as well, but like maybe you can, since you have a small R, then you can kind of go and do a few cases and then analyze all the situations, no. But what happens if you have a larger R? Yes, so the situation is essentially as follows. The bottleneck. The bottleneck is not really finding the candidate groups, but the problem is that is to realize it as Galois group of something of a very special form. So like for higher, in higher degrees, in my opinion, it should always be possible to do it with R when R plus one is prime. Because in that case, the subgroup Lattice is essentially over C. Platis is essentially oversimplified because essentially a transitive group of SP is also primitive. And so this means that if you just add a transposition, you're going to get the full SP. So this is somehow like these cases one should be able to say something strong on this. For all the composite. This for all the composite ones, uh, I expect the one of the form SP to the n to be difficult. Um, yeah, yeah, so you need, so if you if you want to deal, if you want to deal, for example, S6, for example, is super easy because, in some sense, like you don't need to classify all the possible groups that can occur, but you only need to classify But you only need to classify the smallest one that can occur. So, yes, you have to, I wouldn't expect like you to have a result like for all n, you know, like this is the best you can get like for all n, or this might be possible only if n is or if n is prime. Yeah, I wouldn't expect that, but for any fixed n, the subgroup lattice is. The subgroup lattice is not that difficult. These are only the difficult cases in some sense. Sorry if I took longer than I said. No, no, sure. No, I was. I was thinking what I would think. So I think we have one more question by Emina. So thanks. And maybe I let Emina speak. Yeah. So thanks, Giacomo, for this talk. I am interested actually. I am interested actually in the entire spectrum of these recovery sets. Is that something that you or anyone in the community looked into? The reason I'm interested is because of a problem that we are working on with Alberto Ravagnani and Janeira and Altan, who are, I believe, on the participant lists, which comes from a different practical problem. From a different practical problem, but can be seen as a generalization of locally recoverable codes. So you said we are looking to find small R's, but how about finding a spectrum of R's? What do you mean exactly? I mean, I want to find all recovery groups for a given code, for example. Or to construct the code which has some kind of a A list of possible groups that are good for me. Let me think. So I think you'll need some. You probably need an interaction, but if you want to use this approach to If you want to use this approach to do this kind of thing, you need an interaction at the level of different splitting fields, probably. But I have to think it through because I have to think it through because, you know, also for a Because, you know, also for like availability, like this method is not great because for availability, for example, you have that availability essentially, the only way to make availability arise is essentially with arithmetic condition. It's more complicated to let it arise from density condition. So I'm not sure, but I'll think it through. That's good to know. That that that's good to know. Yeah, that availability is not because I for us it's kind of essential to have availability. And I don't know this literature of LRCs sufficiently, so that's why I yeah, I mean I never thought it like too long about it, but you need an interaction like for to obtain availability, you need an interaction between the splitting field of f f of x minus t say for some x. f of x minus t say for some f and g of x minus t so you need that that these two have some kind of algebraic property that connect them they cannot be correlated they cannot be that the compositome of these two is m1 m2 and this has degree degree of m one times degree of m two this is not going to give you availability because the your locality set are gonna be mixed because we obtain them by a density result. them by a density result which can be a pre which can be precise but then you you also need the interactions between these two yeah but if you send me something I can look it uh through thank you I'll actually give a talk on Thursday about oh brilliant brilliant brilliant thank you come thank you wonderful so um unless there is a very short one minute question we can Short one-minute question, we can. Um, yeah, yes, even here is a question. No, I want to pick up. So, hi, Giacomo Emina. Um, Emina, is the question you ask, is it about the distribution of minimal code words in the dual code? Recovery set is like a minimal code word in the dual code in the sense of messy exactly. So, that probably would be helpful. Uh, and uh, and this recovery set that's a difficult problem, right? Yes, so. Yes, so you know, but we can always limit here. We are looking only at minimal. Maybe we can look at some at a specified lens or some that overlap in a certain way. Yeah. Yeah. So that's that would be interesting. But yeah, so it sounds like a problem that goes in the direction of matroid structure on the dual code. Correct. Correct. Dual code, correct the correct method structure, right? Okay, yeah. So, okay, I'll finish before the break, so I'll stop here. Thank you. You'll have chances to talk about this later, no doubt, in all the gathering rooms. Yes, yes, exactly. So now we have a half-hour coffee break, and I invite everyone who is interested to chat with others during the break. With others during the break to connect to Gathertown, Felicia put the link again with the password in the chat.