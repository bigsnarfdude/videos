In the face of product returns. Okay, so at a high level, you should think about, we're going to have sort of two phases here, very similar to consideration set formation phases. And I'll sort of actually talk to you about the connection between the two. But here, what's going to happen is you're going to look at what's offered, whether it be on a website or in a store. You're going to decide what to order. And I'll formalize sort of how you make that order decision. So you're going to order some subset of the offered products. Of the offered products. You're going to try them all out, and you're going to keep the one that gives you the highest utility, and you're going to return the rest. Okay, so we're going to have sort of this two-phase model. First, you order, then you purchase. Everything is going to be based sort of on MNL-like choice probabilities. But we're going to have two sort of different models for how you do that. One is going to be a bulk model, where you order everything at once, try everything at on, return the rest. The second one is going to be a sequential model. You buy one thing, try it on, decide if you like it, exchange it. On, decide if you like it, exchange it, and go through sort of this optimal stopping time problem. Okay, perhaps surprisingly, perhaps not, there is going to be close connection here to browsing. In fact, one of our models is going to be almost exactly like browsing models in the literature. And I'm even going to touch upon a little bit of an extension about reusability. Okay, so I'm going to mention briefly some work that we're working on right now that has close ties to product returns, might answer one of your questions, and also I think is a really interesting sort of. And also, I think, is a really interesting sort of extension of the classic notion of reusability that a lot of people in this room have talked about. Okay, this is joint work with my former student, Shinka. All right, so I'll talk for a good chunk of the talk just on the two models. Okay, the bulk model, again, you're buying everything at once, you're ordering everything at once, trying out, and then returning, versus the sequential model where you do things one by one. So I'm going to have N products. Colored N will be: I offer it. Colored in will be: I offer it. Just for the sake of sort of deriving the models, at least the sequential model, which I'm going to start with, let's assume just everything's offered. As I mentioned, there's going to be this two-step choice process. At a high level, customers are going to associate this classic sort of deterministic component plus random component with keeping product eye. And just like in a lot of the browsing models, we're going to assume this is available to you. So the deterministic component is available before you order. Before you order. But you only learn this once you order and you try things on. So this is sort of a standard assumption. I'm not going to, you can basically assume this is complete. Let's just assume this is complete for now. I'm not going to get into the details of that, but let's just assume it's complete. Okay, so as I mentioned, there's two phases. In the first stage, you make an order decision. So again, you only observe the deterministic components, and you're going to choose which products to order based on maximizing the expected utility. Maximizing the expected utility of the one you keep. All right, so a natural question here is: why don't you just order everything? Well, we're going to assume that there's a disutility of return. So, for example, if I order five items, I have to return four. But the more I order, the more I have to return, the greater disutility I experience. So, you're going to see a disutility of return in the second stage, right? After you order, you try everything on, you learn the random components, you keep the one with the largest utility. You keep the one with the largest utility and you return the rest. So for each one you return, we're going to assume you experience this disutility of F. You can think of F as a disutility of like repackaging it, the time it takes to try it on, the money you lose from not getting your money back right away. So F contains a lot of different things, but we're going to assume it's not product the same. Okay, for now I'm going to talk about single-type models. The really interesting combinatorial The really interesting combinatorial aspect of the problem comes about when you have customer types distinguished by different F's, and I'll mention that at the end. That's really sort of where things get interesting. But for now, I'm going to assume every customer has the same F. Okay, so the first model is a sequential model. And this is not my model. This is a model by Laura and Victor in this 2020 OR paper. So essentially, what happened is I read this paper and I thought, okay, so point. And I thought, okay, sequential, that's sometimes how people do things with returns. But personally, I buy everything at once, try it all on, keep the one I like, and return it. So that's you're like, okay, can we build from the same model primitives as a sequential model? Can we build a bulk model? And then can we then compare the two? So you're going to see we're going to eventually compare the two. All right, in terms of revenue. So here's how the sequential model works. Again, assume we've offered everything. And we're also going to assume that the products are indexed and reached. That the products are indexed in decreasing order of these V odds. So, in the sequential model, essentially, the customer solves this optimal stopping time problem. And I'm not going to prove this. It's pretty obvious to see that they should sort of proceed this way. They should start, since this utility is the same for every product and every product, they should first order this one, see if they like it, then order this one. The question is sort of when they should stop. Yeah, it's IID, exactly. As long as these are IIDs, it's pretty obvious that you should. As long as these are IIDs, it's pretty obvious that you should proceed in that order. Yeah. Yeah, yeah. Yes, yes, that's okay. Exactly. In the bulk model, you're going to do the same thing. Okay. It's very similar to Nagin and Vihide's paper, and I'll make that reference in a second. So the sequential model is essentially going to be, if you've seen Nagin and Vihide's Learning Ranking on Platforms paper, the sequential model is almost the same. Okay, it's almost the same. Same. Okay, it's almost the same. Okay, so you can think of it as the customer solving this DP, right? The stopping problem DP, where before they've ordered anything, they think about stopping and not doing anything, obviously. That gives them a utility of zero. Or they could order product one, in which case they'd get the maximum of either keeping the product or returning it and incurring the disutility of F, and then going from product two to F. So this is like the maximum utility I could get having not ordered. Utility: I could get having not ordered any after I order product one. This is the maximum utility for product two and on. Okay, so let's just say this is higher. Okay, so then I'm using notation a little. This is the random variable, this is the realization of the random variable, so I'm using notation a little. So, here they're doing this expectation. Here, they realize the full utility. And so, then they compare this, which they've realized, with this return. Let's say they return it. Let's say they return it. So then they move on to the same question with two to end in front of them. They say, Should I stop or should I order product two? Okay, let's just say they order product two. Then they do the same comparison. They realize you two make this comparison. Let's say they keep it and then they leave. They end their search process. Okay? Quick comments. Even though this is kind of a sequential model, you can really think of it as a one-shot random utility model. Shot random utility model because in Pandora, you know, basically the item selected is the one that has the maximum capped value of the largest value. Yeah, so that's going to come about random utility in disguise. Yeah. Kind of like your model when f is zero, but then the distribution of the low utility. And that will come out when you write the choice problem. You could think of it essentially like an M and L model with a cutoff, essentially. Yeah, that will. So this is their theme. They very nicely characterize two things. So I'm going to put these two things up. The first thing is: when do you stop? Is when do you stop? Okay, and it's this critical product LQ such that this is the maximum L where the weight is greater than this term, right? Since the weights are decreasing, well the weights I'm saying is just e to the guy, by the way. So since the weights are decreasing in the index, right, this is like some threshold stopping point. What is f? So f is the deletion of returns to the A. And then, so for every product in And then, so for every product indexed lower than this, you get this choice probability, and everything indexed above, you get choice probabilities. So, this is actually very natural, right? So, let's assume I've just offered one, two, and I. This looks very like the M and L, very much like the M and L model. So, if F is zero, it is the M and L model, right? If F is zero, there's no disutility of return. I should just order it, right? If F is not zero, what is this turn? I essentially get a deflated W y, deflated by how many. Deflated by how many products I have to return. So if I keep product I, it means I've returned these two. The cardinality of this is two. So I essentially just get a deflated M and L weight based on how many products I've returned. So sequence is exogenous here? The sequence that they order? Yes. They do it optimally. So since this is the highest weight, that's the lowest, and since these are IED, you'll naturally progress from the first to the last. And that's the effect of minimizing with the reservation value that you defined. Yeah. So, a couple things, right? This is assortment independent. Okay? And this is a sort, the weights at least are assortment dependent. So, like, the magnitude of this weight, the magnitude of I, right, if I look at this whole term, is a function of how many products I've offered with higher index than I. So, the stopping point in the sequential model is going to be assortment independent, but the weights. Dependent, but the weights and the choice probabilities are going to be sortment dependent. And the opposite is going to be true in the bulk models. Okay? So again, here's a natural extension to the bulk model. Question? Oh, sorry, maybe you don't have to get. No, I just said there's, there's, to me, there's like another model where you can sequentially decide what to buy, where you don't have to return revenue. Like you can buy, see, if it's good enough, you just buy and keep. But you can buy another one, but if you have a low realization, you can return that one. Low realization, you can return that one instead of your original one. But like I'm saying, their model doesn't allow this, right? Yeah, their model is not. Yeah, you can't go back. You can't go back in there. Okay, that's fine. So yeah, so that's what I was going to also ask. So meaning, so it's not like this, like there are all these online search papers, right? Like wherein I evaluate, keep evaluating, and then the search cost. And then after the process, I pick the one which is the best of the ones for the evaluator so far. For here, you cannot go back and order. You cannot go back and order something. You hadn't come. Yes, and the bulk model will be that model. The bulk model will be a model where you search sequentially each time. You can think of, so the notion of returning is the same thing as a search cost. Exactly. It's the same thing. You'll get, what I'm going to say is you're going to get AusGA and Fusion's model. It's going to be slightly different. And actually, that slight difference matters when you move to multiple customer types. When you move to multiple customer types. But you could essentially think of it as clicking and learning about a product is the same sort of, and paying that search cost is the same thing as ordering and paying for turn cost. And this book model is going to be the same as that model. Almost. So yeah, in the book model, let's just say I've offered one, two, and three. Okay, what you're going to do, and to derive this model, it actually helps to start from phase two. So I'm not going to, I'll first assume you just ordered one, two, and three. Ordered one, two, and three. And you're going to get something very like M and L. And then we'll move back and say, how do I actually order? So for now, assume just you've ordered one, two, and three, you've ordered everything I've offered. And here's the utility for keeping each of the products. If I keep product three, I get its utility, and I return these two. And that's what this is just. If I choose the no purchase, I get zero minus f times three. So this will evaluate to f times three, because you've returned all three. And then you just, is this going to be true? Okay, and then you just, it's just going to be traditional ML. Okay, so if I keep product I, I return everything except for I minus one, sorry, the cardinality that I ordered minus one. If I keep three, I return two. And I can just normalize this to get something like this. So here all I did is multiply by e to this negative f term on both sides. You get something like this, where this is the total weight of the order set. So this is essentially an MNF model with this, with this. With this no-purchase option. Okay, so how do they order? Well, they choose the order to maximize their expected utility. So they're going to choose the order set to be a subset of S that maximizes the utility of the one they keep. So it's well known that this expectation has this log form. Okay, so they're going to choose O to maximize this log sum right here. And what we show, I'm not going to go over this, there's some critical threshold L of. There's some critical threshold L of S, such that the order Z is S intersect the first L prompts. So L, this is like our stopping point. This is like our stopping point in the full promise. Okay? I'm going to put them side by side in a second, just so you can compare them. And this is the same threshold that Osgam shouldn't hit. So this is why it's essentially the same model. Okay, so let's compare the two. So again, as I sort of foreshadowed, over here, we have an assortment. Out over here, we have an assortment-dependent stopping point. Okay, so where you stop and how you order is a function of the assortment, but your choice, the weights and the choice probabilities are assortment-independent. This is a function of the assortment because you sort of, the S gets filtered down to the O of S in the numerator, right? You might offer something and it gets filtered down to this O of S. You might not order, they might not order some products that you offer. Okay? So, again, just to So again, just to sort of juxtapose, right, we have here is the stopping point for the sequential model. Again, assortment independent or sort of an dependent. And this is greater, L of Q is greater than L of S. Right? Why is that? We have this term and this term. And this term is positive. This term is positive. So this right-hand side, this threshold is going to be greater than this one. So if I offer the same assortment, the sequential model is going to go further than the bulk model. Model is going to go further than the bulk model. And then we have the choice probabilities over here. The weights are assortment independent. Here, the weights are assortment dependent. And these are going to be sort of the difficulties that arise. Those things I just mentioned are sort of why the assortment problem is non-trivial, even for single types. So this is very similar to this paper here. There's some slight differences. There's some slight differences, which I'm not going to go over, but essentially, you could think of this browsing model where you click on a product, you search hotels in Banff, you look at the results, right? You click on the top product, decide if you want to purchase it or not. If you don't, you move to the second product, you click on it, you decide if you want to purchase it and move on. In this one, you're sort of like right-clicking, opening a new tab, all the ones you like. Then you're going back after that and actually looking at the hotels and picking one. The hotels and thinking about it. Okay, and that's sort of like Russian and Osgi's theory. Okay. So the one difference is that when we introduce multiple, in this paper, when we introduce multiple customer types, this no purchase weight is going to be a function of the customer type. It's going to be e to the negative fk, where k is the customer type index. And that's actually going to matter a lot, and I'll say a little bit why that matters at the end. In this paper here, this is just w naught. Just W naught, okay? Even if you have multiple customer types. Why is that? Well, in our model, if you order five and keep one, you're going to return four. In this model, if you click on five, you pay the search cost for all five. Okay, so essentially there's like one difference which causes the no purchase weight to be a function of the customer's. Okay, so we're going to think about the assortment problem without return costs. Without return costs, we also look at with return costs. So, meaning there's a refurbishing cost, right? If you return four products, the store actually has to refurbish them and pay a cost. So, the more you return, the higher the refurbishing costs. But right now, I'm just going to think about the assortment problem without refurbishing costs. So, F is the cost. I think it was set by the I could say that this is. Could say that this is the return cost you have to pay. So, I mean, it is a cost that the customer is paying. Oh, okay. This is an extra parameter I'm not even talking about. So, yeah, so this would be in the assortment problem. If you return four, you pay four times the new parameter C, let's say. Does that make sense? I'm saying from the firm standpoint, I decide not only S, but also the return cost. I could, I guess. Oh, so return cost, I'm thinking about when you would. So most places make this free. That's cost. But most places make this free. That's cost uh so I didn't talk about like why returns is are so important and in the paper we do, but most people are making this free and then they're actually having to pay the refurbish. You have to they're paying for your shipping costs essentially. No, no, no. So I guess the F, right? Yeah. The customer is paying. Yes. Right? Like I can, there could be many components. One component of F would be what I pay to the firm to return a product. Sure, sure. I get only like 30%. Yeah, that could, the higher the more I have to pay, the more difficult. The higher I have to pay, the more disutility. That's what. But there's also a disutility in returning, right? Like a personal disutility, personal friction. Exactly. That's multiple components. Yeah, yeah, yeah, yeah, exactly. That's inconvenient. Plus, what I paid to the one thing I don't love about this is that in the bulk model, the return to the utility is linear enough. I think it should be maybe concave, or you have maybe a fixed cost. Or you have maybe a fixed cost, like if you return one, the most annoying thing is returning it to the store, right? Packaging and returning. And then there's also sort of for every extra item, you had to have tried it on, right? So there's a little bit of this utility. So ideally, this would be sort of concave or something, concave increasing, but I think it's reasonable to assume it's linear, and then we can compare the chip models, right? We're going to get a very sort of apples to apples comparison between the two models. Okay, so let me just quickly say about this working paper. So obviously there's no inventory either, right? So, obviously, there's no inventory, right? We're thinking about a static assortment call. What I think is a really cool extension of reusability, and it has applications and product returns, and every paper about reusability, Mika's, Rad's, Wills, Venice, Rajans, right? The fundamental assumption is when I use a product, it returns back as itself. But if you think about returns, as I just mentioned with return costs, you could have a scenario where you return a product, which is reusability, but it comes back and done. But it comes back, and it comes back and comes back as a used version, and then I discount that. Or you can imagine I return it to a different store than I bought it from. So here we're looking at a notion of reusability, where when you return a product, it doesn't come back as itself. It comes back as a different product. And what we can do, if you're familiar with Omar's coordinated inventory paper, we can extend to sort of, we can extend the Samadhi there. Sort of, we can extend the submodularity result to arbitrary networks. What's interesting also here is that greedy becomes trivially arbitrarily bad when you have a network, and the CDLP becomes the traditional CDLP becomes arbitrarily bad. It's pretty easy to choose. So that's something that should be even with like two node networks. It's pretty easy to change. So you get sort of this, I think this interesting extension, and we haven't fully resolved this by any means. Okay, so we are going to think about, though, just the static problem. I just the static problem. Okay? So the first natural question is: like, which one of these two models is better? In other words, if I solve this assortment problem and I look at the optimal expected revenue and sequential, and I solve the bulk one and look at the optimal expected revenue under bulk, can we show generally that one is higher than the other? And if we can, that sort of shows you how firms should encourage, what sorts of return behavior firms should encourage, right? Doing things like saying you can only return a certain amount of money, making returns easier, so you're more likely to do. Returns easier, so you're more likely to do things sequentially. So, what we can actually show is that sequential is always high. And that's true with return costs as well. So, we can prove that the optimal expected revenue here is always greater than E. How do we do it? We take the optimal expected revenue here and offer it over here and show it does at least as well as what it would do over here. Pretty much like complicated non-adaptive policy with adaptive policy for that's in how they choose, though, but it's hard to. Though, but it's hard to see. This isn't too hard to see. Basically, it's like here you get an ML model. So, you're thinking about that alternative. So, it essentially comes down to the fact that, like, this actually isn't, this, anything you offer over here will be ordered over here because this threshold is looser than this threshold. So, you can sort of ignore what happens in the search. And then, this is essentially an M and L model with higher preference rates. That's the high-level intuition. It's actually counting. Because first the customer thinks we're smarter on the sequential model, but then you turn out to extract more numbers. The output is clairvoyant, like the customer knows the localization not. That says the output and model customers garner higher sequence. They have higher utility. Yeah, they definitely would get higher utility over here. Not under the optimal assortment, though, necessarily. Yeah, yeah. For the same assortment, for the same assortment. Yes. Okay. Okay, so again, so I think. Okay, so again, so I started by reading this paper and thinking, okay, I think I can prove a couple more things. So I'm going to briefly talk about some results that I can show that are not in the original paper. Very quickly, they show a p-task for this problem, or an F-P-task for this problem. You can actually write this problem as a polynomial-sized LP, polynomial in the number of products. So we can solve this assortment problem, which is just an LP. So naturally, the question is, and that's with return costs as well. Natural question is, is this actually harder than M and L? Harder than M and L. Okay, so is this sequential model even harder than ML? And we can answer that pretty strongly. So under M and L, we know TU constrained M and L is solvable in polynomial time. What we can actually show is you can't do any factor alpha greater than zero with TU constraints under this model. You can't do any factor. It uses a reduction to the decision click problem. The intuition is that, like, in click, we have a click of size k that has k choose two edges. K choose two edges. A click of size K as K choose two edges. In my returns model, if I look at how many pairs of purchases and returns, if I purchase product three, I've returned one and two. If I purchase product four, I've returned one, two, and three. Five, one, two, three, four. That's also, if I offer K, that's K different, that's K choose two different combinations of bought and returned. So that's a very high-level intuition for the reduction, but it shows it's. This shows it's a lot harder, obviously. Okay. Okay, so what can we do for our model? Again, I'm just going to talk about the single-type model. So, where we only have one FK, I'm calling E to the F, this is E to the negative F, I'm just calling it W naught. So, in the multi-type model, this is W naught K. Okay? Okay, so we first showed this is MB hard even without return costs. Okay, so even if you don't have the return costs, which is the problem. Even if you don't have the return cost, which is the problem I formulated, this assortment problem up here is NPR. So, where does this hardness come from? It comes from the filtering down from S to OS. So, let me sort of walk you through that very quickly. So, let's say I offer these products. Let's think about determining this L of S, right? So, again, they're going to order some nested set. So, our first C, is this L of S? So, this is the check I do. That's exactly this condition up here. That's exactly this condition on here. Is w1 greater than this? Let's say it is. So I move to 2. This is the new check I do. Let's say yes. This is the new check I say no. Right? This isn't satisfied. So LS is equal to 2 in that case. So they're going to order these two products. So it's pretty obvious to see that offering these two and offering everything that's in blue gets you the same revenue. Right? So R of S is equal to this, which is equal to this. I'm going to use rho i for r i times w i. rho i for ri times fy. So what I can think about is I can rewrite this assortment problem as a standard assortment problem with the added constraint that OS is equal to s. It's the same thing. In a single type model, I shouldn't offer anything that's not going to be ordinary. That's just what this is saying. And that's where the hardness comes from. It's satisfying that constraint. Okay? So very quickly, I'll show you just how to solve this. This is actually repeating Osge and Rushin's argument. This is the same argument they used, so this isn't anything new. This is the same argument they use, so this isn't anything new. Again, we adapt it to account for return costs. So we add the return cost in for the single-type model. Okay, so let's say this is the optimal sort. Okay, this is the problem I want to solve. Again, the hard part is this. First thing I'm going to do is just guess this last product. So I'm going to call L star L of S star for short hand. So now I know the last product ordered in the optimal sort. So what does that mean? I don't know what happens over here, but I certainly know these. Over here, but I certainly know these can't be offered. So I'll delete those. Okay? Now, what I'm going to do is just focus on these ones. What do I do? I'm going to solve like a dual knapsack problem. I'm going to minimize the total weight over these products, subject to getting at least the row value. This is at least the, when I don't count L star, this is the row value that the optimal assortment gets. If I could solve this problem, I'd be done. But I don't know this. So what we show, I'm going to hand. So, what we show, I'm going to hand wave a little here, is you can solve this with a 1 minus epsilon factor. It's just traditional sort of Napstack guessing ideas. So, I can solve this problem optimally. So, what does that mean? Well, the optimal assortment is feasible. So, I get, let's let S hat be the optimal solution here. Blue is the ones that the NAPSAC gives me, and then I also offer L star. This new assortment S hat has smaller weight. Why is that? S star was. Weight. Why is that? S star was feasible here. It gets at least a 1 minus epsilon fraction of the row value. So this is true as well. So then the revenue is good. The revenue is good. It's at least 1 minus epsilon as long as OS equals S. So why is OS equal to S? Well, we know this was ordered in the optimal assortment. So this is true. But we just have to show this was ordered under S hat. Why was that ordered under S hat? Well, because of this. So I can replace this star with a hat. Replace this star with a hat because they both offer L star. So this is bigger than this, and this is exactly the condition that L star will be ordered under S hat. Okay, so this shows you OS equals S. Okay? Very quickly, I'm just run through this. If you have multiple customer types, this is really the interesting part. If you have multiple customer types, how do we solve this problem? Again, now it's not like you don't have OS equal to S, obviously. You don't have OS equal to S, obviously. Because like this product, these two are ordering, and this one is not ordering. So here's what we can show. So if the customer types are indexed in decreasing order of F, you get these nested sorts of order sets. And these are the arrival probabilities of each customer type. Okay, so if this no purchase weight is dependent on K, we can do log N. If this no purchase weight is not, like in OSD and Ruchi, Weight is not like in Osby and Roushey's model. So it's just W naught, we can do a constant factor. Okay, intuitively, why? Why is that? Why does this matter so much? If this is just W naught, basically at a very high level, the revenue, RK, so the revenue as a function of the customer type, is increasing in the customer type. Okay, when this is a function of K, it's not necessarily. So at a very high level, that's the one little algorithmic insight you need to prove the constant value. To prove the constant value, you critically need that the revenue is increasing this way. You need something, you need a lot more than that, but that's like the starting point. The notation omega here is lower bound. Yeah, lower bounds. Is this being cost? You can do one seventh, one seventh. Yep. Okay. So, yeah, so a couple of extensions, as I mentioned, right? Not having a linear return. Not having a linear return and then just utility, I think, is important. A completely different problem, you see a lot of these free shipping thresholds, right? So you like, if I order at least $100, I get free shipping. So I think, how do I do assortment under these sorts of thresholds is an interesting question. How do I design that threshold is interesting. And then obviously, just sort of more on this idea of network reusability. Again, we essentially can only solve the problem when you have like for each product, you have like new. For each product, you have like new goes to used, goes to like worn, goes to like can't use. So like you sort of have like line graphs or something like that. When you have general networks, we can extend the submodularity result, but we don't know about the gap between the LP and the alpha calls. Okay. So we do have a minute for a question or two. For a question or two?