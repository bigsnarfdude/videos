I think it's anything like that. It's a minimum. So the last talk of today is by John Sunich with the long title, so please. Okay, thank you for sticking around. It's been a long day, I hope. So let's finish in half an hour then. I'll be talking of course about the spectra of iterated polynomial groups of critically fixed polynomials, what we call the spectra of the shared graphs. Most of the results are due to two groups of people. One is involving Slava, Polucia, and me, and the other is involving a huge group of undergrads. Involved by a huge group of undergrad students. There was this interesting program in 2021 because you couldn't have these REUs on site. There was this huge LSF supported initiative where we had undergrad students from all over the world participating. And I've got this group of 20 or so students who worked on these kind of questions. Basically, general. Basically, generalizing whatever Slava, Volodya, and I did for one example, generalizing to more examples. Now, everybody knows this nice little things, like if you have nice polynomials, such as that one, cubic polynomial, 3z minus z cube over 2, you take a random point in the plane and you start iterating backwards because this is a third degree. I mean, the first time I put it. I mean, the first time I do it backwards, there's three pre-images, and then nine pre-images, twenty-seven pre-images, and so on. As I go backwards, I get some very, very interesting set. And of course, that set is known as the Julia set of this polynomial. Now, okay, you can do it, if you can do it with any points, of course, you can do it with any set. So instead of doing it with a single point, I will do it at least two loops: the blue loop and the red. Two loops, the blue loop and the red loop. And I will take backward iterations of those two loops. And this is what happens the first time. Of course, this points denoted by 0, 1, and 2 are the pre-images of 0. And then the blue loop will have lifts starting at 0, lift starting at 1, and lift starting at 2. Okay, and similarly for the red loop, so I can continue again lifting these loops further and further, and that's the kind of pictures I'm getting. So, of course, this is, I don't know, the fifth or sixth iteration. In some sense, this is much nicer backward iteration, because in addition to approximating eventually the actual Julia set, it also tells me the blue look, you see, this is a blue region. Look, you see, this is a blue region, and this is a red region, and this region is red, and so on. And those regions are precisely the basis of attraction for this critical point and this critical point. They are both super attracting. So, anything that is in a blue region will jump around when you apply the polynomial and eventually end up in this particular component and then be attracted to this guy. The point of both of these critical Point of both of these critical points are fixed. So, this is an example of what we would call critically fixed polynomial. So, this is a polynomial of third degree. Critical points are points where the derivative is zero. Those are points such that when you apply the polynomial f, the critical value does not have three pre-images. In that sense, In that sense, they're telling, that's why they are critical. They are describing the places where this map, this polynomial map, is not 3 to 1. Okay? Anyway, and of course the white points, the points outside of this field in Julian said, go to infinity. I can find that polymer. Alright, so for now, these are just loops, but later there will be something different. So I need to. So, I need to define this monodromic group, an iterative monodromic group. The notion is due to Volodymyr Kashevich. It's very general, but let's not try to be very general. It's sufficient to just get the feel for it. And in particular, on the Riemann sphere, it's very, very concrete. Anyway, in some generality, you can think of, let's take a covering of M0 by M1, D to 1 covering, so it's a. One D to 1 covering, so it's a finite covering. Take any point in this space and lift it. You'll have D preimages. And then any loop based on that point D that you had here, well, first of all, the base point here will have D preimages. And any loop here will be lifted into D curves. That beginning at every At each of these three images. So it leaves to all these paths, and then you can define a function that says, well, that loop acts on these preimages simply by saying A of the preimage TX is the end point of the lift of the loop A that starts at the point Tx. And that's well-known notion, it's a monotonous reaction of this gathering. Of this covering. Yeah, that's the model. So I have a simple picture. If this was some kind of seven-to-one covering, here's some loop in this space. You lift it. That's how it lifts. And this, of course, defines certain permutations. That I recorded here. You need 0 and 1 are permuted by A. 2 is fixed, 3 is fixed, etc., etc. Etc., etc. Standard monotromy, actually. But the point is, well, yeah, here's a more concrete example. Here I have a 3-to-1 covering. The topological space here, just think of the graph itself as a topological space. The covering is delete the last digit. So from here to here, I have a 3-to-1 covering such that when I delete. Such that when I delete each of the last digits here, that's how it goes. So this goes to 2. 0, 1 goes to 0, etc., etc. And you can quickly verify that this is indeed 3, 2, 1 covering. And if I think of this as being my base point here, that point is lifted to the points 1, 0. So 1, 0, 1, 1, and 1, 2. Those are the three lifts. And then I can take any loop here. I can take any loop here. Let's say I took the loop AA. So AA, oh sorry, AA is a loop in this space, so I can lift it. What happens here? When I apply AA, 1, 0 goes to 1, 1. When I look at the lift of that loop that starts here, AA sends 1, 1 back to 1, 0. So that's what I'm going to do. And the third lift of this guy was 1, 2, which is right there, and the loop. And the loop AA lifted will just fix that much. And so you can take now any loop here based on one, and you can lift it, and you can calculate what exactly does it do in here. So you have to commute things somehow. Okay, and then more generality, imagine that M1 is a subspace of M0. If you have such a finite If you have such a finite covering, then you can continue lifting. The first time you lift it, you're fine. But if this is a subset of M0, then of course you can continue lifting. Nothing prevents you. And you can create this tree of pre-images of your base point, your base point from M0. So you have entire rooted tree of uh degree D, exactly the degree of the cut. Okay? Degree of the cover. And you can play now this game in iterated monogrammy fashion. You have your loop in the original space, you lift it, maybe it doesn't permute these two points, who knows? But now you can lift again, and then it permutes these two again, and so on. So that's the iterative reaction of this loop on this tree of K images. K will act by three automorphisms because it has. Quite true automorphisms because it has to preserve all these coverings. So, in that way, any element of the fundamental group of this space acts on this three of green by three of the morphisms, which is what I've got here. And what is called iterated monoframe group then is the fundamental group of that original space m0, and then mold out the kernel of the actual. And then mold out the kernel of the action of the preempts. Because some loops, some loops will actually never move anything. You can leave them all you want, they will never move anything. You're not interested in that, you want what is left, that's an integrated problem. Okay? Now, in this silly example, you can kind of continue. Continued. Here's a 3-to-1 covering of this guy, and I can make a 3-to-1 covering of that one with larger and larger graphs. And you can do this game of iterating modeling. All right, so now, a very nice source of examples for these kind of things come from post-critically finite polynomials of degree D. If the degree of the polynomial is. D. If the degree of the polynomial is d, then eventually this tree that we are acting on will be of degree d as well. So here is some random example. Here's a cubic polynomial. You calculate derivative. You have two critical points, 0 and 1. And then you check what happens when you apply F to those. 0 goes to 1 half, and then 1 half goes back to 0. So your forward organ got closed. That means completely. Starting at the critical point zero. This two here means that, okay, remember what I said before: when you have a critical point and you map it by f, this is a point that doesn't have enough pre-images. This will not have three pre-images. The pre-images of this one are zero twice, like a counted twice basically. And then one more point, I don't even know what it is, it doesn't work. I don't know what it is, doesn't matter. So this point will have exactly two p, which is zero count kind of twice, and then one more and more. Same story here, the other critical point, when you push it forward, you get negative one half, which is actually fixed by this polynomial, so that's it. This is positively finite polynomial because all the critical orbits, form of orbits, were finite. That's what it means to be positive. That's what it means to be post-critically finite. And like I said, this looks like three-to-one covering of the, say, complex plane, except this point is bad, doesn't have three pre-images, this point is bad, doesn't have three pre-images. So what you do, you remove them. You remove the any point that is in forward orbit of this bad uh point, okay? point. So you remove the points one half, negative one half and zero and that will be your space M0. So M0 is the complex plane which removed three points. M1 will be, well, now any other point in the complex plane has three premiums. So if M0 is this, then M1 will be well. And M1 will be, well, as I say here, just F inverse of M0. And that will be whatever. Some finite set of points. And there you go. You have perfectly good covering from a subspace of M0 to M0, which is 3 to 1 everywhere. And then you have exactly. Exactly the setting of the definition for iterated monogrammy group, and you can define it, calculate it, and so on. Now, polynomial is critically fixed if all of its critical points are fixed. That's our definition. The simplest example, of course, would be uh z goes to z squared or something like that. But definitely critically fixed polynomial. The only critical point is zero, and it's fixed. Point is zero, and it is fixed. For the purposes of this game of iterated monitoring group, you'll have to delete zero from the complex plane, and then the map z goes to z squared will be double curving of one's punctured plane. In the previous example, you will have three times punctured plane. The fundamental group will be three groups of rank three, but then details it will be grouped. But then details it's not only group, but if we group mode out something, so it will be some tree-generated group acting on a ternary tree because our polynomials don't begin. Alright, so what happens near this? So here's an example of another critically fixed polynomial. The critical points are 0 and 1. What happens near 0? Well, here's a circle. Well, here's a circle, and when I apply F, this blue loop is the image of this loop. And this loop is just going four times around the critical point. And this attracted to it. Remember, this will be super attractive to this point. If I, yeah, this is like one quarter and then another quarter. Further, and another. So it will go four times around. To illustrate, if you take a smaller loop around this critical point, this one, then its image is this one, so it will be closer and closer. So as you get closer and closer here, what your function f is doing is it's wrapping this locally four times around. It actually behaves exactly as z goes to z to the fourth loop. z goes to z to the fourth will be shaved near zero. Okay? Sure. And similarly, what happens near this other point, other critical point? Well, if you rewrite the original polynomial in terms of, you expand it in terms of z minus one, then you see that this term is the only one that matters. Basically, why was 4 important there? Well, near 0. Near zero, uh, you can ignore the rest of them. This term dominates, so that's why the function behaves like z e goes to four and route things four times around near this point. For the other point, well, that's behavior near one, but when you rewrite your polynomial near one, then this term dominates, and therefore your f will behave like z goes to z cube near that other point. So it will run. That other port. So it will wrap things around one, three times. Okay, and as I already said, this is the simplest scenario. Z goes to some power of Z. There's only one critical point, zero. And there's only one interesting loop that you can lift. So take the unit circle, start lifting. So this is the picture stuff where z goes to z squared. And of course you will be getting these kind of pictures. Pictures. Okay? So you can sort of see these are the shared graphs of the action. Okay? Because that's exactly what I was doing. Here's the only loop that matters in this once punctured plane. And I start lifting it. These vertices are the pre-images of my base points. And this is a lift of this loop, and this is another lift of this loop. So this loop, when it tacks on the first level, just preview these two. Just premute these two. On the next level, it secretly premutes the four pre-images. On the next level, it secretly premutes the eight pre-images, etc. etc. So the Schware graphs, the graphs of the action of my loop on the T, at every level, they're a pair of circles. And in some sense or quite those circles approximate eventually the Julia set of this map, which is, of course, a circle, the unit circle. So that's the theory of. So that's the trivial example. We've seen it many, many times. This is the so-called adding machine. And we even saw in all this talk some kind of representation for the adding machine. For the ternary machine, it will be 0 goes to 1, 1 goes to 2, and 2 is the one that needs to have carryover. So 2 goes to 0, but then it continues doing the carryover. Representation for it. Now, all the critically fixed polynomials are parametrized basically by bicolor trees. Here I have an example of a critically fixed polynomial. These are the three uh critical points that are also fixed points. Uh and these are other fixed points of this polynomial. Fixed points on this polynomial, that the black ones. And what you do, you can build now a tree by simply connecting every critical point to the fixed points that are in the same Fatu component, or on the boundary of the same Fatu component. So, in other words, I'm building this table. And then I can erase my Boolean set and everything. This reports all the information I need. I can recover the polynomial. I can recover the polynomial up to quantum C from this tree. So again, draw any kind of tree in the plane and then bipart it, basically. So it has to be bicolored. The yellow dots here represent critical points that are fixed, and the black points are the other fixed points that are not critical. So, okay, here's a random example. Here's a random example, here's some three. The white vertices are the critical fixed points, the rest of them are not critical. And the point is that you can easily calculate the action of any, so again, one, two, three, seven. There's seven critical points. So those are the ones that I need to remove from the plane so that I can play this game. So my fundamental group is three on seven. Group is free on seven generators. So there will be seven generators for my iterative monomy group. And the way to understand their action is simply: okay, I put some kind of labeling on all the vertices in this tree. I start at some black vertex and I start going around. 0, 1, 2, 3, 4, 5, 6, 7, 8, blah blah blah. But the point is, remember that's a silly example that I told you before. A silly example that I told you before. When I have only two critical points, around one of the points, the thing behaves like z goes to this to the fourth. Around another, it behaves like z goes to this cube. So around this point, things will behave like z goes to z to the fifth. Same story here. Here it will behave like z goes to z cube. It's just whatever the degree of this is, plus one. Around this point, it will behave like z cube. This part it will behave like z goes to z squared. So each of these is some little odometer that uses these guys as digits. This one in particular is nice because it's precisely the five array odometer with digits 0, 1, 2, 3, 4. Now the others are confusing. This is also 5 array odometer, but it uses digits 0, 6, 9, 11, 12 in that case. 12 in that order. But you can just think of them as being 0, 1, 2, 3, 4. You just have to get used to the fact that 0 goes to 6, according to this logometer. 0 goes to 6, 6 goes to 9, 9 goes to 11, 11 goes to 12, and 12 is the place where you're resetting everything. Okay? So you have a bunch of logometers that share some digits and don't share some digits. Only happens here. Happens here. I wrote here the kind of definition. This is what A4 does. It permutes these five digits this way, and in all coordinates, later does nothing except the coordinate that corresponds to the digit 4, in which coordinate is supposed to reproduce itself, which is like in odometer. Okay? So anyway, the point is, it's very easy to go from arbitrary picture like this to a definition of the iterative. Definition of the iterated monotony group, precise action, and from that precise action, you can write then those representations, matrices. So, of course, forget complicated examples. Here's the simplest possible example you can think of. Well, not counting examples like this one. So, two critical points, both of them fixed, sharing these digits. So, if I ignore this digit, this optometer just is a... This odometer just is a binary odometer using the digits 0 and 1. This odometer is also a binary odometer, but kind of uses digits 0 and 2. Think of 2 as being another copy of 1. So A is doing the usual thing. 0 goes to 1, it's adding 1. And when the digit is 1, 0 and then reset, continue. B is doing a similar thing, it uses 0. Thing it uses zero, but now when it goes up, it goes to the digit 2. And digit 2 is reset back to 0 and it continues working. B does not understand the digit 1. It's not. This optometer doesn't care about that digit. It's not its own digit. So whenever it sees that digit, it kind of stops working. It ignores it. And same story for A. The A guy does. The A guy, that's not the digits of this orgometer. This ordometer only works on these two digits. So, whenever it sees two, it's not working. That's not my number. So, this is the simplest possible example. And like I said, your iterative monotromic group based on a polynomial that is corresponding to this situation, which is the polynomial I studied at. Whatever it was, the definition. This is the first Julia polynomial. Exactly. So whatever the remember I started with some polynomial and right now Right now, best page. I know, but this takes too much time. Anyway, these are the shared graphs of the action. These are the shared graphs of the action of that iterative monitoring graph. So as far as indicating, that polynomial was not chosen randomly. So that polynomial from the beginning was precisely the polynomial that corresponds to that very, very simple tree. Two binary osometers. Binary osometers kind of intertwined. They both work on two digits and share the digit zero. So they are in each other's way in some sense. Anyway, so that will be the action on the first level, action on the second level, etc., etc. All those pictures I was showing you before, they are precisely the shared graphs of the action of the iterative monochromatic group of that little polynomial. That's level 3. And so on. And so on, and now you sort of see: oh, these are the shared graphs of the action of the iterative monitoring group, and that's the same story. This lifts or these loops look exactly like a straight graph. Second level? Sorry, this is the first level, the second level is not true, but anyway, you get the point. So in some sense, this share graphs approximate the two cells. Approximate to the z of the and some sense is very very precise. You can find the sense in Lovoj's book. Okay, I don't have time for more details, but we can sort of see that it does approximate. Anyway, now we can define this group for all critically fixed polynomials, and now we have a group. You can study algebraic properties, but you can also study kind of dynamics. We calculate spectra of the Share graphs or spectra of the limiting graph, which is what happens when you go to the boundary of the tree. You have action also in the boundary of the tree. So these guys will be, of course, some finite representations associated with this. Remember, those matrices, as in Feynman, if you stop at some level, there will be finite dimensional representations. They are precisely permutational representations coming from the Representations coming from the picture that you see on level n. But if you want to go to the boundary, then you will see an intrinsic rare graph, and then your action will have to be on a Hilbert space, little L2, something like that. And then the spectra will be more interesting. Anyway, as far as algebraic properties, let me skip them. All these years are not that interested in the algebraic properties. Yeah, we have kind of more or less complete. kind of more or less complete understanding of actually complete understanding of the closure of the iterated monothermic group in the group of three automorphisms. Remember the group of three automorphisms, the full group is profinite group. So you can take any of this abstract finite generated group, take the closure, we understand exactly what the problem is. In particular, the nice situation is if all multiplicities of your critical points are equal, Of your critical points are even, then the closure will be just iterated with product of cognitive plot and closure will be. Anyway, we have presentations and as far as spectrum, in two, three minutes, I can describe the spectrum for you for certain situations. Here I have several five iodometers, so just three of them, and they should. So, just three of them, and they share only one digit in the middle. Okay? So, I have three five array odometers, three of them, each of them has local degree five. It behaves like z goes to z to the fifth. And in general, I can do k odometers, each of them local degree around the critical point equal to r. So, that will correspond in a unique fashion to some. To some polynomial of this degree. And then what about the spectrum? Okay, going back to that first example, that would be G22. There's just two odometers sharing both of them binary sharing a digit. So that would be G22. I can write a formula for the spectra on every level. On the zero level, of course, there's nothing. Level, of course, there's not much to say, it just happens to loops. It will be x minus 4. You have a, a inverse, b, b inverse. So that's level 0. And on level 1, it will be this. And more generally, on level n plus 1, it will be x minus 2 to the power 50 times pn of this little polynomial. Now we start seeing formulas like in the previous talks. Where determinant on one level is associated somehow with determinant at another level, but not evaluated at x, but evaluated at a different point. Okay? But that's sufficient, that you can easily understand from all that, that the spectrum of level n is just take the privileges of four under this polynomial, that polynomial, and then take take the privatization of two under that polynomial. That will be your spectrum on level n. If you go to the boundary of the tree, it will be union of all these things to infinity and force. For these examples, the measure will always be concentrated on this guy. The entire measure is concentrated on. So, topologically, you have a bunch of countable set of points that accumulate on a Julia set of this polynomial. Julia set of this polynomial. That one is not very exciting. The Julia set is counter set. But nevertheless, you have countably many points accumulating on Julia set of that, which is a counter set. That will be the spectrum on the boundary, which is the infinite rough. And I can write a precise formula for the spectrum in any situation. That was just 2-2. This is the one that we give with Slava and Maloja. And with George Granny. And with those undergraduate students, we did for all of them. A polynometers, all of them of degree 3. We have precise formulas. I don't want to bother you with them. In any case, formula of precisely the same type is correct, where this polynomial is defined in this accursible in some way. So we can answer this question. And in all cases, you have a bunch of isolated points. You have a bunch of isolated points which accumulate on a counter set, which is the Julian set of that polynomial. The interesting thing for me was that, well, let's just go back. For example, 2 is cubic polynomial, which means I'm getting my spectrum by backwards iterations of cubic polynomial. Or if I go with k equals to seventeen, oh sorry, r is equal to seventeen. If r was here fifteen, If R was here 15, I'll have to do polynomial backwards iteration of polynomial of degree 15. In all our previous examples where we calculated things, the polynomial was quadratic. But there was no reason why the polynomial should be quadratic. Only we could handle those examples where the polynomial happens to be quadratic. But now you see there are examples where you can actually go through this entire program of joint spectra, X, Y, Z, whatever, and the backward iteration once you have a very good point. And the backward deterioration, once you go back to only the original spectrum, the real spectrum that you're interested in, becomes any degree you want, depending on what kind of odometers you started with. And to finish, more or less, there's a nice application that comes from work of Voloja and Glaif, namely these finite graphs. You can work to find Laplace. Or to find Laplacians on them. In particular, you can associate any weights you want on A and invert and another weight on B and B invert. So these are weighted Laplacians. And if you rescale them correctly by multiplying by R to the N, this sequence of rescaled Laplacians converges to a Laplacian of the Julia set of the original critically fixed polynomial. Okay, that's one thing and another, again, in the spirit of. I fear that we're going to miss dinner if I don't interrupt you. This is the last slide. So it's just fun. What I'm doing here is this is the spectrum when you calculate it like this. X minus whatever, A minus B. So in a sense you choose okay. Sorry, okay. Choose a variable. Sorry, okay. Z B and then there's usually you will put to make it self-adjoint and so on, you'll put the same weights here and here. But I'm saying, okay, why put the same weights? Let me put weight zero and see what happens. This is the spectrum that I get in that case. And of course, I'm getting something more interesting because now this is not self-adjoint anymore. The eigenvalue doesn't have to be real anymore. Don't have to be real anymore, so it can be pretty much anything. So, in that original case, the first, the smallest example, this is the spectrum. And if you start varying this, so that starts here and start increasing it, what happens is, of course, this will start moving, you have a movie, and eventually, once you hit y equals y and z equals z, it collapses into the real line, and you have. Into the real line, and we have a nice real thought. Okay, so let me stop closing thoughts for today. Nine folks, wow. 