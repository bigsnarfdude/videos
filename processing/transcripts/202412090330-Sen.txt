So, first of all, I would like to emphasize that quantum key distribution QKD is actually quantum key expansion. So, there was a discussion on it in today morning's tutorial. So, quantum key expansion. Okay, so that's because of the following. So, if you recall the setup, there are two honest parties. Call the setup: there are two honest parties, Alice, Bob, AB. And what do they have? They have a quantum channel between that. So, this is quantum channel. When we say one-way QKD, the quantum channel will be used for sending qubits only from Alice to Bob. Okay. And there's more to it. I'll come to that. Then, what they have is also a class. What they have is also a classical channel. So, there was again a discussion about this aspect. So, this is a classical channel, CC, classical channel. So, this is what is called public authenticated. So, public means anybody can read what is being transmitted. An authenticated means An authenticated means nobody can tamper with it. As part of the definition, this precludes the man in the middle attack. So, I mean, if there is a Charlie who comes, sits in the middle, the man in the middle, and Charlie behaves like Bob to Alice and Alice to Bob. So, that will be the man in the middle attack. So, you want to prevent that also. So, part of the adjective authenticated means that. How is this achieved? So, this is achieved by actually assuming. Actually, assuming Alice and Bob already share a classical secret key. Okay, so already share a secure key. The point is, this key is on a small number of bits, polylogn bits. So ultimately, we want to get. Ultimately, we want to get something like n bits of secure key between Alice and Bob at the end of this entire protocol. So we cannot get something out of nothing. So this is that something. So Alice and Bob already share a small amount of secure key. Nobody else knows it. Maybe they met many years ago in private and exchanged pieces of paper and all that. Okay. Okay. So Okay, so that's the assumption. So, where is that required? That is required to create this public authenticated channel. Okay, including destroying man-in-the-middle attacks. Okay. So, this is an information therapy result. So, there are certain two universal hash functions which allow us to do this. So, if the amount of public bits being communicated, let's say, is polynomial in m. Polynomial in n, okay, then to authenticate it with a negligible error. Negligible means like one upon polyn is a noticeable function. Anything which is less strictly less than one upon polyn for any polynomial, I call negligible. So if polyn bits of classical messages are being exchanged, okay, if I want negligible error, If I want negligible error of authentication, then I need to start off with polylogin initial secure key. Okay. And in one way, even this is going to be one way. Okay. So all of you would have heard of BB84. Now, BB84 is not one way under this definition. Though you will see people in literature saying BB84 one way. Okay. So when they say one way there, they When they say one way, there they say it is one way after a certain time. And I'll tell you what after that time is. So if you recall BB84, what was the deal? Like Alice will make a choice at each step of the bit she wants to send and the basis she wants to encode it. And as a result, it's a four-state protocol. So the quantum state that she puts on the quantum channel is either 0, 1, plus, or minus. One plus or minus. Okay. And then there's a latest step where Alice and Bob. So, yeah, so Alice makes a random choice of a bit, random choice of a basis, and then sends the corresponding qubit along. Bob, of course, doesn't know the choice of the basis. So Bob measures the basis according to his own whim and fancy, random and independent of Alice. But then you have to exchange notes using this classical channel. That is two-way communication. Okay, because Alice and Bob do this business. Because Alice involved do this basis shifting steps, so they have to know what locations to keep where the basis matched and discard the rest. Okay, so that's what makes it two-way according to us. So when earlier people said one way BB84, they meant it was one way after the basis shifting step. Okay, but today our definition is stricter. So basis shifting is still two way. When I'm saying one way, we cannot do that. Okay, why would anybody want to do this? Tie your hands behind. Do this, tie your hands behind the back. So, there could be, let's say, military reason behind it. I mean, this is a central command, these are people out in the field. Okay, and then one way becomes important because if Bob sends anything back, even some classical bits, maybe the location is revealed. Okay, so this is the setup. So, using these resources, the final aim, okay, so final aim is Expand to a secure n-bit key. Question Pranab? Yeah. So there's at least one thing that Bob needs to do, which is to let Alice know that he has received all the qubits. Point. So, in one way, you're not even allowing that. So, I'll come to that. Okay. Yeah. So, the question was: there's, of course, one thing Bob needs to do is to tell Alice that I've received everything that I'm supposed to receive. When I'm saying one way, I'm not even allowing that. It's honest to God one way. Okay. So, of course, that means I have to replace it with some other assumption. So, the assumption that we are going to make here is okay. Okay. Yeah. So, now, of course, there is the eavesdropper eve out here. Course, there is the eavesdropper Eve out here, so she can tap into the channel. So that quantum channel actually has two outputs: single input, Alice, two outputs, Bob and Eve. And of course, Eve can tap into this also. Okay, the Eve cannot temper this, but Eve can temper rather one. Okay, so the assumption that you will make Is that after one second, if has no, which we can later relax to limited. That's not suited. Quantum memory. Okay, so can you prove one second by your favorite delay? So this is the model where even The model where E has no long-term quantum memory. Let's say one long-term means after one second on the clock. Okay. Otherwise, yeah. No, no. Good point. Yeah, I'll remark more about that. Yeah. So to answer your question, So, to answer your question, Ashwin, Alice will send whatever qubit she needs to send to Bob, and then she'll wait for a second. And then the rest of the protocol, the classical channel part, will go on. In that one second, Eve's quantum memory has gone. Okay, but otherwise, there is no limitation on Eve. Okay, so otherwise, Eve. If is computationally unlimited, so within that one second, Eve can take in an exponential amount of quantum ancilla, do whatever CPTB map she wants on it, store, I mean, you can have some the CPTB map can have a a classical output also, which she can store for posterity and deal with it the way. And deal with it the way whichever way she wants. So, in that one second, Eve can do whatever. After that one second, she can still do a lot, but she doesn't have that quantum memory. Okay, so this is the adaptation. Okay, so this avoids Bob having to even send that one book back saying I've received everything. Okay, so there is some. So now I'll come back to the practical part. So, is this a practical? So, is this a practical assumption? And actually, I've been talking to some experimentalists in quantum optics. They say it's very practical. Okay. I mean, not just the assumption on quantum memory. In fact, several more things. In fact, I'll come back to BB84. So, what usually happens is if you try to do the first part of this experiment, so this is like prepare and measure. Prepare certain states. In fact, in our protocol, we'll be using the same states as BB84. The same states as BB84, 0, 1 plus minus. There's also an extension of the protocol to the so-called six-state protocol. So 0, 1 plus minus, then whatever, right circular, left circular with slightly better parameters. Okay. Just a comment on how realistic the model is. I mean, it may be realistic today, but like Anand was saying, 20 years from now, you know, so as I said, I mean, there is the word limited. So, as I said, I mean, there is the word limited also here. You can probably change the delay. Yeah. Yeah. A related question would be: can we make this like going from bounded storage to noisy storage, which could be yeah, so we haven't done that. I would believe we can address it with our techniques. Okay. Yeah. Um, yeah, uh, so sure, I mean, the I mean, so this is somewhat fairly strong-looking assumption on Eve. Okay. Then let's see what this gives us. But even with this assumption, what do we have with current experiments? So the experimentalists, of course, I mean, one second is a long time. So they buy this totally. Experimentalists will tell you that the biggest problem when Alice sends photons to Bob is actually erasures. Photons just visit. Photons just disappear down the channel. Channel is like brain. And if Alice sends 100 photons, Bob may actually receive 10. That is in the run-of-the-mill apparatus. If you have the best apparatus anywhere in the world, then Bob will receive 90 plus. Okay? Some question? Okay. So note that images are actually the biggest headache. Actually, the biggest headache, and then, of course, there are the what they call the bit flu paddles, which are presumably caused by the action of Eve, the malicious action of Eve. Okay, so now if you go back to BB84, the way BB84 is written, they don't address the erasures explicitly. Okay, so what is implicit? So, I talked to the experimentally, so they'll say that, oh, you know, when you're exchanging basis, we just say which locations are erased, and that's it. After that, we pretend that they never existed and continue with the rest of it. So, one question to ask is this. So, one question to ask is this kosher for BB84. So, actually, one needs some thought, but this is kosher for BB84. But note here, we are doing one way. So, Bob, poor Bob, can't even say which locations are erased. So, this makes it even harder. And this is a real problem. Okay, the erasures are the killer. So, something like let's say 10% erasures and 0.1% bit flip errors, or it's one. One percent bit flip errors, or it's one percent bit flip. This is a very realistic figure of merit that you can get with very, very good current hardware. Okay, okay, so what do you mean by bit flips? So, sorry, actually, it required, I mean, uh, recall db84. So, the uh, Alice would have sent some bits, forget the choice of this, should have sent some bits. Bob, uh, let's say, does something and tries to recover and he's. Something and tries to recall on his own version of those bits. The bits, the classical bits. So Alice has a version of a rocky on, let's say, some poly bits. N is the final secure key. So she has to start off with a little bit more than n. So the rocky might be some constant times n, or let's give some more leeway. Polyw bits of rocky. So, some of it has been erased. Okay, some constant fraction has been erased. Now, so what Bob gets is let's use concrete figures. So, let's say n square is rocky. Okay. N square bits at Alice's end. Bob will end up with, let's say, point line n square bits. Bits okay and locations of erasures. Okay, so God knows which look uh which bit positions are erased. How is this done? I'll come to in a moment with XMA and locations of erasures. Okay. So and 0.1 and the remaining 10% has been erased. Okay. So this is Bob's rocky. Okay. Rocky. Okay. So Bob's Rocky is a ternary alphabet: 0, 1, and let's say erasure. Some third symbol, question mark, 0, 1 and erasure. Okay. So when we say bit flip errors, it means count those locations where Bob has not seen the erasure, but Bob's bit in the rocky disagrees with Alice's bit. Yes, so these are marked. Yeah, so what happens? So, so how does this happen in practice? So, this is yeah, so if there are experimentals here, I'm sure they will have many more things to say. I'm probably not 100% correct. Okay, so the way this entire business is done is alerts will use what are called heralded single photon sources. All that single photon sources. So these are devices which are supposed to emit one photon in one time window. Okay, so even before doing it, Alice and Bob will have to synchronize their clocks. Okay. So they have the basically the same clock, they have a time window. It's broken up into smaller sub-windows. Okay. And one photon is supposed to be transmitted in one sub-window. So the start and end of sub-windows are already known. Now, Now, what Alice will do is that she will fire her signal photon emitter, which is supposed to emit one photon in one sub-window. But sometimes it emits two photons, sometimes it emits nothing, and then there are channel losses. Some of it might be due to each action, some of it is just due to nature. Okay, probably most of it is due to nature. Then the thing is, Bob will just look at it in the time window and see what he gets. What he gets if Bob manages to detect more than one photon, that's an error. Okay, Mark does an erasure because he knows that time window. If Bob sees nothing, that's an erasure. Okay. Or else Bob sees something. Maybe it's correct. Maybe it's wrong. So that's the bit flip error. So under this metric, synchronized clocks, synchronized sub-windows. Okay, so what is the heralded? So heralded means that, okay, so the probability. That, okay. So, the problem is this is all no good, but today's detectors are, I mean, a little disobedient. So, if Alice says, okay, this is the sublinker, produce a photon for me, the detector may simply refuse to do it. Or maybe it is not the photon Alice wants. I mean, Alice wants to create the plus state. The detector creates maybe a cat one. So, such things can happen. You mean emitter? Ah, the emitter, sorry. The single-photon emitter at Elisa. Yeah. So they. Yeah, so they do not actually emit the right state on command. So the herald is actually a classical signal which says whether the emitter has emitted the right state. It does not tell what is the right state, it's just a 0-1 signal. It's a classical signal which will be sent toward the authenticated channel. Okay. And so again, I mean, if the herald is not there, Bob will just ignore that window. Okay. Only when the herald is there, then the Bob will consider the window. Then the bob will consider the window, and then there can be erasures, as I've said, or there can be bit flip errors. And this is the kind of metric we are looking at: like, let's say 10% erasures, 1% bit flip errors. And apparently, this is very reasonable. I mean, 1%, just about every device out there will do. Okay, the challenge is to come down to 10% erasures from 90%. Okay, so that's the model. So that's the practical part of it. Okay. And It's okay, and you can also guess what is resilient. So, this is going to be one way, and Bob should be able to tolerate some amount of erasures. Okay, and there is no acknowledgement back from Bob, but there is the delay of one second. So, whatever happens after one second, moving photons that are too late, they will also be considered erased. Okay. Yeah. Any further questions before I go ahead? Well, go ahead. If not, okay, so let's see what is known. So, here there was an assumption of no long-term quantum memory. Okay, so what if Eve has long-term quantum memory? So, again, So, again, BB84 and the similar kind of two protocols actually work even if against an Eve who has long-term quantum memory. Okay, as long as I mean Eve's time putting is below some threshold, of course. Yeah. So we can ask this question. Is one-way QKD possible if Eve has long-term quantum memory? The answer is yes. So there is a protocol by Vidik and Wazirani. From a few years ago. So they called it a device-independent UKD. As written, the protocol is not one way. But with some thought, you can make it one way. But what parameters does it get? So again, they include ignore erasures, but I mean, erasures are very important, especially one way. Are very important, especially one way. So, erasures plus bit flips. If it is less than one percent, then protocol works. Okay. So, eros plus bit flips. Now, this is extremely stringent. Okay. So, I mean, it's far from what is current technology. Far from what is current technology, so I cannot call it practical. Okay, so that is part of the reason why we are putting this assumption that okay, Eve has no long-term quantum memory. Now, when can we do better? Okay, so Okay, so this is today. Okay, so so this protocol actually plays a CSH type game on each bit. So one qubit assistance. Qubit Alice sends received at Bob, and certain CHS game is played. And results of some of the games are sent as information. Okay. Now, if there are immersions, then you cannot verify those games. If there are bit flips, also those games fail to be verified. Okay. So that will turn off alarm bells and then destroy the protocol. So one problem with all these DI things is that they're based on This DI things is that they're based on the robustness of CSH type games, and usually, I mean, these are the errors. I mean, these are the thresholds you can get. Probably even worse. I mean, in most of the papers, they don't even bother to calculate this, but Vidik and Vazirani actually did. And this is what they got. Okay. Now, so that's why we are making a further assumption with no long-term quantum memory. Can we do better than this? Okay. So the answer is yes. The answer is yes. So let's say S is the fraction of irritation. So fraction of irritations. So a rough thing is S plus this is the fraction of book flips. If the fraction of erasures plus the binary, this is the binary entropy function of the fraction of bit flips, plus you have to put in some tolerance delta. This is a small constant. You can make it smaller and smaller, but then the number of bits of the protocol will start going up as a function one by delta. So if this is less than 0.25, okay, then one way. One way Q K D is possible. So, for example, I mean, let's talk of concrete numbers. So, something like 10 percent erasure, so 0.1, okay, and uh 1 percent bit flips. So, S is 0.1, P is 0.001. Okay, this is this satisfies the inequality. This satisfies the inequality. Okay, so there exists it. Okay. So, yeah, so the so this is a great improvement for practical experiments. Any further questions? Yeah. Yeah. No, no, so yeah, so I mean, you are assuming that she keep bringing in fresh ancilla at a rate of 0.5 seconds. Yeah. Yeah. Yeah, yeah. So, so basically, basically, we are assuming that an unlimited amount of fresh ancilla can be brought in faster than one second. Yeah, so it's kind of like that. Yeah, so yeah, of course, that has to be disallowed. Yeah. Okay. So so what is the protocol? Remember, Alice and Web actually started off by exchanging something. So earlier that something was only for the authenticated channel. So in our protocol, of course, for the authenticated channel, we need the prior secret key. But then we'll also use some part of the prior secret key. Secret key in the first step of protocol. Okay. So. Okay. So let us say Alice chooses a random string from maybe one to hundred and so this is supposed to be rocky and Alice and Bob here this This polylogin, this is this key is the polylogin bit string of secure key that they already have. So some of it will be used for the authentic channel. I'm not even talk of that part. I'm just going to talk of the part of this pre-shared key, which they'll use for the protocol for setting the qubits. Okay, so this key actually dictates the choice of a Dictates the choice of a sequence of basis. So there are 100 and bits to transmitted. So to make 100 and choices for basis, whether it's a computational basis or there's a Hadamard basis. Okay. So K maps to, let's say, computational or Hadamard. Okay. For each of these hundred and locations, uh These 100 and locations, uh, one has to make a choice for the computational Hadamard basis, and then just as in BB84, the corresponding photons are sent. So, this is f of xk. So, yeah, so it will make a table xk and then f of xk. So, if this is computational, zero one is sent us. 0, 1 is centers, 0, 1, and if this is Adamad, 0, 1 is centers plus and minus. The same table as BB84. The difference on BB84 was that in BB84, this came was chosen randomly. Okay, this choice. And then, of course, Bob, I mean, Alice and Bob could not have shared 100 bits to start off with. Hundred and bits to start off with. So, really, Bob had to make his own blind guesses, and then there was the basis shifting step. But now it's generated pseudo-randomly. Okay, so both Alice and Bob know what is the basis used for the first bit, second bit, third bit, and so on. Okay, and it's very simple. What Bob will do is, of course, Bob knows what is the basis, and then Bob will invert. Okay, invert according to the pseudo-random basis and this gives some x prime. Okay, now this x prime is a string in 0, 1. In 0, 1 or there are inertia 0, 1 question mark to the power 100l. Okay, because sitting in the middle is, of course, Eve. Okay. And other channel noise and all. So as a result of which, there are even erasures and bit flips. So this is the string which comes out at this end. Okay. Yeah, yes. Okay. So usually that would give the bit flip error. Yes. Okay. Yeah. Now after this, wait one second after this is done. What do you have to do? What do you have to do? Decohere, and then we'll do the rest of the protocol. So, what happens after one second? So, Eve's side information about this will have to capture by a classical object. So, formally, the action of Eve after one second can be modeled by a quantum instrument. Okay, so what's a quantum instrument? It's like a quantum operation, like a CPTP map, but there is the classical side information. So, Maybe I'll erase this one. This key, yeah. Yeah, I've not told you what is the pseudo random expansion, but yeah. No, no, no, no computational assumptions. This is, I mean, with that one-second assumption, this is. With that one-second assumption, this is secure. Yeah, I'll tell you what it is. Okay, so okay, so maybe I've let me write down what is the instrument. So ease action after one second. One second is modeled by a quantum instrument. So, what's a quantum instrument? So, that is a subscript M. Okay, so M is, or maybe let me say. M is or maybe let me say small e. So small e is the side information, classical side information of Eve. There is no bound on the size of this side information. Okay. And but if I fix the label of the side information, then this is like a completely positive trace decreasing map. Okay, so that's what it's to me. That's why it's to me, but if I sum over all E, it becomes a CPTP map. So, this is a map from Alice to Bob. Okay, so it's basically depending on the label of this side information, is there some corruption on the qubits transmitted from Alice to Bob, which is modeled by this completely positive map. That's what this instrument is. Instrument is okay. So, so this is how we are going to mathematically model Eve. And now back to Rahul's question. So, what is this pseudo-random mapping? So, actually, so this mapping, so so remember K was chosen uniformly from polylog and bits. Polyogen bits, but it will be mapped to some big k which is 100 and bits. Okay, so so actually yeah, so this map is actually what is coming from almost mutually. Mutually on an unbiased basis. Let me explain what I mean. So if I go back to BB84, in BB84, what was this mapping? Like in BB84, of course, there was no little K, there was just the big K uniform. So every prediction is either computational Hadamard independent with probability half-half. Probably half half okay. And now, if I look at two such independent strings, they're mutually unbiased. I mean, at least informally, you can see. Like, I mean, the about half the location of the basis will disagree. And when they disagree, they're the most unbiased. I mean, in the sense that if one is computational and the other is Hadamard, if I take a basis state from computation and measure it in the Hadamard, I'll get half of the probability. So that's what mutually unbiased means. Okay. means. Okay. So the BBAT4 step was using a perfect mutually unbiased basis, but a perfect mutually unbiased basis requires 100n bits. Okay. But there are almost families of almost mutually unbiased basis which require far smaller bits. So just polygon bits are good enough to do. So actually this part comes from an earlier work. And all the work of with Patrick Herron Rohmosi comes from this efficient information locking paper. So, this use of the mutual and bias basis. Okay, I'll tell that I think. How much time do I have? I'm probably running out of time. Huh? One second. Yeah. Okay, so one way to do it is that you need an efficient family of codes on 100n bits, which have a distance close to half. Close to half. Okay, so such a thing can be found by first of all doing a brute force search on a polylog and block length and concatenating it with Read Solomon code, for example. Okay. So there are better constructions, but yeah. So what I need is basically a family of official A family of efficiently constructible codes. Efficiently constructible is a family of codes. Let's say code one, two, three, four. Now, if you order me, give me the thousandth code, I should be able to construct the generator matrix of that code in polyn time. Deterministic classical polyn time. So this can be done by clever concatenation. So actually, this thing, there's very little quantum in it. Most of it is classical coding theory with souped up. So you can say classical coding theory on steroids. So to So, to do this, you need a certain set of classical codes. But I can point you to this paper. Actually, even this paper doesn't originate these ideas. So, I mean, it originates the construction in quotes, but this concept of creating small families of mutual unbiased basis comes from a paper by Pyotr Indik on embedding L1 into L2. Okay. Okay, so actually, in that sense, you can say that this thing was already there in that paper, which is more than 15 years old by now. But it has to be interpreted in the correct way and brought to this. Yeah, so the basic idea is the almost mutually unbiased basis. Okay, so let's say Alice has encoded in basis one. By basis one, it means Alice has dictated the choice of computational Hadamard for each of the location. But Bob decides to measure in basis two. The basis one and basis two are coming from this set. The thing Coming from this set. The thing is, well, the definition of mutual unbiased is that if you prepare in one basis and measure in the other basis, the measurement outcomes look almost uniform. Okay, so and to do that, you don't need the full power of what BB84 was doing. You can do with much smaller sets, and they are officially constructible. Yeah, I think maybe. I think maybe I should, yeah. So, I'll just wind up saying so. This is basically the only new quantum idea here. And again, it's not really new. Okay. So, once you do it, you get rid of the main bottleneck of BB84, which is the basis sifting step. We don't need that anymore. The rest of it is similar, but then we remember Bob cannot even declare the location relations. So, we need very good. So we need very good codes to do what is called information reconciliation. So that is, Alice and Bob have different ideas of the rocky. So they have to reconcile on a smaller set and get the key positions perfectly correct. So this requires more work in coding theory. And I would like to point out that to this day, no protocol, BB84 or anything else, actually had a rigorously proven efficient information reconciliation scheme. So I can. So I can talk about it offline why I'm saying this, but I mean, this is a glaring lacuna in the field. So people, I mean, people were saying we will do information reconciliation this way, that way, but there was no rigorous proof given. So our information reconciliation analysis can actually plug back into BB84, and then we can finally say that the information reconciliation, I mean, there is a proving efficient. Prove efficient information reconciliation step that can be used in BBAT fund and in the earlier protocols. Okay, of course, we need the classical authenticated channel. Is the claim that even the short Prescal proof and protocol didn't do that? I think it does. It does. Well, the short Prescal protocol is a proof of security. Yes. Okay, but to implement the protocol, you need information reconciliation. You mean from Rocky. Swift errors. Yeah. To recover. First of all, you have to make the Rockies equal. Yeah, first of all, you have to make the raw keys equal and then we apply the extractor to get the secure key. I think it does that. I can talk on offline. Short Preskill has an offhand remark about the existence of certain CSS codes, but the only proofs we have are existential. So there's no efficiency there. Yes. So yeah, yeah. So it is practical, right? I mean, it has to be efficient. So I'll tell you another thing people put under the carpet when they say this can be done with codes. So, so maybe. So, maybe all people have proved is that, okay, there are the generating matrix of the code, and then there is some decoding algorithm. But even to create the generating matrix, it's not clear. I mean, it's constructible. So, when you're talking of codes, you need three things. Constructability, efficient encoding, efficient decoding. So, when I'm saying practical, like this is provably efficient in all the respects. So, as I said, I mean, it is classical coding theory on steroids. So, we have to go address all these concerns. And then, yes, it turns out. Then, yes, it turns out at the end of the day, we can do efficient information reconciliation. Then, of the next step, of course, is the extractor which is fine. I mean, has been known to be efficient for a long time. Okay. And yeah, and all of them can be done strictly one way. The only thing which was not strictly one way was the basis lifting step, but then this takes care of it. So we can put all that together and then get this. Then get this number at the end of it. And this 0.25 is basically coming because we are using four states. If you use six states, this becomes one-third. So this is one-fourth, and then that becomes one-third, 0.33. Okay. Yeah, I'll stop. Yeah, Marco? I had a question. So, are we allowing for collective attacks here as well? Yes. Coherent attacks. And now, is my understanding correct that we are no longer going to use strings of ket zeros, ones, plus, minus, but instead we are going to use some arbitrary sets of almost mutually unbounded. The actual states in the protocol are zero. States in the protocol are 01 plus minus exactly that. But we are going to expand from oh, this is just to get the choice of basis. I need 100 basis, either computational or hard or not. So it's still those same four states. Okay, maybe I missed how where, I mean, I'm doing polylog and almost MUVs, but yeah, well, I didn't define what is almost MUV, but yeah. But the point is that to. But the point is that basically to get a random looking string of computational or Hadamard of length 100n, I mean sufficiently random looking for purposes, we do not actually need 100n random bits. We can do it much less. But this strategy only works for this memory limit, no long-term memory. Eve. The moment Eve has long-term memory, this analysis will. Memory, this analysis will not, I mean, gel with the rest of the protocol. No, almost mutual. So properly mutual n bias would be, so this is the basis on 100 n bits, right? I mean, once I fixed the choice of compression, this is the basis on 100 n bits. So, I mean, something which lives in two to the power 100 n dimensional space, the vectors, okay. Okay. No, so mutually unbiased basis would be: if I take a basis vector from basis one and measure it according to basis two, I get the completely uniform distribution. Okay, so so so so here so here uh uh or rather more precisely like Yes, as the state. Yeah, yeah, yeah. So, I mean, if I take vector number one from basis one and then project it onto vector number 10 of basis two, I should get one upon two to the 100n. That would be the perfect mutual unbiased for 100n qubits. Yeah. So instead of instead of one upon two to the 1 upon 2 to the 100n, what I will get is 1 upon 2 to the 50n. Okay, so that's, and that is, I mean, this dimension 100 and dropping to 50n is the reason why this is 0.25 and not 0.5. So that fact, there is that half factor which will go. 