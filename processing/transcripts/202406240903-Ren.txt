The humble goal of this meeting is to predict, anticipate, and even design the future of computational geometry. So that's how our informal meetings should be used. So in between the four talks we have per day, we have a lot of free time, so we can discuss about those things amongst other political issues. Alright, now I think it is my pleasure to announce Yu Ren from Durham University with the title Tropical Home. With the title Tropical Homotopies Two Ways in Oscar. Yes, thank you very much. Thank you very much for the introduction. So I'm going to present two different types of what we refer to as tropical homotopies. And it's a little bit unfortunate that we refer to them by the same name. It's just we haven't come up with a better name yet. So this is still a work in progress, so suggestions are very welcome. If you have anything, the also the problem is like none of us are actually native English speakers, so we're like struggling a lot. So this is trying to work with Oliver Daisy. Join to work with Oliver Daisy and Oscar Endingson, so two PhD students from Durham Hagen, and Paul Heming, who used to work in Durham at House in Lando in Japan. So now I will just go over this very briefly. So this is basically what the motivation comes from. So I'm talking about solving polynomial systems. And polynomial systems, I one thing that you should take away from these slides is a lot of things can be written modeled using polynomial systems, even stuff that you wouldn't think is possible, like wouldn't intuitively possible. Like, wouldn't it be possible? So, for example, if you want to figure out what your angles theta1 and theta2 have to be in order for the endpoint to reach this thing, well, I mean, x1 is actually the sine of theta1 and y1 is the cosine of theta1. And if you do this, then you can just solve a simple polynomial system. You search for values where every variable is between minus 1 and 1, and these give you the angles. So, even these things you could model using polynomial systems. Yeah, and also one thing that right. And also, one thing that sometimes happens is that the coefficients of your polynomial systems, you only know them with double-sum noise. So, I mean, of course, sine plus cosine squared is always one, right? So, here the coefficients are always one and one, but you know, whether the R men is 2.1 or 2.0001, engineers don't care. And hence, neither should mathematicians. This is a little bit more basically more system of interest. So, these are basically like chemicals. Interest. So these are basically like chemical reactions, like you probably have known from high school, right? So you have reaction arrows. So A, B, C come together and then they become 2A plus B. These arrows usually have like, are equipped with basically positive real numbers that tell you how likely it is for these fractions to occur. And from that, I mean, you can hook up something in Once system. That's what it would be useful to say about it. So, for example, the first equation describes the change of the element. Of the element A in your system. And for example, this, so if you follow the first arrow, you basically gain one A because there's one A on the left hand side by two A on the right-hand side. And this is basically by the factor of one A. And this is how the system is derived. Okay. And again, rate of change is polynomials, the chemical concentrations. Technically, these are also exponents of chemical concentrations, but let's not go into too much detail. So here is what I'm not going to do. Going here is what I'm not going to do now. And this is basically, there are multiple ways of solving coinomised system. One way is basically using the symbolic methods. So just so we're on the same page. So suppose now you have polynomials that generate a zero-dimensional ideal. I also assume it's radical for the sake of simplicity, but not really necessary. One way you can solve this, there are many ways. I'll just introduce that maybe one. The easiest, conceptually easiest way is you can, for example, Way is you can, for example, just apply a random change of coordinates so that the new xn is a linear combination of your old xn. Then, this new system, every solution, I mean assuming the lambdas are chosen generically, you will have a unique coordinate in xn, which means the Goethe basis, computer-texticographic GÃ¶rdner basis, will be of this form. And then, if you want to solve it, well, I mean, it basically then boils down to a chain of univariate polynomials that we have used by. Univariate polynomials that you can use, but I mean that is what we use in that you basically learn in high school or maybe even in kindergarten if you're from the and this is just one of many things. I mean if you want to use Gutenberg bases there are also eigenvalue solvers. So here in Canada there is Maple, so they don't use like triangular decomposition, but they use something called regular chains. And there's a whole strew of symbolic methods that involve basically symbolic manipulation of your polynomials. I'm not going to talk about that. I'm not going to talk about that. I'm going to talk about numerical things. So, this is homotopy continuation. So, this works as follows. So, if you have, so suppose I have now a square system, sorry, so I should have said small n is always my number of variables. So, I have small n variables, I have small n equations, and I want to solve basically all of them is equal to zero. What homotopy continuation does is it basically constructs a system that's easy to solve, like That's easy to solve, like just pick up the system that you want. And then you basically interpolate from this system to this system on some random path. So, I mean, I just wrote like t times f plus 1 minus t times g. So, for t is equal to 0, this will be equal to 1, I think this will be equal to f. For t equal to 0, this will be g. And just this is very important. You don't have to, I mean, you can walk, but generally, it's not advised to basically walk a straight line from 0 to 1. From 0 to 1, because there's a chance you hit something called a discriminant. The numerics will basically go insane. So just pick a random path in C, and because your path has real dimension 1 and the discriminant has real co-dimension 2, because it's complex co-dimension 1, you will not run into it. So, and what you do is basically you just trace the solutions of G to F. And if you're basically, if a starting system in G has two. If a starting system in G has too many solutions, then basically what happens is they will just diverge to some point at its literature. Yes? You were mentioning that the system should be square, but how important is that really? You might have over-determined systems which locally aren't. Yeah, so I think it's really important to have square systems. If it's not square, you square it up. You can square it up, yes. Because you're inverting it, you have a Jacobian, you're inverting it every step. Jacobian or inverting in every step. You're taking a kernel of your, you're assuming that Jacobian is invertible again, and that's the key to the tracking algorithms. But it's not a big deal, you just square off. The only thing that you need to be aware of, it's basically like this trick by square, it's very similar to the trick with this transformation. Whether you basically do this or you square it up, whatever structure you have of your original system, you might basically use it. You might start out with some. You might basically use it. You might start out with something that's very sparse, and then you do this, it becomes, the final becomes sparse people. Squaring up means you add more variables than that. No, okay, a typical overdetermined system is you have like a map between vector bundles and browse rank. And what you do is if you're actually at a zero of this system, then only dimension many of the equations really matter. So you take a random linear combination of them, and that will cut out the path. Cut out the path we found. Okay, we can discuss the details later. So let's just assume for now it's square. And so this is just one way to do this. Taylor will talk a little bit about something called monodromy. And this basically involves, you just trace one solution to it, and then you basically just run loops around t equal to one, and basically you jump between the solutions. Now, this this is this is the main method that I want to look at today. Main method that I want to look at today, as in this is basically where the problem comes from. And I want to discuss two problems that are very related to each other. So, the first one is: how do I avoid the red path going to methink? So, this is, because I mean, ideally, I only want to track as many paths as I have solutions. How do I avoid this? So, this is for the homotomy solver, for the monotomy solver, it's kind of important when do I stop? When do I know that I have all the solutions? And these are kind of very related to each other. I will just focus maybe on the red question first now. On the red question. But I mean, part of basically constructing these optimal homotopies involves knowing how many solutions there are. And if you know how many solutions we are, you know where to stop. So the blue one is strictly easier than the red one. Okay, yeah, so how do I avoid this? Now it turns out this is a really difficult problem. Like really, well, it's difficult to get to develop a fast algorithm. You can always compute a Grubner basis, you can compute the degree of your ideal. The degree of your ideal, and then you can basically read off from this how many solutions you have, counted with multiplicity. But I want to do this without computing with quadmatrices. So let's assume I have an example where I count with quadmatices. How do I do this? Well, this is kind of really difficult, and it's like, yeah, it's very difficult to answer. So in traditional mathematical fashion, I'll just look at an easy problem instead. And that is this question here. So suppose I have now a paralyzed family of polynomial system that is like suitable. system that is like suitable with like a bit asterisk so I'll explain later what that means so how do I determine how many solutions it has for generic for generic choice of parameters right so suppose this is all suppose I'm only looking at systems over the complex numbers then you know over the complex numbers so the parameter space in this case is c to the power of five and then there will be a Starbuckski open set over which the number of solutions will be well will be well determined. I'm trying to find that number and use it. I'm trying to find that number and use this to construct the optimized font. Yeah, and again, like the suitable is kind of really, really important because one example of a parameterized system is a system with zero parameters, and then I'm basically back to my original question. So I really need, this is not like, I can't do this for all parameterized systems. Okay, so here are a couple of two-known answers for this. So this is the first one, this is something that we So, this is the first one, this is something that we all learned at the very beginning of our study, this theorem of Bizou. So, suppose your system looks like this: every equation is basically a sum of monomials, and you sum up over all monomials below a certain degree. And then every coefficient is its own parameter. Then, basically, for generic choice of parameters, you know, generically, there will be the degree, there is a degree-many solutions, and one possible starting system is this. Right? Because these G's. Because these G's will have exactly that many solutions, and you already know what the solutions are. So, this is what I meant. You can construct a starting system where you know the solutions. That's kind of quite handy. So, this is Bizu. More of interest is the BKK theorem or Bernstein's theorem that tells if your polynomials look as follows. So, you basically fix a monomial support for every polynomial, and then you basically just Every polynomial, and then you basically just pick random coefficients. But certain coefficients are zero, so that's like that's different from the previous one. Then the generic number of solutions, so I usually refer to this with a small L because it's the length of a certain module, but this is just how many solutions there are generically, it's something called the mixed volume of the convex hull of these supports. These are also referred to as mutant polytopes. And yeah, Mv is a normalized mixed volume. So it's normalized so that basically a triangle will have what you want. Basically, a triangle will have what you want, but that is a triangle. Yeah, and basically, you can use this, both mixed volumes and easy-to-solve starting systems can be constructed for mixed subdivisions. So, let me just show you how this is done. So, take a look at these equations, F1 and F2. So, if I look at the Newton polygon of F1, it's basically a convex hull of 0, 0, 2, 0, 0, 2, 2, 2. So, it's a square. The convex hull, or the Newton polycubber of F2 is a triangle, and then what Of two is a triangle, and then what I do, what you can do with the mixed volume, is you take the Minkowski sum of those, and you get this big shape here to the right. And this is basically, there are multiple ways to decompose it into basically original shapes. But one common thing that will, one thing all decomposition will have in common is there are these cells that basically are comprised of both red and blue edges. And the volume of these cells, the sum of the volumes, is the mixed volume. So, this is how you can compute the mixed volume. So, this is how you can compute the x-point term. Yeah, this is a very simplified picture in R2. If you have like n equations, the mixed cells basically are n-dimensional cells that are sum of edge of pre-model. Okay, so this is how it makes one of those. Now, yeah, so and basically I'm trying to find something for certain systems that basically generalize this PKK. But that I wanted. For that, I want to need a little bit of tropical geometry. So, in this case, from this step almost, let's just capital K be the field of complex pursuit series with a valuation. So, these are basically power series in T with rational exponents, and the valuation is just the lowest power of t that you have. And the tropicalization, one way to write this is it's basically you look at the solutions of the original ideal, you look at all the component-wise valuations. All the component-wise value rations, well, the coordinate-wise value rations. Depending on convention, you add a minus or not, and then you close it in your clicking topometry. So the value of vi lie in r to the power n, because that's the valuation as values in r, and then you close it, basically. And for that, it's supposedly, yeah, for that, it's kind of important for the field to be algebraic, so we don't just end up with a finite number of points. So I don't want it discretely valued. Yeah. Here is the. Here is the. How did the 13 get there? Sorry. That should just be a one, there's a type of game. So this is one example. So if you look at the topicalization of x plus y plus one, it looks like this blue set. So for example, the point lambda, lambda comes from this thing that's a solution to your original equation. Again, sorry, instead of thirteen, it should be a one. So you add this to this and you get to minus one. So it's a solution. This is how tropicalization looks like. Tropicalization looks like. Generally speaking, if your ideal is the prime ideal, then the tropicalization, there's a way to assign weights to it so that it's basically balanced. So this means you look around the codimension one cell, you add up all outgoing directions with the multiplicity, and you get zero, essentially. It's balanced, it's connected in codimension one. This means, I mean, it's kind of, that means just connected in this case. So you can go from any point to any. In this case, so you can go from any point to any other point by only calling the origin oneselves, and also it's of the same dimension and degree as the original. Yeah, so here are a couple of examples of tropicalizations that are easy to calculate. So, for example, if you have a binomial ideal, I mean, we know valuation, like valuation of Z1 times Z2 is the valuation of Z1 plus the valuation of Z2. So, if you take a binomial ideal, then So if you take a binomial ideal, then basically your coordinate wise evaluations of the solutions will basically satisfy these linear equations, which is basically because of this property. So in this case, the tropicalization is literally just like a classical linear space. So one thing that you probably learn in very elementary number theory is if you have, let's say, a single univariate polynomial, so univariate, it's just a single polynomial, and you want Single polynomial, and you want to know what are the valuations of the roots, or the negative valuation of the roots, you basically look at its extended polygon, and you basically look at the slopes or negative slopes of the lower edges. That's what you do in a number theory, elementary number theory. And this has a generalization that says if you just have a principle, ideal, not necessarily univariate, then what you do is you look at the root of the. Then, what you do is you look at the Newton polypole, you raise every point again, same as before, to a height that's the valuation of the coefficient. This induces a regular subdivision, so in this case, you basically get an edge here. And the tropicalization is basically just dual to this. So, you see here on the left, it's just like dual to sublimation here. Okay, so this is and set theoretically, you can just find it. And set directly, you can just bind it as far as like same as before. Okay, and okay, this might I might not really talk a little bit too much about this because the cominatorics workshop is on the other side. But if you have a linear ideal, this thing is dual to something called the matroid subdivision. If you know what the matroid is, good. If not, this is the next slide. So, one important thing. One important thing is intersection theory, like you know from classical algebraic geometry. And in tropical geometry, you have the same problem as in classical algebraic intersection theory, that things just might not intersect well. Well, but what do you do in classical intersection theory? Well, you have the moving level. And in tropical geometry, you do the same thing. So the stable intersection of red and blue is computed as follows. You perturb it in some random direction. Then you can show that if you do. Show that if you perturb it in some generic direction, then the intersection will be transverse, and then you basically undo the perturbation and you just see where the white points end up with. And the stable intersection would then just be the three things. And this is nice because either the stable intersection is empty, right? So think of like two lines here. You translate it the zero intersection. So it's either empty or it's balanced of the co-dimension the sum, which is what we want it to uh be, essentially. Essentially. And oh, yeah, sorry, I also talked about the degree of a polyhedral balance region complex. So this thing is of degree 3, because again, like this red thing was just a tropical line. The stable intersection of the blue with the tropical line has three points. Hence, the blue thing is degree three. The degree is basically the number of intersection points with a tropical linear space of complementary dimension. It's exactly the same as in classical. Exactly the same as in pressure, which I'm trying to. Do they come in weights? Do you have multiplicities here? In this case, all multiplicities are one, but generally, yes, they have weights. Yes, but yes. Maybe naive question, but since this tropicalization business went through it necessarily the case that we can only detect local phenomena here? Or is this about s what happens on CF? This is what happens over the complex pursuit series, over the field of complex pursuit series. So, this is not just complex numbers anymore. So, I basically, when I say v of i, I meant the vanishing set over the field of pursuit series. Yeah, okay, so you're thinking of prizot series as branches of singularities and curves. Okay, but um, the way we think of the priceot series is they're just the complex numbers with a different um metric on them. Metric on that because they're an algebraic closed field of continuum with a transcendency over. They're isomorphicous fields. Just with a different metric, and it has nothing, it is related to branches of curves, but it's much more than just that. Keep the branches of curves simple. Keep the branches of curves in mind for the next. Yeah, I mean, it also picks up asymptotic information. Exactly. But it does many things. Yeah. Oh, yeah. So, basically, also, what's nice about these transverse intersections is if you have tropicalizations that intersect transversely, then basically the tropicalizations of their sum is the transverse intersection, basically. And this is the cheap way to compute tropicalizations. You start out with basically a trop I1 and I2, like I said. Can drop I1 and I2, like I said in the previous slide, that are easy to compute. And you can suddenly compute drop I1 plus I2, even though this might not be that. Generally, computing a tropical variety involves a lot of code-level exist computations. And this is one way to do it code-balanced. Okay, sorry, just one final example. So here's these two polynomials that are similar to what I had before. Similar to what I had before, F1 and F2. So, yeah, so this is basically, they kind of intersect in two points, they're transverse in 0, 3, and 3, 0. And one way to basically compute the multiplicities of the intersection is the following. So just take a look at 0, 3. Then the blue curve is in direction, sorry, blue curve is in direction 0, 1. The red curve is in direction 2 minus 1. You put them into matrix, completely determined, that's an value. Completely determinant, that's a mean value, and you basically get 4 because it's this determinant times the blue one that was multiplicity 2. And the same here, basically, this is the determinant of 1, 0, 1 minus 2. So the absolute value of that determinant is 2 again. Yeah? Where is the 1, 0? That's just the direction of the... Yeah, you can take the primitive vector, primitive integer direction in that direction. And because it's transverse, this will be always a square matrix. Transverse, this will be always a square matrix, right? So you can't get the determinant. Okay. So yeah. So in this case, basically, the tropicalization of F1 and F2 are just these three points and all of multiplicity form. That's like a quick way to compute the tropicalization of this ideal without computing a Kerkler basis of it. Because you need F1 and F2 basically, where that's possible. Okay, so I'm going to use this to compute To compute optimal homotopies. And the theory behind it is basically regarding this Pursuit series, so regarding a polynomial system over the theta-Pursu series, as essentially like a one-parameter family of polynomial systems of complex numbers, like you and Frank talked about. And basically the solutions over the Pursuit series will basically determine the behavior, asymptotic behavior of the branches around zero. So this is our original, sorry, this is our original system, and chances are, if you look at the Pursuit series, And chances are, if you look at the pursuit series and they don't happen to have a constant term, they start at valuation, find negative valuation, positive valuation to go to zero or infinity. But what I can do is I can apply changes of coordinates to make basically... So for example, these two blue branches will have the same valuation. I can make them basically converge to something equal torus. So in C-SOD. This is just a coordinate change on some compactified toric variety. It's basically like how you teach. It's basically like how you teach the PN being comprised of different charts. So I'm just looking at different charts of a certain toric variety, and then on one chart, the blue one will converge, and on one chart, the red one will converge. And this is basically the general idea. So let me just run this through an example. So both were divergent in the first case. Yeah, yeah. So for example, this would be like have positive valuations, this would have negative valuations. Negative valuations means it's t to some power. But negative power, so t goes to zero, it's goes to infinity. So t goes to zero, it goes to infinity. And I'm generally just looking at c starting here. So positive valuation goes to zero. Yeah, so here's an example. So again, we mentioned like solving. So suppose I want to solve this system. One way I can do is basically I embed this into a family of polynomial systems. So in this case, this is just like picking specific values for my small a's. What I can to get tropical geometry. To get tropical geometry into it, I can basically pick a generic specialization. So, the way I generally do this in my code is you basically pick the same coefficients here, but you now just give them some random power of t. And under sufficiently nice conditions, these things, yeah, you should be able to compute tropical data. I'll just treat it as a red box for now, right? So, compute the tropical data. I'll talk about this later. You see this. The tropical, I'll talk about this later. You see, I'm only like slide 12. So, suppose now I know what the tropicalization is at this Q, and I also know what the initial eigenvalue. So, this is all those. Now, in this case, I can get the tropical data. I know the points because they intersected transversely and it was cheap to compute. But ideally, the large part of the question is, how can I get this information cheap? For what system can I get this information cheap? So, for example, in this case, it is So, for example, in this case, it does a generic visualization. So, then I have like two different audio device valuations, so two different branching patterns. So, for example, for 3, 0, I can do this following operation. So, I look at my f, and now I replace x with t to the power minus 3 and y with t to the power minus 0, y. And if I do this, and I just multiply t to the power 6 on it, so I have a positive exponent, I basically get this polypony. Basically, I get this particular. But forget the bottom of the analysis. I get this. And what you can see is at t equal to 0, this would be binomial because you only have the second and the fourth monomial. And at t equal to 1, it's actually what we would compute. And you can do the same for h2. Again, replace x with t to the power minus 3x, y with t to the power minus 0y. And sometimes you have to multiply by a power of t to ensure that all exponents of t are positive. That's social speaking. And so, this is basically one way to do this. So, this would be like the blue, two blue curves that we had in the previous slide. And you can do the same for 0, 3, and you get basically again, so you get this, but for t equal to 1, it will be the original equation, and for t equal to 0, it will be binomial. And this is how you basically can construct homotopies from this tropical data, if you can get this. So, the tropical data gives you the information about the coordinates. Data gives you the information about the coordinate change. Yes, exactly. Exactly. It gives you the information about the branching behavior around zero, and that gives me the, that tells me how I need to change my coordinates so that they kind of don't diverge. And again, like, so for t equal to zero, this is binomial, so it's easy to solve. Your solutions to f1, f2 with the parameter, they're locally around zero, they're susering. Zero, they're suseri. And then you're computing the first terms. Yes, so this is the initials. Yeah, it's the three zeros. Yeah, exactly. So that's what I mean. So each point, let's say three, zero is one of the solutions or the leading term. So x diverges like t to the three and y diverges like t t. Yeah, it doesn't necessarily be just like, I mean, there will be four solutions here. There are four, remember, these were multiplicity four. So there were like four branches, but they. So there were like four branches, but they all diverge in a similar pattern. And so, for example, if you set t equal to zero here, you will notice that the resulting system will have four solutions in the complex torus. Because this is of degree, I was about to say this is of degree two. Clearly, that's not true. But if you just put it in the computer, you will see that there are four solutions. One of them is a constant plus x squared, and the other one is a constant plus x times y squared. So you can. y squared so you can yeah yeah so so it's possible to change uh and this is this is basically for lead with homotopics so this is huber strongness right so this big cell picture that i drew in the beforehand this was exactly just a dual picture to this and if you ask like homotopic continuation jl or like chief bank to compute the mixed volume using these tropical dissections is actually how they compute it uh yeah so but this is basically the the goal how do you get this tropical dissection. Could I get this tropical data cheap? Yeah, so the idea works in general as long as tropical data is cheaply computable. Okay, so how do I get this cheap? Well, in the previous example, it was very cheap to compute because I had transverse intersections, but generally I might not be as lucky. As in, I can write down families that, regardless which parameters you choose, topically they will. Choose topically, they will never intersect transversely. Yeah, so which, yeah, so these are usually tend to be also families where the mixed volume count is not the tape. And one way to basically resolve this is using something called modification. So I basically introduce extra variables and extra equations so that I have a transverse function that I can compute cheaply without completing code basis. But this, of course, depends on the. But this, of course, depends on the family. So, one family, this, and maybe I'll briefly talk about this. So, one family this basically applies to is something called these vertical families. So, if you're not, let's just go through this example. So, these have parameters, but notice that kappa 3 is always in front of the same monomial, and kappa 4 is always in front of the same monomial. Kappa 1 and Kappa 2, every parameter is in front of the same monomial. In front of the same monomial. And if this happens, I call this a vertically characterized system because every parameter is restricted to one column of a coordinate matrix. Think of it that way. So this is vertically parameterized system. What I can do with this is I can apply a change of coordinates. So basically on the top you see, I basically introduce a new variable y. That's basically my old x to the power alpha. So Frank calls this like exchanging of nonlinearities. Then my original equation. Then my original equation becomes basically linear in y's, and then I end up with binomial equations here, with y equals some monomial in x. It's not really rocket science, but it's quite simple. But what you can do is basically now you have a, for generic types of quantities, you will have a transverse intersection. And you can get the tropical data cheaply. So basically, you can compute this using these cheap combinatorics. And, okay. And okay, sorry, I should not take chic combinatorics, because this is literally a PhD student's project of mine. He would be very upset if I say it's not, it's not, it's conceptually easy, but getting this efficient implementation is actually surprisingly involved. But if you have this, you can basically get the original points just by forgetting basically the components for the y's. And basically, you can also show that these initial ideals will be binomial. So it's exactly what we wanted to have. It's exactly what we wanted to have. There is a system that I will have to a little bit gloss over for time reasons. This is these horizontal systems where basically every parameter is in front of... So now A1 is in front of two monomials, but every parameter is in front of... This only occurs in one polynomial. So A1 is in F1, so A1 would not be in F2. So this is called horizontally parameterized because every parameter is restricted to a row of the Macaulay matrix. And you can do a very similar thing here. So you can be able to. Similar thing here. So you can do modification, you have transverse intersection, and under some conditions, you can even ensure that the initials are binomial. I get some views of disbelief. I have some minor technical conditions that ensure that this is actually true. So it's not just, these are not like general systems that you find in the papers of Karve, Krovansky, and Kukov bodies. These are actually more specialized. Group of pointers. These are actually more specialized. Okay, this is the first type of tropical homotopies. So basically, homotopies from tropical ones. I had this tropical data, I extracted these homotopies from my complex systems from it. Now let's talk a little bit about homotopies to compute these tropical points. So here, there's this, in thermodynamic network theory, there's this example called wind example. This kind of, I don't know if you know what, I'm not going to explain what that means. I'm not going to explain what that means biologically. I also think it's not really interesting for this crowd here, and neither it is for me. Just keep in mind that these are nineteen variables, it has 22 quadratic monomials, it has 14 quadratic steady-state equations, so these are the equations of the first thing, and then it has like five linear conservation laws. Like it's following. Now, if I do what I described beforehand, this exchange of non-linearity, I introduce y's, I introduce I introduce this particular mode x. I now end up with 19 plus 22 variables, 19 x's, original x, 22 new y's. And again, I have like 14 plus 5 linear equations. So these 14, so these things become linear. I have like original ones, and then I have binomial equations as well. Now, if I want to compute the intersection, you kind of realize that tropical linear spaces are kind of weird. So tropical geometry is. Are kind of weird. So, tropical geometry is a realm of mathematics where basically like binomial equations are super easy, but linear equations are super hard. So, the tropical linear space basically consists of a quarter million cells, and I have to intersect all of them with this one. Again, like this is a binomial thing, so it's just a it's a cleaning space, it's just one cell. But I have to do basically a quarter million um intersections, which isn't really difficult though. Which isn't really difficult. It takes like a minute, maybe, maybe a little bit less. But what is very intellectually unsatisfying is that only nine of them, if you intersection. So I'm intersecting a quarter million things, of which 99% I didn't need. More than 99. More than 99, yes. Frank is very fast with the math. Yes. So even though I don't have a problem with timing, my suggestion points fine. So now the idea, sorry, so the idea basically, how do I avoid doing all these insurance is, well, I use homotopy continuation, but for the tropical data. So suppose this is, okay, I will have to close all of this very quickly for time reasons. But so this is an original example by Anders Jensen. So suppose I have this intersection I want to compute that is dual to this mixed subdivision here. What I can do is I can start with Start with something that I know. So these are basically syntaxes of length 2. This is why this thing has volume 4, by the way. So this is length 2. But since theoretically, this thing looks linear. So I should be able to compute intersection quite easily. It's solving a linear system, basically. Yeah. Again, what made that other thing in the last slide hard is because it was a positive dimensional linear object. A zero dimensional linear object is still quite easy to do. Zero-dimensional linear object is still quite easy to compute. That's just quite easy to compute. And then what you do is basically I try to make this into this and keep track of the intersection points. So for example, what I can do is I can increase, so by the way, so this blue one is dual to basically this, so this blue curve is dual to the blue triangle, the red curve is dual to the red triangle, and these are all like regular subdivisions of this that I have. So what I can do is I increase the height. Is I increase the height of this topmost vertex, but then I get a subdivision like this. It will basically do it in this, and I can basically just use this entire gain. So I can basically increase it. So if the height of this goes to infinity, that means it's just gone. And then it looks like this. Next one, I can change the heights without changing the subdivision so that the intersection point kind of means on the top. I can increase the height of this point. Increase the height of this point, so I induce a fault here, and then it's due to this. I can let this height go to infinity. It looks like this. I can, again, change the subdivision a little bit. So basically what I do is now I take the red curve and I move it to the right. Then this is what happens truly. And then basically I can let this height go to infinity and I get this at the end. Yes, so. Yes. So with the moving of the triangle, the the vertical arrow there, it seems that your structure model is G Just? No, no, it's 4 and 1 plus 3. Oh, the 4 is all tied up in the... Oh, yeah, yeah, yeah, sorry, yeah. It's with multiplicity. It's like this determinant thing. Now you see, some of these steps have arrows, and some of these steps have like these. And some of these steps have like these squiggly equality. And the reason for that is if you do this, if you implement this on a computer, if the blue curve changes, all you do is you keep track around the intersection point. You're only interested in the blue and the red curve around this point. You're not interested in how it looks elsewhere. So basically, if it changes elsewhere, you will not even recognize in your code. Because you only track all these things locally around the point. So these are basically just three non-trivial steps in G code. And this is. And this is incredibly fast because of it. And when something like this, where some multiple z disappears, you branch. Yes. Yep. Yes, exactly. Okay. And so this was with hypersurfaces, but this also works with linear spaces. So again, like remember in this modification thing, I had a linear space that was a difficult thing, and then I had a couple of binomial things that were difficult thing. You can do the same thing with matrix subdivisions. It's just more difficult to draw because matrix subdivisions are kind of more complex. In this case, I have an intersection. So the blue one is a tropical linear space. It's dual to a bipyramid. And intersects this red thing basically in the bounded edge. And then the mixed cell will basically be this red edge that's like dual to this horizontal red line, red plane, plus basically this rectangle here. And if you would move it up, then it will. And if you would move it up, then it will base the two mixed cells corresponding to the two dual points will be the red edge plus one of the two triangles on the side. It's essentially the same. It doesn't matter that much. So this is how this homotopy is done for these tropical points. Now, here's the main challenge for these homotopies. And it's because the main challenge is tropical linear spaces are hard. So suppose I my So suppose I uh my uh I look at a linear equation where the solution set is the row span of this matrix plus t squared times some random matrix. But I talk about now over some field, valued field, right? So I'm not going to talk about anyone. Now then the tropicalization, I mean you know that this thing will have six true Lugger coordinates and you need all of them for the to determine what the tropical linear space looks like. What the tropical linear space looks like. Let's just pretend 15 is very large, okay? 15 is very large, and this is too many, too much for us to handle. How do we do this? Well, I mean, as I said, we only need to keep track around this linear space, around the point W. So the question is, how many of these over sneer infinitely many Plicker coordinates here do I need to just know how my tropical linear space looks like around the point? And the answer, again, answer star because I'm cutting a lot of corners, it's quite easy. Cutting a lot of corners, it's quite easy. We just look at this point w, that's e1 plus e2. Notice that w1 is equal to w2 and it's larger than all the other things. So what you do is you just pick one of one or two and pick one of these four. And these are your critical coordinates you need to care about. Again, it's indexed. The critical coordinates are indexed by two element subsets of one up to six. And these are the two element subsets that you have to care about. So basically, instead of fifteen, I only eight. I only need 8. If you look at the WT example, you get from 13 choose 19 down to less than 50. So it's just something that scales much better. So technically what you need is you need like the number of vertices of your rootless class. The number varies depending on which double you are, but in our experiments it was always less than this number that was around 55 million. Okay. So do you have a theoretical result for that right now? No. No. Because we don't even know how. Yeah, no, actually I don't know. So you need to know basically what are the sizes of the biggest rupees facets of these metric protocols. And I don't think anybody has looked at these sort of questions yet. Yeah, so the conclusion of this talk before I go to the OSCAD demo is: you know, before you try to. Is, you know, before you try to solve a system over the complex numbers, try to solve a tropical. And maybe, you know, you can use these tropical solutions to basically get these complex solutions more cheaply. Or rather, actually I mean the other way around. Try to find out which systems are easy to solve on the tropical level, because then necessarily you get that they are easy to solve on the complex levels. And that's now time to go to the Oscar remote. I have 15 more minutes, right? I guess 18. 18 and a half. Okay. I will have to do it like this because I can't somehow mirror my screen. And oh, I just realized that the resolution is quite big. Okay, that's good. Then I don't need to zoom in. So this is just a demo. So all uh oh everything that I've talked about in my talk is basically work in progress. Um the implementation part is still work in progress and we're doing it in Oscar. Lot of progress in doing it in Oscar. And I just mean to talk a little bit about, I guess, okay, this is just like the most general thing before I talk about the topical job in Oscar. So if you want to install Oscar, what you do is you install Julia, just download it from the website, or use the package manager, install it on your system, of your choice. In Julia, you basically run this up command to update the package information that's available. That's collected centrally in Julia. Yeah. In Julia. Yeah. Just the square bracket close. Is that? But that's part of the command. So Julia has like a multimodal REPL basically. And this basically tells it, Julia, whatever comes is now related to the package manager. And then you basically add Oscar, and then it will just install Oscar by default. If you want, for some reason, you want the developed version of Oscar, then you basically Version of Oscar, then you basically replace the ad with that Oscar. And then it automatically close Oscar from GitHub. And everything will be installed in, if you're on macOS or on Linux, everything will be installed in a.julia folder in your home directory. Since I see some people opening their laptops, in case you try it out, if you're in Windows, please install it using the WSL subsystem. I use a real operating system. Okay, then never mind. System. Okay, then never mind. Yep. Once you run the market, you're already in the package. Oh, you don't need to type it a second time. No, no, yes. Oh, I see. You don't see the bracket at the moment. Yeah, but this is basically Julia handles all the package management on Python. That's like one nice thing about Julia, Python. Python. Okay. Um yeah. Okay. Oh yeah, and then if you want to use Oscar, then all you do is basically just type use on Oscar and then it'll load it. Chances are it needs to pre-compile for like a minute. Okay, Julia question. Yep, I see parentheses at the 1.6. So parentheses is DK. Oh, no, it doesn't recognize. Oh, no, it doesn't recognize. No, it doesn't. I'm not getting that prompt. It's not all calculus, Oscar. It's okay, yeah, I'm getting it. But you're not getting the Julia prompt itself. Yes. I'm getting a package. Yeah, yeah, yes, yes. Okay, sorry, sorry. Okay, here. Now I type, let me just type square bracket close. It's not all capital Oscar charges. And then you just do add to Oscar here. Oh, I see. It's not all capital. Yeah. Or you do upcoming. Okay, it's working again. Thanks. Thanks. At least it's the cleaning board. Yeah, and basically, if you prove a concept. And if you need any help, then you can basically just use question mark. It's usually faster, just post it on start. Okay, so this is how you install it. Now, if you want to run it, let's say you're interested in chopping. So I think what here is. Let's say you're interested in the chopper. So I think Matthias is talking a little bit more about. Will you be talking about Australia as well? Will you be talking about what you did with schemes at ECIS? Yeah, so. Okay, Matthias will talk a little bit more about schemes at OSCAR. So I'll mainly focus on the tropical geometry. So in OSCAR, basically the tropical... Okay, so this is now kind of cut off. Apologies for it. So basically, the tropical semi-ring is either this T min, so it's basically Q with infinity, and the addition is the minimum, multiplication is the addition. addition is the minimum, multiplication is the addition, or it's T max, and that's basically, yeah, addition is the maximum and multiplication is the minimum and you have minus infinity. So minus infinity is the neutral element with respect to addition. Well, minus plus infinities. And it's a semi-ring because there is no inverse of taking the minimum of k numbers. Okay, so um yeah, so now Yeah, so now basically in Oscar to get a tropical semi-ring, you basically just use this construct a tropical semi-ring min, and then you can basically just add to numbers, which is the minimum, multiply to numbers, which is addition. Notice that the zero element of t is infinity. So zero always, in Oscar, zero is always the neutral element with respect to addition. The neutral element with respect to multiplication in this case. With respect to multiplication, in this case, it's zero itself, and we can do the max as well. So the maximum of one and two is two, and the addition is still the same. And now the zero element is minus infinite. So Oscar basically also uses min convention by default. So if you don't specify min or max, we just assume min. I disagree, but all the books are min. So I'm like kind of forced to adhere to that. Forced to adhere to that, unfortunately. Does it depend on what is the implications of the mean? It depends on where you believe infinity is. If it's at zero or infinity. It's C star. I mean, really, it's how you parameterize C star. Yeah. So this is your parameter x or is your parameter in a one over x parameterization. Depending on basically where you come from, one is more natural than the other. Because in one of the conventions, you have less minus sites than you. One of the conventions, you have less minus sides in your equations than the other, and that's really what determines what you should be using. Well, also, at least one of the schools comes because one of the proponents doesn't understand there's a difference between a primal and a dual. Yes, polynomials, you know, Torres acts dually on it. Yes. We don't name names here. You can guess. Okay, um it's also important um And also important, tropical numbers, in the literature, they're always the real numbers with minus infinity and infinity. But in Oscar, it's always rational, because I don't want to deal with floating point everywhere. So stuff like this, for example, I mean, you can work with algebraic closure on OSCAR, right? So you can say, okay, V. Sorry, V is like, you know, V is like square root of 2, W is square roots of 3. You can add, for example, square root 2 to square root of 3. That's roughly 2.56 with the minimum. 2.56 with the minimum polynomial there, but you can't make this to a sort of conductor. That's sort of oh, yeah, that's at least at least. Let me try. Okay. Yeah, you get some error. Okay, so this is tropical numbers. Now, many functions in OSCAR, they are kind of implemented generically. So it's basically like a Python, right? So if you write like a Python function, we don't really have to tell it what the types are that you've. To tell it what the types are that you put into there, it'll just run it and it either works or it doesn't. So if you basically write like A plus B, and then when you enter it, you've given A and B, and some conditions are defined, you type the operating at one time. And in Oscar, you can do something similar. It's a little bit more elegant than that, but yeah, let's just say it's very similar. So basically, if you have these tropical semi-rings, you can basically get. So basically, what happens is I had to just implement tropical semi-rings. And I get matrices and polynomial rings. Simulate. And I get matrices and polynomial rings all for free, so you can get like polynomials over it. Oh, yeah, by the way, we are using, okay, first of all, two things. So we're generally just using the parentheses to distinguish this from a rational number. And just notice that zero is not a neutral element with respect to addition. So plus zero is really non-trivial. This is a monomial. And yeah, you can evaluate it and you do whatever you want, basically putting on the arithmetics. Yeah. But just keep in mind. Yeah. But just keep in mind that some generic functions do not work because tropical Zemi ring will have no subtraction. So if you now take with her now compute a row-reduced echelon form, you get an error that tropical subtraction is not defined, it's the only problem. And if you want to compute an ideal over the tropical semi-ring, this is not supported because tropical ideals are very, very difficult. However, so what Julia does. So, what Julia does, so you don't really necessarily need to specify what type of function you enter. But if you do, Julia always tries to use the function that is the most specialized to the input that we matched it. So, basically, I can compute the determinant of a tropical matrix because at some point I defined the function that specifically for a tropical matrix. So then Julia basically uses that function instead of applying the generic one. And because there's that, you can also compute like minus. So, in this case, I basically stacked m twice horizontally next to each other and just computed two minus. This is a monopolized thing. It could have computed that m in a stupid way, but would have been time consuming, so you implemented a new that. No, no, no. The way it would have computed that is using the cross. I played algebra in German. I don't know what this thing is in English, but yeah. Expansion, yes. And it cannot do it that cannot do. That's no negation. I was thinking, just use the stupid formula for the that's the same. But even that is the negation. But negative one is one, probably. Yeah. At some point, the tropical generas decided determinant, impermanent, they're not that much different. So whenever we now take that of a tropical matrix with the permanent. Right? Well, I mean, that's if you interpret what it means, since you have constants, negative one and plus one are just constants with evaluation zero. So really the dropable determinant is also current. So if you work over the, yeah, that's true. So if you work over a valid field, you look at the determinant and the permanent, that coordinates valuation would be generically basically that the same. So yeah. Okay. Um okay and a lot of so a lot of if you again like talking about valued fields um a lot of features that work with valued fields and also tropical features will require a tropical semi-ring map that basically encodes both the valuation and the minimum custom convention. So basically it's a map that goes from a valued field to a tropical semi-ring that's either basically sorry it's cut off again, but that's either basically the valuation of C if you're in the Min convention or minus the valuation of C. convention or minus the valuation of C in the next convention. And then basically it takes 0 to either infinity or minus infinity. And yeah, so unfortunately right now this isn't like fully generally supported. There is basically just there are just some valuation on the supported. So trivial valuation on any field, you can work with pietic valuation over the rational numbers. Valuation over the rational numbers. So this is basically generated as follows. So this is like the two-addic valuation where zero has sent to infinity and two is sent to one. And also T-addic valuation of our rational function. I'll go through this. And the general rule of thumb is if you don't specify a uniformizer, you usually meet the trivial valuation. And if you don't specify whether min or max, we assume that. Okay, I have. Okay, I have a little bit more time, so let's talk a little about tropical varieties. I talked about these tropical linear spaces and hypersolutions before. These also exist in OSCAR. So OSCAR has basically four different types. One is a general type, tropical variety, one is hypersurfaces, curves, and linear spaces. And effectively, you can just regard the bottom three as a subtype of the top one. This isn't how it's implemented in Julia. This isn't how it's implemented in Julia, because this is how Julia works. But if there's any behavior that basically contradicts this intuition, we regard it as a bug. So this is how the user should think about it. Error? Only from abstract types, and then you can't instantiate. Yes, it's a bit tricky, but it's doable. Yeah. Okay. So So, yeah, hypersurfaces, you can basically construct them from the polynomials and Newton poly or Newton subdivisions. So, here, for example, I'll just construct, this is a, I'll just make a polynomial ring in coordinates in variables x, y, and z. I kind of define a polynomial, that's a degree 3 polynomial, and I can basically compute its hypersurface. In this case, it's max, because I specified max when I defined mu on the top. Find new on the top, and you can visualize drop of H1. So this is how it kind of looks like. Okay, and it opened up in the wrong browser. Okay, it's a bit better. So this is how basically the this is how a cubic thing looks like. It's something in R3, it floats around. More importantly, let me just More importantly, let me just go back. So, this is hypersurfaces. You start out with a polynomial. For varieties, you have to start with a general ideal. Or, okay, the feature is still somewhat limited. There's a GitHub issue. If you're interested in, I'm working on it at the moment. But if you want, again, as I said, one way to construct these varieties is to save an intersection. So you take to hyper-service. Stable intersection. So you take two hyperservers, you intersect that stably. Right now it's a little bit slow because the fast code is still a work of progress. But yeah, so you intersect two things and you get actually a tropical right. Because it's not a hypersurface anymore, it's a four-dimension one. And then in this case, basically, what I did is I intersected this hypersurface you had before with the tropical line, and then you basically get a degree three tropical curve, which you should notice, this is basically like classically, it's genus one. You have the cycle here. Cycle here. This is so basically I intersected this degree 3 curve with the hypersurface of something x plus something y plus something z plus some constant a. So stable intersections are varieties and yeah it's currently extremely expensive because it uses a generic implementation instead of a fast one. So one example where we already have a fast implementation is of linear spaces. So could you go back to this example? I mean in real life In real life, they expected a planar cubic. It is a planar cubic. But he has these things pointed out. You don't see the plane. It lives on a tropical geometry. It lives on a tropical plane. Yeah, tropical geometry, some planes are more equal than others. So this is the example of the matrix that I had before. So I basically took this 110011 and in the first row, 0, 0, 1, 1, 1, in the second row, I added t type. The second row, I added t times some random matrix here. So this rand just says sample from int 8 randomly a matrix of size 2 times 6. Add them together, I make a tropical linear space. And in this case, basically, the intersection is much faster because you just work with the Pilker vectors. So you know basically, and in classical geographic geometry, you also know basically how the Pilker vector of the intersection of the linear spaces can arise from the Pilker vector of the two intersects. In tropical geometry, it's similar, just to get the The student needs. And hopefully soon we'll have something ready for the hypersurfaces soon. Yeah, so this is sort of. And I think I'm running out of time, so let's just stop. Thank you. Any questions? Yeah, that's just for the demo that you just did. So you're So you're uh showing a lot of uh sort of very nicely wrapped uh tropical geometry uh functionality here. Are are you aware of any other packages that currently offer tropical geometry sort of as a concept accessible? Um so there are two packages that are like basically the main packages of the geometry. One, if you coming from the algebraic geometry background, is something called Algebraic geometry background is something called GFAD that's implemented on Siensen. That's this tropical homotopy thing that I showed is actually also by him. And that's, yeah, so that's with polynomial ideals and stuff like that. If you basically just work combinatorially using subdivisions, matrix polytopes, then there's also polymake that you can use. Those are stand alone systems or? Yeah, uh yes. GFAN is actually just like a command has a command line interface, so it's basically binary so it passes files. So it's basically binary. It passes files. Yeah. And GFAN, if you want to use GFAN, maybe it's more worthwhile to check out the McConnelly2 library that has like a.