Or so is joint work with Arsenal Meta and JAO. And it's basically the result that's in the title of the talk. Thanks to the organizers, by the way, for organizing such a great event. And also, thanks for sticking around at the end of the day. My thinking for this, just I've talked about it a little bit before, was to be nice to do some technical details for the proof. And when I started writing it all down, I found that I got a whole talk of technical details. Technical details. But if you want to prevent that happening, you can ask more questions in the beginning of the talk, which is less technical. Maybe I suggest that. Anyway, let's do a warm-up question. So here's the question. Given X in the full group, C star L prototype free group, is X positive, well, how would we answer that question? Well, the first thing is, what does it mean to be given an element of a full group C star algebra? C star algebra. So maybe it's going to be hard to be given an arbitrary element. So we could cross that out and say instead we're going to be given something in just the ordinary algebra, or maybe even in Q Fn, then it would be really easy to say with at least we'd give it an element. And then of course we made our modifiers to say, is it greater than or equal to zero in the full group C star electro? And then when we do this, we see that there are Do this, we see that there are. Well, the first thing we might say, well, this should be very easy because we'll just have to say x is equal to y star y, right, if it's positive for some y in the full group C star algebra. And so we just have to find y. But again, what does it mean to find y in the full group C star algebra? So we better cross that out. And then we can say, well, maybe we can try and find y in one of these algebras. But it turns out we can't quite say that x is equal to y star y, but it's Y star y, but it's a theorem of going and that x is greater than or equal to 0 if and only if x is a sum of permission squares like this across i of y i star yi for y i for y one up to y n in C of and then C of and we could also, so it turns out this result is also effective. Okay, so it gives us a way to say, given x, by looking at x, we can say not only do such y1 into yn exist, but there's some degree bounds on those yi. So we can actually use this to answer this problem in a practical way. Alternatively, we could use a fume of choi. You have a joy. Excuse me, so following our encouragement. Yes, please. So, this is for the free group only, that kind of equivalence for the says that x is positive, not positive actually, if and only if there's a representation, say this algebra, to finite dimensional matrices. to finite dimensional matrices such that phi x is not positive. Okay? So positive should mean positive in all representations. And this is also effective. There's a, oh, just a degree bound in terms of x that we can put on here. And so we just have to check all the different representations into matrix algebra. And it turns out that actually gives a practical And it turns out that actually gives a practical, well, something you could do on a computer, not practical exactly, but a way of checking whether something's confident. So we have two ways of doing that. Now, in general, let's say A is a group algebra, or just say an Archimedean, Archimedean star algebra, then we can. Then we can say that x in A is positive if we have that phi x is greater than or equal to 0 for all phi from a to b of h. So positive in all representations, which is the same thing as saying that it's positive in the envelope and C star algebra of our star algebra there. And we can say that Um and we can say that uh x is, let's say, f g positive or finite dimensional if um if uh we have the same thing here, but instead of for all representations, just the ones with the dimension less than you know, finite dimensional representations, we'll say A is XOS, or sometimes this is um Archimedean flows, okay? Median closed, okay, if x is greater than or equal to 0, if and only if x is equal to y1, you know, sum of permission squares like this, y n star y n for y 1 up to y n in A. And A is R F D If x is finite-dimensional positive, if and only if x is positive. And that's the same thing as the enveloping C star algebra to be RFD. Now, galma of these algebra, we'd like to know. Is it SOS or RFD? And maybe the first thing we can say in general is that, well, food. Well, if we want to know if something is positive, there's the health in the cola let's say non-negative Stalin Sants. And it says that x is positive, x squared equals 0, if and only if x plus epsilon is equal to. Plus epsilon is equal to a sum of squares, okay, for all epsilon greater than 0. Now, notice that when something's SOS, the nice thing about that is it gives us a way to prove when something is positive. We're kind of saying, look, if something's positive, then there's always this summit squares proof that it is positive. And when we say in other words, RFD, we're saying there's a nice way of proving that. That something is not positive. Because if something is not positive, that means it's not positive in finite-dimensional representations, if the outputs are of phi. And like we did here, we could go and find a representation that shows it's not positive. This is a great theorem. It tells us exactly when an element is positive. But the problem is it doesn't give us away. So this doesn't prove. Doesn't prove. Doesn't prove an element is positive or not positive. We can't use it to do either direction. So if you think about it, let's say we're trying to prove an element is positive. Well, we could say, look, I could take x plus epsilon for epsilon equals 1 over 10 and find a sum of squares, and then it could be 1 over 100 and so on. But I can't check all epsilons. So none of those would prove that it's positive. And vice versa. Prove that it's positive. And vice versa, if I want to show that something is not positive, well, the issue here is that the sum of squares is not effective. So, in principle, if I can show that x plus epsilon is not a sum of squares, fine, it wouldn't be positive. But how do I know when I've hung over here? I've said there's a bound on the degree here. Whereas here, unfortunately, there's no bound on the degree. So we get, we don't get a We don't get a practical answer out of our question, unfortunately. So, what is the generality of these any Archimedean star algebra? Yeah. So, that's the nice thing about it, is it really answers the question of full generality. And I think Helen McCullough did not prove it in this form. And I learned about this form from some very nice notes of Azawa, although Simprich, I think, may have been the first to write it down in this form. I think may have been the first to write it down in this form. But I highly recommend tax notes for all of these things. If you know something about the generators of G, then can you give an upper bound for the number of sums at the core? Yeah, not really. Yeah. Okay, so the point is that if we have these two properties together, say if A is, I'm going to put it finally presented here. Put it finally presented here. So, what do I mean by finally presented? I mean I want it to be C star x1 of xn, so generated by some elements x1 of xn, modulo, some finite list of relations. So it's finitely projected plus RFP plus SOS. XOS, then there is a way, then we can determine then we can determine if x is greater than 0. And actually, we can even do it like, you know, on a computer. If I want to do it on a computer, then I maybe need this to be actually defined over. To be actually defined over Q, let's say. Defined over Q. And here, maybe I'm going to do it for only for x that are in star polynomials in over Q. So I can plug this into the computer. But why is this true? Ignoring all this stuff about whether this exactly makes sense for a computer. The idea is that given my element, Given my element, so if it's positive, I may not have a bound on what degree of I need to look at here for the yi's, but what I'll do is I'll just go searching for some sparse decomposition for the element. And at the same time that I do that, I'll go searching through finite dimensional representations. And now, how do I know if I have a finite dimensional representation of my algebra? Well, when it's finally presented, I just have to check assignments of matrices to x1 to xn. matrices to x1 to xn that satisfy our relations r1 to rm so i can look at all uh representations of dimension d very easily and i'll look for one where the given element x is not positive and if we're rfd and the element's not positive that's guaranteed to terminate if we're sos and the element's positive the the sos search is guaranteed to terminate and so whether the element is positive or not one of them is guaranteed to terminate and eventually we'll find out whether it's positive Terminate and eventually we'll find out whether it's positive or not positive. And we'll have a proof in there that it is one or the other. Yeah. But doesn't this have an issue of like if you're trying to enumerate all possible representation and all possible yi, then you like have to enumerate over uncomfortable instead? Yeah, great question. So yeah, what does it mean to search over all representations? It turns out we can use something, and similarly for SOS, you might notice even if we're given an element in Q, here are these words. In Q, here, these were, like even back here, these were in CFN. So, how do we know that you actually, you know, what if you actually have to take coefficients that aren't in Q here? And what you can use is something very handy. In terms of for a given fixed dimension here, this one's created on the RFD one, the problem of whether you have a representation in dimension D where the element is negative is given by a set of. Is given by a set of polynomial equations over the entries of the matrices that these are assigned to. And then it turns out that whether or not you have a real solution, instead of polynomial equations, that's a solvable problem. Whether, you know, independent of how you represent the real numbers or whatever. So this is, you can do it with parsley quantifier elimination or things like that. So yeah, that's kind of a detail that's under the rug here. Detail is under the rug here. And also, part of why you can do this, but Tarski quantifier elimination takes a long time. It's not a practical thing to do. So maybe this isn't, when I say it's practical, it isn't so practical. And that's actually something I wanted to mention here. I'm talking about computability. And don't normally consider computability when we talk about operator algorithm problems in them. And so is this just something we should, should we only care about computability when we're trying to solve some practical problem? Well, here are the Some practical problem. Well, here the reason it's coming up is actually just because something is computable, let's say a yes or no question that you're trying to compute, if and only if you have a way of proving that you have, when something is a yes instance, that you can have like a finite proof or certificate that it is a yes instance, and that you can find a finite proof or certificate, something to no instance. And if you have that for your yes or no question, then you can compute the yes or no question because you can search over proofs for both. There's no question because you can search over proofs for both the yes and the no sign. And vice versa, yeah, if you have, if something is computable, then you have a yes or no, you have proofs for both the yes direction and the no direction. So here we're looking at properties that come up pretty naturally. And like for these properties, we see this property is about telling us how to prove something's positive. Prove something's positive. So, whenever we have a property like that, that's like telling us about how to prove something with a finite proof, we really have computability coming up. It's not just about trying to solve something on a computer. Something that can come up just thinking about problems that have nothing to do with computers. Okay. Just to check on misunderstanding. Are you saying the YI, saying the SOS situation that we're saying? SOS situation, they're saying that yi could be have coefficients over c, but there is still a like a computer verifiable finite proof saying such yi exists. Exactly. For fixed number, so if you like take kind of a finite support here, right, and then you know write it out so that the coefficients are all real numbers, right? Like do a variable plus another variable times i. A variable plus another variable times i, and then you've got a finite set of polynomials and real variables. Then you actually can decide, yes or no, whether it has a solution. I see the problem. Yeah. It's only when we let the number of coefficients vary, like the size of the support sets of the y vary, that we don't have a decision problem. Okay, let's do some examples here. So I just want to remind you that probably Remind you that probably the most famous example of when people were looking at some of the squares decompositions is for polynomial algebras. These aren't actually Archimedeans, so they're not really examples of what I'm talking about. But here we have Artemon's solution to Hilbert's central problem. And so this is not a So, this is not SOS for n greater than equal to 2, but what Artin showed is that every positive element is a rational sum of squares. Another commutative example we can look at are the group algebras, say C, C, N. So, these are Archimedean now. And here, these are SOS. And here, these are SOS n is less than 2, my result of Scheider. In general, for abelian unit of algebra, I guess, can be practiced. A lot of different things can happen with sums of squares. I think people have studied these for a long time. But the question of whether an For a long time. But the question of whether an element is positive can be usually decided, as long as the outcome is not too pathological, by a couple of different methods. Let's say target quantifier limitation is one. Or there are what are called effective positive stellar sets. So they're not quite so nice to say that every element is a sum of squares in many cases, okay, but they say something along the same lines that allows you, as we had up here, where we have something being a rational sum of squares, okay? They modify the sum of squares definition in such a way that you can always find a certificate of positivity and in such a way that you have some degree balance on how big the things in the certificate are. The things in the certificate are. An example of this names here are Berucci, Lombardi, and Roy. There's a very powerful paper from 2020 to look at. But we're interested in non-commutative examples. So we've just here talked about what happens for Fn, right? So that would be maybe the first non-commutative. So that would be maybe the first non-commutative example to look at. And what we saw from these two results is that this is both SOS and NORA. So we can mostly solve positivity, or almost always solve. Positivity, or almost always self-positivity, in the abelian case. And we can also do it in the first non-commutative example we might look at. The next question is, what happens if we start getting products of Fm itself? Let's look at Fn cross Fn. And here, right away, we're going into some difficulties because we have a first-verse result that. This algebra is RFT if and only if one of any problem is true. And of course then we have sort of re theorem from Gorojan. Ewing that point of heading is false. So we know this algebra is not RFT. So question, what about the SOS property? Can we show that maybe it's not RFT, but maybe it's at least SOS? So here's the theorem I want to talk about. Again, joint with Arthur Meda. June. So positivity, so positivity is undecidable for this algebra. And I'm going to explain what this means much more specifically. So what we prove There's a mapping, there's a computable mapping. It goes from Turing machines. So Turing machines kind of a model of machines that compute things. But if you haven't run into them before, just like computer programs, okay? So that's from computer programs to elements of Elements of QFN plus Fn. Oh, the theorem in here is for large enough n. So you get to fix n as long as it's large enough. Okay, and so it's going to send m to alpha m such that alpha m is positive, if and only if m does not help. So we have a corollary that uh That therefore cells were not SOS. Why is that? Because if it was, if it was, we could prove we could solve the whole problem. Okay, so suppose it's SOS. How do we solve the halting problem? We're given a Turing machine. We've got to figure out, so the halting problem is given a Turing machine or a computer program, figure out if when you run it, it will eventually stop or halt. Okay, so what we do is we're given a machine, we start writing it, okay? We're just going to see if it does halt eventually, we'll say that it halts. And then we want to know, you know, the problem with that algorithm is that. The problem with that algorithm is that if it never halts, we don't know, you know, do we just need to run it for a bit more and it will eventually halt? Or is it never going to halt? So just running it is not going to solve the problem for us. You can only tell us one side. But what we'll do while we're waiting for it to see if it halts, we'll compute alpha m, and then we'll start looking for a sum of squares decomposition for it. And if we eventually find a sum of squares decomposition for it, we know that alpha m is positive, and therefore m does not hold. M does not hold. So basically, if this happened to be SOS, we have a way of proving that this is positive always. This is what the SOS property means. And hence, we have a way of proving that M does not halt. So we can sell the Halton problem because we prove that M does not halt when it doesn't halt. We have a finite certain set of facts. For some, like, this isn't necessarily the easiest way to solve this problem, right? All you have to do is find some element in the algebra which is not a sum of squares. But I don't think, we've talked to a lot of people and couldn't find anybody who knew such an example. So we think this is new. But I also should emphasize it's a lot stronger. Because it says that not only is it not SOS, but there's no certificates for proving positivity. There's no version like this where we just change some. Version like this, where we just change sum of squares to rational sum of squares, or any other types of finite certificates for positives. You just can't prove that something is positive in this algebra. If you have some kind of proof system, there'll always be some element which you can't. The proof doesn't apply to you. Definition doesn't apply to you. Can I quickly revisit insufficiently large so this doesn't hold for F2? Yeah, we don't know F2 in particular. Yeah. I think uh n equals three is fine. Okay, but so three is sufficiently large. That's what I'm remembering. I didn't actually check the paper again. For that, I was just like, yeah. I guess the first way I interpreted this is you know there exists an, so that this is undecidable for the bigger end, but you're saying in the paper you can figure out what it is and it is possible to read. What, yeah? Now I'm wondering if it could be two. I think actually it might be okay for answers two as well. Definitely not one. I'll check out. Yeah. There's a bunch of other elements you can do this for, not just fn. And I think it's a different, it's actually Z2 pre-copy with itself n times, both two copies of that. That one we don't know for n equals two. But actually, I think F2. We don't know for n equals 2. But actually, I think f2 is fine. It contains all, contains fn. Okay, so the reason we wanted to prove it like this is actually because this is actually very similar to how the Vitstar equals RE theorem proves that pun embedding is false. So here's what Vit-Star equals RE says. Star RE plus RE, okay, says that there is a beautiful map. So it goes again from Turing machines. Yes, Turing machines to, so there's some technical differences actually here. So in Mitchard Sari theorem, we can't fix n. So n also has to vary in this map. That's fine. I don't think the coefficients aren't in Q either in that theorem, but they're in the algebraic closure of Q, which is a computable field, not really different. Okay? So it goes from M to alpha M. So it goes from m to alpha m, and it's such that if m holds, then alpha m is not positive. And if m does not halt, I hope the sacrificial paper does not halt, then alpha m is actually greater than or equal to 1. It doesn't quite say this, it says for positivity in finite. For positivity in finite dimensional positivity. So that theorem is about not positivity as we have here, but finite dimensional positivity. And this implies the, so Perov CFN plus FN is not RFD. So the reason there. So, the reason there is we want to be able to prove the non-halting direction, right? In other words, we want to be able to say, we want to say if this was RFD, okay, then we'd be able to solve the halting problem. And to solve the halting problem, we need to be able to prove that something does not halt. And how would we do that? Well, if alpha m is greater than or equal to 1, well, we just Is greater than or equal to one. Oh, I just got rid of the Help-McCullough positive cell in sense. But in particular, some proof: if alpha m is greater than one, then Helton column implies that alpha m is a sum of squares. Let's see, right, alpha m, so alpha m minus one then is positive. m minus 1 then is positive. So alpha m is alpha m minus 1 that's positive plus 1, right? That's plus epsilon 1. So everything of the form plus epsilon 1 is a sum of squares, so this is the sum of squares. So that means that while we're waiting to see if m halts, given a Turing machine, we could search through some of squares decompositions for alpha m. And if we find one, we know we're not in this case. So we must have been in this case. So again, now this is only going to work. The Halton-McCullough positive shell status only applies if it's actually greater than or equal to 1 in all representations, not just in finite dimensional representations. So if we're RFD, right, if RFD, then alpha M greater than or equal to 1 in finite dimensional representations implies that it's actually greater than or equal to 1, right? So we would have solved the halting problem. We would have solved the halting problem. So this stands out. Yeah. Couldn't you also just enumerate all finite image representation and use TarSkey without passing? The problem with that is, and it's kind of interesting, if we find a representation where, so if we would go to finite maximum representations, we end up showing, we find a place where this isn't positive in a finite matching representation. All we would have proven is that m halts. So So it turns out when you're checking finite-dimensional representations, right, you can always check non-positivity in finite-dimensional representations by searching through them. So the theorem kind of has to work out this way. It's an interesting... If you just enumerate small things, we just be able to find something that's RFF. No, because we never have a way, even if we know that it's RFP, right? We don't know. Right, we don't know, like let's say we start checking finite-dimensional representations, and they're positive in the dimension 3, dimension 4, dimension 5. We don't know at any point that it's positive in all dimensions. Okay. Uh yeah, so I wanted to say we're getting um getting dangerously close to the technical part here. The technical part here. Yes, so I'm going to talk a little bit about the proof of this. And actually, it's much easier to explain the following theorem. So let's say we've got x and a again. We're saying it's cratially positive if tam of x is greater than or equal to 0 for all For all tracial states. Okay? And we have a theorem, actually, from which this theorem follows that it is undecidable to determine if x in the free group algebra, like this q here. Algebra, like this Q here, is facially positive. Okay, so positivity is undecidable in product algebras, and facial positivity is undecidable just in three group itself. So we also can prove it, as I said, for a bunch of algebras, and one of them we can prove it is for Qz2 to the star n, and for n sufficiently large. Then for n sufficiently large. And here I think the n is 3. And so let me tell you a little bit about how this group works. So what we want to start with is, well, we should start with just being given a Turing machine. And by the way, when we say that it's undecidable here, I mean exactly the same as the statement I have right here. Pages with tracial. I have right here. Pages with tracial positivity rather than ordinary positivity. So we want to take a Turing machine m to an element alpha m. So what we're going to start with is start with an algebra A0, which is going to be an algebra generated by a bunch of elements, countably many, x1, x2, and so on, and p1. X2 and so on, and P1, P2, and so on. Such that Xi is a unitary involution. In other words, it's unitary squares to 1, and I want Pi to be a projection. And then the final thing I want to say, or relation for this algebra, is if M hasn't halted after N. After n steps, let Pn plus one equal Pn plus Xn Pn Xn. But the thing about this algebra is if M halts, okay, then A 0m has a tracial state tau with tau P0 strictly greater than 0. Why is that? Well, basically, what's the effect of this relation? This relation says that how of Bn plus 1 is equal to Plus one is equal to, oh, this backwards. Okay. Oh yeah, no, it's okay. Yeah. Equals tau of Pn plus tau of Xn Pn Xn. Okay, but it's a tracial state, so that's just the same as tau of Pn. So 2 tau of Pn, right? So what we get is that tau of Pn is less than a half. Is less than a half, or less than a half, tau pn plus one. These are projections, so this is at most one. Okay? So what's going to happen is if m runs forever, then we're eventually, we're going to get that tau of p zero is less than or equal to one over two to the n for every n. We end up forcing this down to zero. But if it doesn't run forever, if it stops at some point, then all we're saying is that tau of t zero has to be less than one over two to the n. Has to be less than 1 over 2 to the end, and it's halted after end steps. And that's no big deal. Just define the state so that panel p0 is 1 over 2 to the end, and then kind of fill in the rest of the p1, p2, and so on up to the end to make it work. And then after, for n larger than, you know, after the point where m is halted, you don't have any more relations here. It's just fill it in however you want. So, yeah, very easy to construct a state if m halts. On the other hand, if m doesn't halt, M doesn't halt. If M doesn't halt, then tau of C zero right is equal to zero for all traces tau on H0. The next step is we want to start, we want to take an embedding of A0M into a finally presented algebra. So we want an A1M which is finally presented. X1 up to Xn, R1 up to Rm. So you want You want some technical things as well for this, such that image. Oh, and also I want here this algebra to include, actually let me write it like this. It's nicer. I actually want this algebra to be finally presented and the generators to be unitary pollutions. So let's actually start with Z2 star n, okay? And then taking that and modding it up by a few, you know, a finite list of relations. Okay, what we want is such that the image of the i and xi in actually in just the group algebra for z. Oh, let's phrase this properly. Such that pi and xi have representatives, representatives. So they're going to be represented by some word in these generators, or some polynomial in these generators, right? I want that polynomial to be for the Pi a projection and for the Xi to be unitary projections slash unitary homogeneous easy enough to enforce in this algebraic. Easy enough to enforce in this algebra. I've got lots of unitary evolutions around, right? So that's the advantage of doing this with these two RN. The other thing I want is I want the relation, Pn plus 1, so if M hasn't halted, if M hasn't halted after N steps, I want the relation P n plus 1 equals P N. 1 equals Pn plus Xn Pn Xn. I want this to hold, so it's going to be implied by the relations here, right? That's the whole point of having an embedding. And I want, so that means we're going to be able to turn this relation into zero using relations. And I want it to take only so with fn applications. of R1 up to Rn. And I don't want that to be too large. Let's say, I think hopefully this seems reasonable, where fn is a polynomial. That's what I want to construct. And then, once I've And then, once I've got that algebra, I'm going to set alpha m equal to, oh, I'm going to set, first of all, I need a constant, okay? I'm going to set constant. I'm going to take the sum, overall n, of 1 over 2 to the n over 2 times fn. fn's a polynomial, then this converges, okay? And I'm going to say alpha m is equal to the sum over ri star ri minus. minus P0. So this is the point of putting it in a finitely presented algebra. I've got a finite list of relations and therefore I can make an actual element of the group algebra. It's only a finite sum. So let's see what happens if m halts take tau on, oh, and this is by the way going to be an element of C Z. They're going to be an element of C Z2 star n. So if M halts, take tau on A, oh, and I'm missing maybe the most important part of the list. Okay, actually this is a good. So what's going to happen here? So I'm going to take tau on A0M such that tau of Of 0 is greater than 0. I want to turn that into a state on A1 now. But just having an algebra embedding doesn't tell me, you know, if I've got a state here, it doesn't necessarily extend to a state here. So I better put in here, bit in up here, if every state on a zero m extends. Extends to A1M. Now that I've got that, I can take tau on A0M, this property, and I can take that to tau tilde on A1M. And now I can go to L1, and then I can go. And then I can go and lift that to a trace on Cz2 star n, right? On Cz2 star n. And then what will that trace do? Well, in Ri star Ri, because this is a trace actually on this algebra, it's 0, right? And on D0, it's greater than 0. So what we get is that count tilde alpha m is less than 0. So we got the first part of what we wanted. We got it. If m halts, this thing is not. If m halts, this thing is not positive. So what about if m does not halt? Well, that seems pretty clear, right? We're going to try and use the To try and use the fact that we don't have a trace on A0, which makes this positive. If only it were that easy, okay? Here's the issue. I mean, there's a million ways we can construct an algebra that has this property, that if m halts, we have the trace be positive on an element, otherwise it's zero. Why do we have to pick this one? Okay? And here's the issue. So suppose now is a trace is a trace on CZ2 star n. How do we, so that is not necessarily a trace on A1 now, right? So it can be non-zero on this part. Okay? So let's say epsilon is equal to tau applied to the sum over Ri star Ri. It's the sum over i of r i tau star. RI tau squared in the trace norm. That's not zero, so we can't really use this factor at all. It has to be there, okay? But yeah, we're not going to be able to use that. So instead, what we want to do is we want to look at this relation again. So best way to say this, if we stare at this, okay, and now we're talking about elements in CZ2 star n, that's still going to be true. Star n. That's still going to be true, okay, because these things are still unitary revolutions. We're going to get that norm squared of tau is equal to a half the norm squared of Pn. Sorry, the tau norm of Pn is going to be a half the norm of Pn tau Pn plus. Pn plus, oh, actually, let me just skip right for this line. What we're going to get is that this is less than or equal to 1 over root 2 dn plus xn dn xn in the council. We went to square root there because we went from, these are actually not. From these are actually projections, so these are actually norm squares at the Pn plus one and so on. Now we've got a square root. And then it's going to turn out that this is going to be, this part here is going to be close to the norm of this because we know that this can be turned into this using the relations ri. But we're going to have to account for the fact that tau is not zero on the Ri. So what we have here is actually like an approximate representation. What we have here is actually like an approximate representation of our algebra. Okay, so this is going to be bounded by 1 over root 2 fn root epsilon. Using the fact that basically the tau norm of all the RI is bounded by root epsilon. So our conclusion, we've got something that's similar to what we had over here, where we were able to, like, say, we're going to get a bound on. Say, we're going to get a bound on tau p0, bounded by 1 over 2 to the n. But actually, now it looks like the tau norm of p0 is less than or equal to 1 over 2n over 2 plus the sum from k equals 0 of the n of 1 over 2 to the k over 2, f n, move epsilon. But this happens for all n, right? For all n here, because n doesn't call it. And so this is just going to get smaller and smaller. And this is going to be bounded by our constant C. So in the end, we get this bounded by C, root epsilon. So now we can go back, see what happens to tau of alpha m, tau of alpha m. Tau of alpha m is equal to epsilon minus, oh, excuse me. Didn't actually use the constant in here. Okay, I'm gonna use that in there. So epsilon over tau of b 0 c squared. But then the largest that this can be is actually c root epsilon. Okay, so we end up, this is greater than or equal to. This is squared and equal to epsilon minus c squared, epsilon over c squared, right, which is squared and equal to c squared. So alpha m is trace positive. Okay. Okay, well that's all we have to do. So that's the end of the proof. We have our mapping from m to alpha m such that it is trace positive if and only if m does not hold. Does not hold. The hardest part in this proof is actually how to construct the algebra A1. Okay, so I didn't say anything about that. We had to do it by hand. It's a real thing. But it should look like something similar if you know your group theory. We had that whole algebra we wrote down. Those relations were recursively presented. It's a countable number of generators. And then it's easy to write down a computer program that just lists off the relations. Off the relations. So, when you want to embed a recursively presented thing in a finitely presented thing, well, for groups, that's called Higman-Ebeddy theorem. It's from the 1960s. Here, we want a Higman-Ebeddy theorem for algebras. Well, that exists. But unfortunately, we want it for algebras in such a way, this point that I almost left off, that traitial state, that traitial states are Are extendable. So that's, as far as I know, has never been considered. In fact, in group theory, there have been questions around about can we make Higman embedding in terms of preserved analytic properties? Can we make a Higman embedding for amenable groups or maybe for hyperlinear groups? So if we start with an amenable recursive percentage group, can we embed it in amenable finalism? Well, here we have, I think, a pretty natural problem for For star algebra, it's an analytic property, right? If the star was recursively presented, star algebra, if it has a tracial state, does the algebra that it invents to have a tracial state? So preserving the existence of a tracial state. So I guess the last thing I'll end with, i I wanted to mention work in progress that I think this is actually true. You can do this type of embedding. I have three more pages of technical details that I can continue to talk about. Technical details that I could continue to talk about if you want to see something like that. But I think my time is actually up, so I'll stop here. Any more questions for Will? Did you use this MIT style already somewhere? No, actually, part of the reason we wanted to do this was to do a decidability problem where it was much. Do a decidability problem where it was much easier than the star goes up. Yeah, because so I guess everything I would want to point to is erased. Let's see, we can so there is so there's a myth, there's a conjecture. So there's a conjecture, which I'm sure you know, but my po equals po already. And this one would look like that you have m to alpha m computable, such that if m halts, which way does it go, so we want that point where m not halt. So if m halts, we want alpha. I'm gonna figure that out in a second. But the point is, so we're looking at positivity, and we prove that it is co-Re hard. In other words, the non-positive direction is where the machine halts. And midpoint equals co-re would be, so that's a conjecture would be that this is re hard as well. And that would just prove concept. And that would just prove kind of many. So basically, it's about which way around. If you have sums of squares, you can prove that something's positive. So showing that this is co-R E hard disproves sums of squares. If you could prove that it's R E hard, you would disprove R F D. So yeah, we get it the wrong way around. But conversely, if you can prove a mid-point correlation, you can't disprove existence of sum of squares. Yeah. So it's kind of their complementary. And I think it should be true that this problem is actually, if something's both Cau Re and Re-hard, what we'd think, Alton would call it positive Stellensatz says that positivity is for all epsilon there exists a sum of squares. That's a, for all, there exists a problem, so that's a pi zero two problem. So we have a conjecture that this is pi zero two. First, we have to figure out if co equals co alarm. I think if you can prove this, I think if you can prove this, then you can probably prove this. Yeah, does not halt. So we can figure out from this which way it should go. It's supposed to be Re-hard. Then we want M halts. We want this to be the positive correction. So alpha M minus 1 is positive. And alpha M is not positive. So I think that's right. Thanks for the question, which is probably not the activity but Is probably not directly able to talk. Is anybody actually verifying the solution of the column-based problem? Depends what you mean by verify. Yeah. We don't have, you know, like how hard we're to convert a formal proof of it. Extremely hard. So yeah. In fact, the proof as it is not only implies that we have That we have this computer mapping like this. But it tells you for which, it gives you a machine that you could plug in to actually get an element that separates the max and minimum. And although it's fully specified in the paper, nobody's ever tried to actually produce that element. I had I hired an undergrad to work on it for summer and it didn't get very far. Actually even just producing the element in the paper is not so easy to find. But I think very soon we will have more screen light because that will solve the problem.  Yes, yes, yes. I want to research It's a total space. It's a total space. No, I was saying what was the zebra from the English. Right, again, you have the A0 answer to every question. So we have A0 and that depends a lot on what it is. So it's not true that we're when it's when does it transfer it would be fine if we did but I think it would be a bit of a problem because then you'd be able to tell it to me it's a little bit easier both at the same step which follows so I don't think there is a way to do it all because they're going at the same scale like yes Yes, all isomorphisms, right? And we certainly don't from the first that are approved, it would be fine. It did, but I don't think it should be the same. They could be isomorphic though, though. I mean, we have that. Technically not, you have to sing this latest on the screen. Yeah, there's no problem. So this is computer version. I would be zero. These are the relationships. I think these relations actually for ourselves are make our friends. Make out front. It is. So this is verified for all. And then we model our A and A. So for example, if you look at 10 by 2x, actually I remember a little better about what's going on. I mean, remote remote property algebra is character with you. So then it corresponds between Turing machines and natural models. Right? So then you just load them up. Yeah. Oh, if you know right entries, find every description and then vice versa if you have a permit as a machine. Same thing with the classic and home or something smarter, which makes it that we actually don't have like. Nobody has to move out and then these relations we have to fall down. That's how you always get the same relationship. Make this final relation. You've always got like the same relationship. And that final relationship has to be actually like x to be n. Assume like compared to finally it's just like changing the number of tracial numbers you put. You change the depth to put P01 signals. There might be a little bit more time. Yeah, something very similar to what you might use in the stream plugins you want to have a different element. We have to explain it online. Yeah, it can be but it's more simple. I don't think anybody's except for that one paper from the paper. How far is this? How far is this before that? The only paper I know was Fritz Nets and Pollin and Fritz Pollin. 