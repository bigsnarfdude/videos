This is based on joint work with Or, Jakob, Tony, Robert, and Mark. Okay, so as we've seen before, lifting is a method of taking lower bounds on weaker computational models to lower bounds on stronger computational models. Okay, so one example would be: we have a decision. Decision tree, we prove a lower bound in the decision tree, and then we can lift it by composing with some gadgets and get a lower bound in the communication model. Okay, so we've seen this before. Okay, and this talk is about looking at the gadget we use for lifting. So most of the, well, the general Of the general lifting theorems we know, they hold for hard gadgets. And with this, I mean, well, gadgets such as indexing or inner product that are hard, well, not only for deterministic communication, but also for randomized. So one could think, okay, what about easier gadgets? What if I have the greater than, or if I have equality, which in particular for randomized is these are easier gadgets? So this is what. So, this is what we'll talk about. But first, let's see why do we care, right? Why would we want lifting theorems for easier gadgets? So, first, let's see some application to circuit complexity. So, here I have a monotone Boolean formula. So, I have OR and AND gates, but no negations. And then monotone real formulas where every gate. Formulas where every gate is allowed to compute any monotone function of the inputs. So, as you can probably tell just by looking at these, these are both computing the same function. So, these are computing the majority of five bits. And well, you might recall that it's not obvious that a monotone Boolean formula can compute majority of Majority of n bits with polynomial size. This was first proved, I think Baylin proved that there existed such a monotone Boolean formula. And later, some years later, with switching networks, you were able to actually construct such a monotone Boolean formula. But it's clearly not trivial. So it's, I think. I think a very natural question if monotone real formulas are actually stronger than monotone-Boolean formulas, or is it just harder to prove upper balance? Okay, so actually, monotone real formulas are exponentially stronger than general Boolean circuits. So not only monotone, but general Boolean circuits. And this was proved by This was proved by Rossenhulm, 97, and it's an implicit separation. So it's simple enough that I can present it now in one slide, in a minute. So, okay, so first we want to show that monotone real formulas can compute any slice function in linear size. Okay, so what is a slice function? A slice function is, well, we look at our hypercube. It's some slice. The function is Slice, the function is allowed. So, a slice is where all the inputs have the same haminoid. So, at some slice, the function is allowed to output 0 or 1. But below that slice, it must output 0, and above that slice, it must output 1. All right, so this is the monotonial formula that computes the slice function. So, the idea is. So, the idea is that you want to compute two different functions, g1 and g2, such that any two inputs at the same slice with the same Hamming weight, it won't be the case that g1 of x and g2 of x are larger for one of the inputs than to the other inputs. So, actually, these inputs will be uncomfortable. So actually, these inputs will be uncomparable. For one of the inputs, g1 of x will be larger than g1 of y, and for the other one, g2 of y will be larger than g2 of x. And the way to do this in some monotone way is, for example, just adding the bits with the exponential separation so that you can, and in the other fractions, subtracting it. So in this way, it's. it's very easy to for inputs at the slice the the function the the output of the of the monotone real circuit will actually be a monotone function on these two on these two inputs. Because anything in the size is uncomparable, so it's allowed to output either 0 or 1 for these according to the function, and it is a monotone computation. Computational. Okay, and then for anything below the slice, it will be at least one of them will be smaller, and above at least one of them, G1 or G2 will be larger. So this is the monotone real formula. And then for the lower bound, well, we just need to show that most lice functions require Boolean circuits of exponential size. And this is just the standard way. Well, there are so many. Only so, well, there are so many different just middle slice functions, and there are not so many different Boolean circuits. Okay, so so monotone real formulas are actually very powerful. Okay, but this is an implicit separation. So, what about explicit separations? Can we get an explicit separation? Well, between monotonous real formulas and general Boolean circuits, I guess this would not. I guess this would not be the most interesting consequence if we could prove such a separation. But what about between monotone real formulas and monotone Boolean formulas? Can we get an explicit separation in this case? And well, this wasn't known before, so this is one of the results of this lifting with an easier gadget. So we're able to build an explicit family of functions where there is. Functions where there is a monotone real formula that computes this function in size almost linear. But any monotone Boolean formula computing it requires nearly exponential size. Okay, so how does the proof go? Well, the idea is to use this Karshwar-Vichtersin relation. I'll just recall this in a second. So, Monotone who. So, monotone-Boolean formulas, we get some communication protocol for the monotone Karshmer-Wignderson game. And for monotone real formula, we get another type of protocol, which I'll define soon, locally real protocols. Okay, and then the lower bound, we prove for these communication protocols via lifting. And the upper bound, it's kind of funny, I think, because we need this upper bound for locally real protocols, and we prove it in. Protocols and we prove it in a not-so-direct way via semantic tree-like CP refutations. But I won't talk much more about this. Okay, so what is the monotone Carteman-Buchterson game? Well, we're given some monotone function. Alice gets an input in the pre-image of 1, Bob gets an input in the pre-image of 0, and the goal is to find some index where xi is greater than 0. Some index where xi is greater than y. And then Alice and Bob can communicate through this. Okay, so well, communication protocols, as we've seen in some other talk before, we can view them as some tree where the nodes are labeled with Alice or Bob according to who speaks at that node. And you go left if you send a one or right if you send a zero. And these can also be viewed. And these can also be viewed as combinatorial rectangles. So here in green you have all the inputs that are compatible with this node. And then when Alice sends a bit, she's partitioning this rectangle into two horizontally. And then here in green, you have all the inputs that are compatible with this node. And when Bob sends a message, he's And when Bob sends a message, he's partitioning the inputs vertically, and then you get these rectangles. So this would be, I guess, the classical protocols. They look like this. And then you have locally real protocols, which would look something like this. So this is what I think Mark also called triangles. called triangles in comparison to the rectangles. And well the definition is well I guess not so hard. So for rectangles one way of defining a rectangle is that if you have any two points in the rectangle, you know that both this one and this one are also in the rectangle. And this one are also in the rectangle. So that's one way of defining a rectangle. And for a triangle, the condition is that at least one of these is in. So that is why if you look at these, for any two points, at least one of the points, at least one, I don't know how to call this, the yeah. Oh yeah, one of the things are in the triangle. Or in the triangle. And okay, so for example, this here is not a rectangle. It's not a triangle, because you can see there are two points and probably it's not in the triangle. Okay, so this is locally real protocols. And so these correspond to the monotone real formulas and these to monotone Boolean formulas. So we would like a lifting that is only hard for classical protocols. Only hard for classical protocols, but not for real protocols. That's why it's interesting to look at other types of gadgets. Okay, so this was an application to circuit complexity. This is a proof complexity workshop. So let's also talk about applications to proof complexity. Okay, so we'll be talking about cutting planes. So we have addition, multiplication, division with rounding. And the goal is to add zero breaker. And the goal is to have zero greater than one. So, okay, a natural question is: well, here we're allowed to have these coefficients, but how large coefficients are actually needed for the proof? So, yeah, 96, Buzz and Club asked this question and they showed that, well, coefficients of exponential magnitude are enough. They actually They actually, their goal was to prove that polynomial magnitude, polynomial on the sides of the proof, would be enough, but they say this in the paper, but they were only able to show that exponential was enough. What else can we say about large coefficients? Well, there's a very nice paper that shows that every unsatisfiable formula can be refuted in line space 5 in cutting plane. Line space 5 in cutting planes. And here the proof requires coefficients of exponential magnitude. Not that we know it's necessary. They show that constant is not enough, but we don't know that exponential is necessary, but the proof requires this. Okay. Okay. So C P star will denote C P with Denote CP with cutting planes with polynomial bounded coefficients. I recently figured out that this is not a great choice of name because in some areas star means tree-like, but I guess it's somewhat established. So, okay, so can we prove any separation between cutting planes and cutting planes with bounded coefficients? A length separation, maybe a space separation, maybe a length separation. Separation, maybe a length space trade-off. Okay, so let's look at the lower bound techniques for cutting planes, which also holds for CP star. Well, we have interpolation, and this is a nice technique because you can interpolate from both Boolean circuits and real circuits. But if we were to use this to get a separation, we would require To get a separation, we would require a monotone Boolean circuit versus a monotone real circuit separation. Okay, so it's potentially could be done. I'm not sure what the candidate formula would be. I don't know, maybe you have some idea. Okay, then another option would be well lifting for DAG-like communication. We've seen this before too. And the thing here is that And the thing here is that the lifting they have holds also for, well they also get lower bounce for cutting planes, so we would need some other lifting, which maybe a lifting within easier gadget. Not sure how this would go, but at least something like this would be needed. Okay, then length space, oh, for space we have actually no method for proving lower. Method for proving lower bounds. But okay, let's look at length space trade-offs. This we have lifting, it requires lifting for the standard tree-like communication, not the dive-like one. And here, we also would require lifting with an easier gadget because the lifting with inner products also holds, or with the index. Also holds, or with the index seen, also holds for cutting planes. But we do have candidate formulas. So here, lifted peddling formulas would be candidate formulas. Okay, so this is another consequence of the lifting with simpler gadget. So we get a family of CNN formulas where we have cutting planes refutation in constant space and in space and basically n squared length, but any C P star refutation in space S must have length exponential on n over s. So if you try to have a refutation in let's say constant space then you will require exponential length. And if you want to prove have a refutation in polynomial size you will need linear linear length. But there is a C P star reputation of polynomial size for these polynomials. Good. Here, there is a C P star in polynomial length in linear space. We don't know if there are small space proofs. We don't have any small space proof for this formula. So it might be the case that these formulas are actually require a large space for C P star. Okay, so this is first results, I think, that we know of. I think that we know of demonstrating any situation where high-weight coefficients are more powerful than low-weight coefficients. Susanna? Yes. I think I missed it. We are still referring to line space? Line space, yes. Line space. Yes, let me define quickly what I think is what is line space? So we can view the proof as this classroom proof. So we have a sequence of black So, we have a sequence of blackboards. We start with the empty blackboard, and we would like at some point to derive contradiction. And we have three possible steps. We can write down some axiom clause from the CNF being refuted. We can infer a new line with whatever we already have in the blackboard, or we can erase some line that's not needed in order to save space. So, here, length is Length is the number of steps in the proof, and the space is the maximum number of lines on any blackboard, also called line space. Okay. Yes, okay, so what we'll be interested in solving this falsified clause search problem, which we've seen before. So it's basically you're given an assignment and you want to report some clause that you falsified. And well, given the proof in this fashion, if we view it as a sequence of blackboards, one way of solving this search problem is to do a binary search of the proof and find some transition where we go from a true configuration to a false configuration. So, well, the empty configuration clearly evaluates to true, contradiction to false. So then we can do a binary search and Do a binary search, and if we're thinking of the communication model where the assignment is split between Alice and Bob, they will have to communicate to figure out if there is some line in this blackboard that evaluates to false. In that case, that's right, and we will look for true to false. True to false configuration to the left. And we repeat until we find some step where we go from a true configuration to a false configuration. The step here, it can't be an inference because the proof system is sound, so it must be an axiom download. Okay, so let's suppose that each line can be evaluated with a constant number of bits. Constant number of bits. It could also be a small growing function, could be log n even, but let's just say it's constant. Then if we have a proof in space s n length t, then we can actually have a communication protocol which will be, which will have s log t bits of communication. So if we could actually prove a communication lower bound, we would get a trade-off between space and length. So this is the idea. So this is the idea. Now let's look for a minute at how do we evaluate a line. So if we have classical communication, so Alice and Bob can send bits to each other, if they're trying to evaluate a line, a cutting plane's line, that would have coefficients that are of magnitude 2 to the n, that would require, if we're just, yeah, I'll. Require, if we're just, you know, Alice is just computing her part of the inequality and sending it to Bob, that would require n bits of communication, and that's too high. But if we're in C P star where we only have coefficients of polynomial magnitude, then we can do this with log n bits. So actually, classical communication would work if the proof was in a CP star proof. For CP, we actually need a stronger model of communication. Model of communication. So here we have a greater than oracle. So we've also seen this before. Alice and Bob can send real numbers to the oracle and the oracle just answers whether Alice's is greater than Bob's. And this just costs one bit of communication. So in this way they can compute one line of a cutting plane's proof with only one bit of communication. Okay, just a small observation. Just a small observation. This might look somewhat similar to the locally real protocol. It's actually, this is a tree-like protocol, but it's stronger than that locally real protocol that are trees, DAC-like protocols that are trees, because here in the other one we had triangles at every node, and here we can get intersection of triangles. Can get intersection of triangles. I'm not going to get into this, but just small comments. Okay. So we would like a lifting theorem that holds for the classical communication but does not hold for real communication. And the gadgets, as I've said before, and the Xenon product also hold for real communication. So, we would like some Goldilocks gadget. Can't be too easy, can't be too hard. Okay, so what can real communication do that classical cannot? Well, clearly one function that we can solve with real communication, which we can't with classical. Well, yes, well, greater than first. We can definitely solve greater than. And if we're in that last definition. We're in that last definition of where we can have intersection of triangles. So, with the two bits, we could solve equality. So, greater than and inequality are examples of which are gadgets that could possibly work. So, let's look at lifting with equality gadget. So, can we lift tree complexity, decision tree complexity, to communication complexity with equality? And actually, so for partial functions and relations, the answer is no, we can't. Not in general. And here's an example, it shows that we can't. So I think I'll have to go a bit bit. So you can check that this we actually cannot, that this has, this isn't tree depth n, but if we're lifting with. Exact n, but if we're lifting with an equality on L bits, there's actually a communication protocol that only communicates L plus one bits. So if equality is like log n, that's a lot smaller than the decision tree complexity. Okay, so actually, so Schagnik and Bruno, they proved a lifting theorem which lifts and decision tree to tree complexity. And the only problem is that for the candidate formulas we have, this is complexity is very low, so that lifting does not work. So basically what we need is lifting from something that is not as strong as N decision trees for the search problem on fabling. So what we lift from is nostole and satz degree. From is Nostolensatz degree. And let's see. So this is a generalization of a very nice paper by Tony and Robert. And we generalize it so that it works for any gadget of high enough rank. They had some conditions on what gadgets could work. So in this way, it actually works for equality greater than any gadget of high enough rank. Of high enough rank. Even if the Nostolenzats degree is high enough, the gadget can even be of constant size. Okay, and I think I will... Okay, so the last thing is to prove a lower bound on the Neustellenstats degree for refuting Pebbling formulas. So I won't get into this. This is just a Is just a pebbling formula. And this is reversible pebbling, which we've just seen. So this is great. And then you can actually prove this yourself. I can give a quick hint. So you will use designs to prove it. And it's a simple proof, and I think it's very nice. This was actually studied before, but it wasn't shown that it was equal to. But it wasn't shown that it was equal to reversible Padlein. And it's very simple, so it's, I think, it's also nice. So you can work that out. This is the answer. And summing up, okay, so we have a lifting theorem that holds for any gadget of high enough rank. We get this explicit separation between monotone Boolean and monotone real formulas, this trade-off separation between Cp and Cp star. Yeah, the lower bounds come from the lifting theorem. Come from the lifting theorem. Therefore, bonds, they actually require a little bit of work. And then some open problems. Well, explicit separation between monotone Boolean and monotone real circuits would be very interesting. Also, separate CP and CP star with regard to length. Even a true trade-off between CP and CP star. So the trade-off we have, we don't have any proof in small space. So if you could actually show Trade-off that would have this. And there are also other applications of this, so finding other applications of this vicinity. So we do have some that we made to the Mamatone Kashmir Victors and KRW conjecture. And also some better understanding of inner and outer functions of lifting. In this case, when we In this case, when we lift from, it's not like we're lifting objects of the same type. So it's not like a tree is being lift to a tree or a dog to a dog. So it would be interesting also to, yeah, extend on this. That's it. Thank you. So we can take a question rather than COVID itself. Yes, just a question about the circuit complexity I have a question. So the explicit separation of Monton Boolean and Monton Real. The separation of monoton Boolean and motor real formulas. Can't you just take, so there's a Petassia-Robert function, motor function that's hard for monotone-Boolean formulas. Can't you just take that and embed it in the middle slice? I mean, that would be easy for monotone-door formulas. And maybe you could argue that directly that it would be hard for monotone-boolean formulas. Right, yeah, this so I think the reason this doesn't work So, how does it go? If you prove a lower bound for a slice function, don't you automatically get a lower bound? Well, you show that if there are quantum Boolean formulas for this slice function, especially the slice function, once you've got the embedding, then you can recover Montreal Boolean formulas for the original functions. Yeah, I mean. Yeah, I was thinking if you prove a m if you prove a monotone Boolean circuit lower bound for a slice function, doesn't that already imply something, a lower bound for Boolean circuits? Like non-monotone. Yeah, for non-monotone Boolean circuits. So I think slice functions are not what you'll be able to prove. Or else you'd be proving something a lot stronger. 