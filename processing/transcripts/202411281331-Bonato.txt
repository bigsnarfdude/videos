Unfortunately, I'm here in Toronto. I'm very happy to be talking to you about cooling, which is the new process that I'll be describing on the grass. So I guess the title of the conference, Movement and Symmetry, I'm more on the movement side. I guess that's more relevant to what I'm going to discuss. So let's take a look at this GIF, this graphic that I found, which probably many of you as you're watching will realize what it represents. I'll just let it run once or twice and talk about it. Once or twice and talk about it. As you can see, the red dots are growing all over the world. And what this represents, it'll cycle through it from the beginning again. You can see the change in the date at the bottom of the graphic. Ah, yes, there. So that big red dot was in Wuhan, China. And then there were places in Europe and North America, Australia, and others that were getting red dots. What this represents is the spread of COVID back in 2020. COVID back in 2020 as represented by this sort of scale. So, what was interesting to me about this is that, you know, of course, as we know, COVID spread everywhere, but how it spread and how we tried to slow the spread was of great interest. You know, there was social distancing, masking, and later vaccinations. And it's pretty fair to say that eventually everyone was exposed to COVID. In the early days, like, you know, In the early days, like you know, Alpha, Delta, whatever they were, those variants, they were a little bit more less virulent. But by the time we got to Omicron, pretty much the whole population planet got exposed, a bit like the common cold and various outcomes, of course. So this made me think a couple of years back about how we model the spread of influence, spread of infection, in the case of like a virus like COVID, but also more generally, things like, you know. More generally, things like you know, memes or the spread of information, misinformation, or disinformation on social media. Now, the model that I've been talking about for a number of years now is graph burning. So, graph burning is one simplified model for the spread of influence or the spread of infection on a network. And originally, I was thinking about memes. I think at the time it was something like the Ice Bucket Challenge, and this really dates it because it was over a decade ago. But some A decade ago, but some you know, behavior, some image, whatever spreads on social media, and pretty much everyone's seeing it on their timelines. But you could also have like a virus that's rapidly spreading through a population. And with burning, in case you're familiar, I think many people are familiar with burning by now, but if you're not, the idea is you choose an initial vertex to burn. In this case, on this path, length, sorry, nine vertices, I'm going to choose a second from the left. I'm going to choose a second from the left one to burn. So that's the one I choose as a source to burn at the beginning. Then the fire, the burning spreads to the vertices to the left and right. So I'll just put check marks to where it spreads. And I, in the second round, that's the first round and the beginning of the second. In the last part of the second round, I'm also going to choose a vertex to intentionally burn. So I will choose this one, which is the seventh vertex from the left. And then the fire will spread again wherever it was. And then the fire will spread again wherever it was before. It will spread and it will spread in the next round. And in this final round, the third round, I'm going to choose the ninth vertex from the left. And that will, of course, spread to everything. In fact, with three sources that I chose on P9, I spread the burning to all vertices. And in fact, one can show just by analyzing it that two will not suffice. You need to choose at least three sources to burn everything. So So in the case of a path, the minimum number of vertices that you need would be three. This is the next graph I have here is a Cartesian grid, right, just an ordinary lattice grid. And what I've got represented, it's a little larger, I've got represented the different vertices that you intentionally burn. So one, two, three, up to six. And then all the other labels correspond to the rounds that you. Correspond to the rounds that you have verices that are burning. So, this process, this kind of idea about grass, we thought of in 2014. This was at the time Elm Roshenbin's PhD thesis. This is joint work with also Jeanette Janssen, who was the co-supervisor of Elam. But unbeknownst to us, Nova Alan in 1992 had discovered the process and talked about it very independently. And talked about it very independently just on the hypercube. So, we were talking about it for general graphs, but he did basically look at the burning number of the hypercube. So, that was really interesting to find out. We found that many years after publishing our initial work on it. How does this work? So, how does burning work? At every vertex, every vertex is one of two states burning or not. And like in this diagram, if you have a vertex that's burning, call it X, it will spread the burning. It will spread the burning to its neighbors in the next round. Okay, for some very simple contact process. And a source is a vertex that you choose to burn. And in every one of the discrete rounds, you choose a source. And you keep doing that until no sources are available. Okay, so this is the process. And the burning number, this is the minimum number of rounds needed to burn every vertex. Every vertex. So, like I described earlier, with the path P9, it's three rounds. You can't do it in two, no matter how you choose sources. And similarly, with Cartesian path, that spread of vertices I have is called a burning sequence. It was optimal. It burns the Cartesian path or Cartesian grid as fast as possible. Okay, so some things about burning. We realized pretty early on that burning was a process. Burning was a process really relevant to trees. So, how I describe that is by the following result. If you have a graph, the burning number of a graph is exactly the burning number of some spanning tree. So really, when looking at burning graphs, you're talking about burning trees. Now, this is useful in many cases, but not all. Sometimes it's better just to use the structural properties of the graph than to an expang tree. But nevertheless, this is an important realization. It's a big reduction down to trees when analyzing burning. Second, there are some relatively straightforward bounds that you can derive in terms, one in terms of the radius, one in terms of the diameter, and these bounds are tight. Interestingly, for Cartesian grids, so I denote PM box Pn, the Cartesian product of these two paths, right? That's the usual lattice Cartesian grid. Grid. The question is quite subtle. Burning grids is remaining an open problem. It still is an open problem. There's lots of things we don't know about it. It depends on the n and the m. So in this first example, in this first case, if n is at least the square root of n, then we have asymptotically tight bound in this form the cube root of three halves mn. So this is a result, by the way, of Dieter Menscha Probability. Result, by the way, of Dietermincher, Prabhupada, and Alan Roshaman. And in the case that M is in big O of root N, it's a bit more fuzzy. We just have a theta value, theta root n. So we know the approximate order, but we don't have an asymptotically tight result in that case. And in that case, in that second case with a theta, even looking at a grid of the form P root n box Pn, that we still don't know exactly what. Don't know exactly what the Bering number is, although we have a pretty good handle on the constants: bounds of one plus root three over two and two plus root 15 over four. So, you know, even there, there's a lot more to do. It's kind of surprising. By the way, we call these graphs fences in the sense that they're not very tall, but they're very long, right? So, there, there's a lot of work to do. And we had other results in the case related to. Other results in the case at P sub C, where C is some constant redundant box PM. So, for fences, there's the whole thing, but for general Cartesian grids, it still remains an open question. Now, probably the deepest problem in Berning is what we now call the Bering number conjecture. The Bering number conjecture tells us that for a connected graph, the Bering number is no more than the ceiling of root. Than the ceiling of root n. So, this is corroborated by examples, graphs that we know. So, things like paths witness a Bering number root n. Spiders satisfy the Bering number conjecture. There are things like caterpillars, lobsters, other different families of graphs, and trees are known to satisfy Bering number conjecture. And it just, I guess, part of the reasons why it's conjecture is we can't think of any examples that would be larger. The best known. The best known bound in general for graphs, obviously it's not root n, we haven't proven the conjecture, is this. It's a long list of co-authors, but it's square root of 4 over 3n plus 1. That is the best known bound right now. There are some tighter bounds and better bounds if you have lower bounds on, say, the minimum degree of the graph. But in general, for just a connector graph G, this is what we have. And also from that work, we have a few. From that work, we have a few results about growth. So, growth is a way of describing graphs, sort of generalizing caterpillars or lobsters. You know, caterpillar would be like growth one, where you have a central path, and then every vertex is distance one from that path, lobster growth two, and so on. We have some bounds which basically asymptotically prove the conjecture of k is not too large, is much smaller than root n. And a relatively And a relatively recent paper, I have 24 plus, but I don't know if it's appeared yet. Noran and Turcott actually gave a generalization, an interesting approach to the Brain number conjecture, proving it asymptotically for any connector graph and using the probabilistic method and some continuous mathematics. Some really interesting ideas there. Now, the talk is about cooling, and I've been talking about burning, but burning is really only one way of looking at contact processes on grass. There's many, many different processes. On grass, there's many, many different processes you can imagine. So, the approach that I want to take in this talk is not to make the spread of influence as fast as possible, but to make it as slow as possible. So I go back to my example with COVID-19. Obviously, during the pandemic and even now, we want to slow the spread of the virus. It's not never advantageous to make it spread faster. And also with things like disinformation on X or whatever social media that you're interested in. Or whatever social media that you're interested in, combating that, slowing it down, methods for mitigating it. And so the question is: how do we model this via contact process? Of course, there's many, many ways you can do this. And one way that I'm going to present the graph cooling model is kind of the dual of what's happening with burning. So let me switch colors and go to blue for cooling. So with P9 again, like we saw the burning number was three, but for P9, the Was three, but for P9, the cooling number, what will that be? So cooling starts on the left, because at a leaf, you're going to minimize the number of vertices that get cooled in the next round. So this vertex will get cooled. And if you're trying to slow the spread as much as possible now, this is different than burning, right? Then I guess that the most reasonable vertex to choose that you would, you know, in the next round, that you have to choose a source, just like in burning, would be. Source, just like in Bernie, would be maybe this leftmost one that's not been cooled. And you keep going like this. And really, that is the slowest way for a path. And in any situation, however the length of the path, you always start from one end and you just move slowly from left to right, only greedily burning from whatever orientation you have, say, from all the vertices. So, this process was instigated by myself, Trent Marbach, Teddy Mashura, and Holden Milma. Now, it really began in 23, maybe late 2022, but the paper has appeared now. So this is very similar to burning. Really, if you're following along and thinking about how cooling is fine in a very similar way. So, two states, cooled or not, the vertex is cooled in the next round, it'll cool its neighbors. The next round, it'll cool its neighbors. You choose intentionally sources to cool, and in every round, you choose exactly one new source as long as you can. Now, what we came up with for a name, we didn't want to call it C of G. Those of you who know me, C of G is the COP number of a graph. We wanted to call it something related to C, but we called it C L for the cooling number. This is just the maximum number of rounds to cool every vertex. So it's basically a different. It's basically a different optimization function, right? You're just trying to maximize the number of rounds. Very, very similar to burning in that sense. And we're only going to consider things on connector graphs. Okay, so this is the question I'm interested in. And it may seem, I don't know, it may seem very, very different to you than burning. It actually is quite different. And I'll explain that as I go. For some things, it's a lot easier to cool, like grids. But for other things, even for trees, it's really challenging to get a handle. It's really challenging to get a handle on the cooling number, and I'll be discussing that as I go through. Okay, so, like I said, it is a different flavor. It's definitely, it feels a lot like cooling, but it's different. So, I'm pretty much trained to think in terms of minimums. A lot of graph parameters are minimums, like chromatic number, domination number, and so on. Same thing with Bernie number. Cooling is a maximum. So, when you give a cooling sequence, When you give a cooling sequence, what that does is it doesn't give an upper bound anymore because it's a maximum, it gives a lower bound. So that's one thing to sort of wrap your mind around. Now, what we call maybe whimsically the first theorem of cooling, this is a sort of an absolute upper bound for any connected graphs in terms of its order, right, the number of vertices. And it's about half the number of vertices. And this is pretty straightforward to see. Just think about the path example. In every round, you're cooling something. You're cooling something. Now, in the very first round, you cool something and there's no spread. But for every round after that, you cool something and there's at least one vertex that you spread. So in this round, in this round, what you're going to find is that that many vertices were chosen as sources and that many vertices were cooled, at least that many. And that, of course, then is at least. And so you've covered everything. So around halfway through the number of. Halfway through the number of vertices, the number of vertices plus one over two ceiling, you've cooled the whole graph. So we get a pretty straightforward upper bound in terms of the order. Okay, the second theorem of cooling. All right, so what is this? This is a bound now, not in terms of order, but in terms of diameter. Okay, so there's a lower bound in terms of approximately the diameter over 2, an upper bound of diameter g plus 1. One. The upper bound is pretty straightforward. You just take a vertex, cool it, and let the process run. That will cool everything without doing anything else. So the maximum length it takes to cool everything will be the diameter plus one. For the lower bound, remember, a cooling sequence gives a lower bound. Just take a diameter length path like I have in the figure D, and just cool every other vertex. And this will give a partial cooling sequence, which we're realizing, which will realize that lower bound. Which will realize that lower bound. Okay, so this is what we call the second theorem. And these two theorems together already have some utility. Immediately, what you get is a precise value for the cooling number of path, which you can see directly, but it's nice to know also that you have tightness. So you get the ceiling of n plus one over two. And for cycles, you get ceiling of n plus two over three, just playing around with cooling sequences like. Playing around with cooling sequences like the one that I described. So, very, very close to what you get for a path, not exactly the same. And by the way, already this is quite different as you would expect from the bury number of a path, which is root n, right? So, I mean, it's cooling as much larger as you would expect. It's maximum for caterpillars where every internal vertex has degree three, the cooling number is the ceiling of n plus one number two. So, actually, that gives. One over two. So actually, that gives the diameter plus one band that that really in the second theorem of cooling, that really obvious upper band actually is tight. So the idea, like in this caterpillar, like I have at the bottom of the screen, I cool a vertex, right? So nothing happens. Next round, this vertex gets cooled. Now, what I'm going to do with the leaves, the leaves are time wasters. I'm going to cool the leaves, and that basically eats up around. It doesn't spread any further along the path. Any further along the path. I just keep doing this. The fire spreads, propagates along the path, but I intentionally choose vertices then to cool from, you know, on the leaves. And I just keep doing that and so on. So in this way, just by cooling the leaves, you're slowing down the process and this realizes the maximum. Okay, so so far so good. I mean, these are pretty trivial bounds. I mean, just paths of cycles of sort of playing around with things. Paths and cycles of sort of playing around with things. So, what are the interesting questions? Well, even for spiders, we don't really know how to cool spiders. So, I mentioned spiders before. So, what spiders are, if you're not familiar, you take essentially a root vertex and attach a bunch of distinct paths to them. Okay, so you form a tree with sort of a head and then these arms, these paths of any length that you like, and any number of these likes. All right, uh, so. Legs. So one of our results gives a lower bound for the cooling of spiders with 2M legs in that specific instance. And another case for a different value of M, which is bigger than this logarithm, its round diameter plus one. I just want to emphasize we still don't know how to cool spiders. So this is just a partial result. We don't have a full characterization of what's happening with spiders. Okay, well, you know, spiders, ad hoc, perhaps, but so we don't, fairly simple graph class, we don't. Fairly simple graph class. We don't know how to cool these. Now, let's get into some other stuff. We touched on isoperometry, which has a long history in mathematics and also in graph theory. Bola Bosch, others have studied isoparametry through the years. Basically, the classical isoparametric problems have to do with minimizing area as a function of the perimeter of your shape. Like in the plane, this is a circle, right? But for graphs, the analogous idea for graphs, and I'll say. The analogous idea for graphs, and I'll say with graphs, there are two versions of isoparametry. You can have vertex or edge isoperometry. We're just going to talk about vertex isoperimetry, but you can imagine what edge isoperometry would mean. You're minimizing the cardinality of subsets which form neighbor sets and minimizing those neighbor sets. So I didn't say that well at all. So you're minimizing the cardinality of neighbor sets where S is chosen to have different values, right? The cardinality of have different values, right? The cardinality of s is little less. All right, so that is this parameter phi of gs, so it is a parameter of s. And you can also just make it a parameter of the graph phi of g to be the maximum of phi gs over all the choices of s. So here is a graph and here are different values of s. Now in the case s equal to one, the cardinality of n capital s, this is just the degree of And capital S, this is just the degree of a vertex, right? And the minimum degree here is three. So you see in the chart, it's in the case that's equal to one is three. And for two, just by checking, it's three, three, it's two, four, and one, and five, it's all vertices. So there's no neighbor set anymore. Open neighbor set is empty. It's just zero. So in this case, the isoparametric peak is three. Now, I don't really need the isoparametric peak. I just mention it. Isoparametric peak is very useful when you're talking about other movement. You're talking about other movement situations on grassroots, things like pursuit evasion games, in particular the localization game. We have a paper recently that heavily uses isoparametry to analyze the spread of an infection and how you would capture an agent like a robber loose on a graph. So using these isoparametric parameters, we can define a sequence. And I'm going to initialize a sequence at one. The I plus sequence at one. The i plus one term is the previous term plus phi g of xi plus one, and i is the smallest instance index where xi covers everything. It's the whole, at least the order of the vertex set. So the theorem that we derived was that the Couling number is at most i, always. This gives an upper bound for the Couling number. And the utility of this comes from looking at grids. So like I said, if you remember for birds, So, like I said, if you remember, for burning, it's very, very difficult for grid. It seems to be really, really challenging problems to nail down exactly what the burning number is. But for cooling, we can say pretty confidently what it is up to three additive values, always some small number of additive values, but it's two and minus two logarithmic factor plus zero or two. So, I don't have time. It's too complex in this short talk to give sort of a discussion of how this works, but I'll sort of sketch a few ideas. But I'll sort of sketch a few ideas of how it works for grids. So, obviously, we use isoparametry, and also from the isoparametric literature, there's a paper from Bolavash and later, I think, 91, where they introduce a simplicial ordering for lattice points in the plane, right? So for Cartesian grids, it's relevant. A pair AB is less than C D if the sum of AB is less than the sum of C D, or the sum is equal, and then you have lexographic order. So, this is simplicial ordering, and the idea in the cooling sequence that we have is just essentially always cool the smallest vertex in a simplicial ordering that you can, or that has not already been cooled. So I orient it as I would in the plane. So, I have like one, one in the bottom left. First row, you know, like the first instance would be one, one, one, one, two, one, three, and so on. The second row would be two, one, and so on. So, these arrows sort of list the Those sort of list the simplicial ordering. The first one being one, that's less than one, two, less than two, one. Now, in the second round, these are going to burn, right, without any work on your part. You've already chosen one, one. Sorry, I say burn. I do that a lot. Cool. So you cool one one in the first round. One, two, and two, one are cooled without any work. Then you're going to choose vertex one, three. So that two, that's a second cool. So, that two that's a second cooling source, and then that spreads and it just keeps going. And this is what the picture will look like if you do it, say, for like this is a grid, I think, 15 by 15. So, this is the cooling sequence that you define. It kind of looks a little bit like a sandpile. So, you start in the bottom left and you start spreading this cooling, and you just sort of add layers to it right in these different rows. To it, right, in these in these different rows of sequences of verices that you're cooling, and uh, this basically, so for G5 G1515, this is the cooling sequence, this is an optimal cooling sequence. Of course, there are other ones by taking symmetries, but this is an optimal cooling sequence, and this gives the value for any grid, in fact. Now, I don't have a lot of time. I'll just maybe spend just a few seconds on it. Few seconds on it. We also talked a little bit about ILT graphs. This is coming from my interest in networks and social networks. So the ILT graph was a sequence of deterministic graphs that we introduced a while back to talk about phenomena in social networks. So you start with a cycle here, for example, take a vertex x and clone it. So given x, you form x prime. Now, you notice x prime is all the same neighbors as x. And you do this for all the x's, you get g prime. So this would be like the first step in the prime. So, this would be like the first step in the process. You iterate this, you're doubling, adding clones, clones of clones, and so on, and you get all these ILT graphs. Now, why would the, here's some nice pictures. I just thought I'd throw it up, why not? This would be like starting with C4 on the top left is G1, and G2, G3, and G4 in the bottom right. These get very dense very rapidly. The number of vertices and edges explode, but what's interesting and why it's relevant to real world. And why it's relevant to real-world networks is you have what we call a densification power law. So if you look at the average degree, that tends to infinity. And these networks have very small diameter. They have large clustering coefficients, all the things you see in a lot of social networks. And for cooling, it's interesting. Cooling remains constant after round two. It basically is just one of two values always for any graph that you start with. It's always going to be one of these two values after two steps. Two values after two steps. And we looked at the case of paths. In the case of paths, we can narrow things down very precisely. I say 2n over 3 plus epsilon. We actually know exactly when epsilon is 0 or 1. So it's due with some modulus condition. So there is a precise statement of how you cool ILT graphs starting with pass. So I just have like a minute left. So I just want to say, yes. I just want to say, yes, this is one other direction that we went, and I'm not going to say much further about it. Some questions, always important to mention some questions at the end. Pooling on trees. Burning on trees, very, very critical area, right? Because if you can solve the burning number construction for trees, you can solve it for grass. Even for spiders or K-arey trees, we do not have good cooling numbers or even bounds. There's movement and symmetry in the title of the conference. A lot of people are interested. Symmetry in the title of the conference. A lot of people are interested in highly symmetric graphs like the hypercube or their generalizations, other grids, strong and hex. We don't have a ton of connections between the Cooling number and other known graph parameters. A more specialized question would be to look at ILT for other graphs and paths. We didn't do any of that. And of course, I'd say probably a big question, I may have something to say about this soon, but right now, I can't say anything publicly, is the complexity. We don't know about NP hardness. We don't know about NP hardness of this problem. In general, likely it is, but I think I'll say no more. So that's it. Thank you so much for your time. I think I'm right at half, one half hour. So like I'm at four o'clock, my time. Anyway, thank you so much. Questions, comments? Hi, Anthony. Good to see you. So the Um so the the burning number has uh a way of viewing it where it's like you're covering with balls of different radii. Yes. Uh does does cooling have a similar analogous way to think about it? Short answer, no. You can think of it more like the analogy I'd have. So JD, that was a really good question because it really was a nice segue. So the burning number is about a covering. Like you have a covering essentially of balls in the graph metric. Covering essentially of balls in the graph metric, right? And you're trying to minimize how many balls you choose to cover the graph. For cooling, the analogy I'd give would be more like packing. So if you think about what's happening in the Cartesian grid, you're trying to pack these balls as tightly as possible. Of course, the balls can't be equal, but you're trying to pack them as tightly as possible. So short answer, no. There's this rooted tree partition theorem in burning, which is exactly what JD said. For cooling, we have no such analogous theorem. No such analogous here. You went through? Yeah, are there any two-player or multi-player versions of these games, like where players are competing each other? There is a gamified version on that, and I can't say anything about it. I have a lot of graduate students, so I would be remiss to talk about it. But yeah, you can make both burning and cooling into a game. And there have been attempts at that already. And there have been attempts at that already, I believe, in the literature. I'm getting lots of citations on burning. There's a lot of interest in it from lots of different areas. But yeah, you can, there's a way to interpolate. Let me just say this. So there's a minimum, which is burning, right? Minimum number of rounds, and the maximum number of rounds, which is cooling. So there's a big gap between, right? That liminal space in the middle is really interesting to me. Okay, thank you. Thank you. Let's thank that to you again. 