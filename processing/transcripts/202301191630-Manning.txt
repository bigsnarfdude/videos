And we're going to talk about one slim short diamond and numerical criterion in the possibility of that case. Thank you for the invitation, Boom. So everything I'm going to be saying today is joint work with Shrikal Greengar and Chekhov Paray. So what am I talking about? So the Wiles defect, as improved later by Lensfra and Diamond, was kind of, as most of you are probably, one half of Wiles's original proof of his module. Wiles's original proof of his modularity lifting theorem together with the patching method. So the patching method we've seen several times this week, and it was notably generalized to the positive defect case, by which I mean sort of like the Paris chunk for a deflict, L non equals zero, by Caligari and Garrity a while back. And so, but sort of notably, they were not able to generalize. They were not able to generalize the numerical criteria. So, the purpose of what I wanted to do this talk today is to explain how to generalize the numerical criteria into the same setting as Kaladari Garrett. And sort of the motivation for doing this is that this allows us to prove some integral r equals t theorems you can't get purely via patch. Okay, so I want to start by just sort of explaining kind of roughly how the numerical criterion works originally. So for just to fix some notation for the remainder of the talk, I'm going to be considering some sort of coefficient ring O, which we'll take to be a finite extension of ZL for part L. I'm going to let sort of B this fraction field. And I'll pick a D. And I'll pick a uniformizer, pi. Oh, residue fields, I'll call it. Okay, so essentially, while this proof revolves around showing the certain map of rings from R if T is an isomorphism. So we need to sort of draw the setup we have. So we're going to have a ring R. It's going to project onto T. We call it projection pi. And just to add a few things to this picture. And just to add a few things to this picture, so also we want to, you know, thanks in sort of Diamond's formulation. Instead of just considering T, we're also going to consider a module M, which you should think of as basically being H1 module. Localized setup appropriate maximum ideal. And okay, so this is sort of the standard setup you have in patching. Now, for the numerical criterion, we need one. Now, for the numerical criterion, we need one extra piece of data. We need what we're going to call an augmentation, which is just some sort of subjective map from T down onto O. And I should say everything here is an O algebra. So, you know, maybe I'm just tensoring everything up to O if necessary. Okay, so this augmentation is basically just going to come from some sort of eigenform. This is going to make lambdas just easily every heavy operator to its eigenvalue. You need every heggie operator to its eigenvalue. Okay, so now what do we want to do? We want to prove that r is equal to t. And the numerical criterion basically gives a criterion for this to happen based around two numerical invariants. So let me just, these are going to look weird at first, but we just define them. So first of all, I want to define, I mean, the easier one, the cotangent space. Space. Space, which is just going to be some quantity, which I'm going to associate to this ring R here, which will be the kernel. I'm going to take the kernel of the composite of pi, which would be some prime ideal in R. I'm going to divide by the square of that ideal. And this is going to give me some sort of. And this is not such a weird thing. Another way of thinking about this. Another way of thinking about this, this is just literally the module of Taylor differentials of R specialized the O-valued point defined by lambda and pi. Okay, so the slightly stranger one is the confluence function. And for this, I'm going to assume that sort of M and T are sort of finite finite both. Which is not an issue for the standard modular forms of Q. Okay, and so what am I going to do? Well, now I'm going to define things mostly in terms of T. I want to consider the terminal of lambda again, which I'm going to just call P, some fragmentation. So now I can define another O module, I'll call the congruence module associated. I'll call the congruence module associated to t. How am I going to do that? Well, I'm going to look at the annihilator of this prime ideal P on T, which is going to be some other ideal of T. That thing is going to embed into all of T, and then by this map here, it's going to project down onto lambda. So, because the composition of these maps can be some ideal of O, and I'm just going to sort of quotient by that ideal. Sort of quotient by that idea. So I'm going to co-kernel that. And this is my definition of a congruence module. And this was sort of how Wiles originally did it. Diamond had improved this by conserving a module. So we can also define the congruence module of M, which I'm going to technically slice of T of M, I'm just going to draw the substrate of T a lot of times when necessary. And for this, we're basically going to do the same thing. Same thing. We're going to look at sort of the annihilator of P, embed that into M, project down now onto M mod P M, except, well, this thing, you know, this is just a pretty nice thing. This can have torsion depending on the structure of O, so to ignore that, I'm just going to take the torsion-free torsion here. Okay, and so this will be another O module. Like, if M has to be. O module, like if M has rank one, this will also be cyclic. Otherwise, it won't be. Okay, so I mean, I could say more about like what these things are, where they come from, and there's a lot to say here. There's other interpretations of the congruence module that could maybe justify the term congruence module a bit more. You know, this thing you can interpret in terms of a Selmer group. There's interpretation of this in terms of special values of L functions. This is kind of like some sort. This is kind of like some sort of block hotel thing going on in the background. That isn't really going to be that relevant for most of this talk, so I'm just going to kind of leave it at this. So the real relevant thing for us is this theorem is a theorem, which we do to Weils, in some cases by Lenstra, and proof by Diamond, which basically relates the three quantities I have on the board. Quantities I have on the board. So essentially, what I want to say is the cotangent space is the largest of these three things. That is greater than or equal to the congruence module of t. And well, now I would like to say this is greater than or equal to the congruence module of m, but like I said, you know, if m is not, that doesn't have rank one, then this could be like much bigger. So I need to normalize this a bit. So I'm going to raise this to one over mu, where mu. To 1 over μ, where μ is just going to be the rank of the scenario as an oval module. Okay, so that's not too hard to show in many cases directly. Now, sort of the interesting thing is what happens when these three things are fun. So, furthermore, so if we know that all three of these things are finite, so if this cotangent space This cotangent space is finite. So basically, kind of, there's maybe no actual like infinite deformations of my kind of representation for its point lambda in here. This is not such a weird condition. And I want to say that the total rank as an O module of M is at most μ times the rank as an O module of T. Then we have a condition for when these things require. So then the sphere R is equal to sine T M 1 on mu if and only if, let me just, we're going to have a few things here. So first of all, that r will equal t, which is the thing we're looking for. So by which I mean that this map pi is an isomorphism, and r will And R and T are complete intersections, and moreover, that M is free. So M can be isomorphic to R to the mu. Okay, so this is sort of the wildest numerical criteria I've talked about. So any questions? Are gone? Okay, so yeah, so this is all kind of just abstract working commuters. Just abstract working commutative algebra. So, like I said, this was used by Wiles to prove a modularity lifting theorem. So, now I'm going to sort of say a little bit about how that proof actually works. So, just to sort of fix the setup here, I'm going to be considering lifts of a fixed not be Galilear. Gallo, not P Gallo representation, j over 2k. We should, you know, maybe assume it satisfies all the Taylor-Wild's conditions and so on and so forth. And we're going to say this thing is modular of some number. Level, let's say, n empty sit. And I want to, and so basically I want to consider lifts of this. But you know, a lift of rho bar to me can, you know, it's never going to lose right. Can, you know, it's never going to lose ramification, but can very easily gain ramification. So I want to basically consider another level I'm going to call n sigma, which is just q products of q sigma, q, whereas q sigma is finite. And just while it's restricted everything to the semi-stable case. Everything to the semi-stable case. I'm just going to do that to make things easy. So I'm going to assume these are both Twitter free. Okay, and so, yeah, so this energy z is the level of rho bar, and sigma, I'm going to think of this, the level of whatever lifts, I consider it. And so I'm going to have a picture very much like the one I just erased. So R C. Just erased. So R sigma is going to be the sort of deformation ring at sort of the level n sigma. T sigma is going to be sort of the weight to the algebra at level gamma naught and sigma. I'm again going to have this module m sigma, which as I said before is just going to be h1 of a module curve, x naught, and sigma. Of x0 and sigma. And lastly, I'm going to have this augmentation, which is just going to come from picking some sort of lift left of rhobar. And maybe I'm going to assume that this is a lift that factors through T sigma. So the assumption that rhobar is module level and sigma means that it does actually have some lifts of module lift and level and sigma. Okay, and so the goal here. Okay, and so the goal here is to show that R equals T o R sigma equals T sigma, which is then known to imply that any Gauer representation parameterized by R sigma actually comes from a modular form. I think this is a picture most of us are already familiar with. And so the idea is basically to induct on sigma. So the first step is we're going to use. Step is we're going to use patching in the signatures and so show by patching that everything on V2 is true. So there's by isomorphism, but in fact, patching gives us more than just that. It gives us an isomorphism of complete intersections and the modules for. Modules for CI's and that's mb is 3 of rank 2. So that's standard patching arguments. Now, where's the numerical criterion come in? Well, this line satisfies this direction of the numerical criterion. So this is then going to imply, take here of inequality, it's going to imply that the co-tangent space of R Space of R to square is equal to the convuence module of M. So now from here we want to show, propagate this equality to kind of non-nipple levels. So, and that's just going to be sort of two steps. So, first, so I want to basically figure out what happens when I add a prime to sigma. So, first of all, I'll just say, show, this is some Galois homology argument I don't want to get into. Argument, I don't want to get into, but it isn't too particularly hard. I'm going to show, we're going to show that when we add a prime q to sigma, this cotangent space increases by at most some amount, which I'm going to call CQ. Sigma, and it's not really important for us to talk exactly what CQ is. I mean, it's basically kind of the extent to which you can level raise it. Raise it. Okay. And the trickier part is controlling the growth of conflicts modules, which you might expect because convoys modules are a lot more weird and complicated than these things. So the key fact here is a hara's lemma. So for us, the hara's lemma is basically going to be that a certain level Lord map on the H1s is surjective. So in particular, so So, I'm going to say there is some sort of natural level lower map that I'm not going to define from n sigma u d q to m sigma, and Juhari's lemma statement. This is for natural maps. I should probably say at this point, if you're used to Juhari's lemma, you might sort of be expecting this to be like m direct sum m, because there's two natural degeneracy maps. But I mean, something I kind of buried in this is like. Kind of buried in this. It's like I have some UQ operator interacting on this. I'm sort of localizing with respect to that. So if you combine those two things, it's one. But anyway, so our sum kind of important facts, say this is surjective. And the relevance of this is now that by a unit of algebra argument, you can actually compute the growth of the congruence function. Maybe I should erase that, but whatever. Sorry, just take a look at. Sorry, just to clarify, is the goal to prove that by using while is less red lines right here? Yeah, yeah, yeah. So that's exactly what we'll do. So, yeah, so basically, by Yahara's lemma, sort of some commutative algebra allows us to prove that the congruence module of Q does exactly go by the factor we expected. Technically, I think we need a lower bound where you get an exact answer in this case. The exact answer in this case. I'm not taking a new route. But I'm sort of in rank two here. So new is two. We're up there. Okay, so basically, sort of now these things move. Now, these things move by the same amount. So, by the numerical inequality, again, we now get that we have the equality we expect after all sigma sigma. And so, therefore, by the numeric visor in the undirection of the miracle criterion, we get equal to pi sigma. Sir Sun of its intersections and Okay, and so that's R equals T and that's kind of how the proof of Mars theorem goes much all the details Okay, so yeah, so any questions on that yeah okay so now I mean this one's all Okay, so now, I mean, this one's all sort of just the classical Wiles instead. Now, obviously, in the time since Wiles, lots and lots of work has been done refining and improving on this argument that we probably wouldn't be having this conference if it hadn't been for all the work since Wiles. So let me talk a little bit about some improvements on Patrick. So, the patching argument has been extended extensively since this numerical criterion, a bit, but not as much. I want to talk a little bit about some of the obstacles to extending the numerical criterion. So, probably the most significant improvement to patching since Wilson's time has been this inside of Kissin, which kind of allows us to basically completely search for this argument I did and just prove. And just prove the whole argument at this step with skipping the entire production. This is due to Kissing. I think this is sort of nine or so. And I promised we're going to be doing the positive defect case, but everything I'm saying here is still in the L10 case. So you should be thinking like GL2 over a totally real number field, or maybe something like with unitary Schmohr variety. So basically, we'll just So basically, what Kiss improved is that we can use patching, patching at all levels, at all levels. So basically, and as we know, he did this by explicitly introducing the local information rings into the picture. Introducing the local information rings into the picture. And so basically, that allows him to sort of patch at this level. And what he basically gets from this is that without using the numerical criterion at all, we can get, well, here's the thing. We don't quite get r equals t. So what we get here is that r sigma will not l equals t sigma. And I mean, there's various sort of technology. And I mean there's various sort of technical reasons why this happens. It's kind of like we don't like we can still cache at all the levels. We don't kind of fully understand what the patch module is going to be. But yeah, so in any case, we get this for all sigma without even having to do a numerical work. Which, okay, so this is good enough for some applications. So if what you care about is modularity of a representation value in QO bar, that's enough. So enough for sort of modularity C of GR2. So like for modularity of elliptic curves, this is perfectly fine. You don't really need R equals T. And in fact, in some cases, it's possible to directly prove that R is torn. Prove that R is torsion free. And since T is torsion free as well, this can actually sometimes be fun and properties. So it's sort of like a little disappointing it. Patching doesn't directly give you R equals C in this case, but it's not such a big deal in practice. Now, of course, I found that now there's a different situation where this actually can be a bigger issue, which is the main thing I want to talk about here: the positive defect case. So there's lots of sort of different positive defect situations that can show up. To keep things simple here, I'm just going to focus on PGL2 over a number field. So I'm going to let F be a number field. And I'm going to assume that Assume that R1 and R2 are the real complex places. Instead of considering a modular curve, now I need to consider some sort of like arithmetic manifold, which I'm going to call Y naught. To call y naught n sigma, which are n sigma as before. So I'm just going to define that. 2 f if you don't know what this means, just think of it as an out of the modular curve. Okay, and so there is. Okay, and so there is some defect I keep mentioning. So I'm not going to try and define the defect, but let me just sort of tell you in this case, this defect is the number of complex places of F. So kind of the positive defect case is exactly this situation in the case when F is not totally beaten. Okay, and so now sort of in this case, just like a modular curve, I can now kind of consider it's a model. It's homology in certain degrees. And maybe I can consider a heck of algebra acting on this. I'm not going to define exactly, but I can basically still define a double coset operator in the way you would expect. Okay, and so now, and you know, sort of similarly, I'm gonna maybe have a deformation rating on R sigma, and we're gonna wanna show that R sigma is equal to G C. Show that R sign is the HT signal, which is again showing that every lift of a given representation that of a certain level actually is modular. Now, in order to do this, Caligari and Garity needed to assume a number of conjectures. And I'm going to be kind of assuming the same conjectures. And now, I mean, you know, if you can, if you sort of think like, yes, this is all conjectural. So I should say there is another positive defect situation you could consider, the case. Defect situation: you could consider the case of weight one modular forms, which I mean, for everything you could do over a modular curve or a Shimura curve. In that case, all the conjectures I'm going to state are known, and so we do get unconditional results in that case. I don't want to talk about that in this lecture because it's complicated. So, I want to assume the follow-up, so I want to assume a list of conjectures. So, first, I want to assume basically that some sort of, that any maximal ideal of this hackathon. Maximal ideal of this Hack algebra actually corresponds to a Gaul representation in the way you would expect the module for trace of BES is given by the corresponding packet operator and so on and so forth. I don't want to set all the conditions there. So we want to assume that happens. And next we want to assume that, like, And next we want to assume that, like, there's actually, you can actually kind of interpolate this in a family, so that we actually have kind of a corresponding surjective map from R to T, which is, and I'm just going to say sort of plus some sort of locality structure. I mean, I don't wanna again write that all out, but it's Without all L, but it's sort of things you'd expect. Like, you know, if L is not in the level over here, you expect to find it flat, and so on. Okay. Sorry about that. Thirdly, I want to consider, I want to sort of say something about these homologs. I want to say that basically they vanish outside of some specific range. Oh, assuming I localize at a non-Hisen sign maximally there, so one that makes this thing absolutely irreducible. I want to say this thing is zero for i not in a specific range of degrees, which I believe in this case should be R1 from R1 plus R2 to R1 plus 2 over 2, which an important thing here is that the language thing here is that the length of this integral is exactly R2, which I said was this quantity L0. Okay, so this is kind of like the analog of the fact that in a modular curve, if you localize at a non-Eisenstein maximal ideal, everything vanishes away from h1. In that case, you know, you'd get a range of length zero that not vanish here, you get sort of some bigger range. And lastly, one more conjecture. One more conjecture which did not appear in Calgary Garity, but we need here is the harvest label, which is basically the same statement as before, this time on the D degree hope homology, the lowest non-vanishing one. U N I want that just inject down on to H D not N O. Okay, so that's a big list of conjectures I'm going to assume for the rest of the talk. Let me just say a little bit about what's known for these. So this first one, I believe, is known for CM fields, which is probably the only case where we're even close to approaching this. Approaching this. The second one, it's not quite known for CM fields, but we're getting somewhat close. I think in a lot of cases, this is known if you replace T by T mod I for some Nilkotten ideal of bounded rank. And there have been some work about sort of removing that. I think in a lot of cases, you can get R to T, but possibly without the local compatibility. So, you know, it's So, you know, it's not quite resolved, but it's not too far from being resolved. This third thing, well, it's certainly known in the case when f is a quadratic imaginary field, just because, like, in that case, this is just a three-manifold. It's not hard to show that h0 and h3 vanish. And for other CM fields, there's been, I think, some progress, but it's not maybe known in general. But not so, at least there is some. At least there is some cases in which it's known. Ehara's lemma, it's known for quadratic imaginary fields, again, by kind of somewhat similar proof to the paid proof over Q. To be honest, I'm not entirely sure of the status over other fields. I mean, it gets a little tricky over other fields because then instead of dealing with H1, you're dealing with that sort of higher degree thing, which makes the classical argument trickier in general. But sort of, you know, we have more of this for like. But sort of, you know, maybe the moral of this for like quadratic imaginary fields, these conjectures aren't like too, too severe. Basically, like the second one's the only issue, and it's not implausible that that will be resolved for the next few years. Okay, so basically now subject to these conjectures, we can try to generalize the backup. So this was due to Caladari and Gary. Just due to Caladari and Garity. I believe the paper didn't appear until 2018, but it was sort of floating around on the phone a while before that. 918. I don't want to state the theorem exactly, but basically assuming One, one, two, three. You can generalize catching. Okay, and so what does that mean practically for us? So, again, they're generalizing sort of Kisson's formulation of patching. So, they can patch at all levels simultaneously. But, you know, just like for Kiss. And, but just like for kissing, they don't really get r equals t open up. So only gives, oh, let's say r sigma 1 upon L is T sigma 1 upon L. I believe maybe in some cases they actually only get that R reduced equals T reduced. I forget the exact status of these. I forget the exact status of this versus this. But in any case, so we have sort of similar saturation as before. We don't quite get r equals t. Again, that's enough for proving that something with QL bar coefficients is modular. So kind of famously enough to prove potential modularity of CM elliptic curves. But now, the other thing I said before about sometimes we don't promote this to r equals t, that doesn't. That doesn't work. Because, unlike in the L0 equals zero case, you should expect Re2B to have torsion. And you should expect the torsion to actually be somewhat interesting and important. So it's like the fact that we can only prove this isomorphism ignoring torsion is a bigger deal in the positive defect case than it is in the classical case. So, is there any technical case and it wasn't such an issue? I mean, I think for us, it wasn't such an issue, but here's any issue with components of definition actually. Yeah, yeah, I mean, there's some issue with components. I mean, you still want to do some sort of like Yahara avoidance thing. I think this is why I'm not entirely sure if they, at what general ID we prove this in versus this. I mean, basically, sort of like if you don't have classical points on your components, it's a little harder to maybe do some standard arguments, that sort of thing. Standard arguments, that sort of thing. I mean, if the main thing you care about is modularity of some sort of classic point anyway, you're kind of okay. I mean, so just don't worry if you're not supported on some component that doesn't have any representations you care about in the first place. So yeah, so basically, any more questions? So, this situation is: we would like to, you know, we don't actually have R this T, and we Have r equals t, and we would like to get that. And of course, the way you would do that, going back to that whole thing, is by using some form version of the numerical criteria. And, you know, this seems like a kind of tempting thing to do. Because, well, we still, in the base case, we do actually get articles key from patching, and we get sort of freeness of the mod, an appropriate module, in a pretty similar way. And we still have a forest lemma, at least in the imagination. Behar's lemma, at least in the imaginary quadratic case, which seemed to be like the main thing that was necessary to use the numerical criterion. But unfortunately, the numerical criterion, despite having all the necessary inputs, just doesn't seem to generalize quite as easily. I want to like explain campus. Yeah, yeah, yeah, that that yeah, yeah, that's another thing that can be. Yeah, that's another thing that can be a problem. Like these things can both be torches, so there might not even be this augmentation I talked about. That that's one of that's one of the only problems. Okay, so how does the patching work? It's going to work in this case. And so the answer is basically patching is going to work pretty similarly to the standard case. So again, we're going to start with sort of our RT map. Of my RHT map, I'm going to consider a module of the, which is just going to be sort of my lowest degree homology group. Lowest degree homology group, sorry. And so by some sort of complicated process, there is still a way to patch this. And so patching will give us a module, I'll call it r sigma infinity, which R sigma infinity, which again, you know, is the thing you'd expect from a classical patching thing. So, sort of the completed tensor product of kind of all the relevant local deformation rings with some extra power series variables attacked on. You're again still going to get a module m sigma infinity, which will be Maxwell Cole-Macaulay. And again, if you're not familiar, if you're not familiar with And again, if you're not familiar with the term maximal conflict, just think very nice module that's big enough. Okay. And so, yeah, so this is all completely identical to the standard case. Now, the one thing that's different between this case, classical case, is what happens when you try to sort of de-patch to go back from here to here. So, what's going to happen in this case is that basically the Case is that basically there's going to be an ideal, let's call it i sigma, which will be generated by some set of elements. Let's call it f1, f1 plus l0, and where this n here is going to be my dimension of our sigma infinity, sort of over up. Okay, and so basically to get back down to this picture, this picture, which is To get back down to this picture, this picture we just mod everything out like this. So such that r sigma is equal to r sigma infinity mod i sigma, and m sigma is equal to m sigma infinity mod sigma. And so the one thing that's different from the classical case, in the classical case, this is actually just modding out by n elements in an n-dimensional ring, and in fact, in the ring, Ring, and in fact, in that case, this is going to be a regular sequence, or at least n infinity. In this case, there's just too many elements here for this to be a regular sequence, so it's just basically some idea. But that's the only real good issue. And so what are we trying to do here? So our goal is to prove that r equals t. t doesn't really show up much in this picture, but m does. And so, really, since t acts basically on m, what we're really just trying to show is that r acts basically on m. That or a space of it. Or something like space of none. And you want to somehow be able to detect this at the patch level. And now, the one sort of warning here is like, it's not actually, in most cases, not that hard to prove that R infinity acts faithfully on M infinity, but that's not enough because the property of a ring acting faithfully on a module is not conserved. Faithfully on a module is not preserved through quotients. So instead, you want to prove something that's stronger. The classical thing to prove here would be that M infinity was free over R infinity, which would mean that like M sigma is free over R sigma, which certainly does apply faithfully. But yeah, certainly without that. So, okay, so that's sort of the setup. And I'll say, like, yeah, in the base case, sigma equals empty set, everything does go through fine because in that case, Because in that case, at least if I impose some conditions I didn't mention, like that's going to force R to just be a power, R infinity to be a power series ring. Maxwell Cole-Macaulay modules over power series rings are automatically free. So in the base case, we do get that m sigma is free. But that doesn't really generalize at to other levels because r will no longer be free. R will no r will no longer be a poly series ring. Are no longer being a high series ring at high loads. So, again, like what we'd like to do is somehow apply the numerical criteria to the business. But as I mentioned, there's a number of issues that go up so issues with numerical favorite. So the first thing, you know, numerical criterion really relied on complete intersections. And if you look at this, like in the base case, we, you know, in the base case, this R will actually just be a power series ring in variables. Can you variables, like you would expect. And then we're modding out by n plus L mod relations. That's not going to give us a complete intersection. R sigma, say probably this intersection. I say probably because technically in the L mod equals one case, if r is zero dimensional, that will give you. Is zero dimensional, that will give the complete intersection, which has possibly been an average approach to that, but we're not going to really care about that for this. So that's one issue. So the second issue is that the usual definition of the congruence modules modules ignore torsion. I erased it here, but if you remember, the congruence module involved taking the torsion-free part of M mod P, which, you know, since our whole goal here is to understand what happens with torsion, if your first step is throwing away all the torsion, you're probably not going to get anywhere. So, like, you know, there is some theory of confidence molecules and defects here by just looking at the torture-free quotient, but it's not really going to be enough to actually approach something. Enough to actually approach something like this. And as we said earlier, so expanding on this, maybe R is entirely torsion. Which is an issue because that means the augmentation won't exist. So this augmentation that I base everything around might not exist. This okay, and lastly, maybe sort of a little bit more nebulous one, like diamonds criterion involved a module. Here we don't really have a module, we have a whole family of them. So if we count kind of H D well H D plus L minus 2 h1. And so it's sort of like a little harder to tell what's the correct generalization of diamonds numerical criterion if you kind of have all these different molecules to deal with. So yeah, so I know, I believe Caligari and Gary tried to generalize the numerical criterion in the original paper, and I mean that stopped for probably some subset of these reasons. So, how do we get around this? Well, our trick is basically to change our perspective and sidestep all of these issues. And how do we do that? Well, basically, we're just going to forget about R and T and M entirely, and we want to run the patching argument entirely at the, sorry, the numerical criterion argument entirely at the patched level. And that's nice because, well, as I just said. That's nice because, well, as I just said, the patch level for L0 greater than zero is almost identical to the patch level for L naught equals zero. So that's a nice enough idea, but if you think about it for five seconds, you're going to realize a really driving issue with this, which is that the numerical criterion, as stated, just does not work for these things. A kind of important assumption, my numerical criterion, was that, you know. Criterion was that M was actually finite over O. This is not even close to true here. And I mean, if you just naively take the congruence module and cotent the space I defined before, they're both going to be infinite. In this case, you're just not going to be able to get anything sensible out of it. Which brings us to the real innovation of our work was to formulate a numerical criterion which can actually directly be applied to. Which can actually directly be applied to these things, which, as a first step, involves redefining the invariance I talked about at the beginning. And the big one there, of course, is the confluence module. So this is sort of the last subject of my talk. Confluence modules. So, much of the remaining So, much of the remainder of this talk is just me doing the commutative algebra necessary to sort of run the argument and time destroy it. So, for now, I'm going to fix a commutative noetherian local O algebra A, B, and again, I'm going to consider an augmentation of it. So I've got a subjective map from A down into O. As before, I'm going to let P be the kernel of that map. Of that map. And now, sort of in the base instead, in sort of the original case, like this p was the minimal prime of r, otherwise you wouldn't have had the cotangent space be finite. But here, I'm going to say that c is the height of b, so c for codimension, which I'm going to not make any assumptions about. It could be possible. Okay, and in addition to this, I want to consider a model. And in addition to this, I want to consider a module. So let's just say M is a finitely generated A module. And I want to assume that it is, in fact, supported at P. Otherwise, kind of nothing I'm saying is going to be at all interesting. And so I want to basically define a congruence module for these objects. And, well, it's really not. Well, it's really not obvious at first how to do that. So let me start by just sort of rewriting the definition of congruence modules originally. So remember, psi A we defined to be the co-so let's if C equals 0, we define psi of A to just be the co-kernel of this reference V. Brackets B to A2. And we did basically the same thing for M equals to M2M3. And so, well, now, how do I generalize this? Well, let's think. So, the key thing was. This? Well, let's think. So, the key thing was this sort of annihilator of P. Let's think about what that is. So, just the one way to think about the annihilator of P is it's just homes from HOMS, you know, as A modules from O to M, where O I just, where by O I mean A module. So just topologically true, the generator here has to map to an element of that. Okay, now. Okay, now how do I generalize this to higher C? Well, another way of thinking about Hong is Hong is just X0 as an angle. Okay, and so now that I have that vague idea, let's define things more generally by just saying, well, let's replace all these things with the appropriate X groups. So, particularly early. So particularly, I'm going to define the congruence module of A to be the co-kernel of X C of A O to X A C of O come to O. And well, this is almost what you want to do. This might be this was the first thing we tried, but it turns out to actually make this work, you need to take the To actually make this work, you need to take the torsion-free quotient here. Okay, and then you can do about the same thing for the module. That would be zero, right? Yes, yes, yes. Sorry. Yes, sorry. Basically, in every extra group I'm going to write for the remainder of the talk, the first entry will be backwards. Please tell me. So X O comma N X C O comma G. Okay, and so this is a congruence module. It's not clear immediately what properties it will have. Let me just list out a very basic one to start with. So the normal congruence module of A is just a finite cyclic group. Just finite cyclic group. When does that happen here? So it turns out that's going to be exactly when this is regular, regular of dim C, if and only if this thing is finite, and so in this case, case A is 6. And the proof of And the proof of this is not hard at all. I mean, sort of, in this direction, you literally just sort of localize everything at p and use the fact that we kind of know the x groups of a regular local ring. So you say xc of h from that in this case, we do have some orphan here. And this thing is a one-dimensional vector space. So that kind of gives that this is planet and cyclic. And their turnouts just meet the same criterion for regular rings, which is basically if this is true, we'll specifically. So this is not what I think you're doing. And so this at least makes this look a little bit more like the Saturn conference module. Like we do indeed get some, we do indeed get some. So, when we do indeed guessing the group, you can show that you also have sort of the corresponding inequality you'd expect between these two things. There is some sort of subjective... How fresh do you? Oh, the residue field of O. Fracture field of O. Therefore, resident field thing. I wrote that right at the start of the talk and literally haven't used it since then. Okay, so that was. Okay, so that was a fairly easy theorem. Now, kind of to maybe convince you that this is actually a somewhat reasonable definition, let me try to state a few of the trickier things we've tried. So first of all, now I'm basically, I'm only going to consider this case. And in fact, just to give myself some notation, I'm going to let CO of C be just the category of pairs of A, A commas lambda such that A B is regular of in C, and I'm basically only going to consider the radio scatter from now on. So this is one of the two quantities I need to consider. The other one was basically the cotangent space. And the point is that if A is written, if A is written, If A is regular at P, we kind of know something about this cotension space. If we look at P mod P squared, it's not going to be finite, but since this is a smooth point, we know what its rank is going to be. So this is going to be O to C plus some sort of torchion thing. And we want a finite quantity to compare things to. So kind of the only natural quantity you can take is this fortune part. So now I'm going to define. So I'm now going to define psi of A to just be the torsion of square A. Okay. And so, I mean, eventually we are going to get a new article right here that states when this is equal to this. And that will happen for every intersection. But just to give it, just to state a few theorems before that. So one thing we can ask is: well, what happens? One thing we can ask is: well, what happens if we change the rate? So let's say that A to B is a surjection in this category, C, C. And let's say we consider, you know, M a module over B. Then we can consider two different things. We can consider the congruence module of M with respect to B and the congruence module of M with respect to A. And the congruence module of M, specifically A. Those are both valid. And if you sort of think about how X groups work, there's a natural map from XB to XA. So there will be a natural map like this. And sort of our first big theorem is that in nice cases, this is an isolation. So this is that sort of evil. Is that sort of, well, it won't hold in general, but sort of if the depth of m is at least c, which in particular, if m is maximum, we'll call it that's automatically satisfied that depth of b c equals one. So then we actually get maximum works. Which, okay. Hey, so basically, this says that despite the definition. Says that despite the definition, this actually is kind of an intringent property of the module. And I should say, like, in the proof, this is not an easy thing to prove. Like, the fact that we're taking torsion-free quotients is very critical in the proof. And, you know, also, however, in this equals zero case, this is kind of an automatic thing because x a is equal to x b for any b modules because it's just tall. Okay, so we have this. So we have this, and basically another theorem here. So a second theorem we have is that basically, well, the coordinates we've defined are in some sense compatible with regular sequences. So now if A is in C not C, then depth of M is written M is greater than, let's just c plus 1, and let's say sort of the range of m at p is mu greater than 0. That basically, if I were to mod out by a regular element in A, I kind of preserve the defect between this congruence module and the cotangent space. So if F is B P M, then what happens? So, if I want to compare the quotient between the cotemplate space and congruence module of M, that will be the same as if I instead modded out everything by its coming F. Which, okay, so maybe basically the advantage of this is that this lets us reduce a lot of things to the sort of the classical C equals zero case. What does it say? F in P? Sorry. F is in E, but not in the second symbol, like a power of P. So basically, it's just like an element in P that I can want out by itself. That I have one outbot, I still get a smooth ring, sort of a ring that's regular at the augmentation. As a symptomic power. I can say more about that later. We're running a little low on time, so let me at least space our main theorem here. So, kind of with these two things, we can prove our numerical criterion. So basically, we're again going to be in this case if A is C f and square is one and this with name. Then I do have the inequality I expect between these two quantities. And moreover, I have equality only in a specific case, so if and only if um A is A. Intersection. And well, in this case, I'd sort of like to say that M was actually free. Unfortunately, I don't actually have any control over the rank of M in this setup. So the only thing I can actually say is that it has a free direct sum and somewhere W, where W is just sort of some other homework module that is not supported in MS. Is not supported. And I think I'm basically out of time. But so. Why don't you get a control of the chat? Well, I mean, so this kind of goes back to like the category guarantee patching thing. To control the generic rank of a patched module, you need to have a classical point on the given component of R infinity. So you can appeal to sort of classical one results automorphic for them. This sort of thing already shows up in Calgary theorem because, like, Theorem because, like, you know, if they say, like, if they have a kind of characteristic zero point at minimum level, they get free of rank one, otherwise they get free of some rank they can't control the rank. Here, it's kind of more complicated for us because we have multiple components, so we can't even show they have the same rank on each component. But fortunately, that's not a big deal because we can prove a direct sum, and so we don't actually get a multiplicity one result here, but you know, certainly. Here, but certainly if our patch module has a free direct summand, it will still have a free direct summand after modging out by ideal. So, this will still allow us to prove that sort of R acts faithfully on it. Let me just maybe state that in there. And so as we're assuming conjectures one to four There is some zero such that H D A naught and sigma ho and is equal to sigma for mu for some w sigma for some w sigma mu so in particular So in particular, we do in fact get that R equals T. And sort of the kind of corollary of this, we might expect, is this now gives us a new automorphic lifting theorem, but sort of for coordinating representations. So if we're going from GF to mod pi to the n. pi to the m is a lift of m and oh probably should have said like taylor wild condition there's other things and also technically we have some conditions on the level i don't want to list that all out right now so then row is model Rho is monitoring. By which I mean it comes from some sort of torsion eigen class on one up to n sigma. Okay, yeah, so that's kind of, you know, we think of that as some sort of like application to a torsion eigenvalue. And yeah, I think I mean outer time, so it's up here.