Talk to us about efficiently achieving efficiently achieving salt-tolerant quantum computation by a gate. So thanks for the invitation and it's been very meaningful and learning about lots of interesting work. That's pretty close to what I was already doing. So I wasn't sure exactly what to talk about, but it sounds like people are interested in clipping hierarchy. So I'll probably spend 80% of the time. probably spend 80% of the time talking about some recent mathematical work on the Clifford hierarchy, so specifically the Clifford Macuted Clifford hierarchy, so for like far higher dimensions, which is the Clifford hierarchy has been studied for like 25 years, but now they're more interested in the macuted case. And then like maybe for five minutes at the end, I'll just plug some other work that will be interesting to this community. Yeah, so right now I'm going to talk about some recent work with Imin Chen, who's a number theorist at SIPU. At SIPU. So he does like very serious number theory to do with like formats' last theorem and things like that. And yeah, basically solving one of those questions about the COVID hierarchy required some intense tools that I don't know anything about. So hopefully I learned some stuff about number theory doing this. And I think it could be useful broadly and stuff related to error correction and circuits, things like that. Okay. So quickly, I'll give an overview of the talk. So first I'll just An overview of the talk. So, first, I'll just remind everyone about gate injection and specifically the definition of the different levels of the Clifford hierarchy, which are basically the Clifford hierarchy, the third level at least. They're the gates that you can do false tolerantly if you assume that the Cliffords are easy. So it doesn't matter what the code is, as long as in the code, we assume that Cliffords are easy. And the third level gates are the ones that you can do with magic, sorry, with gate teleportation, where everything's fault tolerant. Okay. And then there are higher levels, which basically are. And then there are higher levels, which basically are also more gates that you can do, but they're a bit more involved, those protocols. Okay, and then I'll talk about the results where the I'll talk about, I'll give the formal statement later, but basically it means there are more efficient gate toolpitation protocols that allow you to achieve fault tolerant universality. So, and for me, also the interest was, I mean, there's the practical reason why we want to know what the gates of the clipping hierarchy are. To know what the gates of the clipping hierarchy are, but also for me, I was interested in quantum advantage, so that was my motivation because it also tells you what, like, um, what the magic states are and what their relative power is. So, I think from a theoretical perspective, even if you never actually inject these data, still interesting if you want to understand fun advantage. And also, yeah, I'll talk about the novel mathematical methods that were required to solve this problem. So, specifically, yeah, you would expect linear algebra to show up because obviously everything in quantum cancer is linear. To show up because obviously everything in quantum mechanics is linear algebraic abstract algebra group theory, but what's novel is the use of algebraic geometry. Um, so I mean, I'm sure that people have used algebraic geometry before, but specifically there were some really abstract tools from more recent, you know, what's the 1960s, right? Like Rodik's theory of schemes and things like that, which is not something that commonly pops up in other areas. So I think that's a pretty new thing. So to review, uh, so here's the simple, you know, definition of uh Definition of quantum teleportation. Okay. Just Alice and Bob share a Bell state. Alice has her own state psi. They do a Bell basis measurement and then controlled on the outcome of that measurement. You do a polycorrection. Okay. So I just put little boxes around here where you prepare a shared state, you perform a measurement, and then you perform a correction. Okay, so make a slight modification here. So all I did is I added G and G star. A G and G star at the beginning of Bob's second line and a G at the end there. Okay, so the G and G star do nothing right through the identity. The G at the end applies a G to the final output state. Okay, and then move the G and G star into their boxes where G is now applied in the state preparation box and the G star and the G are in the correction box. Okay, so because they're commute with everything, move them into place, right? So that motivates Place right, so that motivates the definition of the third level. So, the third level are all the gates where if you conjugate a Pauli, you get back a Clifford. Okay, so the normalizer of the Pauli group, which is the group of unitaries. And the reason why that's an important property is that if G satisfies this property, that means now everything in the circuit other than the state preparation stage is Clifford. Okay, so that motivates the definition of conjugating a correction operator to give you something Clifford, which is false. Correction operator to give you something click rate which is false on it. Okay, so any questions? It's a pretty fundamental definition. So if anyone, anything not clear, then. Okay, so yeah, I think everybody understands third level. But it also motivates this definition of higher levels of the cliffhanger. So if you assume that you can do third level gates volatilely, which you can, because you can use this injection protocol, assuming you can volatilely prepare that state, which you can, then you can also do more gates, like, for example, if the correction operator Like, for example, if the correction operator is third level, then you can inject the gate with that protocol, right? Because you can use the magic state for the third level. So the client harky is just an increasing nested sequence of sets. Oh, yeah. Sorry. G is the element of C1 or no, G is an element of anything in the unitary. But as long as it has that, I mean, G is, can be any unitary, but to be in the third level, it has to have this property that. But to be in the third level, it has to have this property that it conjugates the polygroup to some clifford. Yeah. So you said we can fault tolerantly prepare this state. Why can we fault tolerantly? It's complicated, but it's in like this Gunmin Chuan paper from like 25 years ago where they introduced gate teleportation. But it's ultimately the chunk, but it's like pretty long. But is that specifically for third level? No, for any level. Oh, okay. I know for any level. Oh, okay. Yeah. Okay. Yeah. So we get a nested increasing sequence of sets. So C1 is the Pauli group, the first level, C2 is the Cliffords, C3 is the third level. And then we get larger and larger sets, okay, but they're no longer groups after the Clifford group is a group, but then C3 is not a group, and so on. So this definition works for any number of qubits or qubits. Okay, so, but one thing is like this was based on the teleprediction protocol, but the teleportation is protocol. On the teleportation protocol, but the teleportation protocol had a different origin, where it was meant to be a communication protocol between two spatially separated parties. But in a computer chip, you don't have spatially separated parties. So that means we don't need to have some artificial separation between Alice and Bob. So if we allow ourselves to have gates between Alice, if Alpha and Bob are not spatially separated, then we can compactify this gate teleportation protocol, at least for a certain subset of the Clifford hierarchy gates. So that's the definition of the semi-Clifford gate. Of the semi-uh, Clifford gate, so it's a pretty bad name, but it's 25 years old, so can't get rid of it. So, a gate is semi-cliffered if it's diagonal up to multiplication on the left or right by a Clifford. Okay, and the significance of being semi-cliffered is that you have this compactified teleportation protocol. So notice, I forgot to mention, in the standard protocol, the magic state is twice the size of the gate, because if the gate is n qubits or n qubits, then you need n bell pairs. Okay, so the magic state. Okay, so the magic state is 2n. If the gate is n, qubits are qubits. But with the semi-clifford gates, the magic state and the hierarchy gate are the same size. Okay, so this is the QGIT version of the semi-clifford compact impression protocol. So you might have never noticed this because maybe you've only ever seen T and T is semi-clifford. So you probably only have never thought about the fact that there are other gates that you have to use twice as many. The budget tapes have to be twice the size. But that's because T is semi-cliff. But that's because T is semi-cliffered, which is part of one of the reasons why we use it. It's the simplest one. So, yeah. So, just to recap, the background. So, the Tali group is C1, the first level, and those are just the things that are built from ZNX. The Clifford group are the gates that can be easily performed philatologically, and they're the second level. And they're the normalizer of C1. But they're not enough. You need to do some other gate. Enough, you need to do some other gate. Uh, the third level and higher gates can be performed fault tolerantly with access to suitable magic states, okay? Uh, so they allow you to achieve fault-tolerant universality. Uh, and the semi-clifford gates are the ones that can be performed with efficient magic states, okay? So, they're kind of the best ones, okay? So, the third level ones are kind of the best ones, and the semi-clifford third-level are even better because you can do them with half the use of magic states. And, like, you know, because something like 90-something percent of the physical. Like 90-something percent of the physical qubits are going to be used for magic state installation, efficiency gains like this are enormously important. So, there's two natural questions, and they've been studied sporadically over the last 25 years, studying from when it was first introduced. So, the two natural questions, one is what are the gates of the cliff hierarchy? So, like, we just gave some definitions, but we didn't give that many examples or a systematic classification. Okay, so there are some results along this line. So, I think maybe the most significant. So, I think maybe the most significant would be Kri Garjman Krishna, who completely classified all the diagonal gates of the Clifford Hiki. I'm going to be talking about the second question, which is also a bunch of people have been studying for a while, which are which hierarchy gates are Santa Clifford? Okay, so just to review the known results. So the qubit case has been studied quite a bit. So for one or two qubit gates, all gates of the Clifford hierarchy are semi-clifford. So for D equals 2, dimension 2. Uh, d equals two, dimension two, n equals one or two, uh, and k is arbitrary, kth level, any level, they're always semi-cliffered. Okay, and the proof of this uses a computer to enumerate lots of cases. So I just thought I'd mention that it doesn't generalize to higher dimensions because you have to do a search to do a search. And then also, but that fails to be true for higher numbers of qubits. Okay, so this was in a paper by Beijing Shore. So this diagram summarizes the situation. So black. The situation. So black means that if it has that many number of qubits and at that level, they're all semi-cliffered. And a white circle means there are known counterexamples to the idea that they're all always semi-cliffered. Okay. Actually, I just looked at the counterexample yesterday. And I think actually these two might be still open. But the counterexample only starts at like n equals seven for k equals three. So I'll have to, yeah. Okay, even so that the ones that are those counterexamples, yeah, that's That are where there's counterexamples, is there any norms like structure to the like? Because obviously, the ones where you're saying that it's like everything is semi-livert, yeah. Um, is it as simple as like a semi-literate and like not as a caterexample? Or is there like reason and rhyme to where the calendar example comes from that you could like? No, it's not flashed out that much. Yeah. Okay, so um, briefly review the Stone von Neumann theorem, which is like a very useful mathematical tool for studying the quippet hierarchy. For studying the quippet hierarchy. So, originally, it was a foundational result. The point was to unify matrix and wave mechanics because back in the day, there were two completely different seeming formalisms that both gave the right experimental answers. And everybody's wondering what's going on. And then someone, and then von Neumann said, like, actually, the same. They're describing the same theory. And what it roughly says is that any two representations of the canonical commutation relations are unitarily equivalent. Okay, so wave mechanics and matrix mechanics are describing the same thing, they're unitarily equivalent. Thing the utility equivalent. And it turns out to actually be perfectly suited to systematically studying the Clifford hierarchy. So I developed that idea in this paper in 2020. I'll briefly mention some of the results. It was also like kind of implicitly observed by Beigey and Schor, at least in the qubit third level case, but it turns out it's actually really good for a study of all levels and any number, any dimension. So just to review what it says, if the canonical commutation relations, at least in the qubit case, says that if you have two gates, Two gates and they're both ordered D, and they have the computation relation that moving one past the other introduces a phase factor of omega, then that means that there is a gate that says that those two u and v are conjugates of z and x. So if I took z and x and I conjugated them by the same gate g, they would also satisfy the same commutation relation because z and x do. But this is telling you the converse. That if you have u and v that satisfy these algebraic relations, then they must have come from conjugates. Then they must have come from conjugates of Z and X. Okay, so what that tells you is that there's actually a bijection between unitaries, mod phase, and pairs U and B that satisfy these relations. And it turns out to study gates of the Clipper hierarchy, it's actually much better to study them through their conjugates. Okay, because G is k level if and only if their conjugates generate k minus once level gates. So you can basically study the Klippenharky inductively. Yeah. So are there any restrictions on what old mega can mean? Yeah, because if. Or beggar can be, yeah, mega is a primary root of detailed unity. Oh, usually, yeah, yeah, okay. Any other questions? And there's no restriction on D, right? Uh, I think uh, D might have to be odd or no, actually, no, I think there's no restrictions on D. At least, but there's nothing on D. Yeah, I'm don't quote me, but uh, definitely works with Prime, obviously. Uh, but I don't know if there's actually any restrictions for this one. Okay, so yeah, in this paper, 2020 paper, I used the Stone-Vonnegun theorem to generate the clipper harvesting. So, before they were kind of scattered examples here and there in the literature, but it turns out you can use this idea to find an algorithm that generates all of them. You can also, it gives you a theoretical way of generating all of them so that if you want to do a classification theorem, if you classify the previous level, you can classify the next level. Okay. There's also a much simpler definition or theorem. Simpler definition or theorem for recognizing and diagonalizing semi-clifford gates. So remember the definition of semi-clifford gates is there exists Cliffords C1 and C2, such that G is diagonal when you multiply C1, D, C2. But that's like, you know, you kind of have to search over all Cliffords, pairs of Cliffords, I guess, if you wanted to use that naively. But it turns out there's actually a much simpler criterion. Also proves that all third-level gates of one qubit are semi-clifford. Okay, so there's a very simple group theoretic, you know, just Group theoretic, you know, just using the order of groups, kind of a simple proof to establish this for one quet, but the two que dit case doesn't work anymore. So that gets much more complicated. So I proved that all third level gates of two Qtrits, so I restricted the dimension to D, there's Honey Clifford, but that used a computer proof that I basically checked over all the cutrids because the equations are so complicated that, but I wanted to check if this conjecture was true, so I used computer. And so yeah, all third levels. So basically, I wanted to extend that theorem about one or two. That theorem about one or two Q dits, sorry, one or two qubits every third level gate is semi-Clifford. Want to extend that to Q dits? So managed to get up to one Q dit and D equals three for this two Q dit case, but the equation is too complicated. So that's what I did. And this recent work, yeah. Quick question. Do you have any complicated example of the third one for non-pine deals where there are no semi-clipboards? No. Sometimes you can use something called Smith normal form on basically doing stuff with non-pine deals. Basically, doing stuff with non-product for QBITs. So that's how we can catch up. Yeah. Yeah. So the new tool that was required to establish this case for arbitrary B. Well, the thing is you can't use computer proofs, right? Because now we're trying to do infinitely many dimensions at once. So obviously you can't just search over infinitely like every case by infinitely many dimensions. So I wanted to do one calculation that would work for all dimensions simultaneously. And that turned out to be a bit tricky and requires like algebraic geometry. So in case you Like algebraic geometry. So, in case you've definitely learned algebraic geometry, but maybe not in those words, the idea is to study algebra as in like polynomial equations via geometry and vice versa. So, you know, you study parabolas, right? So, parabola is a geometric shape, but it's also an equation, algebraic equation, right? So, you can study the equation and the shape by each other. Okay, and the second shape is like a quintic, the solution to a quintic equation. So, the idea is to understand the space of solutions of a family of polynomial equations using either our. Equations using either algebra, they're polynomial equations, or geometry, which is studying the space itself. Okay, so this geometric reasoning turns out to be also very useful, even for studying persistence of polynomials. The key theorem in algebraic geometry is Hilbert's Nell-Stellensatz, which says that there's a bijective correspondence between radical ideals, which are certain algebraic structures involving polynomials, and algebraic sets, which are basically like these kinds of shapes that come from solution sets of polynomials. From solution sensor polynomials. Okay, so very quick overview of algebraic geometry. Then I'll talk about the result and a little bit of how we achieved it. Yeah, so basically, the idea, okay, so the theorem is for any odd prime dimension D, every two-qubit third level gate is semi-clifford. So that basically now finishes the extension of Zhen Chen Chuang from the qubit case to the cubic case. And the idea is to characterize third level gates, the set of third level gates, and the set of third level level gates. The set of third-level gates and the set of semi-clippered third-level gates using polynomial equations over Zd. So previously they had been defined in terms of like these conditioned involved unitaries, right? Whether they you could express them as a certain product of Cliffords and diagonals or how they conjugated Paoli's two. Okay, but it turns out that you can change basically using like the like ZD formalism, you know. Like Z D formalism, you know, like Pauli's are bit strings or bit strings, Cliffords are symplectic matrices. So if you convert to that picture, then you can turn it everything into conditions about polynomials over Z D. And we want to show that for each D, these two sets of solutions coincide, right? That they're, so like we have one set of polynomial equations that describes their level gate, so that describes a shape, okay? The another, the subset of them. Another subset of them that are also third level, that's another shape. I'll just show that these two shapes are the same thing. Okay. But it's tricky because that kind of reasoning only works if you fix the dimension. So if you want to do all the dimensions at once, then you need to use Roto Dee theory of schemes. So a scheme is just a very, very abstract version of like those parabolas, where you don't necessarily assume that you're working over a field, that your solution sets could be in a commuted ring. Okay, it's but you can be. But anyway, it involves a lot of category theory and probably takes like a year-long graduate class to really fully grasp this definition. So that's why I collaborated with someone who does understand it. Okay, so the basic idea is, so suppose we have some third level gate. So we know that it conjugates a Pauli to Clifford. So if I conjugate, so this is a two-cut gate, right? So if I conjugate all the basic Pauly's, Z1, X1, Z2, X2. One x1 z2 x2, these are all Cliffords. Okay, so Cliffords have this symplectic representation, right? The representation of the symplectic group. So it turns out that you can conjugate G by, sorry, you can multiply G by Cliffords so that once you conjugate all these basic Paulis, the resulting Cliffords are very, have a nice simple form where they're basically a diagonal Clifford times a Pauli, which means that. Which means that we've now described G in terms of discrete data over Z D, right? So by simultaneously rotating all of them into this nice form, the third level gate G just defines a bunch of variables. So I guess it's three for D and two each for the pallies. So that's seven. So four times seven is 28, right? So 28 variables. So to describe G, we need 28 variables over Z D once we've made this reduction where they're all simplified. Production where they're all simplified. Okay. And, but not every 28-length string of tuples describes their level gate, right? So these are the equations that tell you when they are third level. Okay, I'm not going to get into them. They're very complicated. There's actually like matrix and vector equations. There's actually like, I don't remember, like 10, 17 equations, something like that, when you actually expand them all out. But basically what they're saying is that if you have a bunch of these Cliffords. A bunch of these Cliffords described by tuples like this, then they have the right computation relations if these equations hold. Okay, and by the snow-when-Newman theorem, that means they came from a third-level gate. Okay, so these equations tell you that it's third level because they satisfy the correct computation relations. These equations tell you that they're semi-clifford, okay, which is quite surprising that you can characterize semi-cliffordness in terms of polynomial equations, because as I mentioned, it was originally defined in terms of C1, D, C2. Yeah, uh, just for Too, yeah, uh, just for my clarity, the equation on the last page was quite literally just this symplectic inner product, essentially. Is that right? Uh, no, uh, because it's um you got the matrix in there, so it's not quite yeah, I mean, it's basically if you took a bunch of like cliffords like this and asked what it means for them to have the right computation relation, it oils down to these equations. Uh, okay, yeah, so these equations uh tell you. So, these equations tell you whether the third level gate in the form that I mentioned earlier is semi-Clifford. Won't get too much into the details of why that works, but it is surprising that you can characterize semi-Clifford gates in terms of polynomial equations. So now we basically have one family of polynomial equations that describe third-level gates and a second that tells you when those third-level gates are semi-clifford. So we want to show the two schemes that those give rise to coincide. Give rise to coincide. So, if we fix d, what we want to show is that the two radical ideals that correspond to those algebraic sets are the same because that would tell you that the shape is the same. But if we want to do that for all D, we have to work at the level of schemes. So we work over, instead of working over Z D, we work over Z, interpret these equations as being over Z, a join one half, because that kind of encompasses all the cases at once. And then we reduce. Once. And then we reduce those schemes modulo D, and that gives us what we want for every D. So in principle, you could check the equivalence of these schemes using a computer algebra system like Magma to do like a Grodner basis calculation. But in principle, these equations are way, way too complex for a computer to handle because there's so many equations and there's so many variables you can't just plug into a computer. So that's where a lot of the mathematical arguments came in. Some of the mathematical arguments came in where we uh that I won't really get into, but we had to do a bunch of you know reductions to get it down to a place where a computer can actually do the calculation, okay. Um, oh yeah, and um yeah, so the significance, uh, my interpretation is that, yeah, you get a lot more, more efficient paths achieving universal quantum computation, right? So the T is special because it's semi-clifford, and that's why we use it a lot. But also, I'm curious of wondering, I'm knowing that like many there are many other options in terms of There are many other options in terms of third-level gates that have these efficient magic states. Can that reduce your compilation length or something? Instead of using T, if you used any, if you had access to all these other third-level gates, could you make shorter words if you're trying to decompose over instead of cliff plus D, cliff plus third level, right now knowing that they're all semi-cliffered? Yeah, you also get a better structural understanding of the magic states if you're interested in theoretical study of common advantage. So I was originally motivated by. So I was originally motivated by this result that I had a while ago where I was building on this work of Mark about magic states being contextual. And I was curious if like the best magic states exhibited like this extreme form of logical contextuality. And yeah, it's true. But I proved it for diagonal third level gate magic states. And this theorem now shows that those actually allow you to do any third level gate, whether it's semi-click. Any third-level gate, whether it's semi-clifford or not. I mean, they're also Clifford. Anyway, and also, I think the significant thing is that it's the first time we've used tools like schemes to answer a question in quantum information. And I think that this set of tools could actually be more broadly applied, right? Because basically any question that you can phrase in terms of showing the solution sets of two polynomial equations coincide for all D, right? So I think if you're interested in Q dits, there's an air correction of Q dits that all is taking place, the stabilizer formalism. Taking place since the stabilizer formalism. So, I think this could be useful for answering lots of other questions. And also, it also shows that things that you wouldn't necessarily think that you can phrase in terms of polynomial equations actually can do. So, I think the class of questions is actually bigger than you expect. So, yeah, so I have five minutes left. So, I just wanted to briefly mention some other work that I think might also be interesting to people. Can I ask a question for you about it? The way you were describing it, it sounded like you had these two shapes. You had these two shapes of solution sets, and you said they were both the same. So that was how the principal was. But then it also seemed like the same thing is, was it the same thing to say that just the step two constraints are just redundant? Yeah, okay, thanks. Yeah. Okay. So I originally thought the proof was going to go by deriving those equations by like manipulating the first set of equations, but it's not really easy, obvious, or possible. And I did ask like Yamidin if like. Did ask like Yamidin if, like, having established the equivalence, whether we could also go through the magma proof and construct like the derivation. And it might be possible, but it's also just a huge amount of work. So that's another interesting question. Like, you could be should technically be able to derive it directly, I guess, by substituting this equation to that and dividing by this and blah, blah, blah. But yes, yeah. Have you looked at adapting what the equations look like when you extended like these generalized any preferred operators? Oh, yeah. Operators because there's oh, yeah, no, I haven't talked about, I haven't thought about generalizing. Okay, yeah, yeah, you extended it to prime powers. Uh, I have not. Uh, the scheme stuff, I think, relies on being odd, sorry, uh, prime, because you're reducing modulo prime. Uh, but I also, I do think we can get around it, uh, but yeah, I haven't really looked into non-prime dimensions, so I guess I don't even know if it's true or not, uh, but I, yeah, so I shouldn't comment on it, yeah, okay. Comment on it. Yeah. Okay. Okay. So this is a complex something a bit different. So this is like more about some classical algorithms that I think would be useful potentially in circuit optimization gate synthesis. This is joint work with Wilfred and my student Ming. Okay, so the background is, you know, we have stabilized states and Clifford gates. So they have multiple descriptions, right? So they have standard descriptions, which are exponentially long or big in the number of qubits, right? The state vector. Number of qubits, right? The state vector is two to the n length, matrices are two to the n by two to the n. But if they're from the stabilizer formalism, they also have these compact polynomially sized descriptions in terms of lists of polys that are stabilizer generators or stabilize the tableau. The question we asked in this paper was, how can we, if it's given a candidate description, for example, a state vector of like to the n, how quickly can we verify that it's a valid stabilized state, for example, or how quickly can we verify that a given Or, how quickly can we verify that a given matrix is Clifford? Or how can we interconvert between them? So, example, if we are given a state vector, how quickly can I extract its list of stabilizer generators? Or if I'm given a Clifford matrix, how quickly can I extract its stabilizer tableau, which is like the list of palis that you get by conjugating ZI and XI. So we just, these are kind of core functions, I think, that have a lot of different uses. So we were motivated by them because I was doing numerical experiments where I was like. Because I was doing numerical experiments where I was like, you know, just generating loads of vectors. I wanted to check that they were all stabilized states to test some conjecture. But I think they have potentially other uses, like for example, in classical simulation algorithms, which all build upon, a lot of them build upon Gautam and nil. So in those situations, the compact descriptions are important, but a lot of them extend to larger classes of operations. So they mix stabilizer and non-stabilizer components. So in those at the interfaces, that's where you need to convert. Interfaces. That's where you need to convert quickly between stabilizer and non-stabilizer descriptions of things. I should also mention that a bunch of these tasks, not all of them, are already in popular packages like STIM and EPECJSKIT. And all of our versions are asymptotically faster because we work directly with the mathematical descriptions in question. Yeah, and also I'm curious if these could be useful engagement assists. These could be useful in engagement assist and circuit optimization. I mean, I know of one application already, so Vadim has already used it in one of his paper, the Barnes-Wall Lattice paper, to give an algorithm for synthesizing different unit isometries. So I think there are probably other applications within this domain that these algorithms could be useful for. So, briefly, there's three ways of specifying and stabilizing the state up to phase. Stabilize the state up to phase. You can give a complex vector of amplitudes, so that's exponentially sized. You can use a quadratic form description due to Dehane and Damur. Okay, that's a polynomial size because you just have to give the quadratic form matrix and the basis vectors for the affine space that support. Or you can give a list of stabilized generators. So a bunch of bit strings that describe the Pallis that stabilize the stabilizer state. And there's two ways of specifying a Clifford gate of the phase. You can give a complex matrix, right? So that's. Complex matrix, right? So that's oh, capital N is two to the n, okay. So that's exponentially sized, and as a stabilizer tableau, which is a list of the Paulis, where if I conjugate Zi and Xi, I get a bunch of Paulis. Those also describe the Cliffogate of the phase. So this table here, I'll describe, I'll say what it means, but it summarizes basically the results in terms of the asymptotic efficiency gains over either the best known method, which was like in STIM or Qiskit, or if there didn't exist, then the group. Or if there didn't exist, then the brute force method that might give you Google the stack of change people are talking about. Or in some cases, there is no obvious method. So for the question mark, there is no obvious. So basically, A goes to B, means that the best known method has complexity A and our method has complexity B. If there is a question mark, that means there's no obvious method. Again, N capital N is exponential. So a lot of these have like, all of them have at least linear gains, which seem small. At least linear gains, which seem small, but if you're running it on like a session of millions of qubits, there's actually a very big difference, obviously. Also, the asymptotic complexity does kind of obscure a lot of the efficiency gains because the constants matter, the lower order terms matter. So in practice, these algorithms are orders of magnitude faster than the existing cases. So the thing, I guess, since I'm run out of time, I'll just mention. So, yeah, so the way this diagram works is like these are the The way this diagram works is like these are the different descriptions. So, C1 is the matrix description of a Clifford, C2 is the Tableau description of a method. So, the diagonal entries are verification. So, given a matrix, how do you verify it's a Clifford? Okay, that's the diagonals are verification tasks, and the off-diagonals are conversion tasks. So, given a matrix that you know is Clifford, how quickly can you extract a stabilizer topic? How quickly can you extract a stabilizer tableau? So, the root force way would be to conjugate Zi and Xi. But that is like extremely slow because matrix multiplication is slow and you have to do that for every, you know, for a bunch of palis. But we actually have a more than exponential speed up over STIMS version, which is actually better than brute force. And you'll notice, maybe you want to respond, but C1 matrix is N squared entries. matrix is n squared entries, right? Where, sorry, capital N squared, right, to the n by two to the n. And it turns out that if you want to extract a stabilizer tableau, you don't even have to look at all the entries. Okay, you can look at just the first column, and then you look at one entry from all the other columns that are labeled 25 rows two. So you look at the entire first column, and then you look at one entry from column two, one entry from column four, one entry from column eight. And then the first column tells you where it conjugates the Z I's to, and then the face. I is to and then the phase differences between the entries of the different columns tell you where it conjugates X I2. Okay, so yeah, basically you can extract the stabilizer tableau of a Clifford matrix in less time than it takes to look at the entire matrix. Yeah. You can probably say like the kind of asymptotics of the obviously constants, I'm just curious, have you benchmarked results in the paper? Just we not yet because I should also mention we have Python implementations. I should also mention we have Python implementations, so they're on GitHub already. We didn't do benchmarks yet because, like, you know, IBM and Google have people that can do it in C ⁇. And so it wouldn't necessarily be a fair comparison. Although I will say that we did implement some of them in C ⁇, and they are like thousands of times faster for like small number of qubits. So I guess at some point, maybe we'll update that. I mean, I think we are going to finish the C ⁇  in the middle. Update that. I mean, I think we are going to finish the C implementations and then release them because I do think there would be demand for like our original idea was just like put them out there, show the asymptotic speed up, and then if people want to use them, they can implement them. If they really need super speed, then they can implement them on their own in C ⁇. But we just figured we'll just do it ourselves, I guess. So that's forthcomes. Yeah. I was going to say, you should just email Craig. Craig's really open to incorporating like other people's code into their repo. Other people's code into their repo. And the community, the error correction community, which I'm sure is unfamiliar with Uber, would almost certainly love to have all of these fastwork algorithms. Okay, I had talked to Craig. When the first version was out, this newer version has like more algorithms and all we sped up a bunch of them. So now every, so there's like 10 new algorithms. They all have asymptotic speedups over existing versions. I don't know. I put him as a reviewer for the submission, so hopefully they chose him. But yeah, maybe you said this, but what are the diagonal entries that are just like n squared n damage? Oh, these gray ones. Oh, yeah. Sorry. These are trivial ones where, because like they don't, if they don't involve a capital N, then it's already polynomial in the number of qubits. So for example, if you want to Want to check whether F3 is just a list of polygenerators, right? So if you're given a list of polygenerators, all you have to do is check if they commute, right? So that is like, and already given the spit strings, all you do is compute the selected product. So there's not really any way you could speed up those. So the ones that don't involve a capital N, they already have trivial, like the most obvious thing you can do is already in ZME class. So couldn't really improve on those. But all the other ones that involve a capital N, we gave asymptotic speedups for. Yep. Sorry, good question. question is like uh some what some what is it like the quality comparison or what is cf2 to c2 oh no it's uh checking again these are the ones i mean some of them are just there for completeness because i don't want to leave blank places in the table but given a tableau if if you want to verify it's a tableau you just have to check that the z i things commute the x five tableau yeah so the diagonal entries are verification tasks and obviously verifying a tableau is trivial verifying a list of stabilized generators is trivial A list state by the generators is trivial. That's why I kind of grayed out. You can only see it, I guess, on the screen. I thought it was like comparing with two ID. No, no, no. No, but you have to look at all the entries as well. Yes, you know, total check-in. Another one I'll mention that's quite nice is if you're given the quadratic form of a stabilizer state and you want to convert it into a state vector, so the state, the quadratic. State vector, so the state the quadratic form, like the Dehane de Moore form of the stabilized state, if you want to convert it into a stabilized state, it would seem that the only way to do that is to evaluate the quadratic form for every amplitude to get the amplitude. And that requires evaluating a quadratic form requires quadratic time in the number of variables, right? But it turns out that you could actually do get too faster than that by choosing the order in which you evaluate the quadratic form. So if you use the gray code, which goes through Use the gray code which goes through the bit strings by flipping one bit at a time. If you go through that order, you don't actually have to evaluate the quadratic form for every amplitude, you just have to update the quadratic form, and that requires computing a linear function. So you can actually shave off a factor of little n by instead of calculating the quadratic form fresh every time by updating the previous version if you go through in the right order. So yeah, we did, that was an unexpected like, you know. That was an unexpected, like you know, something that you can do, you know, shave off a factor of the number of qubits for that kind of conversion. So, yeah. I might just ask that any other questions go into the coffee break just because you might get into it a bit. Sorry, Nadu. So if there were anything, Nature.