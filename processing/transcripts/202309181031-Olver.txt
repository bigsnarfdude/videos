Really great to be back. I'd forgotten just how beautiful it is here. So this is some joint work with Nathan Klein, who is for one year at the IAS. To make one last minute change, because previously I had some sort of palm trees on the side, and I decided this would be more difficult. Okay, so what is the So, what is this about? So, what are thin trees? Nothing to do with the thin components from Virginia's talk, no connection. So, what is a thin trees? Firstly, so we're given some graph G, so here it's the complete graph, the only graph, and we say a spanning tree T is alpha thin if across any cut of the graph Cut of the graph, the number of edges of t crossing that cut is at most an alpha fraction of all of the edges crossing that cut. So this example on the left here are two spanning trees of the complete graph. This sort of star and then like a long Hamiltonian path. So this one, well, so alpha here is, you know, alpha should be less than one. You know, alpha should be less than one for this to be interesting. This is always true for alpha equal to one. And here, you cannot pick alpha to be anything less than one, because this cut here, the tree t, has all of the edges plus the thick cut. So on the left, this is a one-thin tree, but it's not anything better, and what we want is small values. Whereas what happens with this sort of Hamiltonian path on the right, I mean, you have to think a bit harder, but it turns out that this isn't roughly all. This is roughly order one of a thin, order one of an n thin. In particular, it turns out the sort of most important cuts here are sort of, if I look at these singleton cuts here, it's two edges out of n. That turns out to be the worst cut. So, yeah, so this is an order one of an nth in tree. And that's, of course, best possible in the sense that, well, I mean, here I'm n connected. Here I'm n-connected, but my tree, spanning tree must contain at least one edge crossing every cut. So the best you could hope for is order one over the connectivity of the graph. And there's a conjecture, which are called the strong symmetry conjectures, due to, well, this is a strengthening of a conjecture due to Godin, which says that every kid-connected graph, you can, up to constant factors, achieve this lower bound of order one. This lower bound of order one of a k at entry. So, again, you cannot possibly hope to do better than this, but can you always achieve this spatter? And his original conjecture is a slip, well, a weaker form of this. His conjecture is that there's a function f which goes to zero as k goes to infinity, such that every kh connected graph has. That every kh connect graph has an f of k thin tree. So as the connectivity increases, at least the thinness you can achieve is going towards zero. Here, this is the same thing, but for f of k equal to one over k. Stop me if there are any questions about this definition of injury. So, I mean, I would say I think this is a nice conjecture by itself, just as a conjecture in graph theory, sort of a question about spanning trees and grass. It sort of came to prominence because it had some implications for other problems. So first, Godin's original, one of his original motivations was to an implication to a conjecture. An implication to a conjecture of Charge on low-way zero flows. And then more in the in our community was this paper by or et al. on ATSP. And they showed that, oh, okay, if you could constructively find such thin trees, then you would get a constant factor approximation for atheism. Of course. Of course, in fact, both of these conjectures have, I mean, both of these questions have been since been resolved. So we can have a constant factor approximation for ATSP using completely different methods. It would still be very interesting if we could obtain something through this approach. And let me also mention, there's a very nice conjecture due to David Pritchard, and that is a sort of a And that is a sort of a weak, well, it's weaker than this symmetry conjecture. So his conjecture is basically if, let me remember it, yeah, so if I take, I have some graph with connectivity k. This conjecture is you can find a spanning tree to remove from the graph, such that what's left, the connectivity, only decreases by some constant. Constant. And that's completely open. We have no idea. Monster multiplicatively, constantly additively. Additively, in this case. Yeah. And in fact, the best we know is from Nash Williams, which says, okay, if I take, I have k over 2 spanning trees that pack into the graph. So if I pick one from there, I will have connectivity k over 2 minus 1, essentially. That's the best we know. And what would follow from this would be the connectivity would be 2. This would be the connectivity we produce by an additive constant. All right. And then, sort of from more of an optimization perspective, again, if you had a, I mean, this is a sort of a less direct connection because there's sort of algorithmic questions involved, but you could ask the algorithmic question of given a spanning tree, can I find a spanning tree where certain constraints on how many times you cross cuts in the graph are. Many times you cross cuts in the graph a satisfy. This will give you very strong results of this one. I'll come back to this sort of interpretation. So I won't go through all of this, all the previous work, just briefly say what we do know. So we do know constructively, and this was in the original paper by Asad Poroto. Paper by Assad Poroto on ATSP. It's sort of there's this order 1 over k multiplied by something depending on n. In this case, it's log n over log1. That's constructive. And then using sort of very more spectral methods, current best we know is still something, you know, order 1 of a k multiplied by something depending on n, in this case, poly log log n. Poly log log n. So that's exponentially better than this. This is existential. But we don't, essentially, we don't have anything without any dependence on n. And okay, there are sort of certain special classes of graphs where we know it's true. I'm not going to. So a different direction we could go in terms of maybe finding something more Of maybe finding something more tractable is to say, okay, instead of, you know, the slinty conjecture is a question about every single cut in the graph. I mean, that makes things challenging for a couple of reasons. One of them is it's not even that clear, or not clear at all, how to even certify things. They give you a thin tree, and they say, okay, I promise you this is a thin tree, but how do I convince you that it really is? Connections to spas is cut. An easier question would be: suppose I give you an explicit list of cuts and I say, okay, I want you to be thin with respect to these cuts. So I will require this condition that you only have an alpha in order to 1 over k fraction of the edges across the cut, only for the cuts in my list of cuts. It's a quickly easier question, and now I can check it easily if I give it free. If I allow time proportionals that. Time proportional to the number of these costs. This we still don't, we don't know anything here either. You can say something if you have sort of, if each of the cuts in your family have many edges crossing them, like much more than k, then sort of Chernoff-Bound type arguments can be applied and then things work. Uh but you need sort of really lots of edges across across the cousin. Across the cuts of this family. Otherwise, yeah, we don't know this. What about if we put some structure on the family of cuts? So, a very, very special structure would be to suppose I look only at the singleton cuts in the graph. So this is degree bounds, right? So I'm saying, okay, there's some bound on how many edges I'm going to pick adjacent to each vertex. I have a degree bound for each vertex. And this And this we can do. Much stronger results are known, so that you can violate the best possible bound by an additive one. We'll come back to that a bit later. But here it's true. You can also do minimum cost versions of this, where you say, okay, I want the cheapest tr tree satisf you know you you would like your ch you know, if you have costs on the edges and you would like your tree satisfying these pounds to be cheap. Satisfying these bounds to be cheap. That can also be done. Another case we can do is a chain of cuts. So I just already have a collection of cuts where each set is contained in the previous one, like in this picture. And there, some work with Rico, we showed that this can be done. And also there is a minimum cost version of this too. Version of this too. And then, you know, I think a very natural next case to think about would be a laminar family of cuts. So that generalizes both the singleton cuts, it generalizes the chain setting. Can we show that this symmetry conjecture holds for such a path? I mean, it's not quite. I mean, it's not quite the right setting, but just I wanted to mention this as a result by Nikhil and Jochen and Britta and others, which gives sort of an additive log n on the number of times you press an edge. But again, that doesn't sort of translate to a useful multiplicative guarantee here unless you have sort of very many edges across each container. But other than that, we didn't have results for this, and that's the main result of our work. So we showed that it's true. So if you have a laminar collection of cuts, then there is a order one of a k thin tree with respect to those cuts. The theorem statement here, do stop me. Statement here, do stop me. And let me rephrase this more sort of algorithmically. So here this turns out to be completely equivalent statement of this strong symmetry conjecture. I give you a point x in the spanning tree polytope of G. Then there is a tree t. So x is like a sort of fractional point, and you want to round. Like a sort of fractional point, and you want to round that to an integral point. An integral point being an actual spanning tree, where on each cut, and maybe each cut in your explicit list of cuts, you're only a constant factor worse than your fractional study point. So it's really a question about rounding. I want to round sort of the natural LP in some sense to an integral solution while only using a constant factor across every cut. Using a constant factor across every cut or every cut in my list. And why is this equivalent? Essentially, because if you just take the point 2 over k for every single edge, this is, well, it might be, it'll be in the dominant of the spanning tree polytope. This will be above some point in the spanning tree polytope. And that's sort of the connection. So with that choice, then this bound here is roughly 1 of a k taxes. Roughly 1 over k times the seismic. So here's our theorem again in this language. So given a point x in the spanning tree polytope in a lambda family of cuts, we can find a spanning tree t which, let's focus on this. So across every cut in the laminar family, we're only a constant 22 times larger than the fractional value that x put across the cut. We also achieve an approximate. We also achieve an approximate minimum cost result. We have costs on the edges will be at most five times the cost of the original point cost. And this is where is clear edge colour you take now? In this statement. Where does it so you said before the result has I saw or where did K go here? Uh there's no K explicitly here. There's no k explicitly here. It's hidden here, right? So if I wanted to turn this, if I wanted to connect to the previous version, the sort of relevant choice of x is 2 over k, where k is the edge connected to the other graph. That will be in the dominant of the spanning tree polytope. So as k gets bigger, I can choose an x which is uniformly smaller on every single edge. So in this version, I don't need to say anything. Version, you don't. I don't need to say anything about k. Does that make sense? Can the general case be reduced to laminar family with the login over log login loss? Uh some of the previous response might have used perhaps not that I know of. I haven't thought about it, but yeah. I haven't thought about it, but yeah. Good question. Okay, so that's the result, and I'll say a little bit about how we prove it. So our approach is based on iterative relaxation. Iterative relaxation. So I think most of you will have seen this method. If not, the book by Nafchi and others is recommended. Nafi, Ravi, and Lahid. Let me just sort of, I mean, I'm really not going to go through it at all carefully, but just to sort of remind us of how this works. So let's look at the degree-bounded problem. So the singleton case. Bounded problem, so the singleton case, like all these cuts are singletons. Here's a very nice theorem by Lucci and Moig. So given a point x in the spanding tree polytope, there is a spanding tree t, cost of t is at most the cost of x, and in this case, you get an additive guarantee rather than multiplicative, so a roundup of the fractional value plus one. So and here's their algorithm. And here's their algorithm. So I'm going to start with sort of T is empty, nothing. And R is V, and R is going to represent somehow a set of constraints that we have, like which nodes we are concerned about the degree bound. Beginning we're concerned about all the degree bounds. Bv is just going to be the round up of this x value, so that is our upper bound, and we'll try and achieve this value plus one for all of our degree rebounds. For all of our degree bounds. And now, what do they do? So, as long as t is not yet a spanning tree, pick an extreme point solution x star to the following. So, we pick a point in the spanning tree polytope satisfying the constraints only for the nodes in the set R. Initially, this is all the nodes. Then, if any of these x values are 1, you just fix them to 1 forever. So they will no longer be sort of So they will no longer be sort of variables, essentially, they're just things. And you'll include this in your tree. If it's zero, you delete the edge completely from the graph, never look at it again. And then the third one is, well, so if this happens, we've sort of made progress. We can sort of shrink our graph and things have gotten a bit smaller. But what if none of these two things can happen? So our extreme point solution is. So, our extreme point solution is fractional everywhere. What they show is that you will be able to apply this third step, which is find some node in the current set R where the x value is actually very close to just the total number of edges adjacent to this. So, what this says is basically even if I pick every single edge around the vertex V, I will only violate the constraint. I will only violate the constraint by 1. This is a fractional violation strictly less than 2. bv is an integer, so integral violation of p plus 1, and so life is good. And then you just keep repeating this process. The hard work is to show that this third step really can be done whenever everything is completely punched. That's sort of the framework. So we make progress by finding a constraint to drop and then resolve some Resolve some somehow. So we want to do that. We want to use this method. And there's a problem. And that problem, I mean, is the following. So if we take our results, there's a very natural matroidal generalization of those results. It would be, instead of the spanning tree polytope here, you just have some other matroid on the ground set of edges. Some other matroid on the ground set of edges. Your point x is in the base polytope of this matrix. And you want to find a basis where again you're within a constant path. That would be very natural. Unfortunately, it's false. And this is something in the Rico we observed even for this case of chains and for M being a partition matroid, this cannot be done. This cannot be done. There is no such result. There's a log n of a log log n lower bound. So, why is that an issue for this plan of using iterative relaxation? The issue is that, more or less, I mean this is not a precise statement, that essentially when you use this method, you generally are not going to be using things that are specific to the spanning tree polytoke. They tend to access that through sort of fairly uh sort of generic Matroid properties. Sort of generic matroid properties. So, particular things like: if you look at the type constraints in a matroid, you can sort of choose them to be a chain. Like, that's sort of a property that gets heavily used. Generally speaking, maybe there are some minor exceptions, but they don't use the structure of spanning sheet polygons, except in particular. And so, this is a problem. The fact that the Matroy version is not true is an issue. So, how we get around this is with a two-step process. So, we will find a special class of extreme points for which this iterative relaxation process works. There'll be some extra property on the point x to start with that we will exploit. And this will work for. And this will work for any matrix. So, this iterative relaxation part of our algorithm will work for any matrix. But then, only for spanning trees, we will show how to sort of take a general instance of our problem and reduce to this special subclass. And that will only work for spanning trees. And this will have nothing to do with the interinter relaxation. And so, let me tell you the definition of. The definition of this special property. So I'll explain it in a couple of ways. But okay, so what is the definition? So we've given our laminar family of constraints L. We say our point X, this is the base polytope, just to make sure this is really the base polytope. Not the independence polytope, so the convex combination of all bases of the matrix. At point X, we'll say it's. At point X, we'll say it's L aligned if, for every set S in the laminar family, if you restrict just to the ground set of E of S, all the edges inside of S, you just restrict to that, you restrict the matri to that, you restrict the point X to this. Your restricted point X is in the base polytope of this restricted matrix. Let me say that again, and also specifically for the And also, specifically for the Steidree polycurses. So, what does this look like? So, we have a laminatory. Yes? Laminath of nodes. And the way we can kind of construct a point X that is L aligned, you can think of it as follows. Start at sort of the bottom, like some. At sort of the bottom, like some leaf in the lambda family, a minimal set in the laminar family. And in that set, let's assume all these sets are connected, that turns out to be without loss, pick some point in the spinning tree polytope of this thing. So I do that. I pick a point here that's a in the in the Spanish polytechnic. In the Spanish polytope of this set, and the same for all of these minimal sets. And now just imagine contracting each of these. And now pick a point in the spanning tree polytope of this set where these things contract. And just do that repeatedly. So it's basically a completely separate choice in each of these sub-problems here. That's generically how you construct an L-line point. And so, yeah, as I said, we show that what we show is that if I have a, so we want to reduce to this case. So in general, when I give you an instance of this problem and you solve it, you get your fractional point x, your optimal fractional point x, it will not have this property at all. There will be no reason why these sets that we're interested in. These sets that we're interested in are sort of somehow within the Spanish political context. Instead, what we do is we show that, so given an arbitrary point x and a lame family L, we can find a new point x prime and a new lamina family L prime, where x prime is L prime aligned, so we have the property that we want. And if we solve the new instance, that implies up to a constant. Instance, that implies up to a constant factor that we've solved the original instance. Not going to explain how we do this, but yeah, and I mean, this family L prime is obtained by, in some sense, splitting up the sets in the laminar family L. Then, as I said, once we have this property, now we apply it, iterative relaxation. And this part, I mean, we only need it for the I mean, we only need it for the Spanish repo, the graphic metric for our main result, but it will work for any matrix. Okay, I think I won't go through this slide. I mean, I could tell you a little bit about how we exploit this colour line property in the analysis, but it's sort of a bit more technical and probably needs. Technical and probably needs I've seen uh a few of these iterative relaxation results uh for me to sort of give you the right context. So in the interest of time, I'll skip that. Um but I'll just just say one thing. We use, in the end, it's sort of quite simple what we use. We don't use like any complicated fact. What ends up being crucial is that if you look at this picture, so I have a This picture, so I have a set S and T in the Lamina family. What we will obtain from the fact that we are L aligned is that if I look at the X weight of edges that are inside of T but not inside of S, so if I contract S, look at the edges that you see inside of T, the X weight of those edges is integral because this is in the spanning tree polyto, and this is in the span. And this is in the spanning tree polytope. So it's the difference of two integral values. That's actually the only thing we use. So it's very little that we need. So let me just quickly mention a few open questions. So yeah, so obviously the main question is this of any relevance to the full conjecture? We don't know. I mean, that would be great. I mean, laminar families sometimes come up in terms of context like. In terms of context, like if you solve an LP of some type, you might find that the type constraints are laminars. Even, yeah, it might be hopeful that one could maybe use this for some of the applications without necessarily proving the full synthetic conjecture. So one apply this somehow to help with ATSP for a different algorithm. Don't know. Our cost result is approximate in the sense that we achieved a factor of five times the cost effects. You can improve that to two plus epsilon if you're willing to lose a larger constant in the constraint violations. But we don't know how to sort of get rid of this approximation in the cost entirely. That comes from this reduction step. Then you can always ask to improve these constants. What I stated was 22, I think, in the constraint violation. 21 by something. Yeah, most of what we lose is in the reduction. The sort of iterative relaxation part is probably tight, I would say. Thanks a lot, that's it. Thanks so much. Thanks a lot, Neil, for the next talk. Are there questions? Is it easy to see that example? You said for general Metroid you use that log over log log? It's not that, no, it's not easy. So what it came from was in the chain case, we primarily had this in the paper as a counterexample to the question of could you achieve an additive constant in this? Constant in this chain case, and that sort of boils down in the end of the day to some of the same example. It's a somewhat tricky recursive construction. It's not a s it's not a super easy construction. So, going uh you know beyond laminar families, suppose I told you my set my collection of sets is the union of two laminar families. Yeah, so we've heard this question before. I think maybe I don't know if it's for me. It might have been someone else. I don't know. It's a good question. Yeah, I didn't really thought about it. That was a good question. I'm online. Oh, yes, sure. Um so if I give you an LLI point, do you do you know let's say you need to use use a multiplicative factor in the degree constraints? The degree constraints? So sorry, say it again. If you start with. If I give you an LLI point to start with, I mean, I know in your algorithm you use a multiplicative factor in the degree constructs, but do you know if it's necessary? I'm not certain. I think so, but I'm not certain. I'm not certain. I I seem to remember uh that we decided that that we couldn't get an additive there as well, again by somehow reducing to this to this low band example on this slide. But I'm not sure, I might be misremembering. I would have to check. Have you thought about space? I have not thought about directing. So you sort of, you mean you bound the number of edges coming in? Yeah, I haven't thought about that at all. Connecting back to Swami's question, the connection that the Kate in conjecture was just saying, okay, but I can give you this point that is 2 over k is in the dominant, and then I can reduce it. So potentially you could take. So potentially you could take such a construct such a point of Was L align to start with? I don't think so. I mean not I don't I don't think you could do that without sort of having to sort of change the point a lot. I'm not s sure, but I don't think I think it I think in general like you might have to sort of really make You might have to sort of really make big changes. I mean, also, I don't you can't keep the same lamina family when you sort of or sort of reduction to L aligned, you know, changes the laminar family. I think that's crucial as well. But we couldn't chart off that. Let's take a final question. Yeah, um I feel like it looks similar to like our previous routing in like many scents. So like is there some like relation or Is there some like relation or some like transformation? For example, we we can think of like uh bracket uh decomposition as like transformation arbitrary uh cut family into lamina family. Right, so yeah, I think it look okay. I would love to talk. I have no idea. I have not thought in that direction at all, but I'd be interested to talk about it. I have no idea. Yeah. Okay, I think it suggests to postpone further discussion to the endspace. Push the