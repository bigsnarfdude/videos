So, I'm going to talk about compatibility or finite type objects. So, this talk is based on an ongoing project with Benu Salvin On from NTU, Singapore, and Nazanu Tabila from Iran. It was interrupted by the pandemic. Okay, so I'll I'll start with some motivation and I'll talk about the first step beyond computational OMIDA, which is compatibility on bare space. And then I'll report some result computational higher type. So let me start with motivation. Start with motivation. It's very, very philosophical. So the question is: what is an algorithm or what is a computation? Well, for many people, for some people, it was emphatically answered by the work by Gregor Turing Church, Host, and many others in the 1930s. So isn't it? So, isn't it? The answer is algorithm is just a Turing machine. The computation is actually a computation done by Turing machine. So, therefore, it identifies always in this Turing program, so also. So, I guess only the issue is the set of natural numbers. This is widely accepted. Widely accepted. So it's become standard. So the answer is yes, indeed, it is the case. But how about computations beyond the natural numbers? So for example, let's ask the following follow-up question. What about the algorithm of real numbers or algorithm of domains other than electron numbers? By that, Numbers. By that, I mean not coded by natural numbers. So again, this is a well-studied, well-investigated area. Lots of people have worked on this. So it was also answered by many people. I'll list a few which are related to the handling tool. To what I'm going to talk about. So, for example, the TTE model, which is originally based on, it was based on Oracle 2 machine. So, since in the previous talk, many people asked what TTE stands for. So, TTE stands for type 2 theory of inductivity. I will give a more rigorous definition in a moment. In a moment. So, this is one of the models. The other model was proposed by Blue Schuvin Smell shorthand by BSS machine. So actually, the BSS machine is kind of register machine, which you can use to compute to do computation of rules. But real numbers are special. But uh, you remember is a special can be good, so and others like Cleanie and others are higher types, like Uthnic type Turing machine by Hampton and many people. Uh, so now what's the difference between the natural number and the other, the unnatural number? So the natural numbers, the different formulations, for example, Different formulations, for example, GÃ¶del's recursive function later becomes a partial recursive function, and Turing's Turing computable function, et cetera, gave rise to the same notion of computability. So it is indirectly showed that there's something intrinsic behind all these things. And furthermore, somehow it fits the intuition of working as coefficients. So there's a Uh, working mathematicians. So there's a church thesis which most people believe, although some people try to explore some other possibilities, but most people believe that the utility recomputable functions are exactly two year computable over natural numbers. Now, so I quote Goethe's paper in 1946, which just says this. Just say this the same point and it's better words. So he says the great importance of the concept of general recursiveness or curious compatibility is largely due to the fact that with this concept, one has for the first time succeeded in giving an absolute definition of an interesting epistemological notion. Logical notion, i.e., one not depend on formalism chosen. So the emphasis is absolute. So no matter what models you choose, they give you the same class. And Guerdo's paper is on the occasion of bicentennial of the Princeton University. So he uses as an introduction. He uses as an introduction, and he's looking for absolute definability or absolute provability. So, the absoluteness of compatibility serve as a good example. Okay, so now if we move on to other domains, there are competing notions of computability. Based on different schools of philosophical thought. Sought. Even on the same domain, like bare space or real numbers, there are different schools, for example, GTE and BSS. These are two main examples. And so, for example, in TTE, everything computable, every function computable is continuous. So in particular, in particular, So in particular, equality is between two real numbers is not computable. But for BSS, it sort of builds in the equality or less than. And it treats the ring numbers or the elements in the ring as an atom. So it can compute equality, but Compute equality, but on the other hand, to me in BSS, they don't consider a possibility in so whether it's a good thing or a bad thing. So you can see that they give two different class of computable functions based on the two notions. So the typical example is equality belong to is BSS computable. Is BSS computable but not TTE computable. On the other hand, exponential function is TTE computable but not BSS computable. This is because BSF's machine, at least as it is written, is aiming for computational rings. So it emphasizes computation like polynomials, symmetric sets, those things. Okay, so the main reason that there are so many ways of modeling computation, I believe, is this. Our natural numbers, the objects are very discrete. You can think of them as, say, think of three as three strokes, three, three things, very discrete, very Very discrete, very concrete, and you can manipulate mechanically. But if you go beyond a omega, then it is an infinite series or it's even worse, like a Cauchy equivalence class or Cauchy sequences. So the object itself is already infinite. Now, on the other hand, the algorithms somehow it has to be finite in whatever sense. So, if you want to have a reasonable computable model, we must balance these two messages either you change the definition of financier in a reasonable way, or you somehow, well, turn the infinite object into finite, like a USS machine. Although it is infinite, I assume my register can hold. I assume I register, I hold it, and I don't ask what it is. Okay, so now, so that's the introduction. Any questions? Now I want to move on to the second part, which is some work done before actually start about 10 years ago. About 10 years ago, before I remember. So we studied computability over bare space, which is the infinite sequence of natural numbers. And also we studied on this blackboard R. The definition of real numbers we define as equal. Defined as a closed class of Cauchy sequences. So, therefore, a single real number actually contains continuum elements in bare space, but they are all fascinating Cauchy sequences. So to many people, To many people, again, these two objects are isomorphic or it make no difference. But only when we try to formalize a reasonable complexity theory, we encounter lots of difficulties because let me say it in a very brief way. So, for bare space, Space, let's say if you want to add two sequences or multiply two sequences of natural numbers, it almost like components additional multiplication. So the actions are, can I say, local? So for example, if you look at the third digit, well, you only need to know more or less the third digital of the two input and then give you the third digital output. The third digital output. But on the other hand, if you look at this in Correspondent Cauchy sequences, somehow the carry or the action will be non-local. So in order to determine exactly the third digit, somehow you need to look forward and you don't know how far you need to move forward. So for this, somehow we find a way to To have a reasonable notion of computability, which is independent of representation. But somehow, if you study complexity theory and then the two notions, especially for Cauchy sequencing, you have to decide in a reasonably fast way what is the computation time. So you have some difficulty. you have some difficulty on but for this talk i will ignore the i'll choose a simple case the bare space so that i'll ignore the the the non-local issue so uh what we have done is uh we have two equivalent formulations on computability of over their space so the the two formulations one by um One by function schemes and the other by machines. So, this is try to mimic the classical definition of partial recursive functions on one hand and the tuning computable functions on the other hand. So, there's also a third recurrent formulation using lambda calculus, but somehow it is a little bit artificial, so I don't want to. So, I don't want to get into it. So, now I want to just give you the definition of the two formulations. So, first, bare space is omega to the omega, whose elements are infinite sequence of rational numbers of natural numbers. And we And we let's refer the elements of bare space as type one objects. To do computation, we also need the natural numbers or somehow organize the machinery. So the natural numbers are type zero objects. In general, we are going to consider the functions of mixed type, right? Of mixed type, right? So the input can be a few natural numbers, a few reals, and the output can be natural number, can be real number. But for the notation, no simplicity, let's just look at, let's just concentrate on the functions from bare space. Okay, so here's the first formulation. So, here's the first formulation, which is mimicking the partial recursive function over natural numbers. So, the class of partial recursive function over bare space is the smallest class C such that it contains some simple functions, basic functions called. So, the ABC are the usual. Functions are natural numbers, while the projection can be a mixed type, but it's very similar to the classical definition. The new functions added as basic functions are all the TT computable functions, which I will define in the next slide, and also we And also, we add the characteristic function on the zero sequence. So, in other words, we are able to detect whether an element is a zero element in that space is a zero sequence or not. Indirectly, equivalently, you can say you are able to determine ecology. So, we add in the ecology. add equality as the basic population. So we have to defend the Russian purpose. Now the second part is so these are the C's, right? So then we have to close on the some operations. So the C is close and the composition, well there are some small prints, but it's very natural. So we only replace real number by real number. So also. And then if it's close, And then it is closed on the primitive recursion and real operator, so the minimum and minimization. But for primitive recursion and minimization, you can only do it over discrete objects. So you can only do it for natural numbers. So but we are considering functions from mixed type to mixed type, so we can use the natural numbers to organize these outputs. So that's the definition of partial recursive functions. If you ignore the DME, the two red label, then this is exactly the classical partial recursive function over natural numbers. Now, I want to explain what is TT computable function. Again, in the previous talk, maybe this. Maybe this description is easier to understand. So the TT computer functions actually can be viewed by computed by an Oracle Turing machine. So an Oracle Turing machine can induce a functional from real number to real number. And the TP computer ones are those. So they're all continuous. But since we are defining things using function schemes, Many things using function schemes. So there's a version like this which avoids mentioning machines. It's just saying the TTE computer functions actually is a sort of continuous extension of a family of coherent type zero computer functions. I guess since I don't need to use these, I will not go through these. So there is a there is a one. There is a way to define TT computer function without motion in the machine, but the intuition is they are completed by the all the okay, so let's move on. Now, to many people, the zero test or the equality was an absolute non-computable object because the input was infinitely. Input was infinitely long, even when you scan through an input, it takes infinitely steps. So, that's not computable. But in order to give some justification, so let me give you some justifications. So, one is in any reasonable algorithm, this command. This command if then else is uh is essential, right? It appears probably so you have to do some boolean, how to say you have to determine the boolean value of something like true or false. So the simplest thing about real numbers is whether they are equal or not. So is this equal equality somehow there's a way to There's a way to do this with them. There are other reasons I'm going to tell you, but after I introduce machine. But to us, it seems that the true worry about including equality is if you add equality, it's almost like. Quality is almost like you add zero job. And then by some kind of iteration, it will explode. So I think the true worry was if you include this equality, although it looks innocent, but with iteration, it immediately brings you to compute all the hyper-semicles. So that's the but as you will see in this model, somehow. In this model, somehow by certain restrictions, including wealth equality, although it extends the computable set a little bit larger, but it is not explored to include the two moments. Yes, but it is, yeah, it is. So it is a this is a complete Taiwan. Complete pi one if you use it to compute natural index. So therefore, it is zero. Any other? Okay, so that's the first formulation using function schemes. Now I want to formulate it using machines. The picture is not complete because I don't want to draw all the arrows. But basically, since I have a But basically, since I'm a board here, the machine can be divided into two parts. The top part is a part to handle natural numbers. So this part is the usual Turing machine, is for natural numbers. And below this dotted line, it is what's happening in their space. So this is. In their space. So this is in their space M. So, okay, so maybe I draw the machine. So this is a Turing machine. And then here, to handle elements in bare space, you need a family of machines. But the information, the communication between the above the line and the below the line was Below the line was done in this way. So, this machine model, we call it, unfortunately, we call it master and slave. Some people said this is not too politically correct, but if you don't want, you can turn it upside down. So, the information flow is symmetric. So, it doesn't matter who is dominating here. Anyway, so. Anyway, so for the master to send a task for the slaves, he will write a code, which is a natural number, a code machine, and so that every slave will read from the code and do this more or less the same task. I'll say this in a moment. Now, so this is the information. Information from top to bottom. Now, to add back, we use zero tests. So supposedly somehow there is a tape which can hold an infinite sequence of natural numbers, hold an element of bare space, and then the And then the zero test command will magically return a Boolean value zero or one somewhere in between here, between time and Earth. And then the master, because he is a type zero guy, so he can only understand discrete things. So in this way, he will obtain the information of what's happening on the mutual world. So he stays in the finite world. So he stays in the finite world, but by these two arrows, he is able to control the infinite world. Maybe an easier analogy is like if you write a procedure to do physical experiment or chemical experiment, and you don't know what's going on here, but somehow there's a machine to help you to read, to see the color or read the signals. So that you understand what's going on for the telephone as well. Um what are the calories for web for the stars anyway? So uh so this is the I go back to I'll come back to this in one more time, but uh hopefully then that's it. Okay, so the picture yeah okay so so that was the picture. Uh now I want to say what's happening for the slaves. Say what's happening for the slaves. So, how does this funny machine work? So, the discrete part is exactly like a standard TU machine. For the slaves here, so each box here is a slave. So, let's call it S0, S1, dot, dot, dot, SN. So, each of the slaves are a universal Oracle tool machine. The masters can ask the slave to do something. Now, as I said in this picture, the master will write a program code on the so-called billboard, on that cell, and then the slaves will all execute this instruction. The instruction. So, the typical example, so let me use an example of real numbers, although we are talking about bare space. So, suppose you want to calculate 2 to the pi or whatever. So, maybe you can think of the first slay will calculate 2 to the 3. Somehow, the second slide will calculate certain approximation of 2 to the 3.1. And the third one is to calculate 2 to the To calculate 2 to the 3.14, maybe up to 2 digits. So each of the slaves are doing more or less the same thing, but the bigger slaves will do more. It's a continuation of the old ones. So we will click the screen. Click the screen because if you activate the window, I cannot you just click the most yeah so so to explain this this thing uh more carefully, uh I need to say what is uh a single slate. A single slave. So if I blow it up, a single slave is an oracle Turing machine. So this is S sub I. So there is an oracle, but the oracle is used to read the input from their space. And Oracle tool machine is like this, right? So you have an Oracle, you have two. Oracle, you have two type zero input. One is the core one, one is the numerical type zero input. So the X is written on the input tape because it's written somewhere here. So the slaves will read the input from this input tape of their space. Now, for the type zero input, he has to know the He has to know the program. So the program code was obtained from the master. So the P, you read the P from here, for example, doing exponential, they'll do this. And also each slave has his own label. So the label I will distinguish all the actual slaves. Although they all follow the same program P, but different slaves will somehow. Different slay will somehow carry out the same coven to different time to a longer and longer extent. So that's the explanation. Well, also there's a zero test command, as I said here. So you mentioned that there's a magic so that it can tell you whether the element with best. The element with bare space is zero sequence or not. So, this two-way information flow, I want to use it to justify the including zero test. Suppose you don't include zero test, but somehow you have to include some some. Some basic predicate. You have to know some basic properties so that the master can get some feedback from the infinite work. So if it's not zero test, you know, something else. So in order to keep the computation goes on and out based on what's happening, it seems that you need some feedback. feedback the the the type one word back to type two word so zero test does that uh so that's the justification of zero test okay so then you can imagine uh what is uh so this is the definition of a class of function using uh machines so we say that a partial function f is ms computable if there is a okay so there's some small points there. Okay, so there's some small things there. MS machine such that the machine somehow coincide with the function you want to compute. So we skip the issue of fine-tuning here. So this is an important detail, but actually we spend lots of time on this, but I don't have time because it's a it's It's technical and funsy to describe. I will point out when it matters when we, in the next slide, or in the future. Okay, so the main result we get from computational web airspace are over airspace, F is. F is partial recursive, that is the thing we define using functional schemes, coincide with this MS computer with the machine computer. And also, from the proof of this, we have a cleany normal form thing. So there are, okay, recursive over their space predicate T predicate. This is the type 1 version of Treen's. Version of Treen's T predicate and a partial TP function u, which reads the output such that for all partial recursive function f, it has this normal form. Now, here I didn't define what is primitive recursive. So the fine-tune we actually used here. So let me spend one minute to explain. The one we need to explain this. So, over natural numbers, the T predicate is really primitive recursive, therefore, it's total. Now, in a type 1 setting, somehow we include all the so-called TT computable functions. So there are some partial, there are partial functions inside. So, therefore, but on the other hand, we want this t predicate to be total. Predicate to be total. So we have to make a technical slowdown and somehow to add some stuff to make the T predicate total and push the partialness to the U function because U function is a T T compute function, it will be partial. So for that, we need to massage the machine. So the so-called fine-tuning is just a technical way to make T predicate the I hope it. I hope it makes sense. Okay, so then it turns out this model is the minimum one containing both BSS and TT. Well, we include TTE as our basic functions and Turing machine can unit over the registration machine as well. So that's more than 60%. So that's the second part. So what's the time? Okay, so that's the what we have got for that space. So now we want to push it, we want to lift it to type n objects. So that's the what's that is the ongoing project. So we want to lift this to complete our final types. So we are going to So, we are going to for each natural number n, we want to define the following notions over type n objects simultaneously. So, first we will specify the underlying set domain. And also, we want to describe a class of computing functions of type, okay, type whatever, type one computable, type two computable, source and then we have. And then we are going to have to define a machine, a family of machines, massive machines, which we will use to compute those computable functions. And also, we can define type n computable subset. It's just like a recursive subset of natural numbers. And then we have to. And then we have to define Oracle Team Machine of type N, then use these ingredients to define the type N plus 1. So for type N, we have to specify these, especially the universal Oracle MS machine. And then based on these ingredients, we can define the type The type n plus one define objects in type n plus one. Okay, so let's look at the first few levels. So for type zero, the domain is just natural number. The computing functions are just partial regressive functions, and the machines are just And the machines are just the classical Turing machine. Well, the recursive sets are just recursive sets. The Oracle Turing Machine are just the usual Oracle Turing Machines. But the main purpose to use Oracle Turing Machine is we are going to use them to induce TT computing functions. In the next type. So, although this is type zero, our control machine, but it gives us a family of type one functions, which we can use as basic functions to define a family of functions. Now, for type one, so we move on to bare space. The domain will be the infinite sequence of natural numbers. The infinite sequence of natural numbers. The computing functions are the one I just described. So the partial recursive functions over their space. And then the machine model will be the MS machine I just described. But the computable sets or recursive sets, again, we can. Again, we can mimic the definition of a classical recursive set because we don't need continuity. So we can say that a set is computable if and only if the characteristic function is partial recursive or NS computer. Or NS computer. And before the pandemic, we actually find a definable description of the computable sets. So they are exactly the infective delta 02 sets. In other words, they are both infected G delta and infective F sigma. So the topology here are the topology on bare space. So it's a product topology over this with. This with topology. Now, you can guess the Oracle version, but I'm going to show it in the next slides. Now, my main topic is to go from type 1 to type 2. That will give us a good suggestion how to go from type N to type N plus 1. and plus one. So I'm going to use Mn, the letters Mn for natural numbers, the capital letter XY for reals, and the curly A and B for subsets of wheels. So these are the type 0, type 1, type 2 objects. Okay, so I have said this before. So the domain will be the power set of power set omega. So we can think of them as subsets of. As success of wheels. Now, the first thing to define is this Oracle type 1 machine. So it's just like the black part is the same as the standard normal Oracle machine. Then you can use subset real as Oracle there so that on the query tape, you can ask a real. Re type, you can ask a real number belong to this subset or not. For example, the oracle may be retarded set. So you give me a real, and you can ask whether this real belongs to the target set or not. If it's in, then somehow give you a feedback zero or one. So that's the more or less the easy. So just like what we did from type zero to type one, we use the Oracle type one machine to induce a family of a A family of computable continuous functionals from D2 to D2. But the continuity is based on different topology. So once you have this, we are going to use these Oracle Type 1 machines as slaves. So we are going to have continuum many type 1 slaves. Many Taiwan slaves. They're all squeezed inside a chamber or a circle or something. And each of them has a label, which is a real number. Now, the difference between this type and the previous type was you have to give up the okay, so let me show you a little bit. So you have to give up the Oracle type. Up the oracle tape because there's no nice linear order of these things. So you have to just imagine they are a collection of dots or whatever. So you don't need to now order them, you don't need to arrange them nicely on a tape. So we put them into a chamber. Channel. But the issue is then which slide can retrieve information from which cell. So the convention now is suppose a slave is labeled by a real number X, it can retrieve information from any box Z, as well as it. Z, as well as it can produce the address of Z, basel X, right? So you so in some sense, each slave can only read at most comparably many boxes, although the input has continued many boxes. For the sake of computation, he only needs to have continuum information. Now, when you write, when you give output, the slave S sub S. The slave S sub X can only write on the box with the address X. So that's some convention. So once you have this, okay, so there's no more input tape and a query tape. Instead, you have some chamber or some station where you stop everything there. So that's a picture. So then you can mimic the you can you can mimic the what have what's happening for their space to to the next level so i guess this is similar uh so that the part d and e are changed to fits type two right so so d become all the effective functionals from d2 to d2 which are induced by the oracle type one tuning machine and then the equality will be the equality between type Type one objects and instead, okay. Type two objects here. So then the rest are the same. So we can we make the proof and have this f is partial recursive in that sense, if and only it is computed by machine in the other sense. And we can get a normal form similarly. So, for recursive sets, again, we can define it by using characteristic functions because again, we don't need to deal with only continuous functions. So, we can use this definition, but we are trying to show that we are trying to connect the compatibility with definability, but Fallability, but this is a worthy conjecture. And so we have some ideas because the proof looks on the face of it, looks very, very similar to the previous type. But however, those fine-tuning, so there are details to be ironed out. So let me say this is work in progress, and we are trying to get this. To provide the ingredients to move on to the next type, we need to relativize, we need to have an oracle type 2 machine so that we can move on to type 3. So then I guess this is exactly similar parallel to type 1. So I'm just leaving, please. Do I have time? Okay, so that'll skip this philosophy. So, there are other motivations to do this because I'm interested also in reverse mathematics and reverse mathematics using subsystem of second-order arithmetic to measure the proof-theoretic strengths of mathematical theorems. But many But many mathematical theorems are beyond second-order aesthetic, for example, ultra filters or measures. So, in particular, for example, some of the graduate theorems are working on Highman's theorem or Gauss's theorem, where the classical proof often use ultrafilters or identifiers. And I would think it would be nice to. To generalize or to find a reasonable subsystem of third-order because those things are third-order objects. So the third order fragments would be the right place to discuss their reverse strands. Currently, people use conservation, other interesting things to To pull back, to remove ultrafilter and somehow stay inside the second-order system. So one of the dreams is to have a hierarchy of subsystem of third-order arithmetic. But in order to do that, probably you need a reasonable local computability of third-order objects. Something like a Options is something like REC or recursive set, but on the next level. So, that's that provides us another motivation. I guess, so there are some philosophical remarks on the algorithms, but I'll leave it at CPU. Okay, thanks.