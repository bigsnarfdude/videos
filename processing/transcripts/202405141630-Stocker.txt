I was muted, okay. Let's see now. But they can now? Yes? Okay, still not, or because now we changed the button? Now it's good. Okay, great. Okay, so yes, they haven't missed anything. I was just saying I will present the different draft methods that are implemented in the package. Draft methods that are implemented in the package, then the combination with the tent pitching, and finally also with the package of NGS-XFEM, which is the method, the package developed by Christoph Lamfeld, who you've seen in the morning, where we can use press methods on unfitted geometries. Okay, and yes, all the notebooks are online and you can try them out later on. So, to begin with, yes, I wanted to first talk about these draft methods. And so, I wanted to quickly recap what we have seen already. Quickly recap what we have seen already from yesterday and today on these different types of drafts methods, right, that we've been discussing. And I just wanted to give a quick overview of what we'll see. So the original or the drafts method, the draft DG method is the one that we constructed this finite dimensional space that lies exactly in the kernel of our operator, right? This is what we started with, but we have seen that this is very difficult. But we have seen that this is very difficult to generalize to the varying coefficients or a right-hand side, as we would have to construct a particular solution, which can be tricky in these circumstances. And varying coefficients, we usually cannot construct a suitable basis by hand for this. Of course, on the beneficial side, we know if we can use this method, we have an explicit basis for it, and there are no additional costs involved. For the quasi-refts method, we are altering this concept. You have seen. Are altering this concept. You have seen, instead of lying exactly inside the kernel, we relax this condition with this Taylor polynomial. With this, we can adapt it to varying coefficients. We can include the right-hand side. We still now construct our basis functions explicitly, as you have seen in the construction this morning. And the additional cost that we have to spend in order to construct this is we have to evaluate this Taylor expansion of our coefficients on the right-hand side. Finally, Side. Finally, the embedded Trefts method that I presented yesterday and you've seen in several talks already. Again, in the general form of the embedded Trefts method, we are not explicitly in the kernel. So if we want to include the varying coefficients to the right-hand side, we can, of course, be in the kernel in the method. Yes, it could also be a yes. You will see later. So, as you know, from yesterday, then we can treat varying coefficients. We can treat the right-hand side, and we do not know our basis functions. We do not know our basis functions explicitly. So, this is a no, but still, I have marked it green since not having to implement them can also be in our favor. So, yeah. The additional cost that we spend to construct the method is that we have to do this element-wise single-value decomposition of these small element matrices that we built for the operator. Okay, so let's have a look at the draft spaces and how they're implemented in NGISolve. Again, we Again, we are going through our Python interface. First, we load the package simply, so as we did from ngSolve, now we import from ngs dreft. And then we have a new finite element space. So this we can use similarly to the L2 finite element space, but now it's simply called draft finite element space. We supply it with the same arguments as the normal space, so we give it a mesh, an order. It's supposed to be a DG method, so we have to tell him that the DG jumps are true. And additionally, Chumps are true. And additionally, we have to tell him for which equation we want to have these Traf basis functions, right? Currently, implemented are Laplace-Helmold wave equation, yes, and then the quasi-traft one. So here we have the harmonic polynomials, the plane waves, and the well, these type of wave functions that, yeah. Okay, so just to give you some background information on the evaluation of these functions, so this is what happens on the C ⁇  side. So, this is what happens on the C side that you will not see in the Python interface. Usually, NGISOLF uses, of course, a reference element to evaluate its finite element functions. This we cannot do because we do not want to transform to reference element because this would destroy our path to property. So, what is implemented on the C ⁇  side is a mapped element, a scalar mapped element that handles the evaluation directly on the physical element. On the physical element of the mesh instead of a reference element. So, this is what you will find if you look inside the C code of my package. Yeah, this extends the finite element class of ngisolve. As I was saying, it evaluates our first basis functions on the physical element. And this function that you can find in C ⁇, you simply give it the coefficients of your first polynomial basis functions, and it will do the rest. But the plane waves, it's implemented slightly differently, but in a similar way. Now, the quasar dreft methods are very similar in this implementation. As I was saying, we relax the condition outreft space. So this is what you've seen this morning. And together, this is the work with Caravan, Lismaria, and Andrea that we've been doing for the elliptic problem and also for the acoustic problem in our previous paper. So you have this relaxed condition of taking the Next condition of taking the derivatives and the value in the center of the element, and now we want these to be zero or match a right-hand side in order to construct the particular solution so we can hold on. Okay, so these are Causetraft spaces. We use them in a similar way, draft finite element space, but now we call instead of wave, we call causetreft wave. And we need to set the coefficient, like, for example, y plus one. And you can see here that in this small example, it's just a propagating wave, but with the wave speed increasing. But with the wave speed increasing in y direction, so it's moving faster on top than on the bottom. Yeah, so this can be done with our left functions within this changing material. Okay, yeah, and we access it with the Z coefficient. Okay, so finally, the embedded Trefts method, now the implementation will be very different as we do not use the Trefts finite element space, but we want to use this projection onto the Trefts finite element space, right? Instead of constructing it explicitly. Right, instead of constructing it explicitly. So, I've you've seen it yesterday, but I never know who how much mescal we are drinking in the evening, so I will repeat briefly. But yes, so the main idea was, of course, we're applying our operator here, and we want this to be zero when tested with a certain set of test functions. The test functions, if we choose this simply as L of B of a V in V H, we get the The h, we get the standard Treft business, harmonic polynomials for the Laplacian. If we replace this with a W, so a projection here, onto a smaller subset, we can relax this condition again to treat Helmholtz as we've seen, varying coefficients, you name it. Okay, so this is what we want to construct. We do this, yeah, we want to project onto spaces. We do this by finding the kernel of this operator on each element. This operator on each element, which will be our projection t. Again, this element-wise, and this is then a block diagonal matrix that projects down onto this weak kind of curved space. And again, if we have a right-hand side, we can similarly use a pseudo-inverse of the already evaluated single-value decomposition to element-wise construct a particular solution that we can use to homogenize the system to treat the right-hand side. Okay, um, here is an example code a bit longer than before. On the left-hand side, we have a pseudo-code, kind of, and on the right-hand side, this is the matching NGSOS code. In turquoise, we have what is needed for the embedding, and in this red kind of color, we have what is needed for the particular solution. I'm showing here a bit more extended code because I really want to show that if you have a running DG code already, DG code already at your disposal, it's very simple to implement this scheme because you only have to add, you have to only build these two additional matrices and then multiply them with the already existing DG scheme on polynomials and it works. So you only have to add a few more computations, particularly this SVD on each element, so finding this kernel, and if you have a right-hand side, computing to the inverse. So basically these two additional lines or four additional lines. These two additional lines or four additional lines in color, and you can transform your system to the read-graphed space and homogenize. How does this look in NGSOL? So what functions will you be using later? We start with the standard PG scheme, so full polynomials on each element with the L2. And we are considering some PG formulation, a general one, A our bilinear form, F our right-hand side. And then we will call this function. And then we will call this function Trefts embedding and give it the operator that we want to use to construct these local element matrices. And the right-hand side, the Trefts embedding gives us back the embedding matrix and the particular solution. And then we simply, okay, we create the transpose and then we multiply this to our system matrix, get the new condensed system, the smaller one, use the inverse and compute our solution inside the draft space, to evaluate it, we map it back. We evaluate it, we map it back onto the full polynomials again using our mapping t here. Add the particular solution, and we have our full solution in the polynomial space. Okay. Yeah. The epsilon is a parameter that we can pass if we want to, so to make certain that, of course, the singular value decomposition will have some small error, maybe. So the singular values will not be exactly zero. So the epsilon we can use. Exactly zero. So the epsilon we can use to distinguish to set the threshold which singular values will be below zero. We can also pass different arguments if we know the dimension of the draft space that we want to find, that we can simply tell it to take the x smallest singular values. Or if we can pass a different test space, as we were doing in this example, so like a test space wh, then we would have to rewrite here V and pass a test space. You can do this. It's in the notebooks. And then the dimension is also clearer since. Then the dimension is also clearer since we know how many how much small our test is. Okay, quick example that I didn't get to show yesterday, just to show some runtime examples. Of course, we know that the convergence looks exactly the same for all the methods. I just wanted to show some timings here for the three methods. So we have the polynomials, the embedded refs method, and the harmonic polynomials. And in orange, we have the cost for the single validity composition. For the single-level valid decomposition that we can do on each element in parallel. If you look closely, I think you can find it here. These bars are the timing, and I'm doing three timings because I'm timing once on four different threads, eight parallel threads, and 12 parallel threads. Yeah, these are the difference between for each method. We have the assembly time of the matrix, the solve time, of course, has to take the most time, and this singularity position is the matrix. Time and this singularity composition is something yeah compared to the solving takes barely any time. Okay, so uh yeah, any questions on the first part of the test business? Um, yes, otherwise I show the combination with the tense. Um, yes, please this is uh this is an excellent question, of course. This is an excellent question, of course. So, yeah, this is kind of if you want to apply it in an exterior fashion. Of course, it takes more memory to do this. You could, while you're constructing the DG matrix, already apply the transformation. This is also implemented. It's a bit trickier, but it's in the notebooks. This is why I didn't present it. I think this is a nice way of doing it if you have a DG code running. Yeah. But yes, it's much faster to do it immediately. I have implemented it and it's called an embedded thread. The embedded space. It's in the first notebook, I think. And then it constructs it immediately while assembling the matrix and only assembles the condensed matrix. Yeah, it's quite nice. But it's a bit tricky if you then want to do a vector-valued functions like for the Stokes problem. So this is not working yet. But for the past problem, it works perfectly fine. Okay, so the tense. Yes. So NGS TENS is the software. NGS 10s is the software briefly mentioned yesterday already that constructs 10-pitched meshes. So you can see the example here. The main idea is that we want to create a mesh of the space-time domain for to solve our space-time draft method on it. The wave propagation has to be finite. So we're looking at a hyperbolic problem that has finite wave propagation. And if we have a finite wave propagation, then we can construct these. We can construct these tens such that each tenth, so each of these tens lies in the cone of dependency of our propagating wave. If we can construct it in this way, then we know that we can solve our PDE problem inside this tent, since all the information that we want to propagate, all the initial conditions, are contained inside the tent, if the slope of the tent is below the characteristic speed. So, if we have such a mesh, we can solve on each tent individually in parallel, so again, very small matrices, and propagate the solution from the initial condition to the top of the tent. So, these sides of the tent are then space-time facets, so to say, in our mesh where we have a new initial condition. So, these can be all solved in parallel. And then we pitch new tents on top of those. So, you can see in blue are the old ones. So, you can see in blue are the old ones, in gray are always the new ones. So, you can see how the tents slowly propagate upwards. In each iteration, we propagate the solution in each tent individually. Yeah, until we reach a final time that we have to set such that we can evaluate again on a flat surface. So, get a reasonable solution, of course. Yeah, how do we do this? We simply import a tense lab from the NGS TENS package. The tense lab, we can Package, the tense lab, we can then give a spatial mesh and provide it with a method on how to measure the characteristic speed. We have to set the wave speed and then we can pitch the tent until some final time dt. So this would be the height of our tent slab. Of course, so dt, so this remembrance of time stepping because the slab we don't usually want to be too large as we want to evaluate. Usually, we want to be too large as we want to evaluate at some specific times. So, we don't want to evaluate until final time, but usually we solve slabwise to some fixed small time step. So, we can evaluate at slices. Yes. The main advantage is, of course, the explicit solving in each tent and that we can easily treat mesh refinement as you can see here. So, there's a refinement towards this corner, and it's very easy to adapt the tents to this mesh refinement as. To this mesh refinement, as they simply have a smaller height if they develop on a smaller spatial mesh size. Yeah, and yeah, simply stay. Okay. Yeah, there is also a 2D tenth. Yeah, I can explain again a bit. So yes, once we have this tent pitched mesh, we can pass it to the function fast wave. This simply solves the wave equation on these tenths. Wave equation on this tense. So we set the initial condition, set the boundary condition, and then we propagate the wave upwards. This is the full code you need to run in order to use Treft's methods on this 10-pitch mesh. Again, yes, here I've extracted like one of the tens in 2D, for example. And you can see so the ideas you have always the kind of initial condition that you gain from below on the integration points of the spatial mesh. And then Of the spatial mesh, and then we solve on this tent or diamond-shaped object to propagate the wave upwards. We can solve our simple, like a local DG scheme. Yeah. Okay, so this is test plus NGS tense. Last one is test plus ngs xfam. So you have already seen the presentation by Christoph today, so I will not go into details. The main message is it works almost out of the box. We construct our test finite element space, we restrict it to We restrict it to our domain, which is now floating around on a background mesh. So this is simply a function from NGS XFERM. So we have this our domain. We restrict our basis functions so that they only live inside the domain. And then, as you have seen already today, we need to apply some ghost penalty or element aggregation in order to fix these types of small cuts. So if we have a small cut element, you've seen in the talk. Element. You've seen in the talk by Christoph, we can either patch up by merging this to an uncut element or use some ghost penalty from in our formulation to penalize jumps between the small cut element and the large element to restore stability in our formulation. Okay. Yeah, so with this, I'm already at the end of my presentation. I wanted to show you there's a web page for the software. There are all the notes. For the software, there are all the notebooks there and some additional information. I'm always happy to, so I really want to invite you to use my software or to extend it, to use it freely in any of your endeavors. I would be extremely happy if anyone uses the software. So, yes, please go ahead. This is the slide from yesterday, slightly updated, so to get you working with the notebooks. The commented line. The commented lines you already have done yesterday, so you don't have to repeat them. So the virtual environment is already set. Hopefully, then we can simply activate again the virtual environment on Windows or on Mac, wherever you've put it. Then we need to pip install additionally NGS drafts. All the other guys would already be installed in the virtual environment. The notebooks from the workshop received a slight update with the additional Corsair Drafts notebook for the elliptic case from Gia. And you again run the notebooks now in the NGS Drafts folder and you can. Books now in the NGIS test folder, and you can play around with all the stuff that you use. Okay, thank you. Questions or programming? I don't know. I stopped winning, yes. Amazing. Be gripping. Okay.                                                                                                                Even more probability than that, maybe for other reasons, because monomials have some nice properties. Or whether this is what you want to do.  The belief that this should be probably minus because this cannot go to zero. Well, one belief that it goes to zero, but if you're going to take state that looks above one, that's too expensive. Probably minus and it explodes. That's if my thing goes with them. That's the circle that makes sense. And that's what we need to do. Yeah, yeah, what you're going to do is. Depending on which kind of paper you can get here, you get different.    