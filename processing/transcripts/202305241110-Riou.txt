Okay, so I would like to thank very much the organizers for this conference and giving me the opportunity to speak about this formalization of derived categories in me. So, I certainly cannot cover all the aspects of the formalization. So, I will try not to make a too long talk so that we can have some time for discussion. That we can have some time for discussion in the end. But feel free to ask questions. If there are pressing questions, feel free to interrupt me so that I can clarify things. So I would like to, so I have formalized initially I did it in Lin 3, but I have recently, as the port was growing up, I found out that maybe I could port it to Lin 4. Ported to reinforce. So let A be any ability category. So if we think of the applications, let's say to group comology, to local cohomology, etc., we would be interested in the category of modules of a learning, for example, or the category of abelian sheaves on a topological space or on a site if we think that someday we are going to do a telecomology, for example, or sheaf comology. So, well, So, well, I'll just remind you that, well, I'm going to use this notation CA for category of co-chain complexes. I'm using the homological convention, so numbering are on the top, and differential lasers are degree by one. And of course, we have D composed with D is zero. And so it's a category. So we have a notion of map of complexes. So all of that has been in my leap for. So, all of that has been in my delib for quite a certain time. Similarly, for the homotopy category, which I'm going to refer to as Ka, which is obtained by taking the quotient of the morphisms in the category of co-chain complexes by the homotopy relation. So, it's still a category and still additive. And actually, it's good enough to do most of to do a Of to do a big share of the homological algebra. So, for example, in the liquid and solar experiment, so there was no like proper derived category, but there was an approximation of it using an homotopy category of bounded above complexes of projective objects, etc. But what I want to do is really the real thing, which is the derived category as it was defined originally by formally inverting quasi-asomorphism. formally inverting quasi-asomorphisms in these categories, the motopy category or the category of co-chain complexes. So the localized category, like this means like as we say, localization of in commutative algebra, you can invert elements. Similarly, in category theory, you may formally invert morphisms, force them to become isomorphisms. So this is something I have formalized. I have formalized last year. So it is in MATLIB. So you can define the localized category, and there are some there is a criteria that a functor is a localization functor and some API for that. But for this derived category project, I had to very much expand this API. So anyway, the derived category is obtained by formally inverting quasi-isomorphism, which are those morphisms which Those morphisms, which, so it's a weaker notion as compared to the homotopy equivalence. So, these are these morphisms which induces isomorphism in homology or homology because I have taken homological conventions, which is a standard one. So, if we think about the Danaf category as a type, it is exactly the same up to some obvious equivalence to the same objects as. To the it's the same objects as the co-chain complexes, or uh, but we change the morphism, so but still as a category, uh, it's it is just a localized category. So, uh, so this is not the end of my talk, I will do something more. So, um, so we have this diagram. Uh, so I don't know if you see my pointer. Yes, yes, yes, yes, okay. So, we have this category CA of quotient complexes, we have the quote. Of quotient complexes, we have the quotient category KA, which is a homotopy category, and then there is this localized category DA. And the homology functors are originally defined on the co-chain complexes, the factors through the homotopy relation. And by the very definition of the universal property, if you like, of the localized categories, they induced morphism because we have forcefully made quasi-isomorphisms isomorphism. Isomorphisms isomorphism. So, well, it is you can then factor this. You get some homology functions on the derived category. So, since we have some structure, so it makes sense to take the homology of an object in the derived category and etc. And in the original plan by Grutengieck, the derived category was defined directly from the category of co-chain complexes by formally inverting the quasi-isomorphism. Inverting the quasi-isomorphism there. And he was maybe a little bit optimistic. The thing is, we do not get so much of a structure if we just do that. And what Jean-Wiverdier observed in his PhD thesis is that if we do the construction in two steps, so first we take the quotient category and then we localize, we have a very nice structure on the category or on the homotopy category. And this is a structure. And this is a structure of triangulated category. And there is a general localization theorem that if Ka is a triangulated category and if take a suitable class of morphisms, then the localized category is going to be also a triangulated category. So I have formalized this general localization theorem for triangulated categories. Triangulated categories under suitable technical conditions. And I also verify that Ka, the hemotopic category, is a triangulated category. So I'm going to say a few more details, but the pre-triangulated structure was already in the liquid tensor experiment. But here we need the octahedron axiom. So I had to formalize the octahedron axiom, which is now in MATLIB, but I had to prove it. But I had to prove it for this category, for this homotopy category. So, well, and also this homology functor, Ka, from Ka to A or from the draft category to the original category, these are homological functors, which means that they are like industrial mechanism to produce long exact sequences. So, before I go. So before I go into some more details about the triangulated structure, I will give some ideas about some technical aspects. I would like to show you what how it looks in lean four. So is this big enough? Or should I erase it? I think bump it up two times rather. Is it okay? Is it fine? Is it big enough? Can you do one more? Once more? One more. I hope this is fine. And I have to do this awful thing. I assume. You can close the minimum. Or don't you send our This there must be a way to make this full screen so okay. So, okay. So, I'm so this is a file derived category basic. Uh, basic. Um, so I defined a notion of so this is in the homotopy category of cochlear complexes. I define a QIS or quasi-asomorphism. I define it as a class of morphism, which is in MATLIB a morphism property, something which was initially introduced, I think, for the applications to algebraic geometry, but it's the same notion of classes of morphism. And it is defined with respect to And it is defined with respect to the notion of acyclic complexes, but I don't want to enter too many technical details. But the thing is, a map F in the homotopy category is a quasi-isomorphism if and only if it induces isomorphisms is iso when you apply this homology functor for the map F. So whichever way it was defined, it is equivalent to the usual notion of quasi-isomorphism. The usual notion of quasi-asomorphism. And then I define the derived category. So there is this dot localization. So it's, I define the derived category as the localization of this homotopy category in respect to quasi-isomorphisms. Then I get for free, obviously, the category instance. Something which is more difficult is it's pre-additive. It was highly technical, so I had to develop notions. Technical, so I had to develop notions of localization. I took a purposely a longer route. So I had to show that, for example, a localization of a product categories, most of the time is a product of the localizations. And that's with some adjunctions theorem, I showed that there were finite products, and then I showed the category was additive, etc. So it was quite technical, but anyway, it works. So the category is a zero. It works. So, Katira has a zero object, it has a shift. So, there is a whole story about the shifts in the, I mean, it's everywhere. The question of kind of coherence, like if you have a diagram, you have sometimes you have to show it is commutative by using the axioms of what is the shift on a category. So, I'm referring to the shift of the complexes. When you have a complex, you may shift it to the right or to the left and changing the signs of the differentials. And I get using the fact that the Using the fact that this class of quasi isomorphism is defined in a certain specific way. I'm going to give a few details after. Then I get that the draft category is pretty triangulated and I can even verify the octahedron axiom. So it is a triangulated category. And then I obtained various results about the drive category. For example, there is. For example, there is a distinguished triangle attached to any short exact sequence of complexes. There is a notion of homological functors, so we have long exact sequences. So in particular, I discovered the long exact sequence of homology of short exact sequence of complexes. So thing which was, I think, in the liquid and solar experiment using the snake lemma, but here I do not need the snake lemma. I get it in a different way. Okay, so that's for the. Okay, so that's for the main constructions. So there are no solids whatsoever in these files. So let's go back to the so what so there are values ingredients. So there is this localization theorem for triangulated categories. So you have to know that this category of this somotopy category is triangulated. So I would like to say a few words about this. So let So let phi be a morphism of co-chain complexes from K to L. So that is a standard notion of cone of phi. So it's a complex which in degree n is just direct sum of k n plus 1 and l n. And we may define a differential on it. So it's given by this matrix. So you see that you have this phi which is there. You have this phi which is there with differential on k and l, and there are some sides. So, actually, I have in order to do computations with this code, I have used a notion of code chain. So, I have considered the complex of code chains from one complex to another, and I have manipulated these almost like matrices, but using code chains of degrees. Using co-chains of degree 0, 1, or minus 1 sometimes. Okay, so, and this fits into a diagram, which we shall call a triangle, because there are three objects, KL, the core, and K, but shifted by one. So when we shift by one, it means that we shift to the left and we change the signs of the differentials. So in this triangle, we have our morphism phi, the right injection, so of Ln into the core. Of Ln into the cone in each degree. And this is a co-chain map, a coaching complex map. And the first projection also is a map of complexes. And for some reasons, I could explain, but maybe I don't want to explain, which we have to put a minus sign here. And this defines the notion of what we call distinguished triangles. So any triangle, so involving three objects, X, Y, Z. Three objects xyz and x shifted by one, it is a triangle, and we say it is distinguished if it is isomorphic to such a diagram in the homotopy category. So, and then we can verify that the category, the homotopy category equipped with the shift functors, shift on either size for any integer n, and the coherence properties satisfy this notion of distinguished triangle. That is this notion of distinguished triangle. So, this homotopy category is a triangulated category. So, as I said before, it was also verified on Bering of the Agenda. It was verified also in the liquid tensor experiment, but with a different notion of distinguishing, I'm equivalent one, but here I have used kind of original definition by Verdier. So, and I think it is slightly more suitable. Think it is slightly more suitable for formalization because, um, so I am French, so I have learned this shortly after the thesis of Verdier was published in asterisk. So there is a book. And this is where I have learned these notions. And I have not learned because at the time the Stacks project was not a thing, it was non-existent. So in the liquid cancer experiment, they have followed, I don't know, do not know exactly. Followed, I don't know, do not know exactly who did this formalization, but they have followed closely the SANX projects. Well, the definition is slightly more complicated. So anyway, so sometimes we have to look at French sources. I'm really sorry for that. Then what the cone, if you have never seen that, so in some sense, it measures the difference between K and L and the obstruction for. And L and the obstruction for phi to be an isomorphism in a certain sense. So, amorphism of complexes induces an autopico balance if and only if the cone is contractible and it is going to induce a quasi isomorphism if and only if the cone is acyclic. And so, in particular, when we apply, I'm going to give you the ingredients, but when we apply the You the ingredients, but when we apply the localization theorem, we get this derived category DA, and then a morphism is going to induce a more an isomorphism in the derived category if and only if the cone is acyclic. Okay, so I would like now to give you the so of course there are some verifications which are not so hard, but a little bit painful sometimes. But there is a very interesting thing we have to show the critical Things we have to show the critical thing we have to show in order to get the derived category. So, if you want to apply the localization theorem, this is the following lemma that we have to show that if with the previous notation, so when you have this any morphism of complex cells K to L, then there is a long exact sequence in cohomology involving K, L, and the cone. And this actually means that the H0 functor The H0 functor is what we call a homological functor. So when you shift H0 in a certain sense, you apply it to shifted version of complexes, you get an infinitely long, and using rotations of triangles, you get an infinitely long exact sequence. So this is the main technical thing with Lemar that we have to show. Once you have done the obvious verifications, this is a thing that requires some sort process. Uh, some sort process, I would say. Um, so uh, to check that, actually, we have to check this for all the distinguished triangles, but it suffice to do it for this one because all of the other areas to this one, and using the rotation of triangle, it suffice to show the exactness at H and L. So, basically, and then I'm going to be a little bit cheating for a few minutes, but we shall see how not to cheat later. So, for CMPC, assume. So, for simplicity, I assume further that we are working in the category of abelian groups. So, then what we have to show is that if I have a comology class in degree n of L that is mapped to zero in the core, then it has to come from a comology class of k. And if you think in the category of Berlin groups, it's just obvious. It's a diagram chase. So, well, I'll just remind you of the definition if you want to really follow the details. So, let X be a comology class. X be a commergy class. Assume that its image is zero in the core. Then the first thing I'm going to say is that X is a commerci class. So it has to be the class of a co-cycle. So there is some Z in degree n such that DZ is zero. Well, I've just said that the map from cycles to the cohomology is a subjective. So it's a quotient. Then I apply my assumption that x is mapped to zero. Then if I take this co-cycle there, If I take this co-cycle Z and set it through the right injection in the cone, it has to, it is zero in comedy, so it has to be a co-boundary of the cone, which means that there exists y, a co-chain of degree n minus one, which I can write as y1, y2, with y1 in kn and y2 in l n minus 1, such that the dy is an injection of so that the differential of Of so that the differential of this class of this co-chain is the image of Z. Then, so I have this formula, everything is Y, then I can, we are working in products, so let's translate this into conditions involving Y1 and Y2. And what we get is dy1 is zero, and Z is this phiy1 plus DY2. So, okay. So, okay, then it means that Y1 is a co-cycle. So, Y1 is in KL. So, now it has a commodity class. And 5Y1, its image, it is commodopus 2 there, because the difference is dy2. So then I can claim that the phi, this map, sends the class of y1 to the. So that's the proof. If you do the diagram chase, Proof: If you do the diagram chase, if you apply, I mean, we have it's not just diagram chase, we have to apply the definition of the cone, how everything is defined. So, now the question is, how do we make this work in any abelian category? So, how to do a diagram chase in an arbitrary abelian category A? So, and this is the only thing I have learned. The only thing I have learned while doing this project, everything else I knew very much, and every time we are arguing in abelian categories, we say, oh, it's obvious in categories of modules. And then, well, the argument must work in any abelian category. So now I know how to do it seriously. So I am not using formalized types of pseudo-elements, etc. Actually, I've tried to use. Etc. Actually, I've tried to use the pseudo-elements that are animatri, but it seems they are not perward food enough for what I intended to do. So, actually, there is a very down-to-earth approach. So, if x is an object in any abelian category, A, so now A is any abelian category, let us say that an element of X is a morphism to X. So it's a morphism from some object, let's say some test object A, and it's a morph. And it's a morph, we an element of x shall be a morphism from a to x. So, in other words, it is just a section of the unidapplish of x. And by Yonida's lemma, we know that a morphism of objects in the category A is completely determined by the way it acts on these elements in a certain sense. Also, you can characterize monomorphisms or isomorphisms. Monomorphisms or isomorphisms in terms of these elements. This is completely obvious actually in any category. But there is a problem with epimorphisms. So we are going to work like mostly the way we do in shift theory. Actually, it might even be considered as a particular case. So let's see what happens for epimorphism. So we should expect that it may behave like May behave like subjectively on elements in some sense. So let y to x be an epimorphism and let a to x be an element of x. So I have a map from a to x. Then in the favorable case, we would have a lifting of this because y to x is subjective. We may expect that maybe there is a lifting from a to y. But of course, it cannot exist. But of course, it cannot exist. For example, if you take the identity of x for your element, this would mean that y to x is a split epimorphism. So this cannot work. But what we have, nevertheless, is if you allow to precompose this A to X by some epimorphism A prime to A, then there is going to be a lifting A prime to Y. You may just take the fiber product of A to X and Y to X using the axiom. Y to x. Using the axioms of abelian category, this is going to be an epimorphism, and then for free, we have this lift key. So then the idea, so okay, so this is true. And conversely, if you have a map y to x, which satisfies this kind of lifting property up to this decomposition with epimorphism, we shall say that we are going to refine these elements. So if we have the subjective property up to refinements of the elements, then the Of the elements, then the map was an epimorphism, and many conditions like exactness can be formulated and rephrased in terms of these elements up to refinements. So then basically we can do diagram shades up to refinements, which means that we add you just like as we would do in abelian groups, but we sort of sort of have to change sometimes the test object. And this is exactly what we do in Shift AOD when you. In a sheaf theory, when you have a map of a sheaf that is an epimorphism, so sections you cannot lift, but you can lift them locally. So, actually, it's exactly the same principle. And actually, it's presumably a particular case if we take the canonical topology on A or something like that. So, I have kind of reinvented the wheel. I do not claim any originality here because I learned afterwards that this way to argue in abidean category. This way to argue in abelian categories is described in an unpublished note by George Beckman in 1974. It's the first page of these notes. And that's where I have found this name, refinements. Okay, so let's see now how we can apply this principle for the proof that we did before, like for this lemma. For this lemma. So let's try to prove it now in lean with this principle. Okay, so it might be difficult to see everything from the tactic state. And let's lemma or an instance saying. Leonard or instance saying that the homology functors are homological functors. So this homology functor is homological. So there is some nonsense. And the only relevant lemma is, whoops, this. So I would like to congratulate all the people who are making this pop-ups work because it's very useful. Because it was not so like six months ago. There was so much, so many progress in that. Any progress in that. So, this is the lemma that we want to prove exactly. So, this sequence H and K to H and L, twenty of the cone is exact. So, we have to show that a certain short complex, the short complex I've just entered MATLAB these days. I was tricked by Kevin into starting the PR process. I mean, I'm very happy. Okay, so let's. Okay, so let's reflect so exactness can be tested up to refinements, as I was saying, saying. So, well, maybe I will enlarge the tactic state. So, well, if we just do this, we do not see anything. So, just do this simple and introduce the variables. So, what I have to show is that I have this x, I'm using the same notation that I used before. So, if I have a homology class, so yeah, so it's an element in the homology of L in degree N. The homology of L in degree N. And the assumption is that it is sent to zero by the homology map when I send it to the cone. So, yes, this is the map from L to the mapping cone. And I have to show something that I have to show that after decomposing with some epimorphism, it is in the image of the homology map. So, I hope that all of you are familiar with these funny arrows, which give the composition in strange order. I mean, it was very strange. Strange order. I mean, it was really strange for me initially. Now it's difficult to think otherwise. Okay, then the second step was to say that, okay, this comology class is a class of ecocycles. This is what I do with this lemma and this obtain. So then, okay, now what I have is Z, and it is a cocycle. And the class. And the class X is a class of this co-cycle. So this quite long thing. I don't know why this is funny. This is happening, but okay. Then I just push this element in the core and let's just simplify this. Okay. Then what my assumption now is that when I push this Z into the mapping code, Z composed with ENR file, it's comologically. Its comology class is zero, so then it must be a co-boundary up to refinements. So I'm just doing some rewrites as well. It's an if and an if, and just get the variables, get the data. So now I have this y. It was the same y as before. It is in degree n minus one. So it is not in the complex shape dot prev or something. No, I have made the API so that if you want it to be like n minus one. you want it to be like n minus one you can get your homology class in degree n minus one um okay then uh the next step was to say that y is a tuple y1 y2 so let's do this and just do some simplifications um so there's some extensionality properties etc so let's do sim to in order to rephrase the assumptions h y in terms of y1 and y2 and then i get okay that uh y1 composes That y1 composed with the differential is zero. So y1 is a co-cycle, and z up to some pi two is the image of y1 plus y2 composed of the differential. So it's a we have gotten exactly the same relation as before. So let's do some simplifications. So what is it that we have to prove? We have to prove that two comedy classes are the same. So sorry, here I am. So, sorry, here I am claiming that the comogy class of y1 is going to be a pre-image. So, I claim that. And then, what is the remaining thing we have to prove? Let's just simplify. So, we have to show that two comology classes of co-cycle are the same. So, well, we are going to check it maybe after definement. So, there is this rewrite that is here. And then I have to show that, what is it I have to show? What is it I have to show? I have to show that two things are equal up to some co-boundary L. And I just claim that y2 is going to work and the simplifier is going to close the group. So, okay, so it's not a particularly cooked example that I have done for you. I only made sure that the notations are consistent with what was there in my presentation. So, almost the ingredients just follow what we do in the cut. what we do in the in the cut what we would do by diagram chase um so it's just sometimes we have you have to introduce uh some epimorphism and so on but so the so there are a few of these diagram chases that i had to do like uh strictly sense sensor sense um strictly speaking i do not need the snake lemma but i was about to prove the snake lemma using the same kind of techniques um and as it was mentioned yesterday in matthew's As it was mentioned yesterday in Matthew's talk, I did diagram chases only for two exactness properties you have to check in the SNEC lemma, and the other I would deduce by duality. Because hopefully, if my proposal of the factor enters MATLIB, by definition, the homology of exactness will be self-dual. Okay, so I've done this diagram chase. So another thing I would like to talk about. To talk about as applications of the life category is a proposal for a redefinition of X groups. So it is not for immediate use. Anyway, there are so many PRs that have to go through the process before we can even remotely think about this, but hopefully someday we shall have this. So for any two objects in any abelian category, using the life category, we can define the X group. Currently in MATLAB, we have. Currently, in MATLIB, we have this only if the category has enough projectives. So, using derived categories, we can define it for any abelian category. And so, then it is also going to apply. And then we can compute it using projective resolution or injective resolution, etc. But there are some issues still, you will see. So, we may define the XYN in degree n to the morphism. This is a full derived category, and of course, I am able to define D plus, D minus, DB. But this definition is good in general. Yes, yes, sure. Yeah, I mean, the D plus, D minus, D B, they are full subcategories of DA. So actually, I would encourage everybody to do as much as possible early construction on the full unbunded. The construction on the full unbanded data of category because when we are going to do, like, let's say, projection formulas, we are going to mix tensor products, direct images. So, if the isomorphism we want to construct at some point makes sense, at least makes sense in the full derived category, it will be easier. So, that's also a restriction that we can remove, but I don't want to go into technical details. So, yeah, so when I just Technical detail. So, yeah, so when I defined the health category, I was taking unbounded complexes. There is no boundedness assumption. But these complexes, X and Y, shifted by N. So here there is an abuse of notation. X is an object in the abelian category A, and I see it as a complex in degree where X is alone sits in degree 0. And Y, when you shift it by N, it is going to be alone in degree minus 1, minus N. So, we can take this as a definition. So, it's a type, a type in some universe. We're going to speak about this. So, if we allow n to be in z, then we can show that the negative x in some sense are zero. So, actually, there is a t-structure. So, everything I'm talking about now, I have formalized also. Okay, so I could check that the x0 are the just. That the x0 are the justomorphisms. So, in other ways, the functor which sends a complex an object x to its attached complex in degree zero in the derived category is a fully face foot functor. So, this the next I've done only in lin3, but x1 I can compute as classes, isomorphism classes of extensions. So, if you have a short exact sequence, there will be an attached class in x. Sequence will be an attached class in X1. And conversely, etc. So, what did I put next? So, the important thing is that using the triangulated structure, you have a machinery to get long exact sequences. So, we have to work a little bit, but because of the shifts, I mean, like, for example, let's look at what happens in for n equals zero. For n equals zero, it is not like om dA x to y, it is om dA x. It is on dAx to y shifted by zero. So you have to use an isomorphism. Y shifted by zero is isomorphic to y, etc. And here it's even worse because if you take the zero of the natural numbers, it is going to be coerced at some point to the coercion of zero as an integer. And of course, these are definitionally equal, but still, Lin would complain. complaints. So there are a lot of machinery behind the scenes to make this work, but the code has some aesthetic value. I mean, I really share it aesthetic notions in the mathematics. I've tried to make the code very clean. Okay, so we have long exact sequences of x attached to short exact sequences on both variables. The thing is, we have The thing is, we have these are just ARMs up to shifts in the derived category, and when we have distinguished triangles, we have on any of the variables, we have long exact sequences. So we just plug this into this matching AV. And so I get long exact sequences in both variables. I think maybe, so it's, I don't think it is in MACLIB. In the liquidosol experiment, it is there is maybe the this long-exo sequences maybe in one of the This elongate the sequences may be in one of the variables. I'm not sure which one. The first one. Yeah. So, well, and the proof are quite obvious from the derived category structure. So the interesting thing is that I also define, so it's not just, so I define this Xn as types, as a type, and I endow it with a abelian group structure. And if the category is linear, I've not done it yet, but of course. R, I've not done it yet, but of course, the X should be R modules. But there is a very interesting multiplicative structure. So you may, if you think of the composition in the derived category, it will immediately give this, that if you have an element in Xp of YZ and an element in XQ of XY, then you get an element in XP plus Q of X to Z. So I have written the composition in that direction because of concerns about science convention, but I'm not 100% sure yet. Percent sure yet. So I get this multiplicative structure. And there's something I would like really to. We did not discuss so much multiplicative structures. And maybe only Maria Ines yesterday mentioned the coproduct in the TET or Technical Yema theorem in class field theory. There was a coproduct with a class in degree two or something. So when we do multiplicative structure, we are going to face medicative structure we are going to face to be faced with some difficulties one is um so if you have to define a medicative structure never do that it should never go from xp or hp cross hq to hp plus q because for example let's say i have a comedy class or something in x zero let's say that p is zero what do i get uh i would have something in uh so p is zero and the q is anything what zero and that q is anything what is p plus q then it is zero plus q it is not x q but if you multiply by a zero a class in degree zero you you don't want to change the degree so this is a wrong definition so what we have to do is the following um and this is very important i am very serious so obviously i don't want to spend too much time and i hope that there is no like a serious mathematician uh and who doesn't know of organization that is And who doesn't know a formalization that is if zeroping here because this may look a little bit silly, but yeah, metrical structure we should define like this. So if I have an element in degree p and an element in degree q, I should get an element in degree any r, such as p plus q equals r. So, and in general, never assume that a relation between the degrees is a definitional equality. Just introduce as many variables you need. Or as many variables you need, and just do this thing. So that then we can easily formulate, for example, the associativity of this, which just comes from the associativity of the composition in the derived category. Okay, so now the problem. So ultimately, it would be nice to use this definition of X because it has really nice properties. Because it has very nice properties. And I mean, to do all the same properties using only projective or injective resolution, it can be very painful. I mean, because this is the way it is usually taught, but with the live category, we get this machine leaf almost for free. So the only drawback I could see. So if A is a certain category and assume that the morphisms are in type V, in this category A, then the X group. Groups are going in type, if we do not do anything, it is going to be in type max UV. So, which can be problematic, like if we think of the example of local comology, if you have, let's say, everything in type zero, you would like maybe that your comology is also in type zero. So, here it might land in type one if we do not do anything, but there might be a cure if A is a growth indicator. If A is a grotendicabelian category. So I am starting to think about how to do that precisely. But then we could shrink this to... So the thing is, if you think just of the X1, it is parametrized by not just by morphisms, but you have to introduce this E. And this E varies in something which is in type U. So you have to take the max of U and V to even consider the class of isomorphism classes of such. Isomorphism classes of such diagrams. Whereas, if you have projective resolution or injective resolution, you can just say I'm using this chosen resolution and then you can have some bounds. So here the idea would be to have, let's say, K-injective replacements for those who know Spartanstein approach to unbounded categories. So there is a Q, but it is not. So there is a Q, but it is not for immediate use. So we still have to work with the current definition of the X group for a certain time. So I would like to show you this a little bit in Lin. Okay, so I have defined the new X as I have said. As I have said, I have done. So again, I have to activate this world map. Okay. Okay, so let's assume that just for this example, problematic example. So if I have a ring R which is in type zero, and I take two modules which are also in type zero. So since today I have just ported this file. I have just ported this file. So the category of R modules is abelian, so we can take its deliverer category. Actually, in my blend, I can take the delivere category. So then if we do not do anything, if I take the X group, I do not know if you see that. Okay. If I take the X group of X, Y in whichever degree, it is going to be type 1, not type 0. But if within a Within a finite amount of time, we can prove that there exists a derived category where the morphisms are in type zero. Then the X group are going to be in type. So if we want to have really usable X groups with very nice properties, like X to something injective is going to be zero, etc. Yeah, we'll have to wait a little. Yeah, we'll have to wait a little some time that everything enters MATLIB, and that for a group and the Kabelian category, which includes category of sheets and category of modules, we can have the smallness in a certain sense of the nine category. Okay, so yeah, so I've mentioned this. Oh no, so it's not ah, okay. So I've mentioned. Ah, okay. So I have mentioned this equivalence between morphisms in the original category and the X zero. Yes, and I have all these lemmas which show the exactness of the when you have a short exact sequence. Is it yes okay? And what I wanted to discuss, yes, is this for me. Yes, it is for me to be experimental, and because when Ether was visiting Orce at some point, she mentioned, of course, she mentioned her work about linear maps and there was at some point notions of out params. So well, so I have here is where the place where I am defining the composition of X. So I have introduced, it's very smart. I did it maybe last week on. I did it maybe last week only. A notion of heterogeneous multiplication. So you want to take elements in X P of something and then XQ of something else into X of the composition and you want to raise to add the degrees. So new X Y Z is the whole sequence of X groups and same for the X Y and the target is X Z. target is xz so the this third parameter is the outpar actually in this type class and what is the data i have to provide uh so let's not care about the details but the data i have to provide is if i have a beta in x q x y and alpha in x p y z I have to provide an element in X R X Z for In X R X Z for whenever R is equal to P plus Q. That's this is the data I have to give. And then I was able to show some, where is it? So it is associative. So it's really, you take more time to formulate the thing than to prove it. But yeah. But I mean, the proof is quite clean. I mean, there is no like X2 ohm or X2E, though. You have to. Easily, you have to manipulate. So, those who know what I'm talking about, they understand. And this is just associativity. Like, so I have written the composition of X as a multiplication. So, if I multiply two classes like this, alpha, beta, and then I multiply with gamma, I will get alpha multiplied by beta, gamma. Okay, so and this type of uh target classes, uh, so I'll show you the record and I'm going to conclude. And I'm going to conclude soon. Yes. Yes, well, it's just what you expect. So maybe I should not go into these techniques, but these types of issues with like when you shift by A and then you shift by B, you get not just a shift by A plus B, but a shift by any numbers which is equal to A plus B. It is very important. And whenever you have to deal with degrees, you have to be very careful. to be very careful um don't do not care about definition proper definition definition properties just uh give as many variables as you so uh the overall um project was like this uh so da is a triangulated category so this is obtained we can redefine the x group so if we know that um category of sheaves are abelian which is in the liquid tensor experiment Which is in the liquid tensor experiment, then we may define group shift homology. We may also define the life functors, and I have ideas using another paper in French by my PhD advisor, Bruno Can and Georges Mass Lutis. So I have a very precise idea. It's a very nice paper. If someone is interested in two categories, there is very much scope for the implementing notions due to guitar. Uh, notions due to guitar. I'm afraid the original sources are also in French. Um, but the problem is really the mathematics. I mean, this is really hardcore two categories. But um, I have extracted from that an existence theorem, a formal existence theorem for derived functors. And I was able to check that if you derive a triangulated functor, it is going to commuse with shift. It's small here on the diagram, it's very huge in terms of headache I had. I had. Okay, so maybe I should stop here. So, thank you very much.