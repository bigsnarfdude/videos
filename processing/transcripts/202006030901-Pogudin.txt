Indeed, Nikki had to cancel her tutorial, but she has sent the slides to me, and I will post her slides together with mine. So you can look up what she was going to say. There's a bit different things, but different points of view on the same story. So it's also very interesting. I hope maybe she will come back to us and we can arrange some discussion about this. So, yes, I will talk about structural. So yes, I will talk about structural interfability with a goal to reach some recent connections to model theory. This is my plan. So first I would like to talk about what is structural identifiability, why it's important, where it arises, how people deal with it. Then I will describe you in more details one particular classical approach of studying these properties. Of studying this property, structural densifiability, using differential algebra. And we'll point out one important subtlety with this method, which in the third part, when we interpret this in modothatic terms, will turn out to be not a subtlety, but actually an extra nice feature. And if time permits, I'm not so sure, I will talk about open problems. Otherwise, I will post slides and we can talk about open. I will post slides and we can talk about open problems over coffee break. So, what is an identifiability? I would like to illustrate this notion on two toy examples. So, consider the following model. The following model is exponential growth. So, x is a function, k is a scalar parameter, and x dot is equal to kx. Now, we will assume that x is something X is something we observe in the experiment. So we have a curve. And K is actually a parameter we would like to infer. And the question is, well, at least in principle, if we observe this function x without any noise, with very frequent measurements, can we find out the value of k? And the answer is yes. So I can. So I can express k from this equation. And this equation, k equals to x dot over x, evaluated at any time point, will give me the value of x unless x is 0 at this time point. But if we will say that we are interested in generic solution, and this is what we will say until the very end of the talk. So a generic solution of this equation doesn't vanish, at least at some point. At some point, and actually, in all points, then this expression makes sense, and I can find k. So I say that k is identifiable. Okay, so what does it mean to be non-identifiable? Let's consider another two example. So this is a model with two parameters, k1 and k2. And x is again a function. So again, I assume that x can be measured. We have. I assume that x can be measured, we have access to x, but we would like to know k1 and k2. And well, I think it should be intuitively clear that it's impossible, right? They are together. So the only thing you have access to is actually k1 plus k2. So you can't find them separately. And then it will say that these parameters are not identifiable. Okay, so here I would like to make two remarks. First is I didn't give you a definition of identifiability. didn't give you a definition of identifiability, and I will not for two reasons. So, first of all, it's like the definition of the analytic property is pretty involved because you have to take care of all these generic assumptions. And what one can prove, this is a theorem, not non-trivial theorem, that it's actually equivalent to having such expressions. So the parameter is identifiable in a model if and only if you can write it as some rational function. Write it as some rational function in things you can measure and their derivatives. So, but this understanding on these examples, I hope, should be enough for this talk. So, now let me explain why do I care about these properties? So, it's a common problem that several parameter values fit your data. And there are multiple reasons to this. And I would say that there are two extreme reasons. One is that you just have a bad data. If you have a bad data, well, you have to get more data or you should have better data or better measurements. Another possible cause is this non-identifiability phenomenon. Because in the equation in the previous slide, Equation in the equation in the previous slide, in the second one, whatever measurements, whatever accuracy of measurements is, you cannot find K1 and K2 separately. So, non-identifiability means that you actually should either change the model or change things that you observe. So, by new telescope, instead of microscope. And importantly, you know that your data is bad usually once you get it, and you can know that your model is. That your model is structured identifiable, just looking at the model with pen and paper, or at least with a computer. So it's important to know in advance that your model is identifiable before you will go and spend some time on trying to use it and identify the parameters. So this is the motivation. Is this really an issue? From my example, you might get the impression that, well, nobody will write such a system. Nobody will write such a system k1 plus k2 instead of just one parameter k. That's that's that's that's stupid. Uh, but I will show more examples later. Uh, this issue can be hidden pretty well. So just let me show you a couple of papers. Of this one is actually by Josh Creshen, who is one of participants of the workshop. And this is a paper about biodynamics and interfability. And this is my favorite one about animal modeling and diffability. There are actually papers. There are actually papers ideas on the febility of models about cows and how they produce milk. So I would like to introduce one more notion that will be sort of in the middle of identifiable and non-identifiable. So here I have three models, three models. So in the first one, so in all the models, k1 and k2 are parameters I would like to know. K2 are parameters I would like to know, and x is a function I can measure. So, in the first one, the parameter k1 is identifiable, I can just find it. Second and third one are not so good. So, the third one we have seen already. So, you just know the sum of k1 and k2, and you can not get your hands on one of them separately. And the second one doesn't look so bad, right? So, in the second one, you have two options for k1 plus plus. One plus depending different by a sign, and it makes sense somehow to distinguish between this situation, which one is bad and another one is not so bad. And what actually people say is that in the first case, parameter key one is global identifiable, in the second, it is local identifiable, and only in the last case, it's not identifiable. Okay, so not identifiable if you can have infinitely many values generically. Values generically, locally, if you have finitely many values, and globally, if you have a single value. So, what can we say about these two questions of local and global interfability? So, for local identifiability, there is a fundamental theoretical result by Hermann and Freiner that is actually about observability, but can be ported to identifiability, which allows one to test local. Test local disability pretty efficiently. So there are several software packages for doing this. And the author of one of the authors of the last one, Strike Gold Alejandro Guillaverde, will give a talk tomorrow. And I think he will also mention this software. Moreover, in this case, in the case of lockdownability, people can ask more sophisticated questions. So these software packages, they can do more than just check the features because the situation is so. The situation is sound good. And also, there are many criteria. Actually, Nikki was going to talk about this. If you have models of particular kind, like linear compartment models, which are also built from a graph, like chemical action networks we have seen. For these types of models, you can get just criteria based on their committer structure. So, model. So, for models that are built from graphs, you can often look at the graph and just say, oh, okay, it's identifiable, it's identifiable locally, locally. So, this is what we know about locally, and I will not talk too much about local defiability. I will focus on global diffrability. So, why? Why do I want to focus on the global difficulty if there was such nice software and nice results for local interfability? So, first of all, well, I would like to find the unique value of parameter, and this is what global difficulties are. Parameter, and this is what global disability is about. So, local disability is not quite there yet. The second reason is that if you have global detail, global non-denetility, so you have let's say two different values parameters, they will be, well, in some distance apart, and usual numerical methods for inferring parameters that perform local search will not really see this. Will not really see this. While if we talk about local detribility, if you don't have local densibility, usually your numerical methods will just become unstable, ill-conditioned, and you will notice this even if you didn't check for difficulty in once. So global difficulty is sort of better hidden. And at last but not at least, it happens. So there are actually interesting and important models. interesting important models where some parameters are defined up to finitely many values given the observations. I would like to show you one such example. So this is an epidemiological model, SEIR model. Let me just describe it a bit because I would like to point out some connections between identifiability and what the model is about itself. The model is about itself. So it's about modeling a disease, an infectious disease. So, and we, all our population, is split into four compartments, susceptible, exposed, infectious, and recovered. So, first person is susceptible, then it might get exposed. So it gets the virus, but not yet, doesn't have symptoms yet, and not yet infected. Then it becomes infected. Then it becomes infected and then it recovers, and after that, it has immunity to the disease. So, and these are the equations. So, and n is the total population which is constant. You can just sum up the equations and see, but the right-hand sides will sum to zero. So the equation, it's in some sense similar to the mass action kinetic. To the mass action kinetics. So, like in the first one, so beta is a coefficient that is responsible for transmission of disease. So, when susceptible and infected individuals meet, then there is some chance that there will be transmission. Then, eta is responsible for the rate in which exposed people turn into infected people. And finally, alpha is a rate in which infected people become recovered. Infected people become recovered. Okay, so all these constants, their rates, not reaction rates, like in chemistry, but have a similar meaning. Before talking about what do we measure in this example, I would like to emit some redundancy so we can actually get rid of R. So get a bit simpler system. So this system is equivalent to the previous one. And what do we measure? So, well, first of all, we know. First of all, we know Y1, our first measured variable. We will denote measured variables as Y's in this talk. Y1 is the total population. We just know it, and that's not surprising. And Y2 is that says that we know how many people are infected, but not quite, because, well, not all people go to the doctor if they are infected. So we know some proportion of infected people, and we actually don't know what the proportion is. Proportion is okay. So, this kappa is the proportion of infected people who go to the doctor. So, this kappa, alpha, eta, and beta are null parameters. And it turns out that, well, beta and kappa are actually not identifiable. There are infinitely many values if we have only these measurements. And alpha and eta, they are locally identifiable. So, there are finitely many options for them. Options for them, and interestingly, what it turns out is that you can find them as a pair. So you can know that these numbers are three and five in some order, but you don't know which one is which. So you don't know the is this one now, this one alpha and this one theta, or vice versa. And you cannot know this no matter how good the measurements are, as long as you measure y1. As long as you measure y1 and y2 only. And we'll see this phenomenon later. In chemistry, it's sometimes referred to as low-pass ambiguity, and I will show an example of a similar switching behavior. There are more examples in one of the recent papers of Maria Pierce-Camani, who is a participant of the workshop. There was an example, there were three possible values. There were some order three action on the space of solutions. Okay, so I just wanted to show that. So I just want to show that this we're not talking about empty set of objects, we're talking actually about a big and important set of objects. So what do we know about global interfability? So as you can see, they have pretty long history. Actually, the history goes back to the 60s. And several methods have been devised. Let me just say some words about each of them. So the Taylor series method. Method. What it does basically takes the output, these output variables, y's, the ones we observe, and computes the Taylor expansion zero and tries to find out whether we can express the parameter values from the Taylor expansion of the measured variable. And of course, the natural question here is: well, how far should we go in the Taylor expansion to be sure about our answer? To be sure about our answer. And there are especially with answering this question in full generality. There are two more methods, second and third. They are based on differential elimination. It is an log of elimination algebraic geometry, which is geometrically a projection. So when you have equations in two sets of variables, and you would like to get all consequences that do not contain. That do not contain subsets you don't like or you don't want to have. I will talk about this: the second, the input-output equations method later in more details, and then I will show what are the subsets and how this connection works. So, just to say that the first one has limited deficiencies, so it from my experience, it tackles usually pretty small examples. The second one is The second one is the theory behind it goes back to the PG thesis of François Olivier, my colleague in the Colbert Techniques. So it's nice because it splits the one elimination problem into two. So basically, instead of one projection, you make two, but the simpler ones. And the second projection is purely algebraic, not differential anymore. And there are two nice software packages based on this method. One is Combos developed by Nikki Neshkat, who Nikki Nashkat, who were supposed to give this tutorial, and another one is Daisy by Maria Pierce Kamani, who is one of the participants of the workshop. And finally, is a recent method developed by Hong Kong Kleeksiev Chinikov and Giap and myself. And we also have software based on this, and we are proud of it, which sort of combines previous three methods in some way. So you also, in some sense, look. Also, in some sense, look on the Taylor series expansion of the outputs, but differently. I will not talk about this today because I want to get to the third method and its model theoretic relations. So, this is how this part looks like. So, there is some theory, there is some software, but still many, many interesting problems can be tackled with existing methods and existing software. So, the work is largely on. Work is largely ongoing. Before you move on, Gleb, maybe there's a question. Jason White, you want to ask your question? Jason? Hello, sorry, time lag from Australia. Yeah, I just wondered if the lead derivative methods, if you would allocate that to any of those groups. I'm not especially familiar with the last group you present. Group you present, uh, well, I would say the lead derivative method uh is sort of a Taylor CS method because lead durative is a way you can get this Taylor CS expansion. Okay, I guess I think of it in terms of invariance, so thanks. Uh, Rahim, were there any other questions? No, no, you can go on. Good, good. Then I will move on to the third method. Uh, I would like to discuss it in more details. So, the input applications approach. Applications approach. Let me, before going to the method of the algorithm itself, let me first state what we want to do exactly. So our input is a system of ODs. So we have state variables x's. And we know that x dot is equal to some rational function of x's and unknown parameters. So we don't have direct access to x's and to parameters, so we don't know them. Don't know them, but what we know are output variables, these green y's, which are in turn rational functions of state variables and parameters. Okay, so it could be one of the state variables, or it could be as in the epidemiological model, state variable multiplied by a coefficient, or it could be something more complicated. So this is our input. And what we'd like to know, we'd like to know which To know which parameters are identifiable, or even generally, which rational functions of parameters are identifiable. So, which rational functions of parameters can be, in the generic case, uniquely inferred from measuring the outputs. And what you can notice is that identifiable functions of parameters, they form a field. So, if you there are something, two things that you can identify, if you can identify their sum and their product, and their Sum and their product and their quotient. So basically, there is a field of identifiable functions, and we'd like to find it. So this is the problem that is attacked by the input of Portuguese method. So what does the method do? I will show this method on a random example. So this random example is perverted pre-model. So we have two state variables, x1 and x2. State variables x1 and x2. So x1 are preys. Well, you can choose, but I guess it's mouse. And x2 are predators, this crowd here. So, and there is some natural interaction between them. So when it's also similar to chemical reaction networks in a way, when mouse and cat meet each other, then that could lead to decrease of the population of mice. Of the population of mice. And other round the population of cats might benefit from this medium. So there are four parameters here. And I was preparing this tutorial in a bit short time. So I would love to make queries about this because I often do this when I give this talk in person. I ask which of these four parameters is not identifiable if I tell that. Identifiable if I tell you that only one of them is. But yeah, I didn't do the quiz, so I will just tell you the answer that actually the only non-dentifiable parameter is k2, although it in the equation for x1, which we can measure. That's a little bit surprising when you first see this. And all other parameters are actually identifiable. Okay, so we don't know x1, have no chance to know it, and we know can. And we know can infer values of k1, k3, and k4, and therefore we can infer values of any function of them. So I will say that the field of identifiable functions is the field of rational functions in these three parameters. Okay, so how can we get such result using this input-output equation method? So it proceeds in two steps. So it proceeds in two steps. So step one, and step one will follow the advice of Ludwig Wiegenstein. So we will try to be silent about the things we can speak about. So in our example, in our case, we can speak about state variables, about x's, right? So what we can do, so we cannot measure them, let's just eliminate them, okay? So x1 and x2. So x1, well, in some sense, I know because it is. I well, in some sense, I know because it is equal to y, but x2 is not my friend. So, what I do, I derive a consequence of the system, oops, sorry, a consequence of the system that doesn't involve x's. So, it involves only y's, its derivatives, and parameters. There are algorithms for doing this, and there are theoretical grounds for doing this, as Dave will tell you in about an hour. So, but my point now is that. So, but my point now is that we can do this. So, we can actually find the minimal differential equations fied by y with coefficients and parameters. And this minimal equation will be called the input output equation. It will be just one equation if I have single y and if I have several y's, I will have the same number of these input output equations. And well, already at this stage, you can see that k1 is sort of in trouble. K1 is sort of in trouble because K1 just disappeared. Okay, and we will see that this is actually the reason why it's identifiable. Okay, so to summarize, so we have the system, we eliminate x1 and x2, the get equation only in the output and parameters. They are called input-output equations because they could be input functions, but I don't talk about input functions in this talk, not because this method doesn't work for them. This method doesn't work for them, just forcing priests. So there could be inputs. And the second step is: we'll look at this equation, this equation we got in the previous step, and extract its coefficients if we consider it as a differential equation in y. Okay, so we have one here, k4, k3 minus k1, and so on. And so we can make sure that one of the coefficients is one, as it is here naturally. And then what we can say. And then what we can say is that if we evaluate this equality at many time points, we'll get a linear system in the orange expressions. Okay, so what is written here, here, is a linear system in these orange expressions. And if this system was non-singular, we could find the values of orange expressions. So if you assume that it's non-singular, So, if you assume that it's non-singular, then everything, what is it, what is identifiable, will be a rational function in these orange things. Notice that from what we have seen so far, what I can conclude is that all these orange expressions are identifiable, but there is a theorem that says that in the case of non-singularity, it's actually an accordance. Okay, so if this matrix is. Okay, so if this matrix is non-singular, so in other words, well, it's not exactly in other words, but or if we know that these coefficients are identifiable, then they actually are the generators of all identifiable functions. And under these assumptions, we are done. Okay, so this is basically the method. You eliminate state variables, take efficiency, and here you are. You have the generators. And if you're interested in one particular parameter, you have to check. One particular parameter, you have to check whether this parameter belongs to the field joined by them, and you can do this also with computational algebra tools. Two important remarks. One, which is the most important for us, is that this assumption is not always true. Okay, so this might happen, these coefficients are not identifiable, and then we don't get an answer. And that's a subtlety. That's a subtlety I mentioned earlier, and this will be our main concern in the next 20 minutes. Another remark, which is sort of hinting what will come next, is that these coefficients in model theoretic term are called canonical base. So, sort of they have a name. So, some method in applied algebra and in all model theory. Algebra and old model theory, they call the same object with some special name. So that's already sort of a sign. So now I would like to talk a bit more about this assumption because it's a central thing, right? So if this assumption was always true, we would have a nice, really, really nice, beautiful algorithm. If it's not true, then we're in trouble. So let us look at the example when it's not true. I will build this example step by step a little bit. Step by step a little bit. So, first, I will consider a twisted harmonic oscillator. Okay, so these are equations. So, x1 and x2 are state variables, and I measure y, which is equal to x2. And I have two parameters, omega and alpha. So, if there was no alpha, or in other words, if alpha was zero, this would be the usual harmonic oscillator. But I just twisted a little bit, so add some small thing. And in this case, actually, the method. In this case, actually, the method works pretty well. And in this case, you can perform this elimination by hand. So, if you will differentiate this equation twice, you will get first you'll get x2 dot x1, then we'll get x1 dot, which will be x2 multiplied by some expression of parameters. And in this case, well, y and y double dot are actually independent functions, so this coefficient. So this coefficient is indeed identifiable, but it's not enough, right? I mean, if you know the value of omega times omega plus alpha, you have one equation for two variables. So you have infinite-main solutions. But at least we get correct results, so they are not needable. Now we will assume that alpha is known. So we don't know the number right now, but we just know that there is also a separate equipment that can measure alpha. Measure alpha. So, how can we encode the fact that alpha can be measured? There are several ways. Let me choose this one. So, I will just say that: okay, now alpha is a separate state variable which has zero derivative, and it can be measured. So, I add it as a second output. Okay, so I have two outputs. One is my original output, which is x2, and another one reflects the fact that I can measure this constant function, constant function alpha. Alpha. What will be the input-output equations in this case? Well, in some sense, you can get one of them from this one. Basically, you replace alpha with y2, because y2 is equal to x3, and x3 is our new name for alpha. So this equation is obtained from this one by replacing alpha with y2. And the second equation just says that alpha is constant. So these are the input of the. So, and these are the input equations in the appropriate sense. And what you can see, well, you have coefficient one here, and you have omega as a coefficient. So, omega should be identifiable according to the method, but in fact it's not. Okay, so to see why it's not, let's think about the situation in more high-level terms. So, what is new compared to the new? What is new compared to the first case? The new thing is that we can actually know the value of alpha. So now we basically know what we knew before: omega times omega plus alpha, and we know also alpha. And these two things, they give you a quadratic equation in omega, right? So you have basically omega times omega plus alpha is equal to some c, and c and alpha are known. This is a quadratic equation for omega. Generically, it has two solutions. Okay, so in the Okay, so in fact, omega is only local identifiable, but from the input output equation, it looks like it's global identifiable. Okay, so this is the subtlety that prevents this input output equation method to be like universal algorithm that we can just run and trust it results always. Okay, and well, at this point. Uh, and well, at this point, you might say, Okay, there is a bug in the method. You had uh three more in your slide. Why should we care about uh investigating the subtlety and you know fixing this method in some way? There are several reasons to care about this method. Okay, well, reason number zero, it's actually beautiful, I would say. It's really beautiful, but there are other reasons. So, one is that it is used. I mean, there are two nice packages that have been. That have been applied to many problems of practical interest. And I mean, it's nice, it's great. A lot of work has been done. Second thing is that if the assumption I was talking about, that coefficients of the output equation are identifiable, or the matrix is non-singular, if this assumption is true, which is not always the case, then the method finds you all identifiable functions. And this is a And this is a key feature of this method. All other methods I mentioned, they don't do that. All other methods I mentioned, they just check a fixed parameter. So you say, I want this parameter, and they say, okay, it's identifiable or not. But this method gives you much more information. And this is the only one, okay, up to recent times, the only one method that could do this. There is just a very recent paper by me and Pele Exchange where they propose another one, but it's based on. Proposed another one, but it's based on the same applications actually. And finally, it's this subject is not a bug, it's a feature. And I will tell you in a few minutes what do I mean by this. Okay, so let me just summarize what we have by now. So there's identity problem. You have a system of bodies. You have some functions you measure. And you would like to know which expressions of parameters. Expressions of parameters can be inferred from your measurements. Okay, and there is an approach to this via differential algebra, with differential elimination, but I have just outlined. So you eliminate state variables and then work with the now purely algebraically with just algebraic geometry with the coefficients of them result of this elimination. And this algorithm has several crucial advantages, but there is some But there is something which seems like a bug. Okay, so this is a summary by now. And are I here? Any questions by now? Sorry, no, you can go ahead. There has been some discussion which I'll bring up after your talk. Okay, okay, okay. Oh, sorry. Oh, I'm sorry, I just. My apologies. I wanted to close the chat and declose the presentation. Five seconds. Well, I'm now so intrigued by these 20 messages in the chat. Okay. So now I would like to rephrase things I were talking about before in model therapy terms and Model theoretic terms and show how this talk in language model theory can guide us to in view, and in my personal opinion, very exciting result about this method. This is not the only thing you can do with model theory here. There are some other things that are not yet written down carefully and published, so I will not talk about them. I will focus on this one. Before I move on, I would like to say. Say a little bit higher level way, at least I think about this. So ultimately, the theorem I will state can be proved and can be understood without any model theory. Okay. However, first of all, we found like arrived at it by model theoretic thinking. And it basically what I will say grows from Say grows from a remark by Tom Scanlon, one of the collaborators. And somehow, this to the best of our knowledge, this didn't happen in last 30 years of using this method. Okay, so this shows something. And to build, to just sort of analogy, not complete, but still, in algebraic geometry, you can prove anything. Can prove anything using commutative algebra, purely commutative algebra, and at least almost everything. But you don't do this, right? You use language algebraic jams because it might make often more convenient, it provides intuition, and so on. And even more, even more exaggerating, we don't write programs in assembler, we write programs in more high-level languages, although we could write all programs in assembler, but our online conference would be impossible in this case, I think. So, in this case, So, in this case, also, I will introduce the language, and you can do this without this language, but at least I and my collaborators also think that this language is much more natural, and this is how we arrive at it. So, since I'm so constructed with language, I will first set up a certain dictionary connecting the terms from the previous part of the talk to the model theoretic language. So, our language is So our language in sense model theory will be almost the same as in the Dave's talk. So constant 01 plus multiplication and x is a symbol for derivative. So this is language of differential rings. And axioms of my structure, again in the sense of their marker, are axioms that I have a field and that the derivative behaves as a derivative is affected to behave. So derivative of the The behavior. So derivative of the sum is our derivatives, derivative of the product is five, 11th rule. And there is also the second part of axioms that I think they will talk and I will not talk that also can say that the field is so big that everything that could be there will be there. And this is a differentially closed field. And I will assume this. So I will fix some field. I will fix some field, and you can just think it as a field of functions, field of possible solutions of differential equations. And there are theorems that say that this thinking is actually correct to some extent. So I have just very, very, very big structure that can be found as a structure of all possible functions that has, you know, field operations and the digit. So now I will introduce some notions from model theory. I apologize to model theorists. From model theory, I apologize to model theorists. I will be pretty frivolous with these notions in the interest of time, and also I would like it's my understanding of them. So we can discuss more precisely this in coffee break. So I will need three notions. Two of them actually appeared so far in my or some previous talks. So the first notion is notion of type. Okay, so here is written uh formal definition. Let me explain it on an example. Explain an example in a moment. So, if you fix some subset of this big field case, so you fix some functions or some constants, then a type over this set is a set of formulas that can be satisfied. So the set of formulas such that there are elements of this big field, or in modeling terms, there are functions that satisfy these relations. So, for example, if we consider the paradigm-pray model, I will I will take k1, k2, and k3 be just the transcendental, very transcendental constants. So they behave like algebraic independent parameters. As I said, in my big field K, there are all the things. And then my equations of the Predator Prime model are a type, because it's a set of equations that can be satisfied. Okay? And then realization of a type. Realization of a type is just a solution of this system. So it's just a single element of k that satisfies these equations. Okay, so far, type can be a system of equations, and in this case, realization of type is a solution. Just translation, nothing more. Then I can talk about function being an output, right? Because I can take this system of equations and put existential quantifier in front of it. So I can say, okay, my function can be. My function can be an output of the Parato-Prey model if there are x1 and x2 such that the whole system is satisfied. Okay, I'm still in the first order language, so I just added quantifiers, so it's still a formula and it's satisfiable because I mean there are solutions to the system, so there are outputs. So in this case, type is a part of the solution, and realization is a function that is. Is a function that is part of some solution of this system. And what is very important, sort of important and convenient here, is that I can also turn this notions into generic ones. So basically, I can say that I can talk about a generic solution, which means that it is a solution. So I take all these three formulas, V1, V2, and V3, and I also And I also prohibit any other relations of the parameters. Okay, and this will say as a generic point of a variety in language logic geometry. Okay, so in language logic geometry, this would be an ideal and this would be generic point. And they can say the same about output. Okay, so basically any set of requirements on the function give you a type. Second thing is, the second notion is the notion of definability. So it was defined by Dave in a more general setup. I would like to stop for a second on this definition because it might look technical and somehow unrelated to what you're talking about, but in some sense, this is a definition for the intributes. So let me put it this way. So this B, I suggest you think B is a set of outputs. Okay, so output functions. And A is a parameter. And A is a parameter, so constant function which is equal to a parameter. And then A is definable over B if every automorphism of my big field, if it fixes B, then it fixes A. Okay, so in other words, if the elements of B, the outputs, are fixed, uniquely defined, then A is also uniquely defined. Okay, so it's like the identification. If you fix outputs, then if the value You fix outputs, then if the value of parameter is also becomes uniquely fixed, it's ideal. Okay, so it's really striking that it's basically the same. And even the name is similar. And just let me give an example how one could show this. So I have my exponential growth equation, x prime is equal to ax. And let's look at any automorphism of my big field of functions that fix. Of functions that fixes x. Then, since I had an expression of a in terms of x and x prime, I can say, okay, alpha of a is alpha of this. And since alpha is an automorphism, it commutes with arithmetic operations and commutes with derivation, and I get a. And you can think for a second and see that if I have even more complicated rational function, so a is equal to something bigger, I can play the same games because altomorphism. I can play the same games because automorphism commutes with any operations I have. And actually, there is a theorem, fact model theory. I think Dave will say something about this, that in differentially closed fields, differentiability actually is equivalent. Oh, yeah, I should be equivalent here. It's equivalent to existence of such relation. Okay? So these are all equivalent functions. Okay, so definibility is just modularity term for identifiability. Identifiability. And now the third ingredient are canonical basis. I will not give the definition of canonical basis from a model theory perspective, although there is one very enlightening, but I will just show it again on the example we already have seen. So this is the input-output equations for the predator prey model. So why, let me remind you, it's a number of prey, so number of mice in the terms of pictures I have shown. And then if If I consider the generic solution of this equation, generic output of this predator model, then its canonical base, it is a canonical base, will be these coefficients. Exactly the ones I was talking in the previous part of the talk. They are called canonical base. And it's a canonical base because any other functions that will generate the same field will be also canonical base by the definition. Okay, so for example, Okay, so for example, as we discussed, these functions generate the same field as k1, k3, and k4. So k1, k3, k4 are also important. Okay, so so far I was given just names, okay? So type is a set of conditions, realization is a solution, definability, identifiability, canonical base, coefficients of input-output equation. So here it is: coefficients as a canonical base of the output, alpha is identifiable, alpha is definable. Alpha is identifiable, alpha is definable over output, alpha is rational function in the coefficients, alpha is definable over the canonical base. Okay, so this left and right column, they are just translations, I'm just giving different names to the objects I have already seen. The goal of my game is to see the following. So there is crucial thing, the assumption that what I can get from the coefficients of the input and output equations is actually what is identifiable. Actually, what is identifiable? Okay, so this is the fundamental assumption of this input-out-output quasi-method, and this is not always true, as we have seen. So, this assumption is like some technical assumption in our administrative setup, but in model theory, it's actually there is also a name for it. Almost for it. So, I again apologize to all model theorists. There are some technicalities, which I will admit. Model theorists would say that. Would say that the type of the output is one-based in this case. Okay, so we were just building bijection. And then all of a sudden, our assumption turned out to have a name. So this assumption, and in a sense, our subtlety had appeared in model theory. And well, in this case, you know, here we had just a single assumption, and now it's in some context, it's one base. So there might be two base, three base. Based. So there might be two based, three based, and so on. And indeed, there are. So actually, model theories say, almost say, that type is n-based if the canonical base is definable from n independent realizations of this type. Let's translate this into our distributed language that n-based type is a situation and the coefficients of Kilmut output equations identifiable from n different solutions. And different solutions and different genetic solutions with different independent initial conditions. Okay, so this just means that these coefficients, you might not be able to get them from a single experiment, but from many experiments, you might get them. And actually, what one can prove now, because in model theory, what what is often the case is that every type is n-based for some n. And based for some n, at least in our good differential field setup. And so, what we prove based on all this is that the field jointed by the coefficients of this identifiable input output equations is exactly, I know that I'm a bit over time, I finished in one half minute, is exactly the set of rational functions that can be identified not from a single experiment, but from multiple experiments. Multiple experiments. Okay, so, and as a corollary, the input output equations method that I have presented is a correct, complete algorithm, but just for a different problem. For a problem of identificability, not from a single experiment, but from a series of experiments, which is actually an important problem and have been studied recently from different perspectives. Actually, again, Alejandro de Laverde, who will the speaker tomorrow, the first speaker tomorrow, had a recent paper with collaborators on this. Okay, so. On this. Okay, so we'll look for the model theory terms, and this model terms suggested to us that we should prove this theorem, which basically turns the problem, the bug and the method, into a feature. It solves an important problem, just a little bit different one. So, well, let me just run out. So, this is a harmonica citrus example, and what you can see here is that actually two experiments will give you the result that we got from. Will give you the result that we got from the input output ages method. Let me skip the rest. I will post the slides. And also, I just wanted to show there is, sorry, okay, so just I will pause on the slide for a second and just say some words. So there is a very simple chemical action network, which results in equations, linear equations with constant coefficients. So what could be simple? And in this case, the canonic, the diffusion from one experiment, The difficulties from one experiment doesn't give you K1 and K2. So, again, as in the epidemiology example, they can be switched. But the canonical base or the input of the equation suggests they could be identifiable, and indeed they are from two experiments. Okay, so just it gives answer just to slightly different question, which is in this case, for example, very natural because, of course, I can have two different experiments. I have just two bottles and put A, this chemical species and B. And put A, this chemical species, and B into them, no problem. Okay, just to summarize: so, what's that is structural denotability? It's an important problem, and it's naturally connected to algebra because it's structural. And computational differential algebra and those rigor geometry have been used for years to tackle this problem and to give algorithms. But it turns out that if you reformulate this in model theoretic terms and use model theoretic language, you can understand much better what these algorithms are doing. And actually, you can design new ones, but this. Design new ones, but this is not yet finished work. And I will not go into open problems now. Thank you very much for your attention, and my apologies for two minutes over time. Thank you, Gleb. We'll give Gleb a hand virtually. Before I open it. Aha, yes. I'll open for a few questions in a second, but first, let me just pick up on one of the discussions that was going on in the chat during your talk, which had to do about. Chat during your talk, which had to do about the inputs. So, both examples you gave didn't have inputs, and there was some question about the role they play, why some examples have them and some don't. Yes, yes. So, short question is that everything I have said works in the case you have inputs. I just wanted to make the notation lighter for this tutorial. And in some sense, inputs are your friends because Inputs are your friends because although they are functions, but they are known functions, and they're functions that actually you define. So they are usually your friends. They enter picture very naturally. Sometimes they bring some complications, but all the results I have stated, they are true for models with inputs. Okay, I see that Anand has a question, but go ahead, Anand. Yeah, so in terms of what Alex said, what Alex In terms of what Alex of what Alexei was saying in the chat, it looks like he was saying in the chat room that one way to. I haven't heard the chat, so if you could. Okay, no, he was just simply saying he was trying to answer questions about what the input things are. So it doesn't matter what he said, but the gist seems to be that, at least from the point of view of differential algebra or this kind of model theory situation, an input is something where you can simply fix that as a parameter and work over that parameter. Parameter and work over that parameter. Is that right? Well, here you have to be careful. So, parameter in the sense. No, I mean in the sense of model theory. You fix it as a name thing, you know, and you can with respect to that. I would say no, in the sense that when you can see, well, it's sort of natural if you have different experiments, you can impose different inputs. Inputs. So inputs in this case, they are more like a part of the solution, but you take them together with outputs as type your insert in. So inputs, they will enter. So in terms of differential algebra, inputs, they are things you will not eliminate as well as outputs. And mono theory type inputs are the things that you will take into the type you are concerned with. But then they are the outputs, so I don't understand. So, I don't understand. Then there are also the outputs. Yes, yes, yes. So, I don't understand what input/output means. Although I'm part of this project, I'm still, I don't, I don't get a mathematical definition. From the point of view of eventual algebra or model theory, inputs and outputs are sort of the same. They have very different meaning in terms of applications. However, there are some distinguished properties, for example. There are some distinguished properties, for example, all outputs, they are independent functions. You impose them whatever you wish, but once you fix outputs, then inputs are independent functions. Inputs are independent functions. And outputs, if you fix inputs, outputs, they leave certain fine-dimensional space. So in algebraic terms, you can say that outputs, sorry, inputs, inputs are the So inputs. Inputs are differential transcendence basis of your type and outputs are differential algebraic over them. Okay. Well, we could discuss it more. We could discuss it more. Okay, thank you. Other questions? I'll ask Jason White actually has a question if we can. Actually, he has a question before. Alicia had a question. Fine, Alicia. Okay, go ahead. Thanks for the introduction. You've given me a lot of motivation to learn about model theory. I just am not very familiar with a lot of what you went through at the end, but if I was looking at a setting where I have similar equations to what you have for a chemical system, but I have variables in it from a lab setting, and I might be interested in multi-experiment identifiability. Would you use the same language that you Would you use the same language that you use where you're talking about multiple experiments from different initial conditions to also talk about the influence of getting different outputs from those different experimental variables? What do you mean by experimental variables? Well, let's say you've got another variable in one of your equations, which might be some concentration that's held fixed in, say, a chemical system. So it's not a speaker. And you can vary between different experiments. Yes, that's right. Yes, that's right. This, well, I would say this sort of fits into the picture. Actually, in the canical example I showed very briefly, that was the case. So there was some parameter which was varying between experiments, some like chemical property. And you would use the same language, though, not just the sort of same technique. Same language, though, not just the sort of same techniques, but you would refer to it in a similar way? Well, at least I would try to do. I mean, it really depends on the particular problem at hand. So you can show me the problem and we can look at it. Thanks. In general, of course, I mean, this language seems to be helpful, at least in one case, so it might be helpful in other cases. I have no restrictions. Okay, I'm I am. Okay, I did realize I'm sorry I missed the question by Alicia before, but we are out of time. So if I can ask her to wait until the coffee session to ask a question, that would be great. Let's take a short break, and we have the second tutorial in two minutes. Let's take three minutes. That's a break. Thanks again, Gleb. Thank you very much. 