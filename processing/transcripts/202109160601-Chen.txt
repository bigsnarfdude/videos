It's really interesting. Many talk is quite new to me. And I also thanks for the organizers. I really wish we can meet in Hanzhou, which is also from this province. So it would be nice we can meet in my home province. And today I'm going to talk about this with theory. Actually, this theory is basically about how we can. Basically, it is about how we can prove or verify some commentorial identities or identities in terms of special functions and using a computer. So, this is kind of a theory which we are going to do, present. And I also will show some applications. Before I start in my talk, I see on the homepage of our workshop and mention that this workshop is That this workshop is dedicated to Professor Haoan. And Professor Haoan is really, he has a one of fundamental paper you can see here, and it's towards the mechanical mathematics. And as I already mentioned, Guinean, I think without Professor Hawan's work, I don't think our lab will exist. And our key lab was funded by Professor Wu Wenjin and Wu Wenjin, and he has a lot of work about the mechanical theorem proving in geometry. And for instance, there are many monographs written by Professor Wu. And our key lab is for the mathematics mechanization. So in a certain sense, it's very close to the proof and the computation. And my personal interest is research interest is about the symbolic computation and its application. computation and its application in comatorics or in the theory of special functions. And for many years I focused on some problems related to the Wief-Ziberger theory. And this is start from 1990s. And Wave-Ziberger developed an algorithmic algorithm for proving identities in chromatographics and special functions. And I think many people in the And I think many people in the high school already know many chromatographic identities, which is always very tricky. And we need to figure out how to interpret both sides of an entity using a comatological object. And then we can get a bijective proof. And then it's a lot of techniques to do this, like proving theorem in geometry, elementary geometry. You already need some ideas and techniques and tricks. Techniques and tricks. And many identities, I think people are familiar with, such as those identities. And nowadays, those kind of identities, we have a very routine way, which means a computer algorithm, which can verify those identities. Actually, the proof, computer proof, computer generated proof also is quite elegant. So not just identity which is involving some symbol. Also, the idea works. Also, the idea works for the integral identities. For instance, those kind of special functions and they also have some relation between different types of special functions involving some simple integral symbols. And those kind of identity for nowadays is quite, we can compute, we have a very well-developed program to verify those identities. And this theory, general theory is called a wave-dependent theory. General theory is called the Wife-Diabet theory and established by Professor Wife and Dieberg. And let me explain some basic idea between how we use symbolic computation tools to verify those computer identities. And the idea is kind of quite natural because, for instance, let me start from the telescoping techniques, which is scorpion techniques which is a very standard way how we can do the summation so once we have a given a sequence and the telescopy means we write this sequence as a difference of another sequence and you and we write this use the difference operator with respect to k and then this is something like in calculus we we we we we try to compute the primitive for the given uh function For the given function, then we can do the integration. This is the same. Once we have this g, if this is very nice, and then we can have the closed form evaluation of this sum. So this is like a discrete analog of Newton-Leibniz rule. Let me just show more some very concrete examples. I think in high school, at least for me, when I was in high school, teachers give me this excise. For instance, this end is. This excise. For instance, this n is 2021, and we are asked to evaluate this sum. And then the idea, we write this as a difference of this function, and then we use this nice formula, then we get a closed form for this one. This is when the summand is a rational function. But when the summand is quite complicated, like it involves some binomial coefficients, which is quite often appeared in computerics. Appeared in computerics. And then we needed to, or in the analysis of algorithms, we quite often encounter such kind of summation problem. And then for this example, probably it's not so easy by hand to find this kind of a nice G. This is the kind of perimeter of this given cement. And then after we obtain this, and then we get this nice closed form. So this one in the So this one in the coming slide, I will mention a very famous algorithm which due to Bill Gosper, and this also implemented in Maple and many other mathematical computer system. We can automatically compute such candle G if this nice thing exists. So this is the telescopian techniques, but life is not so simple because very often the semantic cannot write as The semantic cannot write as a difference of another nice sequence. So, in this situation, we need to do some creative things. We need to try to make something telescoping. So, in order to make this kind of telescoping happen, we need to use some extra information. For instance, if we are given a sequence in two variables and k is the summation variable and n is a certain parameter. And n is a certain parameter. And then we can try to do something about the parameter. We can start from like we can check whether f can be written as difference of another nice g if not and then we try to shift this n to n to n plus one. And then we try to find some linear combination between those shifts. So this is linear combination between the different shifts. So Sn, which denotes the S n, which denotes the shift operator with respect to n. So if you act S n to f, you will make f into f n plus 1 k. Now the idea is we hope we can try to, we shift this f with respect to n for several shifts. We try to find a nice linear combination of those shifts so that this linear combination is equal to a difference of another nice g. So we hope this. Nice G. So we hope this. But such, if such kind of linear combination exists, which is, if we write down, is a linear reference. And we hope the coefficient also polynomial to make things easier. And then if such a nice operator exists, and then we call this operator a telescoper for F. So which means this operator, when you apply it to the given F, you make the things telescopy. So this is somehow is Kendall Valley crucial. Can the value crucial notion in the theory of wave graphic theory? And let me take one concrete example. For instance, n choose k to the power two. For this one, you can run Gauss program or other techniques. You will see that this summand cannot written as any nice G, difference of nice G. So you need to do some shifts of this Ferengs or try to find a linear combination. Try to find the linear combination. And the linear combination is this one. You first shift F by one, and then you try to find the linear combination between F and the shift of F with this coefficient. And then you can get the nice G, which is of this form. So this is a binomial coefficient and also some rational functioning n and k. Let me see how we can use this kind of plate to telescoping tool. Uh, plate to telescoping to prove identities. So, so once you see these identities in comatorics, the idea is you integrate this both sides to make the both sides has a cometroleal meaning. Then we try to find a binomial bijective bijective between two controller objects. But for computer, somehow it's not so smart, they don't know how to figure out the controller meanings. The idea is. The idea to prove identity is the following. So you view both sides as a sequence of n. So when n is one, two, three, you first verify some few instance like n equal to one, two, three, two, ten. And you match the both sides. Then you kind of believe this is true. And now the idea to really prove is then you try to prove that both sides satisfy the same linear recurrence of a finite order. Linear recurrence of a finite order. And then, because you already checked some initial value, then you get the proof. So, then the question is: how we can find the linear reference for both sides? Usually, for a nice identity, one side usually is very simple, like this side, 2n, 2, and you can easily figure out the linear recurrence satisfied by this. But for the left-hand side, because it involves the sum symbol, usually it's not so easy to find the linear recurrence. And then this is. Inner reference. And then this is where we use the creative telescoping. Now you take this cement. This is our input. And our Maple Mathematical Azure package will bring you L and G. This is already automatic. And we have worked for many years in order to find a nice algorithm to compute L and G faster. So now for this semant, we have L and G. Now we can verify that because the by the because the by the because by null coefficient you know that when k less than zero k greater than n this is zero so you can rewrite this left hand side by relax some boundary of this some n boundary k you can that in minus infinity to plus infinity and now you apply this operator on both sides of this red identity since l only involve n and n so this commute with this So this commute with this sum respect to K. So now you can pull this L into this out. So, and then on the left hand, on the right hand side, because this is already a difference of another sequence and for already telescoping. So, it's easy to do the summation of the left-hand side, and which is equal to this. And for this G, you can check that this equals ZLO, this equals Zello, and there. Zello, this equals Zello, and Zello minus Zello is zero. So, what this means? This means the left-hand side of this identity satisfy this linear recurrence. So, if I write down the linear recurrence, basically, it's this one. So, usually this L is the linear recurrence satisfied by the left-hand side. And L is first order. In order to believe that this is true, you only need to check one initial value. So then you run the recurrence and both sides will generate. The recurrence and both sides will generate the same sequence. That's the proof for this, and without any commentorial interpretation. And this is the way we prove the identity by symbolic computation. But the main task for average computation is how we compute L energy. And there's more, that's just a very tall example. There are many, many more complicated identities which can. Complicated identities, which you can play the similar games, just the computation become more complicated, or you need to wait for one minute or more time. For instance, for this digsong identity, the idea is same. So you integrate both sides as a function of B. You choose one variable as the main variable, and then view as B as the discrete variable, and you try to show that both sides satisfy the same reference in B. In B. And then the idea is the same. So you compute the discontent telescopal error, which is also for this example still first order in B. And left-hand side is also quite nice, which is just rush function times the given semant. And then you play the similar game. Then you show that this left-hand side satisfies this linear reference. And now you need to check the initial value when b equal to zero. When b equal to zero, then B equals to yellow, then this is another identity, but free of B. So you need to play the same game for another identity, which is free of B. When B equals zero, disappear and this become, you can simplify a little bit, but it's still an identity. Then you play the same game to prove that both sides satisfy the same reference with respect to A. And then you specialize A equals to the LO. You get another simpler identity in C, and then you play the same game. C, then you play the same game. And I will not iterate this, but basically, the idea is the same. So the main task is to compute L and G. And another example is like this one. So this is a cement, and then you want to show that when you sum k from 1 to n, this equal to the harmonical number. And the idea is the same because harmonical number satisfies Number satisfy a very simple non-homogeneous recurrence, then the idea is the same to prove that this left-hand side satisfies the same reference, which is for HM. After the computation, and you get L and G. And then you do some little bit the boundary analyze. And then finally, you show that the left-hand side satisfy this reference. And this reference is exactly the reference satisfied HN. And then you figure out the both sides, the initial value also the same. I mean, for field n, you check this is true, and then you use this reference, then you prove that both sides generate the same sequence, and then they are matched. So then that's the proof for the identity. So basically, the idea of the behind this, you reduce the proof or transport the proof into a computation of L and G. There are more identities, and I think there are many, many advanced identities, which is something like recently I have done something from representation theory. Usually they have a multiple sum. This is one of the simple example. You need to show that this is true. And the idea is the same. You first try some initial case to believe this is true. For instance, like T equals Z law, you needed to verify this identity. To verify this identity. And then you need once you verify the identity, then you try to prove that both sides satisfy the same reference in T. And then this is the computation. And because the slice is so small, I just minimize those things. Maybe it's not quite visible. But anyway, the idea is the same. So you just do the computation and then try to show both sides satisfy the same linear reference. And then you check the integer values. And nowadays, we have a lot of in our community of Christian body computation, we have a lot of package for doing this computation. For instance, in Maple, we have this package for called Sun Tools. And this is one of the identity which is on a t-shirt of Doran Diaburger. And it is this identity. And now they actually, we have a command in Maple just called the Diaburg record. Maple just called the debugger reference. You take this summary as input and you specialize those parameters. And then they will output the reference for the left-hand side, which is for this example is also first order. And then you can check the right-hand side also satisfy this linear reference. And then you believe this is the proof because when you see the identity. When you see the identity, you usually will check some initial value. Otherwise, you will not trust this is true. So, the main task is to prove that both sides satisfy the same reference. I think this is quite a general idea for proving reference. And also for the integral identity is the same. And then the idea is to prove both sides, satisfy the same differential equation, linear differential equation. differential equation and then you check some initial values and then you then you believe that both sides are the same function uh also i already see that there are more uh more complicated identity which can verify the uh in the same way like this healer hardest identity which is quite useful in the analytical number theory and there are many handbooks which record many identities for instance those Many identities, for instance, those, and this is one of the Chinese books, which is for Olympic mass training. And when we were young, we do a lot of computer identity proving, use different techniques. But now I check that in this Olympic book, there's 116 identities. And I think I tried 18%. We can use this package automatically to prove those identities. Prove those identities. Also, there's a nice book by Gooden about the computer identity. Many identities you can use the same idea, the algorithm, to prove. So most of the, but then sure, the computerists will not really, they are really looking for computerial proof. But how to generate the computer proof, that's another topic. And this theory, we have the EBEX theory also. We have the Eyebrows theory also not just prove something which you already know in computer, but they also can solve many, many quite amazing conjectures. For instance, Derberger and his collaborators has showed two very famous conjectures in comatology, which is lasting for more than this one lasting for 20 years and this more than 30 years, something like this. And the key This and the key is always to prove some identities in this latte space conjecture which involve this identity. And another one is this one. So if you see their paper, they mentioned that in order to verify this identity, the size of the linear recurrence, if you store this in computer, is about like 400 megabyte. And for this identity, even larger is like eight gigabytes, so which is quite. Eight gigabytes, so which is quite big, and you need to trust the symbolic computation say that they already get the right operator. So, I think we this like the four color conjecture. So, you need to leave the computation, but I think that's nowadays people believe because calculus computer is more just when we When we do some computation, we usually use a computer. So we will not hesitate. Usually, we also have a formal verification to check all the computation is really done in a correct way. So that's the kind of very quick brief introduction overview of the view of theory. View of the V of the Abigail theory, and is the but now become more about the research work has been done related to in this theory. So I will present some state of art of this researches about this series. So I think as a mathematician, when you define some notion, such can telescope, and you will always curious about for which class of the object. For which class of the objects or sequence or inputs this kind of nice telescope exists. So, this is usually because we will try to figure out the function which is make this telescope exist. And also, as I already mentioned, the telescope actually has different types. If the input is a sequence in N and K, both are... In N and K, both are discrete variables. And then this telescope is a linear reference, and the left hand, right-hand side is a difference. And this is used for proving identities, commuter identities. But there are also different type, like if x, y are continuous variable, which is a continuous function in x and differentiable function in x and y. And then the operator will linear differential operator. And the right-hand side is the. And the right hand side is a derivative. And this kind of telescope can be used to prove some integral identities. And also, there are some mistype, like x is the continuous variable, k is a disk variable, and then the operator is a linear differential operator, and the right-hand side is the difference. And this can be used to evaluate some power theory like this. And also, there's more, like, if you have a Or, like, if you have a multivariable function with the variables belong to different types, and there are many different types of telescopers. So, as I already said, as a mathematician, we always will focus on this existing problem. Like we want to classify a certain class of functions so that this kind of nice operator exists. This is so-called existing problem. And also, as And also, as a computation or computer science, you already know this kind of operator exists, but you really want to prove the identity, you need a really construct operator. So you need to find a good algorithm to compute the telescope. That's kind of called the construction problem. And in order to solve those two, answer those two problems, a lot of the things will involve mathematical things and also computational things. And also computational things, we need to use a lot of knowledge to solve those two problems. Let me first mention some work related to the existing problem. Probably, but I think this will be quite a, I just will overview some things. So there is a in the beginning of this development of the theory, Diablo already showed that for so-called holonomic function, which is a function set. Function, which is a function satisfying a system of a linear differential equation of a certain type, which is so-called a holonomic system. And for such kind of function, actually, most of the special functions are in this class. And they show that he showed that this class of function always has telescopes. So his algorithm will always work for this class. And also, they have other so-called. So-called hypergeometric turns, and they also show that this kind of proper hypergeometer always has a telescope. So, actually, proper hypergeometric already cover most of the cement in the phalanochometros. So, a proper and holonomic both are a sufficient condition for the existence of telescope, but they are not necessary. So, and then the later on, Later on, some work about whether we can really detect, given the input, we can detect whether before we run the algorithm and we whether we can detect the existence of the telescope, which means we need to find a necessary and sufficient condition for existence. And this is, we start from the rational function. So nowadays, we know for rational input, we have algorithm to detect the existence. We have algorithm to detect the existence. And then this work was generalized into more general class of input, like bivary hypergeneral turns. And the Q-hypergener, Q-hypergener turns has a lot of application in the integer partitions. So there's the in the area of integer partition, there are a lot of identity which involve Q series. And then to prove those identity, we need this Q analog of a diagram. This Q analog of a zero-grade algorithm. And also, myself with my collaborator, we also solve some many classes in the missed case, which means some variable are continuous, some variables are discrete. So we solved the many missed cases. And that's the work. And now in this direction of research, and the previous work focused on the input are bivaried. And now we are moving our research towards the In our research towards the multivariable case. And we now, for this moment, we only can do the detection of the existence for rational functioning in three variables. And we still have a lot of open problems in the multivariable case. So this is quite a restrictive work. We now know how for Russian mark in three variable and for all different types, we know. And for all different types, we know how to detect the existence. But for more general class of inputs, it is still unknown. So, which means we don't know whether the algorithm terminates or not. And as already said that there's a very nice class of input which is quite interesting, computer, because this appeared quite often in computerics. And this is so-called mixed hypergeometric. Mixed hypergeometric. Probably I can define this in a quick way. So this is just a kind of a function or sequence which satisfies the first order linear differential or difference equation. First order, which means the Logan derivative or shift quotient are Russian function in this one. So mixed hypergenerons actually is just a certain kind of generalization. Certain kind of generalization of rational inputs. Actually, most of the functions we see in cometoric identities appear in combat identities are belonging this class, like rational function and hyper-expansion function, like exponential function and two to the n geometric sequence, and hypergeometric sequence, which is involved some factorial. This is quite important because so that you can get built-up binomial coefficients. built up binomial coefficients. So most of those four classes actually are hypergeomic terms. If you can check that those all satisfied first order either differential equation or difference equation. And there's a structure theorem we prove that actually the previous four class already can build up arbitrary hybrid mutants. So any arbitrary mixed hybrid mutant can be factored into the Be factored into the product of the previous four class of inputs, which we already well known. So, this is just mean we know the structure of this general input. And there's a more quite complicated notion which is called holonomic terms, which is I will not go to the detail of this definition. Basically, the idea is that if you Basically, the idea is that if you have a sequence, then you talk about the generic function of this sequence, then you get a power theory, and then holonomic city, which just mean this power theory satisfy a system of a linear differential equation, and whose solution space has finite dimension. So that's kind of a roughly idea. So, but the idea is that you want to check that this satisfied linear defines your equation, but then you need to. Differential equation, but then you needed to figure out all the possible differential equations satisfied by this power theory. So, basically, there are no algorithms to verify this kind of condition. And then in view of the epic theory, there's one of the main conjecture is how we can verify the input is holonomic or not, especially for this mixed hypergeometric terms. And then there are conjecture that actually, if this holonomic and this must be proper, proper, which means already in this. Proper, which means already in this previous junction, is in this very explicit form. So, this form we have uploaded to check like recognition a given term whether it's of this type or not, because it's already in a very explicit form in terms of four basic blocks. So, then the conjecture is that actually this complicated condition is equivalent to this explicit condition. And this is conjecture was recently. And this conjecture was recently proved by me and my collaborator. So that's the research about the existence. And then, as I already said, another kind of fundamental problem in this topic is if we know this kind of operator exists, whether we can have an efficient algorithm or whether a fast algorithm to compute it, to construct this kind of operator. And about the construction. And about the construction of the telescope, I think the history is quite long. Even though for the comator identities, the task is to construct the linear reference. But for the integral identities, if we try to construct this linear differential equation, I think the history at least can trace back to Picard-Fuchs equation, topical about the Picard-Fuchs equation. So this is kind of very Kind of very more than 100 years ago, and Pika actually studied a very nice class of integrals involving some parameter. And he tried to find a linear differential equation with respect to the parameter. And this is so-called a Picard-Fuchs equation. And actually, the idea to construct this kind of Picard-Fuchs equation is already the constructive way already presented in my idea presented in in in manin's paper about proving the the function function field analog of the model conjecture and the idea the one the concrete example which manin did did in his paper is for this uh this uh elliptical integrals and here the integral is respect to y so the x is a parameter and manin want to construct the second order differential The second order differential equation satisfied by this integral, and which is this one. And this is so-called the Picard-Fuchs equation for this elliptical integrals. And nowadays, actually, you don't need to do this by hand. The problem of constructing this equation can be translated to the construction of a telescope. And then later on, there are many, many works about how we can construct this kind of picture focus. This kind of picture focus in high dimensions, like some work by Griffiths. And many years ago, I have formulated this kind of problem in terms of telescopers. And then we have a more efficient way to do the computation. And there's definitely a lot of work. And also in this, there are many, many different approach to do the computation. One of the approach is based on the so-called One of the approach is based on the so-called elimination method. So elimination method, which is used in the study of polynomial system. And this kind of can be generated to the non-computative setting. So the idea is the same. In the non-computative setting, which involves some variable and some derivations, and this is a polynomial, it's not the commutative. And then the idea of the elimination is kind of similar like Is this kind of similar like in the polynomial system case? So, for this kind of two non-computing polynomial, which is the differential difference equation satisfied by the given input, we want to try to eliminate this kind of y. So then we get this operator A. So, this is, but this elimination is in the sense of a non-computative setting. And once you have this kind of y-eliminated operator, then you just evaluate this. Then you just evaluate this variable dy to zero. Then you can show that this is the telescope for the input. So the computation of telescope can be both done to the elimination problem, but it is unified algebra, not in the usual polynomial algebra. And this approach is kind of, in principle, can compute the result, but it's kind of very slow, so it's not quite efficient. And later on, one of the really Later on, one of the really nice approaches based on the Gauss program, which is very good for this hypergeometric input. And this is very interesting because most of the binomial coefficient identity, which is in this involve this kind of a sequence, turns. And in 1990, Anderberger presented a very nice algorithm, which is for this faster algorithm, which A faster algorithm, which is for this computing this telescope. And I will give a brief introduction later about the Gospel algorithm. And recently, the fourth generation of the algorithm is, we call it the reduction-based approach. And I will not explain all the works. And now, let me And now let me present what's really the gospel algorithm. So in 1978, Bill Gosper or William Gosper presented one very nice short paper, which is only three, four pages. And it answers the following question. So given a hypergeometric terms, and you know the binomial coefficient and geometric sequence are in this class. Sequence are in this class. And his algorithm can detect whether this input is the difference of another hypergener, and which means that the G is capital G is also nice. And for instance, for this K factorial and Gauss algorithm will tell you there's no solution, no hypergeometry exists. But if you multiply this by K, then this algorithm will output the K factorial. As already mentioned, that for this. As already mentioned, that for this input, if you do by hand, it's quite hard to find this one. So I think without any other idea, you will not figure out this G. But the Gauss-Bargon can help you to compute this if this exists. But also, Avrion will also detect if such kind of niceness does not exist, and they will return, tell you that this doesn't exist. So this is a gospel. And this is a gospel aggregate. And this is the Gauss algorithm. And this is the main step of the Gauss algorithm. I will just skip. And Diablo algorithm is based on the Gauss Braggland. So this is, and the input is a proper hyperometer, which make the existence of the guaranteed existence of telescopa. And then because telescopa is, in this case, is a linear reference. So the idea to compute, construct this L, you will. construct this L, you will try for L from order one, order zero, one, two, you will increase the order one by one. So the idea is you fix the order and then you write down write out the linear occurrence symbolically, keep those CI symbol, and then you will try to find the equation satisfied by this linear system satisfied by this CI. Then you solve the linear system, then you get the L. You get the L. And then the idea to get the linear system satisfied by this CI is go through the Gauss Braggland because when you apply this operator to H formally, and this is still a hypergeomic turn, and Gauss-Braggland can tell you whether this is equal to the difference of another hypergeomic turn. And if the Gauss Barglan tell you only when Ci are zero, then you get the nice G. Get the nice G, and then you increase the order by one, and then you run the algorithm again. So, as I already said, that this algorithm will terminate only when the telescope exists. So, it can happen that for some input in Maple or other computer agile system, and this algorithm may not terminate if the telescope doesn't exist. For more details, people can read this nice book. People can read this nice book, A equals B, is about proving identities. And my rational work in this topic is about the following thing, as I mentioned, we developed the so-called based reduction-based approach. And why we developed such kind of reduction-based approach? Because motivated by the following example. So for this kind of input and this telescope is kind of very simple, it's first order. Simple is first order and with those coefficients. But the certificate, which is on the right-hand side, is quite big. But for many polynomial proving identities, we actually don't need this kind of big object. So then the idea is how we can avoid the computation of this big output, which is not needed for many application. For many applications, so this is why we this is so-called we are telescoping without certificates, and then that's the many work we have done in this direction. So, we started from the simple input, so-called rational function, and we based our result, our algorithm on the very classical technique due to emit. And then, in the multivariable rational case, we use some work. We use some work from Derwerk and Griffiths, and then also other works. I will not explain more about this. I think, and before I finish my talk, let me just mention there are many, many software already has been developed in this topic. So you really don't need to do the computation by hand. And there are many efficient algorithms already implemented in different computer. Implemented in different computer algebra systems. And for instance, this is for the, if you try to compute the pickup fox equation, and you can use this in Maple, you can use this DE tools. And for proving identities, you can use these SAM tools. And then for that other, my personal developer is called Hermiter package, CT package, which will be, if you really encounter some very big complicated identity. Complicated identities, you need a more efficient algorithm to compute telescopes. You can use this package, and also in Mathematica, there are also many packages. I think I will advertise this holonomic function package, which is quite powerful, which is developed by my collaborator Christopher Kuchan in Mathematica. Also, there's other software you can use. And also, nowadays, there's also free software. And also nowadays, there's also free software like Sage. I didn't mention here, but in Sage, there are many packages have been developed to do this thing. So let me just summarize my talk. So actually, in this topic, and we are really care about how we can detect the input has a telescope because this guaranteed the termination of the diabetical algorithm. And then we also try to, in order to do really. try to in order to do really uh for to prove really do the proof uh in the computerics we need to develop a very efficient algorithm to compute uh this nice operator but in our topic actually uh most of the identity if only involve a simple uh summation then uh the existing uh package is quite efficient but if you some identity already see is involved some identity already see is involved some triple uh sum or multiple sum and then for this moment the many packaging is not so efficient for for for proving uh for the computation so there's a kind of very natural open problem in our topic is how we can generalize this gospel gospel algorithm uh from univariable to bivariable or multivariable case and uh i think this is uh And I think this is as joining Jian Carlota said, when you are listening to talk, if you cannot understand anything, but maybe you can take one problem back home. Probably this is a nice open problem you can take home. It's not so hard. You're given a sequence you want in this called a hypergenomic case. You just believe this is like a binomical efficiency. And then how you can detect this sequence can be. This sequence can be written as a sum of two differences: one is relative to n, another with k. Maybe you can try to figure out this question. Then you will help us, at least help our community to speed up the computation. Thank you very much. Yeah, thank you very much. Okay, um, we have actually Have actually plenty of time.