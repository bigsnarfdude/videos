So a great pleasure to introduce Amir Watt. He will be the partner to write algorithms for recognition programs. Yeah, you have a floor. So thank you. Thank you. So first, let me let me. So I don't think it's going to be two hours. Hopefully, I will not take the full two hours, but it's a long talk because there's a lot to cover. Lot to cover. But first, let me start by thanking the organizers. I don't want to forget anybody, so just let me thank all the organizers for all the effort and for keeping this community growing year after year. It's really great to see this happening year after year. So the first time I attended CORE, I was a student. And now I actually have students attending CORE. So it made me realize that I'm getting old. So, but that's not the topic of the talk. Uh, so yes, so thank you, everybody, and it's really great to be here. I wish I was on site, but it's okay. That's second best thing. So, the talk is going to be a survey about reconfigure parametrized algorithms for reconfiguration problems. So, please do stop me, interrupt me at any point in time. I would love to take questions while we go. So, so, so, this is. We go so so. So, this is a tutorial. So, please do interrupt whenever if I don't go too fast, if I say something you don't understand. This is a survey of a lot of results that I will not properly reference during the talk, but all of this can actually be found in a very recent survey that we put out on archive, which is work done by Nicola, Naomi, Sebastian, and myself. And myself. So, everything I will say today was actually put in writing, and you can find the survey on archive. It was uploaded very recently. Okay, so let's get started. So here's the outline of the talk. I'll give a quick introduction about reconfiguration, of course, since we've seen it so many times already, but I'll also introduce quickly parametrized complexity and the problems that we will be looking at. And the rest of the talk is divided into two. The rest of the talk is divided into two parts. In the first part, we will talk about almost everything we know on the parameterized complexity of independent set reconfiguration under both token jumping and token sliding. And then the second part of the talk is going to be about everything we know for both dominating set reconfiguration and connected dominating set reconfiguration under both token jumping and token sliding. And when I say everything we know, I mean parametrized complexity-wise. mean parameterized complexity wise and i'm gonna focus mostly on one parameter because this is the one that's been studied the most and we will um i will basically define all of these things formally as we go all right so quick introduction so the way i like to look at the configuration which is i mean it's it's it's just a different uh side of the same coin so we all know the st reachability problem so ST reachability problem. So you're given a graph, n-vertex graph, you're given two vertices, s and t, and you have to decide if there's an st path in g, right? And this is like one of the most fundamental graph problems. And in this eternal battle of tractable versus intractable, or p versus n p, this is one of those nice problems that is on the tractable side, meaning we can solve it in polynomial time. Right, so but now what happens if instead of this n-vertex graph that we're given part of the input, we have a two to the n vertex graph, right? So now we have a humongous graph, but we're still trying to answer the same question, right? So we're trying to answer, is there a path from s to t in this humongous 2 to the n vertex graph? Now, of course, you can no longer assume that the graph is part of the input because that graph alone is exponential in size. Alone is exponential in size. So instead, you can basically imagine having a polynomial size encoding of an oracle that, and the oracle can answer some questions in polynomial time. And for us, the two important questions that the oracle needs to answer is, I give this oracle some vertex and it has to tell me if it's in the graph or not. And you can think of this as some configuration. And the second type of question that the oracle needs to answer. Type of question that the oracle needs to answer in polynomial time as well is if I give it two vertices, it has to tell me if there's an edge between them. Right? And I call this problem oracle reachability. So you're basically given the oracle input of some super polynomial size graph, and you're given two vertices. And now again, you're asking, is there an ST path in this huge graph G? And many, many reconfiguration. And many, many reconfiguration problems, and all the ones that we're going to be talking about in this tutorial, are actually ST Oracle reachability problems. And I'm going to be focusing on a reachability question in this talk anyway. All right. So what are the problems that we're going to focus on? We're going to focus on vertex subset problems, right? So it's basically problems where you have to find a subset of the vertices of the graph, and this subset has to satisfy some properties. Subset has to satisfy some properties. And we're going to look at independent set reconfiguration under both token jumping and token sliding, dominating set, and connected dominating set. Now, for those of you who don't, let me define those problems just in case somebody hasn't seen some of them before. So in the independent set problem, you're given a graph G and an integer K, and you need to decide if the graph has a set of size at least K, that is a set of vertices of size at least K, such that the vertices. At least k such that the vertices are pairwise non-adjacent. And now, of course, in the reconfiguration version, you're given two independent sets of size k, and you need to decide if you can go from one to the other using either token jumping or token slide. We've seen token jumping and sliding already, so I will not redefine them here. Now, in the dominating set problem, again, you're given a graph and an integer k, and basically you need to decide if there's a set of at most k vertices such that At most k vertices, such that every vertex in the graph is either in the set or adjacent to a vertex in the set. And again, you can define the 2D configuration variance in the natural way. And then in the connected dominating set, it's the same as the dominating set problem, except that we also require that the set must be connected. So the set of k vertices must be a connected set. And these are problems that are very widely studied. That are very widely studied in parametrized complexity. I mean, so it's, there's a lot of work done on the non-reconfiguration versions of those problems in parametrized complexity. And I'll say a little bit more about that later. But and the reason I think, I mean, these are like very interesting problems to look at is because, I mean, even though they are all vertex subset problems, they kind of have different types of properties. And what I mean by that is that independent set is a very local property. Independent set is a very local property. I mean, it's something that you check pairwise between the vertices of the set. Whereas dominating set has more of a global-like property, where it's something that has to hold, there's something that has to hold about all the vertices in the graph. And for connected dominating set, you additionally have connectivity constraint. So these three problems seem to have different types, seem to be encoding different types of properties, at least, to check. To check. And so that's why, like, when you want to study those problems, at least studying those problems from the aspect of reconfiguration is interesting because we can see how those differences are going to basically show up in the complexity of those problems. Right? And I'm going to talk a lot about tokens in this talk. So, because I view any solution as a set of tokens placed on k-verse c's of the graph. Of the graph. Okay. So notice that, of course, if you want to lift this back to the Oracle view here, the Oracle needs to check if a token configuration is a feasible solution and if two token configurations are adjacent under sliding or jumping. And this can easily be done for all NP graph vertex subset problems, right? So the oracle view of the problem fits very well here. Okay. Okay, so which are what are the two big, big questions, which are good we're still very far from answering, but at least like it's kind of a view from 10,000 miles above. So from in standard complexity, one can think of the big question in reconfiguration, one of the big questions is for which types of articles is the reachability problem in P versus NP complete or versus P space complete? Like, can we have some sort of classification from which we're From which we're still very, very far, but hopefully, we'll be getting closer as we solve more and more problems. So, can we kind of have a classification depending on the types of articles? And you can take that same question and lift it to the parametrized complexity world. And you can ask for which types of articles and which parameters does the reachability problem become FPT versus W hard or worse. So, in this talk, I'll focus on FPT. So, in this talk, I'll focus on FPT versus not FPT. So, if you don't know LW hardness, it's okay. We're not going to worry too much about that. Okay, so these are the two very, very, very big questions. And so the purpose of this talk is to show some progress towards the second question, but it's really negligible progress. We still have a very, very long way to go. But what I'll hopefully show you is that already there, there's a lot of very There's a lot of very interesting questions still to be answered. And there's gonna be a lot of open problems spread out during the talk. Okay, just a few words about notation and parametrized complexity. So any instance of our problem, of any of our problems, is gonna be a tuple GK SSST, meaning G is an n-vertex graph, K is the number of tokens, S is the source configuration. S is the source configuration, ST is the target configuration. And the question is always going to be: is there a reconfiguration sequence from the source to the target configuration based on the model, depending on whether we're doing sliding or jumping? And it's going to be obvious, so don't worry about it. The parameter for this talk is always going to be k, unless I say otherwise. So it's going to be the number of tokens. And we say that a problem is fixed parameter tractable if we can solve it in f of k times. bit in f of k times some polynomial in n time. So for those of you who are not very familiar with pattern charge complexity, just think about it this way is that if you're trying to solve any of our problems for sets that are of constant size, so say for independent sets of size 10, dominating sets of size 10, or connected dominating sets of size 20, then if such algorithms exist, this means they can be solved in polynomial time for those small values of the parameter. For those small values of the parameter, right? Because the exponent on the graph size is independent of k. Now, of course, the function f, we expect it to be exponential because these problems are going to be hard. But we're not going to focus on optimizing this function. For this talk, it's more about proving the existence or the non-unlikely existence of such algorithms. Okay, when such an algorithm with such an running time exists, we say. The most suction running time exists, we say that the problem is FPT. Otherwise, the problem is intractable, and usually it's we can show that it's W hard via something called FPT reductions, which is the analog of the P versus N P question classes, right? So just think about FPT being the equivalent of P and W hard being the equivalent of NP. For the purposes of this talk, this will be more than enough. And a final note. And a final notion that is super useful in Paramtra's complexity is that of kernelization. So we say that a problem admits a polynomial kernel whenever we can, in polynomial time, reduce the whole instance size to some function of the parameter, some polynomial function of the parameter. And that would imply a polynomial kernel. And why is this useful, and at least why it will be useful in this talk, is that because when you can do such a thing, That because when you can do such a thing, then the rest is just trivial. You can brute force on the kernel to solve whatever problem you're trying to solve. So if we are able to reduce our input size to some polyk bits, then the rest becomes just a trivial brute force, as long as we're not trying to optimize the functions, of course. All right, so so you can also be a lot more careful about how. More careful about how what you do once you kernelize, but for the purposes of this talk, we're not going to go into those details. All right, so what do we know? We know that independent set, the underlying problems, and dominating set and connected dominating sets are all W1 hard problems parametrized by solution size on general graphs. Meaning, we don't expect FPT algorithms for these. Expect FPT algorithms for these problems. So we don't expect algorithms of this running time form, right? Where the exponent is independent of the parameter, exponent for n. However, I mean, these are easily solvable in n to the k time, right? I mean, roughly n to the k time. And this is yet another complexity class, but let's not go there. This is called XP. But these problems are known to be hard on general graphs. On general graphs, like unlikely to be FPT. So, over the past maybe 20 years, there's been a lot of work to try to understand. So, what happens if we look at those problems, those three problems, independent set, dominating set, connected dominating set, on sparse classes of graphs? And what I've shown here really is an inclusion tree of various sparse classes of graphs. So, some of the families. Of graphs. So, some of the familiar ones would be bounded degree graphs, which are at the bottom left here. There's chordal graphs of bounded clique number, which are a subclass of bounded tree-width graphs. You have planar graphs, which are a subclass of bounded genus. And then you can start going higher where the definitions become more and more annoying. H minor free, H topological minor free, bounded expansion, then bounded degeneracy, no air dense graphs, and all the way at the top. Dense graphs, and all the way at the top, which includes everything below, is bike leak-free graphs. It's those graphs that exclude some bike leak, where a bike leak is just a bipartite graph with a fixed number of vertices on each side. So this would be a bike leak-free class of graphs if it excludes it as a subgraph. Okay, so, and these are all known parse classes of graphs. And why am I? And why am I mentioning those here? It's because it turns out that these three problems that we're looking at: independent set, connected dominating set, and dominating set, are fixed parameter tractable. They are FPT when you parameterize by solution size on all these classes. Right? And this took several years of work and pushing the boundary and pushing the boundary further and further. And now we have it all the way on by click free graphs for all of these problems. And now, I mean, All of these problems, and now I mean, people are even going beyond that. I will say a few words about this later in the talk. Okay, so the motivating question here is, so, okay, so this is nice. This is a nice positive result. These are, I mean, this is a lot of graphs, right? These classes include many, many, many of the graphs we're interested in. So, the question, which we don't have an answer to, is: so, what happens to the reconfiguration? So, what happens to the reconfiguration variance of those three problems on those classes of graphs? So, is there some sort of parallel between the actual complexity, parametrized complexity of the underlying problem and the parametrized complexity of the reconfiguration problems under any model, but we're keeping the same parameter, right? We're keeping the parameter k, the number of tokens. And for the rest of this tutorial, And for the rest of this tutorial, I'm going to show you what it is that we know how to do, and what is it that we still don't know how to do going up this tree of inclusions for sparse graphs. We're going to start easy and things will evolve towards higher levels of this tree. Okay, so I guess this would be a nice place to pause and take questions if there are any before we jump into our first. Before we jump into our first problem, Amir, you mean by click free in the minor order, right? Biclick free as a subgraph. Thanks. And the minor order would be H minor free. It's down here. Yeah, I thought it would be too restrictive if you do it in the subgraph. Okay, so let's start with independent set reconfiguration under token jumping. All right, so we're given two independent sets of size K. We want to know if we can go from one to the other by jumping tokens one at a time. And I will call it ISRTJ. Okay, so first, let me show you a very trivial reduction that. Trivial reduction that shows that on general graphs, there's not much we can do. So on general graphs, you can easily show that the problem is hard by reducing from independent set itself, which we know is W hard, W1 hard, in fact, so unlikely to be FPT. So how does the reduction work? Well, you start with an instance of the independent set problem. The instance is just a graph G and an integer K. And what you do is you just basically And what you do is you just basically take a copy of G, add to it a bike leak of order K plus one, meaning it has K plus one vertices on each side, and you set your source independent set to be L, or the left part of the bike leak, and your target independent set to be R, the right side of the bike leak. And now notice because this is a bike leak, if you want to jump any token from L to R, you need to make sure that everybody has left L. To make sure that everybody has left L except one token, which means that you will have at least K tokens in G, which must form an independent set, and you're done. Right, so very easy to show hardness for these problems, at least W hardness in this situation. And notice just a side remark: I mean, if the independent set problem was solvable in FPT time on G. Solvable in FPT time on G, then this reduction would fail, which is the case for all these sparse classes. This is just a side note. Okay, so it's hard on general graphs. Fine. So let's go back to this tree and let's look at graphs of bounded degree. So let's look at token jumping, independent set token jumping on graphs of bounded degree. So here's the proof that the problem is actually fixed parameter tractable on graphs of maximum degree. Graphs of maximum degree delta. This is the full proof. So just look at your initial and target independent sets, which I'm talking, I'm calling here IS and IT. We know that their union is of size at most 2K, right? Because these are two independent sets, each of size at most K. Now look at the neighborhood of IS union IT. This has size at most 2K times delta because Almost 2k times delta because delta is the maximum degree of the graph. There are more edges in the graph. I just drew a few of them here to show that where the edges go from, between which sets. So now look at the remaining part of the graph, which is BG minus the closed neighborhood of IS union IT. Now I claim that if this part is big enough, then we're done. And what do I mean by big enough? And what do I mean by big enough? I mean if this, the part, the non-neighborhood of IS union IT, if it has size k into delta plus one, then we can find an independent set of size k. And how do you find this independent set? You just find it greedily. Pick a vertex, remove it and its neighbors from the graph. This removes at most delta plus one vertices. And repeat this k times, and you can repeat it k times because you have at least k into delta plus one vertices c's. Into delta plus one vertices. So you can greedily construct an independent set of size k. And when you have such an independent set, this is immediately a yes instance. You just jump from IS to this independent set J. Let's call it J. And then from J, you can jump to IT, and you're done. So when the non-neighborhood of IS union IT is not big enough, then the whole graph has bounded size and you get a kernel. Get a kernel, which means now that you can brute force on the rest of the instance because now the whole graph has size at most 3k into delta plus 1. 2k for is union it, 2k delta for their neighbors, and now k delta plus 1 for the non-neighbors. You add those together, you get that the graph has size at most 3k into delta plus 1, and you're done. Not too hard, right? So, so, so. Right, so so, so, and this is known as the buffer technique. Right, if you can find a large enough buffer somewhere, you can jump to it and then jump to your target, and you're done. Okay, so how about the next class in the street, chordal graphs of bounded clique number? So, it turns out that for chordal graphs of bounded clique number, the problem is actually polytime-solvable. So, it's even like. It's even like I mean, it's p is in fpt, so it is fpt, but it's even polynomial time solvent. Now, if you don't know what tree decompositions are, it's fine. Just know that independent sets on chordal graphs behave exactly like on trees, because you can find a tree decomposition where each bag is a clique. So each bag can have at most one token. And now, basically, what you can do is you can. And now, basically, what you can do is you can find a leaf bag, and this leaf bag is going to have a vertex which is only in this bag. If it has a token on it from IS or IT, then you can jump there, you can delete that vertex and its neighbors, and then you can proceed recursively by induction. All right, so it turns out that token jumping on trees and on cordal graphs is the same thing, basically. You find a little Basically, right? You find a leaf node, you jump there, and you're done. Okay, so this was not very exciting. Fine. So now what happens on planar graphs? And now things start getting more exciting, at least. Right, so how do we show that this problem is FPT on planar graphs? So remember that planar graphs are K33 free, so they cannot contain K33. So, they cannot contain K33. So, the way we can show that the problem is FPT on planar graphs is as follows. Again, we're going to follow a very common strategy, which is common not only in reconfiguration, it's common also in parametrics complexity. Right, so we're going to look at ISUn IT, which are the starting and target independent sets. This has size at most 2K, so we're happy with that set. And now we're going to basically Now we're going to basically partition the rest of the vertices based on their neighborhood in IS Union IT. So I'm going to basically have equivalence classes. Any two vertices in some equivalence class, let's say in this equivalence class, have the exact same neighborhood in IS union IT. Same thing for this class, same thing for this class. So we will get a bunch of equivalence classes where two vertices are in the same. Where two vertices are in the same equivalence class if and only if they have the same exact neighborhood in IS union IT. Okay, and now I'll so I'll call a class a one class if it has one neighbor in IS union IT. I'll call it a two class if it has two neighbors, a three class if it has three neighbors, etc. But also notice that we have a zero class, right? So we have vertices that don't have any neighbors in IS union IT. So let's. So let's try to deal with those classes one by one. So the first class to deal with is the zero class, those vertices that don't have neighbors in IS union IT, but we already know how to deal with those vertices, just like we did in the bounded degree case. Because these are the non-neighbors of IS union IT. So if there's an independent set of size K there, we are done. We can just jump IS to that independent set and then jump it. That independent set and then jump it to it. So we can assume that the zero class is bounded. Okay, so now how do we deal with the one classes? The classes that have exactly one neighbor in ISUN IT? Well, same thing. If there's a very big one class, then basically it will have a big enough independent set. And again, I can jump to this independent set in the one class, but now I have to be slightly more careful, which is. Slightly more careful, which is, I have to jump this token first, and then I can jump everybody else because this token is the only one that has neighbors in this class. So same thing, I can bound the one class. Okay, so now let's forget the two classes for a second and let's look at the three classes. Well, we are in planar graphs, so the three classes are bounded just because we are in planar graphs. Because if a three class is Graphs because if a three class is has three vertices, we will get a k3 three. So each three class can contain at most two vertices. So we're done with the three classes and for any class which is greater than three. So the only problematic classes are the two classes, are the classes that have two neighbors in IS union IT and that are large, right? If they're bounded, we're happy. We know what to do. So, what do you do? So, what do you do with the two classes? Well, here you use the following observation. You look at vertices that are not inside the class, and you notice that each such vertex can have at most two neighbors in that class. Why? Because if it has three, then you can take that vertex with these two vertices and these three vertices to form a K3. So, now basically, what you So, now basically, what you can show here is that if you have any independent set of size k, it will have at most three k neighbors inside this class. So now, if this class is big enough, you can find inside of it an independent set of size 10k. And now you can just retain this independent set of size 10k and delete all the other word c because any independent set is. Because any independent set is going to be missing at least k of the vertices, so you can always jump to a vertex which is not seen by any independent set. And so basically this shows you that you can bound all the classes. Now we can bound the size of each class. So what you are left with is to bound the number of classes. But this is easy because, I mean, if you don't want to be careful, there's at most two to Careful, there's at most two to the two k possible classes, which is four to the k. But in fact, in planar graphs, you can show that the number of classes is actually linear in k. But even if you don't want to apply that, the number of possible neighborhoods into IS union IT is 2 to the power the size of that set, which is 2 to the power 2k. That set, which is 2 to the power 2k, which is 4 to the k. Can I make a question? Sorry. Yes, please. I'm still a little confused on how to find the independent set because in the previous setting, the degree was bounded. So you could just greedily take it. Is the strategy also greedy here? Because planar, not necessarily the degree is bounded, but does greedy give you. You could try several strategies. So one would be to use. Uh, so one would be to use the four-coloring theorem, uh, yeah, another one would be to use Ramsey, right? Okay, it will give you very ugly bounds. So, the four-coloring would be the most adequate one here. Answers the question, yeah, thank you. All right, good. Any other questions? No, okay, cool. So that's it for the bottom layer. And so let me tell you a small side story here that after these results kind of, I mean, they were, they came out independently by different, from different groups, I remember that I spent almost a year of my life trying to solve the problem for graphs of bounded tree. Problem for graphs of bounded tree with. And I was never able to do so. And then one day, my boss back then, which was Daniel Lokstanov, he proposed that we stop looking at graphs of bounded tree width and try to go all the way up to graphs of bounded degeneracy. Maybe it will make life easier. And it definitely did. So, and now I'll tell you that story and how you can, how much. How you can, how much easier it is to show that the problem remains FPT on graphs of bounded degeneracy, which is basically gonna already be a generalization of everything we've seen. Right? But just as a side note, working with graphs of bounded tree with in reconfiguration problems seems super counterintuitive, right? Because at least in my case, like the first thing you always try to do is you try to go for some Do is you try to go for some kind of dynamic programming, you try to apply the things that you're used to, and they just don't seem to work. At least I was not able to make them work back then. So instead of going, trying to go one level higher, let's go all the way to graphs of bounded degeneracy for token jumping, independent set token jumping, and see how you can make it work there. All right, so the theorem again is that. So, the theorem again is that the problem is FPT on D degenerate graphs. Now, a side note about D degenerate graphs: they have at most d times n edges, and they have average degree at most 2d. All right, so before we show why this problem is FPT on degenerate graphs, let's look at the following structure. And let me convince you that one of the red vertices in this structure. The red vertices in this structure is completely irrelevant, and I can delete at least one of them. So, first, but let's let's let's see what the structure is. So, we have a bunch of red vertices, they are independent, and let's call them the centers. So, notice that these red vertices are independent, but they all have the same common neighbors that are in the yellowish rectangle. And let's call this rectangle the core. Rectangle, the core. And notice that, with the exception of the core, if you delete the yellow vertices, the vertices inside the yellow rectangle, then the red vertices are no longer just independent, they become too independent, meaning they don't have common neighbors even. Okay, is that clear? So the red vertices are independent in the graph. If you delete the yellow vertices, they become too independent. Vertices, they become too independent. So they no longer have any common neighbors. So now I claim that if you have a lot of red vertices, then one of them is completely irrelevant to the question of token jumping, independent set token jumping reconfiguration. Right? And the reason why this is the case is the following. So assume I have. Following. So assume I have a huge number of red word seeds. Let's say, I don't know, it doesn't really matter, some 100K. So notice that when you have a token on any one of the yellow vertices, then none of the red vertices can have a token. And otherwise, if a token is jumping to some vertex here, then we know that there can be no token. And we know that there can be no token inside here. And if I have enough red vertices, then I can use another one as a representative of this vertex that I would delete. Because not only are they independent, they are also too independent when you don't look at this yellow rectangle, when you ignore the yellow rectangle. But for our purposes, this yellow rectangle is very well behaved because if something is jumping to a red vertex, no token could. A red vertex, no token could be in the yellow rectangle. And if there's some token in the yellow rectangle, nobody can jump into a red vertex. So now, if you have a lot of red centers, then one of them is completely irrelevant, meaning you can remove it. If somebody needs to jump to it in the original sequence, you can make it jump to somebody else that you kept as a red representative. Okay, is this? Okay, is this clear? Questions? Because believe it or not, this is all you need to show that the problem is FPT on the degenerate graphs. Almost. No questions? Okay. So why is this useful? And what is this structure? Well, this structure is a sunflower. Well, this structure is a sunflower. This is a sunflower with a lot of petals. And the formal definition of a sunflower is the following: So, a sunflower with K petals and a core Y is a collection of sets S1 to SK, such that they pairwise have the same intersection Y, which we call the core. And the sets Si minus the core are what we call the petals, and we require them to be non-empty. To be non-empty. So now, basically, what we're asking is: can we find huge sunflowers in degenerate graphs? And it turns out that we can. And all we need is the Erdo Schrado sunflower lemma. And the sunflower lemma says that if you have a lot of sets of some fixed cardinality Q, then I mean, the bound doesn't really matter here. It's just that no. Really matter here. It's just that notice that the bound depends on the number of petals that you want and the size of each set. If your family is big enough, then you will be able to find a sunflower with as many petals as you like. And otherwise, you can say that this family of sets is of bounded size. So, how do you take this and you apply it directly to degenerate graphs? So, this is basically the proof of the theorem. Of the theorem, you look at the set system formed by the closed neighborhoods of all the vertices that have degree at most 2d. If this set system is large enough, then by the sunflower lemma, we will be able to find a sunflower with enough petals, and we will be able to apply our reduction rule of deleting some irrelevant vertex without changing the degeneracy of the graph. So, as long as we can find the sunflower, we keep reducing, we keep deleting vertices. Now, at some point, we will stop being able of applying this reduction rule, which means that the number of at most degree, at most 2D vertices is bounded. But in a degenerate graph, this also implies that the whole graph is bounded. Because if the number of at most of degree at most to At most of degree, at most 2D vertices is bounded, I have to maintain average degree 2D, which means that the number of vertices of degree more than 2D is also going to be bound. And now I basically get a kernel and I can brute force to find the reconfiguration sequence. So, let me pause here for a second and take questions if there are any. No questions? Okay. All right. So let's move on. Let's move on to the other interesting case. And the reason I want to talk about And the reason I want to talk about this case is that because, I mean, if you are like me, the first time you've seen the definition of nowhere dense graphs, you've decided you never want to work on them ever in your life. So what I want to try to convince you of here is that it's actually not so bad. And because of the work that we did on the configuration on this class, we were able to see some very nice structural property of nowhere dense graphs. Dense cross, right? So, so, and let me uh jump immediately into it. So, the big question here is: can we find large sunflowers in nowhere dense crops? Right? So, notice that we can no longer use the sunflower lemma because we don't have this average degree guarantee anymore. I'm sorry. Did somebody ask a question? Did somebody ask a question? No? Okay, was it only me who's hearing voices? Okay, never mind. All right, so the question is, can we find large sunflowers and graphs and nowhere dense graphs without using the sunflower lemma because we can't, because we don't have guarantees on the average degree anymore, and without having to be intimidated by those very messy definitions. By those very messy definitions, right? And it turns out that the answer is yes. It turns out that what makes nowhere dense graphs so nice is that you can actually find some flowers. Right? And I'll show you exactly how you can find them because we're going to need to find them to show that the problem is FPT on nowhere dense graphs. So instead of using the sunflower lemma, we're going to use this notion of uniform quasi-whiteness. It sounds It sounds a lot fancier than it is. It's actually quite simple. So the uniform quasi-whiteness says the following: if you have a graph which is nowhere dense and you have some large subset of your vertices, W, let's not worry about the sizes, just let's assume that it's very big, large enough. Then uniform quasi-whitness is the following. You can find some very small set B, which is a subset of. Which is a subset of Vg. So B can be also outside W. But B has constant size. And when you delete B from the graph, then you will be able to find inside W a very large set A that is two independent. So let me say that one more time. If you have a nowhere dense graph and you have a large subset of words, C is W, then by delete. W, then by deleting a constant number of vertices, you will be able to find a large two-independent set inside W. But the two-independent set is a property of A in the whole graph. So A is two-independent in G, not only in W, in G minus B, to be exact, right? Because you have to delete B, which is a very, very powerful statement. Now, notice that this A, which is two independent, is almost the sum. Is almost the sunflower that we're after, except that the vertices of A are not all guaranteed to have the same neighborhood inside B. Because the lemma doesn't say anything about that. And in fact, I mean, in many cases, this is not going to be true. Right? The only, I mean, if they all had the same neighborhood inside B, we're done. That's a sunflower. Just like we had before, because they are too independent when you delete B, B would be the. B, B would be the core in this case. And if they have the same neighborhood inside B, we're done, but they don't. So that's the only issue we kind of have to deal with. So how do you deal with this issue? Well, you do what we always do. You look at IS union IT, your source and target independent sets, and you subdivide, you basically partition the vert Cs into equivalence classes based on their neighborhood in ISUNI. Based on their neighborhood in IS Union IT. Now you know that one of those equivalence classes is going to be very big, otherwise, we're done. You zoom into that very big equivalence class, which is what I tried to convey in this figure here. And now what do you do? In this equivalence class, you apply uniform quasi-whiteness, meaning you find a very small set B whose deletion is going to give you a two-independent set. Going to give you a two-independent set A in the graph. And now, what do you do? Now you zoom into A and you again partition A into equivalence classes based on the neighborhood in B. And now you can again show that at least one equivalence class is going to be very large. But now, what do we have? We have a very What do we have? We have a very large equivalence class here, which is a two-independent set in the graph minus B, but everybody here has the same neighbors in B, and they have the same neighbors in IS union IT. So we found a sunflower, and the core is basically some subset of B union IS union IT. And that's it. And now, basically, the rest is the exact same strategy that we used before, right? As long as you can find such a thing, you can find a vertex to reduce or to remove from the graph. Otherwise, you know that your equivalence classes are going to be of bounded size and you're done. And again, here you can show that the number of equivalence classes is two to the Equivalence classes is 2 to the 2k, or even in nowhere dense graphs, you can show that it's linear. So, so, but it doesn't really matter for our purposes. And I find this kind of parallel between degenerate graphs and nowhere dense graphs, like the fact that you can find sunflowers in both of them is quite an interesting. And both of them is quite an interesting fact for me. Because these are two unrelated graph classes, right? And in fact, I mean, for those of you who are familiar with model checking, I mean, model checking is known to be easy for nowhere dense, but hard for degenerate graphs. But the fact that they have this feature in common is quite interesting. Okay, so now finally, to conclude the part about token jumping independent set problem, you can actually, a few years, I think a couple of years later, it was actually shown that you can solve the problem all the way up on bike leak-free graphs. Now, this proof is a little bit more technical, does not fit nicely on one slide, but I will give you the very high-level idea of it, at least. Very high-level idea of it, at least to see how it works and how you could imagine this proof going. It's actually a generalization of the planar proof. So, but now you don't have only the two classes to worry about, right? So, now you have the two classes, the three classes, all the way to the R minus one classes if we assume that the graph is KRR free or some fixed R. Right, so now you need to deal with all those classes, and the problem is that now. And the problem is that now you can have some vertices that are not in a class, but have huge neighborhoods into some class. But because we are in K or R free graphs, you can show there's a theorem actually that says that the number of vertices that have high degree into some class is bounded. And so the idea here is to take those vertices that have high degree into some class, add Degree into some class, add them to ISUnion IT to get a set X, and then do the refinement of the projection classes again. And now you repeat this procedure of taking the bad vertices from below, adding them above, refining the projection classes, and then magically, after you've done it some appropriate number of times, everything will work out. So, notice that there's a lot of commonality between the techniques, but at least I feel like they each have their own merits, right? Because they use different structural properties of the graphs. Okay, so basically, what we know now for independent set reconfiguration under token jumping is that it's FPT everywhere. FPT everywhere on this hierarchy tree that we started the talk with. Okay, some open problems concerning token jumping, independent set reconfiguration under token jumping. So the first open question was recently solved by Dan, who I think is in the audience. So the first Who I think is in the audience. So, the first open question was: Is there a linear kernel for planar graphs? So, I believe that Dan very recently solved this question. But don't worry, there's a lot more interesting open questions. The second question that I put here is, what happens for graphs of VC dimension two? We don't know. So we know that it's W1 hard for three. We know that it's polynomial time for VC dimension one. And we don't, and it's NP hard for two. Don't and it's np-hard for two, we but we don't know if it's w home is for two. And now, finally, what about dense classes of graphs? Right? So, everything we talked about is sparse classes of graphs. And the two examples that come to mind first would be how about graphs of bounded clique width, or even more general, graphs of bounded twin width. Or if you want to go above bi-click-free graphs, you can go to graph semi-final. Graphs, you can go to graph semi-ladder-free graphs, but I will say more about that towards the end of the talk. So again, the very good place to pause and take questions. So let me stay on the open problems. So can I ask? Please. So when you say which dimensions, you are looking at the hypograph induced by closed neighborhoods of the word C's. Absolutely. Thank you. Absolutely. Thank you. Yep. I didn't want to go into the definition because I feel like the talk has enough definitions. But yes, this is the appropriate definition of VC dimension. Because I felt if somebody doesn't know what it is, it's going to be too hard to digest in a talk anyway. Is there an example of graph class? Uh graph class where the classic problem dependent set is not FPG but in the reconfiguration version is the parameter K? Yeah, not that I know of not that I know of not that I know of, and that would be a really interesting class, I think. Class, I think. Thank you. Yep. Maybe a weird question, Arma. But you mentioned token sliding and token jumping. In a sense, one could also consider something like token anti-sliding, meaning that I'm sliding on the complement graph. And if I followed your proofs presented so far, everything you So far, everything you said about token jumping should also work for token anti-sliding. I don't. Isn't it the same as looking on working doing token jumping on the edge complement graph? Oh, no, but no, no, no, never mind, never mind. Oh no, but no, no, no, never mind, never mind. We're not doing jumping, we're doing sliding. Yes. But I haven't said anything about sliding yet. No, no, no, yeah, but if you don't do token anti-sliding, as I said, so you slide on the anti-edges. Oh, I see. Because, okay, so at least the bounded degree case would definitely hold. The planar case would definitely actually, would it? I get. I get your question. I don't want to say yes or no because I feel like I need to think about it more for like at least two or three minutes. Yeah, no, no, see what's happening. But I think I agree with you that it should be the case that everything should still hold. I would say yes. Yeah. I don't know whether anybody considered this as a reconfiguration sort of way, but, anyways, it just occurred to me. Not that I know. To me, not that I know of. I guess it could hold, but at least in the planner case I mentioned in the one class, I think you had a slide, right? Person slidings. Right. So it would require. That's why I didn't want to give answers, right? Because I know, like, here. Because, like, here, the minute changes could really cause huge differences in complexity. So, so, yeah. Okay, any more questions? No more questions. Okay, so let's keep going. Okay, so let's keep going. So now let's move on to the sliding version of the problem. Okay, so now we're doing independent set reconfiguration under token sliding. And again, you can very easily show that this problem is W1 hard on general graphs. Now you give a reduction instead of reducing from independent set, you can reduce from multicolored independent set. So if you don't know this problem, it's simply you're given, think about it. It's simply you're given, think about it this way: you're given a graph that is k disjoint cliques that have arbitrary edges between them, and your goal is to find an independent set of size k, meaning it has to have one vertex from each clique. This is called the multicolored independent set problem. And now you can easily reduce this to token sliding reconfiguration using the same trick we used before. You add a K plus one byte click, but now you basically. But now you basically the connection so this vertex will be complete to this set, and this one will be complete to this set. And then the second one will be complete here and this one here. And then there's one last pair which is not connected to anything. And now the same argument shows that if you want to move from left to right, then at some point you must have K tokens that are below. Tokens that are below, which will form a multicolored independent set. So, same exact, you just have to basically adapt it for the sliding version of the problem, but it's the same hardness basically. Okay, so now let's try to replicate what we did before. So, let's look at graphs of bounded degree, and immediately we will face an issue. We will face an issue. And this issue is something that we call the bottleneck effect. Because now, assume you have a very, very huge path in the non-neighborhood of IS Union IT. Even though you have such a huge path, even though, and a huge independent set, you have no guarantees that you can actually reach it. Because it could be that this only This only vertex, which is the one you need to access this path, is in a frozen situation, which in this case it is, because these two tokens cannot go anywhere. They are twins in the graph. They have the same unique neighbor, meaning none of them can go anywhere. Meaning that vertex here that I have in yellow is completely unusable. Meaning, this whole path that we have, which would have been nice to use, cannot be used. Cannot be used. So already we see that those two problems behave super differently. And it was actually open for quite some time whether there's an FPT algorithm for token sliding on Grasso-Pounded degree. And it was quite only quite recently solved, right? And I will show you how it was solved and how this How this idea helped to solve also some other classes. So, spoiler alert: we know a lot less for token sliding than we know for token jumping. A lot more super interesting open questions here. So first, let's talk about what is something that you could potentially do for graphs, right? They don't even have to be of bounded degree, but let's assume that if you look at the non-neighborhood. That if you look at the non-neighborhood of IS Union IT, meaning at the vertices that do not intersect with IS union IT or their neighbors, assume you have a very long shortest path. So this is the path that I'm showing here inside the blue rectangle. Right? And assume that this is a shortest path in the graph. Meaning that if you take any vertex which is not on this path, it's going to be. Not on this path, it's going to have at most three consecutive neighbors on the path, otherwise, you get a shorter path, right? So, and assume that, sorry, question? No, okay. And now, basically, intuitively, if you think about it, if this path is super long, then you should be able to shrink it, right? You should be able to shrink it to some function of k-sides. To some function of k size, right? Because you, I mean, if it's of size 10k to the power 10 or 10k to the power 20, it's not going to make a difference in terms of how many of your k tokens you can store inside of it. Just because of the fact that it's very long and any vertex not on the path has at most three neighbors on the path. So if you look at any K-independent set that is outside the path, That is outside the path, it can be seeing at most three k vertices on the path. So if you have 20k vertices on this path, you still have enough room to save, to basically store the rest of the tokens. Right, so this is a very high-level idea of where the solution started. And in fact, you can even push this idea further, right? Assume that again, Right, assume that again in the null neighborhood of IS Union IT, you can find some very large grid micro. And you can probably think of other structures where if they're big enough and they're not in the neighborhood of IS Union IT, then you should be able to do something with these structures. However, one of the big issues here is that in reconfiguration, replacing a structure with another one is usually a nightmare because you have to prove. Nightmare because you have to prove equivalence of the instances and it becomes super tricky, the trickier the structure is. Right? So, and the solution to that issue, at least one solution to that issue, came through this notion of galactic reconfiguration. Right, and it's basically another model of reconfiguration, but which is very, very similar to token sliding with a few exceptions. And you'll see why. A few exceptions, and you'll see why it's called galactic reconfiguration in a second. So, before I talk about galactic reconfiguration, I first need to talk about galactic graphs. So, what is a galactic graph? Well, it looks like a galaxy. That's where the name comes from. So, a galactic graph is partitioned into two types of vertices. You have black holes, which I'm showing here as big black vertices, and you have the planets, which are the smaller dots. And of course, you have. Are the smaller dots, and of course, you have the edges between them. And now, inside a galactic graph, we say that a set is independent whenever the planetary vertices, if you have tokens on the planetary vertices, they have to be independent. But what happens with the black holes? What happens with the black holes is that they can absorb as many tokens as they like. So, if a token goes into a black hole, you can. Goes into a black hole, you should think about it as this token being swallowed or absorbed by the black hole. And a black hole can absorb as many tokens as it likes. It can absorb okay tokens if you want it to. And then it can project them back to its neighbors whenever it likes as well. So, and this is basically the difference in the rules of the games, right? So, for galactic token sliding, you can slide along the planets. You can slide along the planets as unusual token sliding, but you can also slide to black holes and be swallowed by a black hole. And to be independent means to be independent in the planets. You can have a token on a planet and K minus one tokens in a black hole, even if they are adjacent, this is still considered an independent set. Okay, and so now we And so now we define galactic token sliding in the natural way, but now you have to be, I mean, it gets a little bit more technical because you have to define weights on the vertices because the black holes can hold more than one token. So, so, but you do all this technical stuff, but the intuitive picture is the one that I told you about. And now, notice that, of course, an instance of independent set token sliding is just an instance of galactic token sliding without black holes. And so now the goal is to see if we can actually design some reduction rules that will use or create black holes in the graph and allow us to basically prove that the problem is FPT. At least let's start with graphs of bounded degree. Okay, so here are a few easy reduction rules. The first one that you should convince yourself is true is that. yourself is true is that if you have two adjacent black holes, then you can merge them into one. Right? You can basically contract the edge between them and get one big black hole. And I mean, correctness is immediate here, right? Because black hole, any single one of them could absorb all K tokens. So it doesn't really matter if you have one or two. The second reduction rule, which is less obvious, but I mean, it doesn't take too long to see, assume. Take too long to see. Assume that you have some planet which is adjacent to a black hole, but none of its neighbors, planet neighbors, intersect with IS union IT. So assume this is my vertex, which is adjacent to a black hole, and none of these vertices have tokens on them. Then what I'm saying here is that this planet can actually be swallowed by the black hole. It can actually be swallowed by the black hole. You can shrink the size of the number of planets by one by making this planet be completely absorbed by the black hole. And here to see why this is actually fine, it's just notice the following. If at some point, any point in a reconfiguration sequence, a token is going to come and sit on that vertex, I can immediately swallow it into the black hole. And when it wants to leave, I can project. And when it wants to leave, I can project it again. So that's why I could just basically contract this planet into the black hole and assume that it's not even there. So these two reduction rules together, when you assume they are no longer applicable on some galactic graph or galactic token sliding instance, you know that the black holes will form an independent set. And you know that. And you know that the black holes cannot be adjacent to the non-neighbors of IS Union IT, right? Just because of reduction rule one and reduction rule two. This will be important in a second. Let me pause here before we go back to graphs of bounded degree and take questions if there are any. No questions? Okay. So let's go back to graphs of bounded degree. And here's the key lemma that's going to allow us to show that the problem is FPT on graphs of bounded degree. If your graph has a shortest path P that has that is long enough linear in K such that it's Such that its neighborhood does not contain any tokens of IS Union IT, then you can basically shrink, contract this path into a black hole. If you go back to the figure that we started with, this long, shortest path in the blue part of the graph, what this lemma is saying is that you can shrink this whole thing into a single back hole. And your graph will now look like this if you apply the reduction. If you apply the reduction, I will not go over correctness fully, but the intuition should be clear. The idea is the following: you can show that if you have any configuration sequence in your original graph, you can modify it so that it looks as follows. Whenever a token reaches the neighborhood of this path, you can immediately project it on the path and hide it somewhere on this path. So, you can assume that this is the behavior all along a transformation. And for the, you can also do it in the reverse direction. When somebody wants to leave, you can rearrange the tokens on the path and project the one that you want to project onto the vertex that you want to project it. And this behavior basically can be what we're saying is that, okay, we can do this in this path. Let's forget this path, shrink it. Let's forget this path, shrink it into one big black hole. So now, this reduction rule with the previous two reduction rules are actually enough to show that the problem is FPT on graphs of maximum degree delta. Let me tell you why. So, first, we know that the closed neighborhood of IS union IT has at most 2K into delta plus 1 vertices. Right, because it's 2k plus 2k times delta for the closed neighborhood of IS union IT. Now, let's forget the black holes for a second. What do we know? We know that if we look at any component that only consists of planets and which is in the non-neighborhood of ISUnion IT, then this component is going to have diameter at most k squared because of the previous deduction. Of the previous reduction rule. Otherwise, you will be able to apply that previous reduction rule of contracting into a black hole, which means that the size of every planetary component is going to be bounded by some delta to the k squared. Now, the next step is to bound the total number of planetary components, but these components have neighbors in only Neighbors in only in IS union IT in the closed neighborhood of IS union IT. So you can also bound the number of connected components using the maximum degree of the graph. And finally, you just have to bound the number of black holes. But we said that these are independent and they don't have neighbors in the non-neighborhood of IS Union IT, so they only have neighbors in this set. In this set, but this set has bounded degree. So the number of black holes is also bounded. So that's a lot more work than what we had to do for the token jumping case, but at least it works. So I will pause here. So, I will pause here and take any questions if you have any. I am getting tired. I don't know how everyone else feels, but okay. Okay, all right. So maybe I won't because I'm realizing that I actually have material for two hours, but maybe we won't cover the dominating. Maybe we don't cover the dominating set parts. Maybe we will stop at independent set token sliding. Okay, so let's move on. Let's move on to the next class, which is cortical graphs of boundary. Class, which is chordal graphs of bounded clique number. And believe it or not, it was polynomial time, remember, for cortal graphs on token jumping. Answering this question is highly, highly, highly non-trivial. And let me show you a smaller question, which is just as non-trivial. Before we talk about chordal graphs of bounded clique number, let's look at the following question. Look at the following question. Assume you have a small set x in your graph, which is a small subset of vertices, so that when you delete x, you get a lot of connected components in the graph. And so now the question is: can you remove one of those components? And remember, we're doing token sliding, not token jumping. And you can further assume, just because we can assume that you have as many components as you like, that all of these components are free of tokens initially. They don't intersect with IS Union IT. Right, so answering this question is actually quite challenging. I will not go into the technical details, but I will give you a high-level intuition about how you can do this. Intuition about how you can do this. And this is using this another tool that was designed for token sliding on sparse graphs basically, which is called journeys and their types. So journeys and types. So let's zoom in on one of those components and let's look at what happens. So assume, remember, initially they don't have tokens on them. So now when a token comes into this component, comes into this component. Notice that it has to come from X, right? Because X is a separator. And then we say that the token makes some journey in this component. And this journey basically is a walk in the component. Right? But you can rewrite this walk as basically X1, P1, X2, P2, blah, blah, blah, blah, blah, where each PI is some path that links XI to Links xi to xi plus one. Now, what are those vertices and those paths? Well, if you think about what's happening here, if a token comes into some component, I mean, the only reason it might be stopping at some vertices is because it has to be waiting for some movement that's happening inside X. And then it can continue along the journey and then it will pause. Continue along the journey, and then it will pause because there's some other movement that's happening inside X. Now, I'm assuming there's only one token inside this component. This is a technicality. We can take care of it. So don't worry about it. Just assume that there's one token in this component. Right? And then it carries on with the journey, and then it stops at some other vertex because of some movements in X, and then it keeps going, and yada, yada, yada. You get the point. But now, if you. But now, if you assume that what I told you is what's happening, which is the case, then the only really important information about all this walk or all this journey is really what is the neighborhood of those vertices inside X. That's one thing that's important to know. And the second thing, which is important to know, is if you take those connecting paths, you want to know what is the union of the name. The union of the neighborhoods of those words C's inside X. Because when the token is making this transition from point Xi to Xi plus one, then you need to make sure that all the neighbors of these vertices in X don't have tokens. So this is another piece of information which is important. And it turns out that these are the only important pieces of information that you need. So now, what do we still need to be able to do something to make progress? Is we need to be able to say something about how many such important vertices are there. Right? And we call them important vertices or important conflict vertices. Let's just call them important vertices here. If we are able to show that the number of such important vertices is Of such important vertices is bounded, then more or less we are done intuitively because the amount of information that we need to kind of represent each component becomes bounded. And now we can guarantee that if we have a lot of components, a lot of them will have the same information. So we can disregard one of them. This is very, very high level, but for good reason, because the technical details are super annoying. Super annoying. And it turns out that we can actually bound the number of important vertices. And the key lemma that does so is the following. It says that if you have a transformation from IS to IT that minimizes the number of token slides involving some vertex of X, right? Assume you have such a transformation. It's a transformation from IS to IT that minimizes the number of slides involving a vertex of X. Of slides involving a vertex of x, then what you can show is that almost all the components of g minus x are going to be well behaved, meaning that the number of conflict vertices inside a walk of a token is going to be bounded by some function of k and the size of x, which is exactly what we were after. So now what we can do is if we have such an x and Such an X, and when we delete it, we get a lot of components. We can reduce the number of components. And basically, this is one of the technical parts for chordal graphs of bounded clique number. Why? Because now, if you look at the clique tree of the chordal graph, you know that the clique tree is going to have bounded degree. Because if there's a clique that has high degree, then this is basically the X from the. Then, this is basically the X from the previous slide. So we can reduce at least one of the components. The second part of the proof, you need to show that the graph has bounded diameter, but this we can do just like we did for the bounded degree case. If you have long paths, you can shrink them into black holes. So once you have a bounded degree clique tree and you have a graph of bounded diameter, you are left with just one case, which is basically now you have a long. Which is basically now you have a long clique path where some vertices appear all over the max. And this has to happen when you have a clique tree of bounded degree and bounded diameter. And now, again, there you have to do some technical work to show that you can actually reduce and you get the FPT algorithm. So that's a long way from the polynomial time algorithm. Way from the polynomial time algorithm for doing right, so a very, very long way. Okay, so finally, let me say a few words about planar graphs, and I promise you I will stop here, even though I have a lot more. So, I'll take a vote later. So, you can also show that the problem is FPT on planar graphs, and the way you do. On planar graphs, and the way you do so, you basically reduce to the bounded degree case. Right, we've already shown that the problem is FPT on graphs of bounded degree. You can show that in planar graphs, you can there's, but the reduction rules are very handcrafted for planar graphs, so they don't generalize nicely. Maybe they can generalize to bounded genus, but that's about it. But you can show that basically you can reduce the degree of the word C's until you get bounded degree, and then you can apply. Bounded degree, and then you can apply the bounded degree algorithm to show that the problem is FPG on planar cross. Another graph class that was where galactic token sliding was used to resolve an open question was for graphs of girth five or more. So we knew that the problem was W1 hard on graphs of girth four or less. It was open for Four or less. It was open for what, for five and more. And using galactic reconfiguration, you can show that it's actually FPT. I'm not going to go into the details because, I mean, it's just finding appropriate structures that you can shrink to black holes and then applying the same kind of strategy. So now, if you look at the picture of what we know for token sliding, it looks very different from that of token jumping. Right? So, so. Right, so basically, this is the boundary of what we know. Not quite, I'm lying a little bit because we very recently solved one more question, which is still unpublished, which is token sliding parameters by K on graphs of bounded tree weight. So this was very, very recently solved, but yet unpublished. So I cannot even claim it yet because we don't know if it's true, if it's correct. But regardless of that result, like it's still. Result, like it's still open for all of these classes. We don't know what's happening on these classes. So, my favorite open question, at least, is what happens on degenerate cards? Can we use those sunflowers in a nice way for token sliding? Or is it going to be inherently a lot harder? And maybe we can show even W hardness. I don't know. We really don't know what's true. Really don't know what's truly happening there. And there's also the open equivalent open question for kernelization. One of them was solved by Dan, who showed that there is a linear kernel for token jumping on planar graphs. What about token sliding? But this is going to be a much harder question to answer, I think. I can never say for sure, but I mean, the Sure, but I mean, from what you've seen already, you should probably believe me that it's going to be a much harder question to answer. Okay, so I had a lot more to say about dominating set reconfiguration, which I won't because I have a sense that everybody's very tired, understandably. So, but I will conclude by saying that the boundary between tractability and intractability. And intractability is still very unclear for most of the problems that we're looking at. So maybe eventually, once we've started solving enough of these questions, we can start coming up with algorithmic meta-theorems that will basically generalize a lot of these results that we're coming up with. But we're still, I think, I mean, we're getting closer, but I don't think we're still there yet. We're quite there yet. But that would be nice. But that would be nice. So, one venue to explore there would be combining model theory and reconfiguration, which is something that I'm actually working on. You can also, there's a lot of different reconfiguration rules that one can look at, like simultaneous movement of tokens. There's also various different parameters that one can look at. And there's now even, I mean, how about what happens on dense classes of graphs, right? Everything we talked about was for. Right, everything we talked about was for sparse graphs, and one way to extend this picture that I started with for dense classes of graphs is if you can go if you go to bounded clique width or bounded twin width or if you go to semi-ladder free graphs. I won't define these classes. I don't think it will give it will be very helpful in the talk if you don't know what they are. But I think this is also very interesting avenues to explore. Interesting avenues to explore, even if we're only starting with token jumping, for which the picture for everything else is resolved. So, what happens for token jumping on these classes? Right, so for token sliding, we're probably not there yet, but what about token jumping? Thank you very much for your attention. I hope this was not too much. There's more material there. If you want the slides, I can also hand them over, but I think. Send them over, but I think yeah, I think going over the dominating set part would have been overkill. So I think this is a nice place to end. And you can definitely refer to the paper, which is on archive as well. All right. Thank you very much, everybody. I have one. Vinicius here. You mentioned other parameterizations. So, a natural one, at least to me, would be the size of the reconfiguration sequence, the meaning size. Are there any results on that? Yes, there are. So, there's a very huge hammer that says that FO model checking is FPT on. Is FPT on nowhere dense classes of graphs. And in fact, if you have L or the length of the reconfiguration sequence as a parameter, then you can encode your problem as a first-order model checking problem. Because you can basically quantify, existentially quantify the changes. And then this gives you an FO formula, and then you can apply the huge. And then you can apply the huge hammer of FO model checking on nowhere dense graphs. And very recently, also on published work, we were asking what happens on bounded degeneracy graphs. We showed that for parameter L alone, the problem is hard. But for K plus L, where L is the length that you were talking about, it becomes FPT again for bounded degeneracy. Answers your question? Yeah, sure. Thank you. Like this model checking hammer is kind of annoying. I don't like it, right? Because it's just like you get a lot of things for free without really understanding. But it is what it is. Okay, so let's conclude this session. Thank you very much. And have a coffee break. Thank you. 