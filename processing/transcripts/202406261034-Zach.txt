The organizers for giving me the opportunity to present our work here. This is joint work with Simon Manhos, and we're part of the OSCA project. OSCA is a computer algebra system that probably all of you know or are aware of. We're part of a Zoom Spoteich in Germany across different universities like Kaiserslautern, Zapruden, Aachen. We have people in Berlin and probably elsewhere. It's a bit scattered, it's a huge project. And one part of this Sonderfox Plateau is to develop this system OSCA. And what you're going to see is basically what I've worked on for now last three years, I'm afraid to say. And it's the first use case or first serious scientific use case of Serious scientific use case of what we did. And what we do is we try to develop the framework for algebraic schemes. It was already mentioned by Hane this morning. Algebraic schemes as they are defined in the common textbooks. Like you have something that is covered by affine patches, similar to a manifold, and then you glue these affine patches to give you a global object. So we have seen. So we have seen, I think, yesterday that in Magma you can also do spec of a ring or project of a graded ring. You can do this in OSCAR. We can do, I think, a little bit more. I'm happy to be corrected. But I'm not aware of another system which can do glued schemes, covered schemes to this extent. And yeah, I would like to show this a little bit, give you a feeling for what might be. A feeling for what might be possible because we are looking for customers. We are looking for people that say, Well, if you have that machine, then let's think about this problem. And it is my hope and my belief that a lot of research is probably not carried out because people don't dare to think in that direction. Let's find something easier to work on. But now, when the machine is there, maybe things will open up, right? Open up, right? So we are trying to find a very specific automorphism of an Enricus surface. Starting point of the whole journey was this theorem by Ohiso and Yu. The references are below. We're probably going to upload that notebook somewhere so you will have access to it. And the theorem is that for this real number, or This real number, or real algebraic number, Clau8, it has this minimum polynomial. The theorem is that this is the minimum solid number which is realized as this first dynamical degree of an americus surface model masses. So I need to give you some background. I think there is no way to get around that that will come below. So what That will come below. So, what are we trying to do? This is a purely, this is a theorem which is just an existence statement, right? It doesn't construct neither the Enricus surface nor the automorphism. So what we're trying to do is we try to construct this universal cover of an Enricus surface, which is always a K3 surface. K3 surfaces are nice, they have a lot of enjoyable properties, and then we want to construct its And then we want to construct explicitly the Henrique's involution to get back the original Enricus surface and the lift of the automorphism on line. So we have this Obeso-U automorphism on the Henrique surface, we have the universal cover, and there exists a lift F tilde of this automorphism up here. So So, some background information, then we're all on the same page. An Enrique surface is a complex manifold. You can also give the definition a positive characteristic, but let's stick with this simple case for the moment, where the irregularity is zero and the canonical divisor is non-trivial, but two times the canonical divisor is isomorphic to the structure sheet. Yeah, the sheaves associated to it. And then, as a matter of fact, the fundamental group of an Enricus surface is true torsion, and you can form the universal cover, and that universal cover happens to be K3 surface. So K3 surfaces have already appeared. They are simply connected complex manifolds with trivial canonical bundle. And this little information is. This little information is already sufficient, or turns out to be sufficient, to really narrow down the possibilities of what a T3 surface can actually look like. So they are all diffeomorphic. The only way they can differ is by their complex structure. But even there, the Hodge diamond has always this form. We saw it already in David's talk. And the second cohomology group, right, which is this bit here in the middle. Is this bit here in the middle? It has an intersection form. You can intersect cycles, you get numbers because of the dimensions. And this intersection form forms a very particular lattice, meaning the gram matrix of this intersection form takes this particular form. So, what's also nice about K3 surfaces is that you have the Torelli theorems for K3 surfaces. I take here a form that you can find in the book by Matthias Schutt and Shioda. So, for two K3 surfaces X and X prime, they are isomorphic if and only if there exists an isometry of lattices, so an orthogonal transformation of these three C modules, which preserves the Hodge decompositions. And that effectively means if you have specified the sub. specified the subspace for H20 or H02, then you have effectively described the Hosh decomposition and that needs to be preserved. So it needs to preserve the period of the structure. And moreover, such an orthogonal transformation comes from an actual geometric isomorphism if an Isomorphism if and only if it preserves the positive cones and induces the bisection of effective classes. So, what's the upshot of this? First of all, a K3 surface can be described by specifying this one linear subspace and textifying K3 lettuce. So that's why the theorem by Obisa and Duke was non-constructive. They only needed to say, look, They only needed to say, look, this vector, that's our K3 surface. But you don't get any equation from it. And they only needed to say, look, we have the following isomorphism of this K3 surface, which is then a big orthogonal transformation or a big matrix, not so big, but just a matrix which is inducing an orthogonal transformation of this lattice. So So, an Enrico surface can then, of course, be described by just saying what the involution is. So, this can also be specified by the matrix, which has to have order 2. And an automorphism of the Enricus surface downstairs can be described by some lift to the K3 surface upstairs, which has to commute with involution. And actually, that's the data that can be cooked up from Opizo's news paper. And used paper, and Simon did that. So, what we are given is such a quadruple where we have the K3 lattice, okay, that is in principle nothing new, it's just we have a specific basis in which this is given, the period, and the automorphism for the lift, and another automorphism for the evolution. For the evolution. So I asked Timon, can you give me, hand me over these matrices? And they look like this. Since I had to make the font a little bigger, it looks now a little messed up. I'm sorry. But this is the input data, big matrix. Um we can check is it plausible that this is a this is an instance of the of the original K three lattice? The original K3 lattice, so the K3 lattice we can assemble here. And then we can do some plausibility check, which is like checking that the gram matrix have the same determinant. This K3 lattice looks, let me make it a little smaller. SK3 lattice looks more for the root, right? It's a little more tidy than the matrix upstairs. But nevertheless, they do have the same determinants. Okay, that's fine. It's an assertion macro, but you can take it out. It's true. So the matrix representing this lift to the lattice upstairs. To the lattice upstairs, it takes this form for this specific basis. And we can check that this is indeed orthogonal, so everything's fine here. And the period can be reconstructed as an eigenvalue of this map. So here is the factors of the characteristic polynomial, and we take this. And we take this factor here. My test model is x here. But this is the Enricus surface. And this is the universal cover of case B. You have a particular case B here, right? Yes. Uh yes. I'm asking which K3 or I mean which data yeah I'm still constructing the data so the the K3 lattice is this one right any any all the lattices are the same as one K3 lattice subtoisomorphism so this doesn't say anything no no but it's it's a choice of bases But it's a choice of basis. It hasn't gotten there yet. It has a choice of basis involved, right? And with respect to this basis, you get to the period down here. I want to show you now. This is the period. Of course, you can say here's the period, therefore there's a K3, but I think you started with a certain K3 and then deduced this information. No, what I'm showing you now is what you No, what I'm showing you now is what you can cook up from Ovizo and Newspaper. They constructed this quadruple. That matrix that I showed you in the beginning and this beering. Okay, and then the first challenge is to give explicit equations for this one. So the unfortunate thing is that The unfortunate thing is that it's rather difficult to get your hands on this H2 here. So what we can actually work with is the Neuron-Severi lattice, which is a sub-lattice which is spanned by the first turn classes of all line bundles on the K3X. And it is actually the intersection. And it is actually the intersection with this H11 part from the Hodge decomposition. So another thing that Ogizo and you have already showed is that the orthogonal complement of the neuron-several lattice, the so-called transcendental lattice, is of this form. It has this intersection matrix. And that the automorphism that we look for acts with order 8 on it, which turns out. On it, which turns out to be quite restrictive. And then, since this K3 surface by construction is projective, we have that the neuron-severic group is actually the orthogonal complement of this transcendental lattice. And we can find what the neurons are very. What the Neren-Saberi group actually looks like, and then restrict the action of F to that Neuron-Saberi lattice. So here is one way to construct a transcendental lattice. Again, it's another choice of basis, but you can diagonalize this matrix. That's perfectly fine. And then you can ask for generators of the neuron-severi letters, just the orthogonal complement of this. Of this, and you can ask for one gram matrix for this neurons very lattice. So, this is what in the end you can use if you have constructed successfully the candidate for X and the lifting F tilde. You need to find a set of generators for your neurons of vary lattice. You need to match it with the generators which are used here. And then you can check with fingerprinting, so to say, does it do the correct thing on the Does it do the right thing on the narrative lattice? And that's how you can, in the end, verify that what you constructed is indeed an instance of this automorphism by Ugieslandi. So we have to do the following steps. We have to find explicit equations for this K3 surfaces. We have to find generators for the Neuron-So-Berry group, compute their intersection matrix, we have to construct Section matrix, we have to construct this automorphism, the pullback or push forward, which oneever is easier, of our candidate, and then have to verify that it's doing the right thing. And then finally, we will have to construct a Hindu collection. And all this, the aim is to do all this with explicit equations for both f, tilde, and x. Questions so far? Okay. Okay. So I would like to show you in a little more detail because it illustrates what we can do in Oscar, how we construct this P3 surface. So it turns out to appear in this database that I mentioned yesterday. I mean, Zimon knows how to do the matching by different invariants, and he finds that the K3 surface with this particular period as the N lattice has already appeared in this classification. Already appeared in this classification, and it turns out to be okay three surfaces with a group action by this particular group, a faithful group action. And then first thing we did was look at the invariant subspace of this group action. It turns out how to be generated by a single element. And then you can ask for the linear system of that element. So that linear system. So that uh linear system is of dimension four, so it yields a rational map to be three. And uh yeah results by Saint-Donat that were also mentioned I think on Monday probably they yield only from the latest theoretic inspections that this will be a two to one map to something that's uh isomorphic to P one times P one and P three. P1 times P1 over P3. So the first thing we did was look for projective representations of this group up there on P3 and see whether we can find something that is a candidate to realize this outcome. So we find projective group representations and it acts on P three with two generators in Two generators in PGL3, which are represented by these two matrices. And then we can compute the relative invariance. And already we have candidates for what our K3s could be. I mean, it could be a 40, but then it turned out not to be because it's just two-to-one cover of something. Yeah. One option would then, I guess, be to use a linear system of twice that. A linear system of twice that device. Okay. You get a much higher dimensional model. That's probably not what you want. You want to keep dimensions low so Kerkler basis algorithms have a chance to finish. And you will see that we're quite fine when we find it. What's x, y, z, and w here? It's the homogeneous coordinates of p3. Up here. So x, y, z, w is just this quote. You have a quadratic and you have a branch locus on that quadric now, right? Yeah, that's that's what will that's what will happen, right? So the the B is the branch code. If I intersect B with the quadrat, that's we we'll get there in a We'll get there at the end. So, one thing that I have to say is today in the presentation, we're going to do computations over this finite field. And what we are going to see is just a shadow of what we actually want to do. We've done parts of the computation over a number field, and we're looking forward to finish this over the number field also. Because we need things to finish quickly. To finish quickly, computations, we're just looking at the shadow. So, how do we actually compute it? We set up the field, we need a 16th root of unity, just because it appears here for these matrices. We reconstruct these matrices, we have a matrix group generated by this, and we manually encode. I mean, there's a way to get this also automatically, but for now, we manually encode. For now, we manually encode these invariants. We can quickly check that they are indeed relative invariants. So this needs a little computation, a little computation overhead, unfortunately. But what we mean relatively variants? It means that they are not invariant, but they are invariant up to scaling. The determinant of whatever. Yeah, I mean, you can see here this one is actually invariant, and then here, this one is invariant. If you get G2 egg on this, this is also invariant, but here it's like 15 times the original polynomial. The original The original B was here. So it's a variant point in some projected space. So, yeah, towards your question, this zero locus of the quartic is not the K3 surface, but what we do is we consider this Q as the zero locus of the small Q polynomial, and then we And then we make a candidate for this 2 to 1 covering suggested by the results by Samuel Na. And we do this by choosing an appropriate rank 2 vector bundle and projectivizing it. And then in one chart, we make an answer with this equation and that spreads out to the other charts. That's what you would do on paper, and we can do it in OSCAR. In Oscar. So, how do we do it? Just like it's written there, we define P3 and the sub-scheme defined by this polynomial Q. And now we have a projective scheme. So, that's what you can also see in Bagler. And then we define the vector Bagler. We have these twisting sheaves. We have these twisting sheaves. And these twisting sheaves then are not gradient modules, but you can ask a projective scheme to be turned into a covered scheme. And then you get what I call big Q. And there you have different charts. And every chart comes with a set of coordinates and some and get defined space. MDN defines. So, so sorry, but I to something you said, this database of K3 surfaces? Yes. Is it public? It's public, yes, but it's not yet in Oscar, I think, Ukraine. They published it in 23. It's by Tommy Hoffman and Simon Planckwals. Published how? Where? The article is published, and the database should also be accessible. I can give you a bit of a Accessible. I can give you the reference. So you don't yet have product projective spaces as sort of first class ambient spaces? You constructed here as a subspace of three, right? Yes. And then what is covered scheme again? Covered scheme is turning a projective variety into Variety into a covered scheme, right? So passes to the canonical affine charts and gluest on. So now we have this, we can form this direct sum sheaf of these two line bottles and it tells you it's a coherent sheaf of modules, all right? And then on every chart it has specific restrictions. But what's also done for you is Done for you is you don't only have the charts, but you can glue these charts. So u is now the list of affine charts of the scheme. And then I say, give me the gluing of the first and the third chart. So it's something that has its own data type, it's gluing. And I can ask for the gluing domains. And the gluing domains actually already appear here. So here. So, here what you see is an affine scheme and the complement of a hypersurface. So, this is an instance of the localization framework that Anne was mentioning this morning. So, we can localize, and this is versatile to modeling schemes because that's how you do topology of varieties. So, we can ask for these gluing domains, and then we can ask what does the What does the sheaf look like on either one of the patches? You get modules, and if you say the sheaf and two patches, it computes the transition from the one representation of the sheaf, or the one patch to the other. So in this case, it will have this representing. V1 and V2 are your U1 and U3 from before, right? That's what I'm saying. I should have said 3. And uh what was E again, Sorry? E is the the direct sum of O plus O of minus two pi. And that's that's the transitions you would expect, right? Trivial on the structure sheaf and minus two here. What I will try to do here was the way I wanted to show you what's possible because I think this. I wanted to show you what's possible because I think this is a distinguished feature of OSCAN, right? And all the computations that are to follow, they are happening in this framework, and this is what allows for these computations to happen. But I mean, this thing is a hypersurface method, right? But I think he's just showing the functionality which you could implicitly do in quite great function. Oh, yeah, yeah, yeah. I get that. That's good. That sense. Okay, here. Sense okay, here it gets complicated. Here it gets beyond hypersurface and projective space, right? Because now we're doing what I said before, we go into one chart of the projectivization of that bundle, we give an equation for a variety in that chart, we spread it out over all the charts of the ambient space, we take a sub-variety and then we actually And then we actually realize this morphism x to q from the linear system. So this is more complicated. This has eight charts. I'm sorry because of the size of the font, it's a little mixed up. But this is not a hypersurface in projective spacing. It can be handled also. And that's or can be that for the K3 circuits. Locally hypersurface, right? This is what you've got that too. But I think every variety is found a representation for that. Good. So how do we recognize that this is a K3 surface? Well, we have already a projection to Q, which is P1 times P1. We can project one of the factors. And actually, this whole construction was carried out so that this will be. That this will be a genus one vibration. And that's I don't understand. You just said every variety is locally vibrated. I believe that. Was A1. No, no, no, no, no, no. I mean, you can have a curve that has three branches that meet in. Three branches that meet in free space with different linearly dependent directions. Well, I see a smooth space. Okay, I was wrong. Every variety has an open subset, which is. Yeah, I'm okay with that. Thanks. Yeah, right. So, here we have a candidate for a genus 1 vibration, and now And now we want to turn this into an elliptic vibration because that's actually where we have tools to construct allomorphisms, or Zimon has tools. And what we need to turn the genus 1 vibration into an elliptic vibration is, first of all, a section. And second, we need the whole neuron separate lattice on this surface, right? We have constructed surface, but we need to verify it's actually the K3 surface that we have. Actually, the K3 surface that we are looking for. How do we do that? We have to find the neurons that very lattice and make sure that it is the correct one from Matizo and you. Matthias, would it be possible here, using pure code, to check that the canonical bundle is changing? I mean, I don't do this by hand, but I'm specifically asking whether now that you've Specifically asking whether, now that you've constructed all these transition functions, whatever, whether then I could ask what is the canonical bundle? It's not implemented yet, but I think it should be doable, yeah. So we kind of build a car, but the engine is not in yet. And we're we're building that part of the engine that we need. I mean, I think you have the car, which is maybe the dest destination. Right, right, that's very good. But it's yeah, computing global invariance is challenging, but should be possible in this framework. And it should be possible with new approaches. Your algorithms. Okay, so how do we, I have to hurry up a little, I think. How do we get our hands on the neurons very group? First thing is that you can do is you can try to look for For reducible fibers. So, what you have down here is this Q, which is P1 times P1. And then you have X upstairs. And generic fiber is an elliptic curve. And then you're looking for points where your elliptic curve degenerates. So, some singular fibers over there, and then you can decompose these singular fibers. So, this is an internal function, ideal sheaf of physical locus. We push it forward to P1. So, this is projection to one of the factors here and do a decomposition of the ideal sheaves of the fibers. The ideal sheaves of the fibers. And that can be done automatically, and even though it has to pre-compile to see, it's rather quick. And what we have here is a list of biodivisors on a scheme. And then we also need sections. For this purpose, we make an Anzatz where we have something like a tilted diagonal down here, an X. This is delta A. Like this is delta A. Then we vary A so that the equation up here that defines this two-to-one covering factors and we get sections from that. That's a little more involved. I think we don't want to go through all the details of this code. Just the takeaway is we make this ansat where A is a variable, big T, and then we can. And then we can just kind of do this generically and then compute a discriminant of the defining polynomial upstairs restricted to this diagonal with varying t and final correct value invariant electric vibration. Sorry. Sorry? No, no, it will not. It will it will not. I guess it's very good. So these are candidates for these tilted diagonals on Q. They are given as sheaves of ideals on Q. We can pull them back up to our candidate of X and decompose everything again. And decompose everything again, and then we get 16 sections of our genus 1 fibrillation. So what we need is we have now a a reasonable set of generators for our neuron so variant group. We need to see whether it's already generating the group, we need to do see what are their intersections. See what are their intersections. So, we can intersect biodivisors on this surface, and that's something we can do, I think, quite well by now. This is a 32 by 32 matrix, and it filled all the entries from intersecting biodives. So, we don't have to do this by hand anymore and go to every chart ourselves. We can just do it with a computer within seconds if we're lucky. Seconds, if we're lucky. But two file devices on a smooth thing, smooth scheme, which I give you as blue charts, you can handle numbers. Yeah, yeah. On a smooth surface. I mean, if it's a three-fold, then you won't get numbers, right? But for this particular case, we have a routine which says intersect two-to-file divisors, give me the number. Unfortunately, this is not sufficient. The rank of neurons here relatives. Sufficient, the rank of neurons in urinal is 18. We only have 14, there are some missing. So, what we did is we realized this group action on the surface and then used that group action to move around divisors. So, I'm going to go through this a little more quickly. But what about the fibers? Maybe there are some reducible fibers. We already collected them. All the reducible fibers are already in the in the bucket and they didn't suffice. And they didn't suffice. So, this is a manual realization of this action, or of a lift of the action of these two matrices G1 and G2 that I showed earlier. And we can turn them into actual morphisms of X. And then what we also have to do, I mean, this action on P3 was not faithful. And we can realize the remaining part that got lost as an evolution. Got lost as an evolution of this two-to-one covering. And now we have three generators, and we can use these to move around the divisors. So last output is the morphism corresponding to this G2 matrix, and it's a morphism between these schemes, which on one chart has this particular pullback. And then it can be spread out to other charts and it can be used to move around devices. So when you're selling. So, when you're setting these, why is it necessary to tell the system that these are isomorphisms? Oh, right. Because there's no reasonable algorithm to check whether it's an isomorphism. And when you push and pull divisors, then unless it's an isomorphism, it's either not well defined or horribly complicated. So, what we decided for at the moment is you have to indicate that you know what you're doing when you're asking for a pool. That you know what you're doing when you're asking for a pullback, so you have to indicate that it's an isomorphism. It's a little hacky-ish still, but that's what we do for the moment. So here's the action of these three elements on the divisors. You get a 32-element list here from the evolution of the covering acting. Acting and here's some code to compute a whole orbit. I don't want to go through all this code. The message is with what we have. You can give a group and group generators and then this scripting is possible. This probably takes a month of computation if you do it by hand. But I think we made a reasonable machine to We made a reasonable machine to assist you with this. So if I execute this, this is just the definition of the function, and then let's compute some divisor orbit. This will take a little, and then here this is now the orbit of the first divisor only. So we get 31 elements. So what was GG? Again, that's great. What was GG again? GG was the matrix group that was generated by these two things. And it's a little hacky, unfortunately, again, because this was acting on the space Q. We were only taking lifts of what's happening upstairs. That's why 31. It's an odd number for an orbit, so it's not the full orbit. But you can move the divisors around. And here we And here we kind of do the same thing. We look what's not in the list, what else can we move around? We move it around, and we do this for T1, T2, and this involution thing. And then we look what we get as the full orbit of the devices we already have. So now we have 64. We can again. Again, compute the intersection matrix of these divisors. This will take some time, but I can already tell you the outcome will be that now at least this matrix has rank 18. And what Simon could do based on this, now that we have explicitly realized the group action, first of all, we now know that this is the K3 surface we were looking for because the entry in the We were looking for because the entry in the database was unique. Okay, three surfaces with a faithful action by this group is unique, so it's the one we are looking for. And we can pass to the next step, which is the actual construction of the automorphism. And one other thing we can do is with this group action, we can find a matching between the devices we have already found. We have already found, or a marking, right? And the specific generators that were chosen in the OESMU quadruple. So now we have the connection of our geometric construction with the lattice theoretic side that was at the beginning of the story. Alright, so the automorphism is constructed with a technique that's called or simultaneously. That's called, or Simon refers to as vibration hopping, and it has already been developed and exploited by Simon himself and Norm Elkies in an earlier work. And what we do is we use elliptic vibrations on the surface. And for this purpose, we developed a data type of itself, right? So far, you saw. Type of itself, right? So far you saw a covered scheme, and there are again and again these statements that Julia doesn't know how to do inheritance. I think it's wrong. We can do inheritance, so we construct a data type elliptic surface, which is covered scheme. It can do everything that a covered scheme can do, but it can do additional things. Namely, it knows about its vibration to P1. Oh, right, here's the Oh, right. Here's the intersection matrix. 64 by 64. So quite some intersections, and it computes this matrix for us. Which the font size on that so that we actually get to see it a little bit? Yep, we can do that. Always switch inspect. Oh, it might be a bit more. Okay. Sorry. Okay, so the rank of this is 18. So it's plausible that we found a full set of generators, at least up to torsion, and indeed we can select generators of the full derence of variables from that. Alright, so construction of the automorphism, we first need to create an honest elliptic surface from An honest elliptic surface from our covered scheme. So far, it has all been an ad hoc construction. So here's the first chart that's candidate for our Bayes class chart. The description here is not a hypersurface, it has code mention 2, so we can eliminate this variable and get a hypersurface that can be done automatically with a simplify command, and then we get this. And then we get this equation here, and you can already guess this pre-Biostras form: y squared equals something in X with coefficients in W. Or no, something in Z with something in W with coefficients in Z. So you have to match the variables. And that's what we do here. Here we construct the We construct the polynomial ring in which the generic fiber or this elliptic curve behind an elliptic surface is defined. So we constructed the function field in one variable and then two other variables and a homomorphism that takes us there. And we met our f then it already looks a little more neat. A little more neat. So y squared equals something in some polynomial z with coefficients in w. And what we need to turn this into an elliptic curve is a point. We have to choose this point this point manually, but we can choose it from the sections and model that we already have. So here I just peek it, one entry of the list, and I choose that one. One entry of the list makes that one. Then we can feed this to the constructor of an elliptic surface. So this elliptic surface takes a polynomial that is of sufficiently nice form, like y squared equal sub coordinate x, and it asks for one point. And then we'll try to simplify the equation a little bit, or as far as it gets. And if it does simplification, there's a transformation behind. Simplification: there's a transformation behind, and it spits out the elliptic surface and the transformation. So the S itself just prints as this first block. Sorry, I couldn't get the y squared in it. So the generic fiber has a very easy splitching. In fact, it's a surprisingly simple elliptic curve. Surprisingly simple elliptic curve. Alright, from such an elliptic curve, you can cook up what's called a Weierstclass model, which is just zero locus of this in Fi3 space. But then you can close it up reasonably with again projectivization of a direct sum of appropriately chosen line bundles, and then again. Bundled, and then we get this fire pass model as a covering scheme. This is still singular, and I promised this morning the resolution of singularities. So here we compute a resolution of singularities. I set the verbose level a little up so that you get an idea of what's happening in the background. For elliptic vibrations, you can only encounter ADE singularities. So that's a rather fortunate set. A rather fortunate setting to compute resolutions of singularities because you only have to blow up the singular points until you're done. What I want to show you here is this can be done automatically and it's just proceeding straightforwardly, needs to do some blow-ups. And then here, now it found everything so it needed to find. Would would it make field extensions if it finds? Extensions if it finds singular points that are defined over an extension? Not automatically, but you could do it. If you find something that doesn't split as you want it, you can pass it a few extensions. Or can it just blow up the higher degree point? Yeah, you can also blow it. I mean, you can blow up any ideal shield. So the underlying scheme is a little more complicated. Is a little more complicated now. You see, it has a lot of charts, not so nice descriptions, but the computer probably doesn't care. This would be tedious to follow up by hand, but for the computer it's okay. Is this parallelized whatever computation you're doing child by child? No, not yet. But we would like to. I mean, we've been talking in the coffee break that we should definitely sit together. Definitely sit together maybe some point in orbits and take some steps towards parallelization because this is actually embarrassingly parallel, right? Like under mention is more here. And the good news is that we have the framework in OSCAR to allow for such parallelizations. We just need to hook up the technical backends. We have modeling of schemes in charts. We can do things in the charts, collect the results later on. Results later on. We just don't have the infrastructure to set up different workers and deploy them. So, this resolution, does it know that it is a resolution still? So, that is there easy access to the resolution graphs of each of the elliptic surface, we did everything a little ad hoc, but you can get access through the continental. Can access through the continuity of elliptic surfaces. Right? For instance, you can ask for the algebraic lattice here. But that specific elliptic surface is not just fibric surfaces. Yeah, I mean we were developing for the purpose that we had in mind. So the algebraic lattice is collecting the exceptional divisors or the components of the exceptional divisors and tries to cook up the full neurons. Tries to cook up the full neurons variable. So, this will take some time, but there's functionality to get that. And Ana is working on the general implementation of resolutions of similarities, and there will be ways to get these things. Because we are working with inheritance, so there will be a morphism of schemes with additional information. I'm afraid now I blocked computation by asking for the algebraic letters. Computation by asking for the algebraic letters, so we have to go on a little bit while we are waiting for the record one for us, so what would be the other entries of the list of divisors and then it's the lattice which is a data type of its own that Simon has implemented and some other things that I usually don't use and I don't recall what it is precisely. But I mean, just to sort of summarize, this automorphism. This automorphism will take this elliptic vibration, some other vibrations. So basically, what you're doing is subwracking them both down in equations and then finding an explicit information from one to the other, I guess. Right. That's what we're going to be doing. So here I did the identification with the surfaces, the surface originally constructed as the The surface originally constructed as this two-to-one cover here to Q. We can pull back divisors along such a morphism, along this identifying morphism. We can use these divisors to find rational points on the generic fiber of the surface. But we also have a hardcore coded version of these rational points, fortunately. Fortunately, so what we do then is we compute the full algebraic lattice after we make known these rational points and the corresponding sections. We do get the full neuron-severi lattice and then we're in the position to realize these vibration hoppings. So, what happens in the vibration hoppings is we already have a marking of our Q3. Marking of our K3 surface, so we can see what the oviso-U automorphism does to the fiber of our one elliptic vibration. We get the resulting divisor, we move it once, we turn that into a new elliptic vibration. This is the two-neighbor step. The two-neighbor step has several important things that are done in the interior. So, in particular, we control. The interior, so in particular, we compute a linear system of an invisor, which we can do for this particular setting of elliptic surface. And then we transform this into a Weierstrass equation for the new elliptic vibration. We can feed this to the constructor for elliptic surface again by choosing a rational point and Then turn this, use the transformations that have been coming out of these intermediate steps to turn this into an identification of the two elliptic surfaces, right? So, and then let's see whether the computation up here finished. Alright, yeah, so we can go through all this now. So here you see a list of devices. See a list of divisors coming from the resolution process, right? And it's neatly arranged, tells you which sensor it comes from, which component it is, everything. Okay. Skip this part. Let's take the hard-coded rational points on the elliptic surface. Inform the surface about these points. And compute the algebraic letters again. This will be okay. Then we perform the two-neighbor step, construct the new elliptic surface, construct the identification, and then, yeah, this is what I would like to finish with. So we have one elliptic surface S, we have enough. One elliptic surface S, we have another one, we have this identification coming from the two neighbors step. We know that the second elliptic vibration is abstractly isomorphic to the first one because we're looking at the same divisor after an isomorphism. So we need to identify this in some way with the original elliptic vibration. This can be done automatically by choosing an appropriate Nubius transformation. An appropriate Mubius transformation that preserves the images of the singular fibers and then lifts this Mubius transformation to the elliptic curves upstairs. And then we extend this diagram further and further. We now have a first candidate. This composition is the first candidate for the obeso-lue automorphism. We have to see what is it doing on the neuron separate lattice. If it's not doing Neurons are very lattice. If it's not doing the right thing, what could be possible adjustments? Well, further Mubius transformations of S with itself, and then automorphisms of the elliptic curve. Automorphisms of elliptic surfaces, which are coming from automorphisms of the elliptic curve. These are finitely many. We have commands for that. Unfortunately, the computations take too long to be shown here. And if we are. Yeah, so at this point you're not really changing the vibration because you know that you've done that step right. You're just finding the now you need to find an automotive that preserves that vibration. Yes, from here onwards, we're preserving that vibration, right? Okay. Okay, and I think I'm out of time, right? Okay, so I have the full hour. We have time to witness the computation happening. So here it's computing the two neighbor step, and that's the output. And now you get an idea of why computations become too complex to be shown here. To be shown here within the presentation. Because this is what you see here are the expressions for the change of coordinates in the Weiers class chart. They are huge and they will be even more nasty over number fields. So these are dense polynomials of degree 200 in three variables. And but we do succeed to To push forward or pull back divisors even along these complicated Mohr systems. And it just takes time. So here's a command to ask for the admissible Bubius transformations. So take S into S2 and it's doing its best to compute it. And then we can realize the composition. The composition of these two maps as a first candidate for the Obeso-U automorphism. So here he needs to compute probably a resolution of similarities again in the background. So everything, all the computations happen hopefully only when you ask for them. Only when you ask for them, right? There's a lot of things that you can compute about an elliptic surface, and you don't want all the computations to be done when you call the constructor. So, in particular, this resolution, the elliptic surface says, I know how to do the scheme that you are having in mind in the background, this relatively minimal model. But the relatively minimal model is not talking when you construct it, because it's expensive. Okay, here is the command that you would ask for, but that takes several hours to run. It's to push forward on the algebraic lattices along this composition. And then you actually play around with it with further translations by sections, right? This is translation homomorphism of the elliptic. The whole orphan of the elliptic surface is induced by the first element of this modifier. Okay, so I think we can finish, wait for this computations to finish, but I can finish the talk and maybe there are questions. So thank you very much. Thank you. Are there any questions?