The soft session. This is intended to be as interactive as it gets, meaning that I'll first tell you a little bit, which is not actually that interactive, about the ideas of the asymptotic expansions module that we have implemented in Sage. And in the second part, I'll actually open up a link, which is very short and memorable, and you can just click on it. Well, you can't click, but you can enter the link yourself. And then follow the example. And then follow the examples that I've provided there online. You don't need to install Sage or anything. It's all online. Click on it. You can run the examples. And if you're done with it, then close everything again. Maybe remember the next time you need to do some tedious computations. We'll see. We'll see what happens on the last slide. Alright. To motivate the entire... Motivate the entire idea. Not that I think this idea of asymptotic computational asymptotic expansions does need a lot of motivation because I'm pretty sure that pretty much everyone here has done something like that before on paper or using some other software. This is mainly one of the chances to show off some nice animations. The story that I want to tell you a little bit is also a story about cutting trees. Is also a story about cutting trees, but in contrast to the talk we've heard before from Alois, my trees, that the cutting process on my trees is deterministic in the sense that you start with a random plane tree, you have a root, children are ordered, and the process that I like to investigate, I've talked about this at AFA, some of them I'm sure, is the following. You take all the leaves and you remove them. And this is what the little image on the right is doing. Select The right is doing, select all of the leaves, remove all of the leaves, and you do this, you repeat this process until you can't continue any longer until the tree is fully removed. I very, very much like the animation on the next slide, because it illustrates this process on a little bit of a larger tree. And the thing that you should first mention what's the parameter we're interested in, it's the size. So I'm interested in finding out the behavior of the trees. out the behavior of the tree size after some number of iterations. This is a larger tree, I hope you can still see. The thing that I really like about this is that it kind of illustrates that there's some sort of complex behavior, where very fast you cut away a lot of the leaves and a lot of the branches that are close to leaves, but then at some point it starts behaving like a path. At some point, it starts behaving like a path. So, at some point, everything of importance has been removed and it just travels up step by step in this little tree. I could not continue to talk about how you exactly set up the analysis of this. I'll maybe very briefly do so, but the main focus of this is still on the computations of the asymptotic expansions, which you'll see in a slide or two. Also, if you're interested in how to generate animations like that, I can also talk about that at some point. can also talk about that at some point later. Not today. Um so I don't really want to explain any of that. The idea is you have a generating function for the plain trees which with an additional parameter tracking the number of leaves. You switch point of view instead of cutting the trees you think about growing the trees which is a little bit easier to model from a generating function point of view. Model from a generating function point of view. There are some substitutions that correspond to this process of growing the trees. So you have some sort of map that tells you if you have a tree of a certain size and a certain number of leaves, then what does this expand to in terms of the generating function? You build a fancy operator that applies, that does the thing, that substitutes this thing for a given generating function, and then you study how this. Generating function, and then you study how this operator behaves if you apply it repeatedly. That's the very short version, and forgive me for not going into detail, but it's really not the part of the talk that's actually interesting. If you do all that and you play around some more, in the end you come to the result that you get the expected size after r iterations of this process as this expansion on the right. So 1 over the n minus. So one over the n minus one Catalan number times the z to the nth time to the coefficient of z to the n in this expression on the right. And this expression on the right, I didn't tell you that, is given in terms of this coordinate transformation. So z equals u over one plus u squared. So this is this is the the idea. I have this thing and now I want to get the coefficients out of that without doing any computations by hand. Doing any computations by hand. Good. So, this is something that we've set up for quite a while now. This is joint work with Thomas Argemeier, Clemens Feuerberger, Daniel Gren, and others. What we wanted at some point was a framework for computations with generalized power series with rigorous control over error terms, so that we know exactly what happens and that we can sort of trust all. We can sort of trust all of the things that occur in this computation. I say especially trust because you can, of course, you can of course hack all of these things together somehow in, say, the symbolic ring of Sage. But if there's one structure on this planet, I do not trust it's the symbolic ring of Sage. It does weird things often, and in particular with series expansions, the results are plain wrong. And I do not want to work over it if I can avoid it. I do not want to work over it if I can avoid it anyhow. How about fixing it? Well, that's complicated. That's complicated. Maybe at some point the symbolic engine of Sage moves to something a little bit more modern. Currently it's mainly powered by some old forkov of GNUC, which, well, yeah, everything is a little bit old and things don't. And things don't work well together as much. The idea, and that's the main thing. Sorry, the font is a little bit smaller. I can't. I actually can increase it. If it works, yes. So... Oh, wait, can I move around things? Well, yet I can't. Okay. The idea that I want to have with this framework, or the features that I want to have, is sort of like this. I need to specify some sort of structure in Sage. I'll talk about that in a moment, just so you know a little. A moment, just so you know a little bit of background in Sage, what's necessary. I want to enter a computation like 1 plus 1 to the n, and then what it should tell me is the asymptotic behavior of this expression for n going to infinity. So without any additional work, I want this to work out. And we worked for that. 2015, we started this in the form of a Google Summer of Code project. Of code project. I was the student at the time, and Daniel Gren and Krimsuberger, the corresponding mentors. And we set something up that did something like this. Over the years, of course, as with any software, we've tried to improve and add more features. I'll show you a little bit more in a minute or two. And most recently, we've had a second Pookie Summer of Code project where the student was Thomas Hagemeier, and me and Timos Hartberg and also Libertani Kren did the. And also Lil Gutanil Kren did the supervising, where we implemented B terms, which is what Steve yesterday showed a little bit. But I'll have to warn you at this point already. The things that I'll show are on a very, very low and technical level. And on the upper hand, on the other side, the things that Steve showed were very high-level applications of these things that we've used. So I won't do very fancy stuff. I'll just show you what. Fancy stuff. I'll just show you what the low-level tools can be used for and well, what comes out of it if you use them correctly. Steve will show so later. Okay, this picture is actually just here for convincing you that we did think about how to implement this sort of stuff. It's a new diagram. I will not zoom in and will not talk about it. Just before we start, I know I keep saying this, but I know I keep saying this, but we will actually start in a moment. People realize you can generate that from the code retrospectively. Obviously, obviously. I did not sit down and draw this. Well, at some points we had an image on a blackboard. But actually, that image and the diagram don't really look alike anymore. Basic design ideas. So, the one thing you need to know about Sage is that every element Every element belongs to some sort of parent. And it's really the sort of set-theoretic considerations that you are making in this case. The main structure that we've implemented, that we are working with, is a so-called asymptotic ring, and an asymptotic ring contains asymptotic expansions. Asymptotic expansions are sums of partially ordered terms, and terms live themselves in a separate thing. themselves in a separate thing, term monoid. These are the summons of an expansion and they are, for example, just to give you an image, 42 log n cubed or big O of n to the 42. These are asymptotic terms. And terms themselves have a growth, which for the example with the log for it that would be the log n cubed, the forty two is a coefficient which lives in the which belongs to the terminoid. Which belongs to the terminoid, and just the growth, we have a separate structure for that, this is of a growth group, and those live there. So, important thing is in Sage, to work correctly with things, you need to know a little bit about how to set up the computations. And in our case, you will need to set up the correct asymptotic ring to work in. It's not extremely scary because usually you know how the Because usually you know how the expansions look like, more or less. And that's all that we need. Well, you'll see in a moment. Can I ask you a new question? So you say term monoid. What's the operation of this monoid? The term monoid you have multiplication. So the multiplication of of different terms is is the operation in in this in this structure. In this structure. And the ring is normal addition multiplication. Yes, in the ring we allow addition for the first time. Also, the growth group, the operation in this group is again the multiplication. I didn't want to talk too much about the algebraic properties of these, but these are what they say they are, more or less. Just look at the diagram of the last page. No addition in the growth group? Do you have addition in the grow growth group? Yes. Sometimes. Just to give you two important development principles of Sage, nowadays it's the case that every new class or function that gets implemented needs documentation, which is very good because then you remember how the things work. Trying to write crypto doesn't work. Anyhow, this is the documentation page for the SM20 screen. And the important thing you'll find here is there are also, if you scroll down a little bit, let me make this a little bit larger so that you can read, there are also lots of examples in here. And the fun thing about Sage is that these examples also serve as tests. So whenever something changes, So, whenever something changes in Sage, the input that you have here is compared to the output that is also specified here. And if something breaks, we notice, usually. And yeah, that's what I was just talking about. All right, that was everything theoretical that I wanted to tell you. Now, let's look at how this thing works. And maybe I do manage to So the link that, if you want to follow along, um, is bhartware.dev slash ask. It takes you to a binder repository and it will probably take a little bit to start up, but once it's started, it should be more or less fast for everyone. Fast for it all. Sure. Here it is. PACO.txt slash Azure. Thank you. And truth will be done any moment. There we actually go. So, this is a little demo notebook I have prepared over the last two days or so. It is a more or less good uh summary of all of our current features and how they work. All of our current features and how they work. It gives a short explanation again of what we consider to be an asymptotic expansion. Basically, some sort of truncated series which approximates a function can also be an exact expression, of course, if there are no O-terms in there. And to execute files in this notebook, you just, if you've never worked with two terms before, just click into a cell and then go shift-enter, or there's a run-up. To shift enter, or there's a run button at the top of the page. So, two technical things: I want my output to be typeset, which is this first thing here, and the second technical thing, which is required for some operations to work correctly, we need to assume that the general element of the symbolic ring is positive. It has no consequence of any further sort, but I do need this to work correctly. I will use I will use as a coefficient ring, so what is a coefficient ring now? Consider the asymptotic ring has elements that I want to have this particular shape. So some rational number to the power of n times n to some rational number times logarithm of n to some rational number. That's the general shape or blueprint of asymptotic expansions that I want to compute with for now in this particular asymptotic frame. Asymptotic ring. And the coefficient ring is basically the numbers you're allowed to put in front of these asymptotic terms. So I'll execute this here so that I'll get the symbolic constant ring, which is basically the symbolic ring without any variables. I just want the numbers and don't care about anything else. And then we this, which is the, well, as I've told you, there is a green, which contains. Told you that a symptotic green which contains all of the expressions that we are interested in. I've mentioned there's a variable n that is the generator, so to say, of this ring. It's literally just a variable n in that context. There's also a nicer syntax where you don't need to separately assign the generator. I'll show you that in a moment. The computations with these things work quite intuitively. With these things, work quite intuitively. So I can just sit down and say I have an expansion that's 42 times one-third to the power of n times n to five-halves times log n squared. So that's some sort of term in there. Then there's another term in there that go off something else, and I can just enter, and it will build the corresponding expression. There it is. If you don't like the typeset variation of that, or the type of Variation of that or the types of output, you can just print the expansion, or you just initially don't execute that setup here so that it doesn't type state. So if you do that, then it outputs the string remotely. All right. Then the ring can do all of the basic arithmetic operations. So you can add two expressions together, and what you will notice is. And what you will notice is that absorption, in the sense that this n here and these 2n here get combined to 3n, that works as expected. There's no term that gets eaten here by the big O term, but if there were, it would also work. We can subtract two O terms from each other, and the result is still an O term, which is good. We can take the big old... We can take the big O of the first thing you did. It's actually like the first thing we implemented, correct? We can take the big O of some polynomial and it will correctly recognize that only the leading term of the exact expression in there matters. And or we can also do multiplication. And in this case you will see that a lot of stuff gets eaten up by the big ol of one that we have in here. Big O of one that we have in here. If we would replace this big O of n to the zero actually by big O of one, it would complain because it doesn't know the one that is specified here is taken to be from the symbolic ring and the big O actually does not belong to us, it's some global thing, and so it thinks you want to build some sort of big O of some symbolic expert, which we don't want. We have everything is. Everything is in this ring A, and if I would cast it in there, then it would actually also work. So it's just a matter of Sage thinking that one is actually from somewhere else than I want it to be. We can do division, and now let's make it a little bit more interesting. Division works by basically it's running the geometric series. So it's the standard thing you would. The standard thing you would do if you would compute that sort of stuff by hand as well. You can as well do something like this: so the exponential of 1 plus 1 over n squared, and it will give you some sort of result, some expansion again, so this time exponential function expansion. And same thing for the logarithm. We can also expand that. What E knows about E? E, it knows about E. E is one of the in the symbolic constraint, so it's just a coefficient. This first term here, this E here is E times n to the 0 basically. How do you control the number of terms? How do I increase that? No, the number of terms. How do you choose the accuracy? Ah, the accuracy. I probably skipped over that. There is a precision parameter which doesn't always do what you. Which doesn't always do what you would expect it to. No, but I forgot. Yeah. So the idea with this precision parameter is that that's the number of operations in some sense it usually does or before it starts to collect things in all terms. It's not necessarily the number of exact terms that you get. So there's something you need to do there. Can you modify this after having the green created already? No, you need to create a new one. Okay. When you created this and specified n was the variable, it seems they defaulted to asymptotic as n goes to infinity, because they're also others. No, we have plans to open up the implementation to so that it also can can deal with variables going to some specified value and not just infinity, but that's not done yet. But that's not all right. We usually, if we need to do something like that, we do it at hoc somehow, so some sort of transformation. One minute. Yeah, exactly. Right. Ah, cool. Okay, let me continue a little bit faster, otherwise we will not get very far. We have the example that I teasered on the slides before already. So this sort of thing expands automatically by internally rewriting this as Rewriting this as exponential of logarithm of times n and so on. The experimental thing that I mentioned earlier are the B terms. So this is something where you can specify. So B terms are meant to be a more quantified version of old terms, in that you specify from which particular point on the bound holds. The bound holds, and you give a coefficient. So you can actually say this speed term that we have here means that we get a warning because it's experimental. This speed term here means from n greater or equal to 5 on, this arrow that you have here is bounded by 42n squared. So that's the idea of it. This was actually introduced, I think, in a book by De Bruyne, not under the name of older B term, bounded term, but P term, bounded term, but uh as under the name L term, um less than L term. We found P to be well before variance. Yeah. You can do basic arithmetic with these. How exactly you do arithmetic is a little bit complicated, so you can't do this in full generality yet, and it will error out pretty soon if you start using more complex structures. But for now, But for now, things like this work. You can add two B terms that have the same growth. You can not combine a B term with an O term of lower growth because then you don't have a constant. You can't incorporate the big O into the term. You can, of course, combine it with exact terms, and you can also combine it with terms of lesser. With terms of lesser growth, like here. The way this is computed is basically one or two lines, but I don't want to do that right now. You can trust me that this is correct for, well, it's correct. Just some more demo things. So we have asymptotic expansion generators for expressions that you might use a little bit more frequently. I'll go back to a more I'll go back to a more sophisticated ring. Harmonic numbers, for example, you have the expansion of those right there. Yeah, right. You can either pass a variable from a suitable ring or you can just pass a string and then it will construct the ring itself. So you don't actually need to know everything all the time. It still works. Catalan numbers we can construct as the asymptotics, the expansion of these central binomial coefficients. function of these central binomial coefficients divided by n plus 1. Do that, and there we go, that's the thing you like to see. We can do singularity analysis in the sense that if you specify a function explicitly and also the location of the singularities, it manages to compute the corresponding singular expansion and from that extracts the asymptotic growth. It is pretty much straightforward. You have the function and then you call the coefficients of generating function method on the Efficiency of generating function method on the ring, and it will tell you that this is Catalan again. And if you don't believe me, you can just take the difference with the Catalan expression that we computed before, and it will tell you it's zero, basically. Same for the harmonic numbers, where you have a generating function log 1 over z, log of 1 minus z over 1 minus z. Same thing, works again, and take the difference again. Again, take the difference again, again zero. Nice. We can do inverse functions, it's not as performant, but if you consider, we saw that in multiple talks today that mentioned simply generated trees. If you have a generated function like that, you just define, you if you have a generated function y, which satisfies this sort of implicit equation, then with the theory from the program. With the theory from the purple book, chapter 6.7, you can also get the expansions from that. Everything, again, more or less works out easily. And bootstrapping, because that was also mentioned, Jim had a different name for it though. Well, we can clarify afterwards. Bootstrapping also works. Here's again an example from the purple book. You have some sort of Example from the purple book, you have some sort of map that you apply to some sort of expansion that you start out with. And if you iterate the map, I think, if you, that's the starting expansion, if you iterate the map, your expansion of, I think, the singularity gets more and more precise until in our world you hit some sort of a boundary where you can't go further. This is because the precision of the of the ring is stopping you from from getting many more You from getting many more terms, but you can just increase that here and then just run all of that again to end up with more terms. Alright, so that's the demo. To finish this off, I just want to show you the example that I mentioned as motivation in these few lines, which I don't really want to discuss in detail. The first part is just the Catalan aspect. The Catalan asymptotics, the second part is some sort of expansion for u and then plugging this in this big expression here. And in the end, you get, it's a little bit small, but I've made it large here, you get that the coefficients that you extract are n over r plus 1, so linear in the number of vertices. If you cut r times, then the expected size of the tree is about one over r plus one. As many people want. All right, and that's it. Thank you very much. Um demo. Uh oh, I guess um Before it, I guess, um we did the the the difference between the Canalman uh computations uh was afterwards I think yeah it was somewhere around yeah there it is very yeah as n goes to infinity this is growing yes because we the the exponential factor is in here so we can only we can only get a difference of of the quality Of the quality that we have, and the error terms. The error terms are exponentially large in some sense. But that's how it is. So the bootstrapping thing, what was the purpose of that? You had a function and you were interested in the fixed point, but then you were taking something else and going towards it, or what were you doing? Yes, you want to have a more or less precise More or less precise asymptotic approximation of some singularity. In this particular example, it's this solution of the denominator over here. And if you just go and iterate this map here, then it will converge to the well, which is quite simple. It's also a nice example from the book. A little so I'm confused about n. That, let's see. Uh that for each n there's a fixed point or are we letting n go to we're interested in the behavior of the root as n approaches infinity. And Domran said, oh, I see, so you gave us a function to apply that offline you can turn. As I mentioned, all of this stuff is really low level, and you need to do some work before you can jump in and use these things. But if you're in there and have the things in a suitable way, then it can be quite handy. I find this very useful if I just directly type a formula into my CNN. So if we want you to do some kind of can we directly type into this working SageMath installation. You don't need anything else. All of this is included in SageMath. So we took great care of getting that actually in and merged. You don't need any separate package right. From what version onwards? From what version onwards? Is it in the middle of the 300.37? 7.3 or something like that? It's been a long time. Yeah. Yeah, we got the first version in 2015, and since then, any recent version would comment on the limitations? Or if I create this ring of some obscure asymptotic scale, when will it start to break? I don't think it's the question whether it starts to break. No, it does. It does. It depends. It depends. You can do this. Um you you can do safeguards, like if I put some some nonsense in this uh the the the term with the double cues. Yeah. Uh what happens? What sort of nonsense do you want to put in? Oh yeah, the same question. I don't know. Uh the sine of QQ, is that a is that not significant? That's simple enough. No, that wouldn't do anything. That would not crash at least for you. Something like this? Something like this? No, I mean uh create the include it as a factor in there. Okay, so in here when you make the ring. Yeah, when you make the ring or I'm I'm not creative enough on the spot to come up with something really really nasty. It's complaining. That's good at complaining, I guess. Yeah. This is robust. Okay. Is that because it doesn't know what sine is supposed to mean? Yeah, okay. Sine qq is not a valid substring of blah blah describing a growth group. So it identifies that sine of qq is a problem. Okay, is there a fixed list of growth groups? No, basically they are all you. No, basically they are all they all you can you can construct them yourself. They they just have the shape some two-letter um uh algebraic parent of uh included in Sage, so I usually use the rationals or the symbolic ring with SR to the power of some of some variable or vice versa. And then you can also do logs and log log. It can do all of that. I'll maybe ask you later what the QQ really is. I think I don't know. It's the rationals, it's a short form for the rationals. But you said asking two. But you said it has to be two letters? Two letters? But this has to be OQ bar. You can actually do that, I think. I think Mark used that somewhere. So if I do QQ bar and delete this nonsense here, it does do that. So it's this is this is a little bit difficult to explain, but but you can you can be quite But you can be quite creative. And if the string notation doesn't work out for you, you cannot construct it manually. So, this is just a short form, and because I didn't want to type, I don't know, Cartesian product of growth group, monomial growth group of blah times exponential growth group of blah. The question I'm asking is different. Okay, how easy can it happen that you do something that's actually wrong without noticing? Not easy. That's not easy. Before it returns something wrong, it raises an error. That it does rather soon. An error. That it does rather soon, but it does create. In that sense, I think it's robust.