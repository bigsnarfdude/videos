And so, first, I would like to remind you, those maybe have forgotten about this paper, the cello paper, how that tool actually went about doing genetic circuit design. So the cello paper was published in 2016. It's been continuing to be worked on since then. The basic idea was to take ideas from my domain, electronic circuit design, and apply that to the design of chip circuits. Indeed, you actually describe circuits using a language called Verilog that I teach in my electronic design courses as well. In my electronic design courses as well. So, the way to do that is you describe a logic function using a thing called a truth table. You have your sensor inputs, which might be small volume inducers. You have your output, which might be some recorder. Zero output means no output production, and a one means output production. And so then what the cello tool does is it comes along and it takes that truth table and translates that into a logical net list and assigns it in genetic circuit parts. Assigned it in genetic circuit parts from a part library that was characterized by foible. So, in their paper, they talked about this one particular circuit, which they called the 0x8E circuit. And this circuit, what they found was when they actually built it and analyzed its time course, what they found was that there was this one signal change where the output was supposed to stay high, but instead what happened is it went low for a little while and then it came high again. Well, that recalled to me as an asynchronous circuit designer. Me as an asynchronous circuit designer, we would call that a glitch. And an asynchronous circuit design is critically important that you avoid these glitches because they can lead to anomalous behavior. So Chris asked me, well, what can we have done differently to avoided this glitch in this circuit design? And sadly, my answer to him was nothing. There was nothing that you could have done because this circuit has what is known in the asynchronous circuit domain literature as a function hazard. A function hazard is one that, no matter how you restructure the circuit, How you restructure the circuit, that glitch is going to be there. The potential of that glitch is going to be there. And so, actually, what happens is you design asynchronous design methodologies to avoid ever having a function hasm. So you have to basically avoid the types of transitions that would lead to these behaviors. So this little simulation is showing you how the circuit leads to this glitch. And no matter how you'd restructure the circuit, there would still be a path that would lead to this glitching behavior. And so this was work by one of my former students, Pedro Fontana Rosa. Our students, Pedro Fantana Rosa. So, what Pedro did then, going from there, is he built a methodology for building computational models that would actually create dynamic simulations of these cello-based circuits, leveraging the data from the characterized part libraries they had, and so it extracted that data. Many of you who know me know that I'm quite the evangelist of Espolitz, the same slide where I mentioned Espel in it. But it basically extracts the data from an SPL representation, puts it in a computational model. Representation puts it in a computational model. There's my only math. I'm sorry, I should have put more math in. You can get a math theme. But so basically, it builds a differential equation model that you can then simulate, and lo and behold, you actually saw the glitch in simulation that you saw, that they saw in the laboratory, and you saw several other glitches that they didn't simulate or that they didn't actually see in the laboratory. So, this methodology can be used to identify glitching behavior. If a glitch causes an irreversible change, it can have Causes an irreversible change, it can have drastic consequences. And for safe operation of a circuit, avoiding such unwanted variations in circuit output can potentially be crucial. So one thing you might do is say, well, maybe I can't avoid it, but maybe I can reduce the probability of it actually leading to a glitch in behavior because the nice thing about genetic circuits, as opposed to the transistors we have on our laptops, it's okay if they don't work all of the time. So we looked at a few different alternative designs. Alternative designs. These are all logically equivalent, but they're structured a little bit differently. And then we used a technique called formal verification to analyze the probability of these glitches actually manifesting into an error in state. And we looked at all the various inputs where we knew function hazards existed, and we quantified the probability of that actually leading to a glitch. This is work done by Lucas Brigerel. And basically, different designs, depending upon different input combinations, fared better. Depending upon different input combinations, fared better. So, if you knew what inputs you actually planned to apply to this circuit, you can then select the design that would actually have the lowest probability of failure in those particular glitching transitions if you couldn't avoid those glitches. And so another thing that we noticed was that there were also in this particular circuit logic hazards. So a logic hazard on the difference of a function hazard is it can be avoided. You can actually restructure the design so that the logic hazard goes away. So that the logic hazard goes away. Now, in this case, this logic hazard is known in asynchronous domain as a dynamic logic hazard, because the input is low, the output is going high, but it glitches along the way to the high state. So you see this place where it enters in this, it goes high for a little while, and so it starts getting low again, and then it starts to go high again. And so when we saw this, we were kind of wondering, okay, so we can redesign the circuit in a considerable way. So you can use what's known as hazard-feed logic. So you can use what's known as hazard feed logic minimization, and you can come up with an alternative circuit implementation, which in this case, the hazard has gone away. It actually goes up autotonically now. Though it goes up slower, it comes out a bit later. And so the question was, well, do we really care about that dynamic logic hazard? I mean, in genetic design, maybe it's okay if there's a little bit of a glitch along the way, your final output, would it ever really cause a problem in the genetic surface? Really, cause a problem in a genetic circuit design. And so, this was all kind of review. I don't know for people if this is what we've already done in the past. What I'm presenting now is literally things I was putting together on the flight over, including data that my student was sending me. This is where it gets a bit rougher. And so, the same student, Lucas Buquerill, was very interested in actually doing some experiments himself. One of the reasons I moved to CE Boulder was they actually had given me now a wet lab. I don't know why they'd want to do that. So, we're almost to the point ready to do experiments, but we need to have people who actually know what they're doing. And so, Thomas Gorachowski from Bristol was kind enough to let my student go and to visit him for five weeks and get some hands-on training with building genetic circuits. And similarly, a couple of you were, I think they actually both left at this point, were instructors at the Colt Spring Harbor lab. It was advertised, one of my students were up there as well, so we're trying to get cracked up for this. So, Lucas went out to Tom's lab. So Lucas went out to Tom's lab. Tom's wife had a baby, and he never saw Tom again, but his students were really great to work with. And so the one circuit from the cello paper you can get from Adgene is this one, the 0xF6. We thought it'd be cool. Let's build a cello circuit and learn how that actually works. And so that's what he did. He ordered this from AdGene. That's the truth table over there. And then he built the circuit with lots of help from Tom's fellow students. And he did flow cytometry measurements. He did fluorescentry measurements, and so this is the results coming from Lucas' experiment, which were exactly more or less exactly the same as the original cello paper. And they matched up with the truth table. So the first four outputs were high as expected. The next one was low as expected. And the next two were high-ish. And then the fourth one was low. But the key thing is that these are, this is a logarithmic scale, right? And so these output for these second two here are not near. Here are not nearly as high, not nearly as bright as the other four inputs. And so this became even more stark when he went and did his plate reader experiment of the same thing. And so this column here, which doesn't even really look like it's on if you look at it visually. In fact, if you look at the plate reader experiments, you can see for the position six that it really doesn't look like it's turned on. So the first four turn on very clearly, five less so, and six. Five less so, and six hardly even looks like it's turned on at all. And so we were really curious: so, why did it not work really well? What's the problem with that particular combination? So, luckily, we have these methods of doing modeling and verification. So, we said, let's go build a model and let's go take a look and see if we can reason about why that one didn't work as well. So, he built a model of his circuit using the methodology I showed earlier. And what we saw was that initially, That initially everything is low, but then everything starts going high immediately because there's nothing being repressed. So, what happens is this gate down here turns on, but then it turns off right well again. So, YFP starts going up initially, but then this gate turns off. And so you actually have this area of time, which went by really quickly, but this area of time where YFP gets disabled. And then it gets re-enabled again by this upper path. Gets re-enabled again by this upper path. But this upper path's got a lot more logic, so it takes a lot more time for it to modificate through and turn this on. And so then what we did is we said, well, let's see if we can figure out if we can use formal methods to extract the traces to try to figure out how we might be able to redesign the circuit. So we passed it over to another student in this joint project we have for the University of South Florida, Mohamed Ahmadi, who took the circuit and we asked him, Who took the circuit and we asked him, Can you produce the traces that work and the traces that don't work? And so he produced this air trace. And in this air trace, what it shows is that what happens first is you see that AMTR and PHLF, they're both basically increasing right away. These are repressors to the two promoters going to YFP. So they both turn on quite quickly. And then what happens is both of the promoters in the Dior gate, the AMT, PAMTR, and PHLF, get repressed. PAFTR and PHLF get repressed, and this means that YFP gets disabled in that state. That's why it's marked in red. And so then, in the meantime, what's happening is that SRPR, which is the purple gate there, it starts to have its protein get produced, which starts to repress the promoter going into that NORA gate. And then BETL, also, which is coming from the red gate, it starts to build up, which represses the other promoter. Eventually, you see PHLF turned off, which stops the repression. Off, which stops the repression of the promoter going into YFP, and it turns on again. So it goes, well, YFP is on, and then it's off, off, and then on again. So you can also extract traces that work. So there are traces through the state space, some that fail and produce that glitching behavior, and some that actually don't produce that glitching behavior. And so here's a representative trace where it doesn't glitch, and in that case, what happens is the path, the longer path through the top of the logic, it transforms. Top of the logic, it transmits first, while this gate down here is keeping YFP on. So we've kind of said that imagine this gate was really slow and it doesn't switch till the end. So it will hold YFP on until this propagates through and then this is free to turn off and then you don't get a glitching behavior. So we simulated, so we said, well, what if we just added some extra delay to make this path a bit slower so that it would be even better. Slower so that it would be there to hold things on. And so, this is the simulation you get in that case. And so, what's actually happening now is this lower path is holding YFP on while this path is working through its process to get on. And then it goes off later. And so you've got rid of that sort of glitch at the beginning. So again, so why might we care about that? When you put these two curves together, what you see is the curve that glitches actually doesn't change as bad. Doesn't change as fast or go as high. So you're actually getting to, say, let's say, for example, we want to get to 60 molecules of YFP, we get there sometime before those 400 time units on the corrected circuit, but on the other circuit it takes longer, and it's also much more marginal getting to that state. And so this looks promising. This looks like this might actually help us. So we're actually. Help us. So, we're actually, and why this seems very, why this might relate back to the circuit is because we noticed that because of stationary phase, which was talked about a lot in this meeting, you see how all these curves are going down. As they enter stationary phase, they run out of nutrients and stuff going down. So, that's why this one here, even though it's slower and it's going to go the same final state, by the time it got up its gusto to sort of head towards that final state, it was already. Toward that final state, it was already too late. Resources were gone. And so the slowness of the circuit that was caused by that glitch is what's actually caused it not to ever reach the intended state. So it was important to try to speed that up in order to get it to the intended state. So the hope is if we speed that up, then perhaps that will actually work better. But on my flight over, we got a wake-up call because we went and did formal verification on this and says, yes, we did improve. Says, yes, we did improve that one, but we screwed up everything else by adding this case. And so basically, what we asked our formal verification tool is what's the probability that we reach 60 molecules within some amount of time, basically before stationary phase. And so, I mean, because the units in our model don't align perfectly with units in the experiments, we don't know where that is. It might be 300, it might be 400, it might be 500, it might be 600. Who knows exactly how that aligns? But what you see. How that aligns. But what you see in all these cases is that the probability, this is the one we had in question, with the new design, yes, it improved it a little bit. It's a little bit more likely to have worked, but unfortunately for all the other inputs, it's less likely to have worked. So we definitely made a trade-off there. But the key thing, the key takeaway is: yes, maybe this is not the best redesign of it, but the key takeaway is this methodology allows us to evaluate. This methodology allows us to evaluate that more rapidly because we got ourselves excited about it. You could run the lab, start building it without realizing, oh my gosh, you know, yes, I thought through the one problem I was trying to fix, but I actually caused problems otherwise. The methodology enables you to see that readily. So we will probably go back to the drawing board and look at other possible rearrangements that might be able to achieve the same goals without having such a knock-down effect on other values. The other big takeaway, I think, of this is the presence. Big takeaway, I think, of this is the presence of the glitching behavior actually can affect both the dynamic behavior and the steady state behavior. So it's the case that, you know, maybe, you know, my naive assumption before is if something is steady state, you just wait long enough and it's going to be okay. But if you actually, it can actually be the case that if you care about steady state, you also care about dynamic because the dynamic can affect your steady state. So characterized gates and automatic model generation. So, characterized gates and automatic model generation can provide predictions of the impact of glitching behavior. So, this can allow you to more readily evaluate design decisions. The stochastic nature of genetic circuits can lead to situations where you need to tolerate, rather, eliminate glitching behavior. So, in asynchronous design, my number one goal was to eliminate any hazards because even the presence or risk of a glitch was a bad thing. But in biological circuits, maybe we can tolerate a certain proportion of glitching behavior, and hopefully, some. And hopefully, some of my past life and formal verification can help to explore alternative circuit designs going forward. And so, kind of, the first half of this talk was supported by DARPA and the student Pedro, and the second half of the talk was supported by NSF and Habits. So, with that, I talk really fast, so I think I've leave a few minutes for questions. Thank you both to Chris and Caleb for getting us way back on time. Anyone needs to check? If anybody needs to check out other hotel room, feel free to do so. Any questions for Chris? I have a question mechanistically. So your models, are you building ODE models underlying each individual gate part, or are you building it in some sort of like abstract ruling logic? So we have multiple model generation techniques. They're basically derived around each sort of logic gate part. Logic gate part. So, like each NOR gate inverter, there's mathematical models inherently describing the behavior of that NOR gate or genetic inverter from the cello circuit. And similarly, we also have a stochastic model generator, which was, I think, actually the main one we were using here, was the stochastic model generator. So, the ODE model generator actually takes characterized part information from the total library. You know, they have these numbers that they've calculated for binding affinities and For binding affinities and cooperativity effect with basically all of these parameters. And we plug those in to do the more precise modeling. But we also have these that use default parameters, and we use those more for the stochastic modeling. I think most of the models were actually using our default model generator that wasn't actually using the parameters from the Hochelle Part library. I didn't follow. You said that on the flight over, you're sure your model flips and said you added all this stuff and it You added all this stuff, and it wasn't necessarily doctrine all. Well, what happened was I got these plots on the flight over because, um, as I said, we the other parts, you know, he'd done that. The design was in the spring, we've been doing some of the modeling, and then I said, can we calculate the probabilities of failure for each of the inputs, not just the input? You know, we saw the simulation, it looked better, but it's important to always realize that even though it looks better, I mean, it certainly looked better. Looks better, it certainly looks better with an OE simulation, that the stochastic modeling was very important to look at the likelihoods of things. So we tend to be more towards using stochastic techniques, stochastic model checking, stochastic simulation, because it's more the probability that's of interest to us. So from the ODE standpoint, it looked like you had improvement, and you did have improvement, but when you did a stochastic model, we found the probability of improvement was relatively small, and the problem. Was relatively small, and the problems in the other places that you created, because that path, that path of that single inverter, that's actually what turns on the OR gate in all these four cases. And so by making that slower, you made it harder to get to its key point. Now, maybe we could make it a little slower, but not as much slower, and we could trade a little bit between the two. But we'd like to kind of go through those different permutations. That's what the modeling technique enables you to do. Have any of the names of the table. When you say so, count. I have a question. Oh, Edmund, go ahead, me first. Yeah. Hi, hi, Lebesger. Nice to see you again. So my question is, I'm just a little bit confused about something, sort of conceptually. So you said even if we are interested in the steady-state behavior, we need to worry about transfers. Now, if you have a circuit that has no feedback loops, and if you're in And if your inducers are kept at a constant concentration, I mean, we are still, you know, presumably the growth phase, so we don't have to worry about the effect of growth. Why should that make a difference in the steady state? I really missed that. Well, in this case, the reason it made a difference is because the growth, the turning on of this was so slow that by the time that it was ready to turn on, It was ready to turn on at state six, it had already reached stationary phase. And so there wasn't and so that affected things. So if you basically, if you, so I guess it's like if you have to reach something by a certain amount of time, then you care about how long it takes you to reach that. And if you ha if your circuit is not optimized to reach that within that period of time, then you can actually not reach the goal and you're allowed time. And you're allowed to tie it. No, no, I'm a question that I just wasn't sure. You know, it's the, you know, in the end, everybody's dead anyway. So, I don't know exactly this case, but no, no, I understand. I completely thanks. I just asked if it was a question of broads. Yes, it is, yes. The variation in plasma copy number and plasma certification model has a huge effect on as things are pretty much. As things are turning off and turning off, that while it's growing, that if some subpopulation of cells has lower copy number as something it's supposed to turn on, then at that next phase, it won't have enough progressor to turn on or turn off. And so that'll have a weird effect on the dynamics with quite a bit of variability. Yeah, definitely. I think that's an interesting point. And I think that you could also imagine. I think that you could also imagine exploiting Plasma copy numbers so that you get more copies of your gates, right? To try to, rather than slowing things down, what you could do is maybe speed up the other path by adding more copies of that circuit so that it could speed that one up in the same time. So you can play with things rather than the more crude approach of just adding the lay algorithms. That's a pretty crude way of modifying the design because you can modify the delay. The design because you can modify the delay by playing with copy number instead of time. So, actually, can I ask before? Oh, I think we have one more hand. Ms. Kay, did you have a question? I mean, between the online question and ours, it was actually asked for least answers. Never mind. All right, Eduardo, go ahead. Last question. No, just to, yeah, I'm sorry, I didn't need to cut off. I can't see people raising their hands or anything. So, no, no, just. So, no, no, just a photo up to that. I thought a little bit more about this for a second. So, you know, when we're doing, we're actually trying some things itself under that now. And, you know, usually what you do is you kind of replate things. You know, you get to a point where you're, you know, you're passing this point to phase, and you say, okay, now I'm going to just take some farther in and replay it and so on. So if you do that, you have more of a chance of going to, quote, steady state, unquote. Steady state. Are you doing that in this experiment? This is just one. No, we're not doing that in this experiment. But you're right in the sense that if you gave yourself more time to reach your goal, you'll increase the likelihood that even in that state that you would reach your goal eventually. But I think that what's more interesting is that there's always some time limits in life. And so it's more interesting to see the effect, the fact that the time does matter, even if your end goal is steady state. There are situations. State, but there are situations where you can't just solve your problem by making the circuit slower. So you have to, sometimes you have performance faults. I mean, just one last funny thing is the first time I went back to the asynchronous circuits conference, we presented a design of a genetic circuit. It's a circuit that's really useful out in asynchronous design. And my student was up there presenting, and he presented his plots of his design. And then they asked him, what's your x-axis? He said, oh, well, that's in minutes. In minutes. And the people in the audience are like, minutes. They're used to like eco seconds. So, despite that, they gave that student the best paperwork. But still, it was just like it kind of shook their... Yeah, so definitely the time scales are very different. But performance does matter even in synthetic problems. Great. Thank you. Thank you so much, Chris. Appreciate it. For our participants on Zoom, we have a coffee. For our participants on Zoom, we have a coffee break now. It's about 10 minutes. We'll be starting around 10.15-ish. And if we could have the next person on Zoom go ahead and start to share their screen now,