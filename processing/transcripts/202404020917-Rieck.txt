Very much and for letting me be a part of it. Thank you very much for the invitation. And so I was asked to make this part of the talk accessible. I figured let's start in the beginning. We want to talk about complexity. Complexity is complexity, how hard it is to calculate this, I think. And so you can ask how hard it is, what you want to calculate, how hard it is to count. Maybe you have a graph. How hard it is to count all the three colorings of the graph. That's incredibly hard, by the way. Don't try it. Send it to them. How hard is it to? Maybe you want to calculate pi, you can't calculate pi. How hard is it to approximate pi? I want a million bits of pi. That's actually incredibly easy. I think the most basic for me, question about complexity is decision problems. So a decision problem, that's a function. That's a function from your input, a function from your input into yes or no. Decision problem just decides yes or no. So this is all about not. So your input will be a knot. And you can ask if it's three-colorable, if it's hyperbolic, if it's If it's unknown, so this setting, asking if it's unknown is a little bit stupid. If it's the annotate, we'll say yes, and for other things, we'll say no. But it's still a decision problem. There are two incredibly stupid decision problems because there are two constant functions. But it's a function. Any function counts as a decision problem. And so, there's something a little bit more stupid on the board here because how do you actually put a knot into a computer? It really doesn't make sense to say. It really doesn't make sense to say that. So you should have some presentation that makes sense to a machine. And so you can write, for instance, there are variants, of course. You can say it's a function from not diagrams. Now asking if it's the anode is not a silly question anymore, of course. And I'm trying to do this introductory part without any unnecessary rules. But there is one rule which is necessary. You can choose what you want your input to be. But it has to be something that the machine understands and it's something that has a size. And it's something that has a size. The size is literally the memory that you need in the machine to use, or something that's polynomially related. And so, for a null diagram, it will typically be the crossings, the number of crossings. And if you bound the size, there can be only finite in your movement. You can't set it up so that there are infinitely many different inputs with the same size because no machine can handle that. And so, what we want is a program, whatever you want to mean by that. Whatever you want to mean by that. You know, that takes your null diagram and calculates something and gives you a yes or no. So you can see from this setup that any program like this is itself actually just a decision problem. And so maybe the first question before we talk about complexity is: can we even calculate them? So that's the question of undecidability. So that's the question of undecidability. Other decision problems that you can't even calculate, of course, everybody knows that the answer is yes, and everybody blames Turing for that. But I don't think it's Turing actually. Cantor's theorem is For any set X, the cardinality of X is less than and not equal to the cardinality of the power set of X. When you know the power set, however you want to set it up, it's a set of all functions from your set into yes, no, or it's a set of all subsets of your function. It's the same. If I give you a function into yes, no, take the pre-image of yes, and that's the subset. And so, what's that got to do with anything, any program like this? Any program like this would give us a decision problem, and the question is: so we have our programs or a machine or a Turing machine or whatever you want to set it up, however you want to set it up. And that adds into decision problems. And the question is: is this on And the question is: is this onto? But if you write your program with at most a thousand characters, I think the North American keyboard has 95 characters that it can write. I read it somewhere, I think, but it's some number. So with a thousand characters, you can write so many things. Most of them are jackpot. Every size has only finitely many programs. You make it longer and longer. It's a countable union. There are countably many programs, so there is a bijection. This is all in the category. Bijection, this is all in the category of sets, so isomorphism is just bijection. From n here, decision problems are exactly the power set of all knots. But knots, of course, are in bijection with n. So decision problems are in bijection with the power set of n. So if this horizontal, then you'll have an onto map from n to the power set of n and counter set which you not want to map. So So, I don't know, just so that you all have happy memories for my days as undergraduate, let's prove Cantor's theorem. So, proof. Take any function f from x to the power set of x, and my job is to give you a set here that's not in the image. Now, if you're given a function that for any x in x, you can ask the question of whether x itself is in f of x, because f of x is. X because f of X is a subset here or not and take all the ones that are not. That's your S. And the claim is that S is not in the image. And why? For any X in X, what do we see? We can compare S and F of X. Well, take your X. There are two possibilities. Either X is in F of X or X is not in F of X. If F is not in X of F of X, If f is not in x of f of x, then by definition of x s, it will be in s. So in that case, they're not the same. And if f is in x f of x, then by definition of s, it's not in here. So in both cases, it's x itself that's going to allow you to separate f of x from s, because it's going to be in one and not in the other. And so one thing to take home from that is that this is a sort of a self-referential thing. You're looking at x in f. You're looking at x in f of x itself, and it's negated. Okay? And so, what did Turing say? Okay, so anyway, once you have this, then you can say now we need Geddel and Turing. We won't discuss Gedel here because he didn't go into Not Turing. Turing actually was the first person, I think, to ask whether the anode. Person, I think, to ask whether the unlocking problem is decidable, or rather, to remark in 1954 that there is no algorithm for this. And so, how did Turing get undecidability? Suppose that you can decide. So, you have a decider. Here is your decider. It takes as an input, let's call it D, which is a description of a machine, and it outputs, yes. Outputs, yes if false, and no if it doesn't. And so now what you do, what the cryptographer calls, you build an elementary wrapper around it. I need more space, though. And what the elementary wrapper does, that's a new machine that uses the old machine as an oracle. It itself will take a description of the machine, will feed it here, and in the yes case, yes means that the machine that is described here holds this wrap. Here holds. This wrapper runs forever, and in the no case, this wrapper halts. Now you know what you do. You take a description of this machine and feed it to itself. And if it says yes, it means it's supposed to hold, but it won't hold. And if it says no, it's all. So one thing that I want to point out, this is also self-referential because you take a description of the machine itself and feed it to itself, and it's also negative, because you do exactly the opposite. Negative because you do exactly the opposite of what you thought you do. Very valuable. Okay, so that's a little bit of why there is undecidability in the world. And one thing to notice that we haven't mentioned any particular model of computation. Suppose that you like Turing machines, everybody likes Turing machines. And you say everybody is a Turing machine. Can I get your definition of a decision problem? The definition of decision problem is a function into yes no. So it's true there are uncountably many flows, but I thought a decision problem was a predicate, and there's only countably many flows. For me, a decision problem is any subset of the input. Most of those are not describable, so I would not... They're not describable. I would not dignify them as decision problems. Thanks for enough. I think there might be some worry there. Worry. Yeah, that's fair enough. Decision problem, decide in this sense, almost none of them is describable. And that is why people go to Jury, right? Because now we can talk about the halting problem, which is very well describable, and you can say this one is undescribable. I mean, you know, Cantor is like that, right? He told you that almost all the numbers are transcendental. Can you name one? Hermit told you that E is transcendental. A year before Cantor, right? But I agree. I agree. Decision problems. But I agree. I agree with decision problem, the way it's defined here is not very useful for computability, right? And so moving forward, we should really use this decision problem specifically. And how does this relate to a topology? So, first of all, it tells you with a bit of work, but not that much. That much that three famous problems that Dengen asked are undecidable. Then problems are undecidable. That's the word problem, the triviality problem, and the isomorphism. And the isomorphism. So let's just focus on the triviality problem. The triviality problem: I feed you or I provide you with a group given by a finite set of generators and a finite set of words which are the relators. I ask you if it's a trigger group. And that's undecidable. What it means is that there is a sequence of presentations, pi one, this is capital Pi1, so it's not the pi 1 group. Pi 1, so it's not the pi 1 group, pi 2, pi 3, and so on. Some of these are non-trivial, some of these are trivial. It will actually necessarily have to be infinitely many of each. And there is no algorithm to decide which is which. And in fact, if you go to the machinery that was built to prove that theorem, the first presentations that you do are recursively presentable, whatever that means. They're not finitely presentable, they have infinite. Representative where I have infinitely many relators, and the relators are listed by the machines that hold. Every machine that holds will get a relator, the machine that doesn't hold will not get a relator. So you're going to have a really hard time writing these relators down. But there is a sequence like that. And with this sequence, you can now construct a sequence of manifolds, pick your dimension, G, M1, M2, M3, and so on. M3 and so on, so that pi1 of mi, this is little pi, so this is the fundamental group, is gi and gi is connected, so this all makes sense, and so on, and so on. So, of course, you cannot construct them in every dimension, like dimensions, the manifolds have to be connected. In dimension zero, the fundamental group is trivial. We all know that in dimensions zero, one, two, and three, fundamental groups are very special. And this has to allow for any fundamental group. So, your dimension has to be at least. So, your dimension has to be at least four. And then you do some work. You use HOP for I2, you use Boravids and Whitehead for some homotopy theory, and I think Smale proved something. I'm really tempted to put Kervari and Milner here. Tempted to put Kerver and Milner here because they worked on this kind of stuff a lot, but they worked after this theorem. Marcus put it all together. And basically, what you do is you say, if I have homology, I'm going to kill off the homology. I'm going to represent the homology by an embedded sphere. I'm going to do a surgery on the embedded sphere that now the manifold doesn't have that specific homology anymore and you kill off all the homology. Except, you know, you have one C in dimension zero and one C in the top dimension, of course. One C is the top dimension, of course. And you get with the work of these people, you get that this is a homotopy sphere and it's actually a sphere. And then what you get is if pi 1 of Mi is trivial, then Mi is Sn. And so now if I feed you Mi, and you can tell me if it's Sn or not, I know if the group was true. N or not, I know if the group was trivial or not. Except that this doesn't work. Without seeing the details, you can't hold it, it doesn't work. In dimension 4, second homology is particularly important. You all know that there is the intersection form and second homology and all that, and this will obstruct you from doing this search in dimension 4. So this only works in dimension 5 and above. Dimension greater than or equal to 5 and or equal to 5, S, let's call it M actually. Sn Sn is not recognizable. That exactly means what we just said. If you the input for your algorithm, which does not exist, the input is a triangulated P L manifold of dimension N. Of dimension n. And you need to say yes if the manifold is Sn and no if the manifold is not Sn, and that's what you come to in dimension greater than or equal to 5. So corollary. I always write notes and then I get all excited and I don't know where I am in my notes and then I don't choose. I don't know where the corollaries are. So, what can be the correlators? One for dimension greater than or equal to six, it is undecidable if a simplicial complex. Complex is a manifold, which to me is very shocking. So you're given a simplicial complex in dimension 6 or more, and you're asked if it's a manifold, and what you need to check is links of things. Let's start with vertices. A link of a vertex in dimension sort, in dimension what n, that's got to be an n minus 1. That's got to be an n minus 1 screen. So you look at the link, and there is a very nice complex, and you're asked if it's a SN. Well, you can't answer that question. You can't know if what you're given is a manifold or not. Anything that's working? That's good enough reason to work in dimension 3. Another corollary in dimension greater than or equal to 5 is undecidable. If a simplicial complex, let me just write complex, embeds in if A and N complex, so the complex itself has dimension n, if it embeds in Rn. Y will give you the complex, maybe the, you know. Complex, maybe the you know, self-bluings and stuff like that. I don't like that. Do a couple of pericetic subdivisions. Take the interior of one of the simplicities and remove it. If this embeds in Rn, then what you're holding in your hand is a ball. And if it's a ball, then what you started was was Sn. But you can't know that. It's exactly what you can't know. So you can't know if it's simply shown complex embeds in R. And so. Let's first of all talk a little bit about decidability of recognizing the sphere. Dimensions 0 and 1 are an exercise, and dimension 2 is also an exercise. But it's not as trivial an exercise as people usually say. People say it's just Euler characteristic, which is not, because the Euler characteristic of two RP2s is two. So it's Euler characteristic plus connectivity, but that's still easy. Dimension 3 is easy. These dimensions, three things we can talk about. Recognizing S3. So yes, yes, it's possible. And that is, of course, Rubenstein and Thompson. That's an algorithm that terminates. That's what you know. Terminals. That's what you know about the time complex to that one. Hess then, the forgotten part, you show that it's in x, which means modify the algorithm so it will actually run in exponential time. So now you actually have a bound on the time. That's an improvement. Then Ivanov and Schleimer, and both these and these, they're independent. These and these, they are independent. They show that it's in a complexity class called NP, which deserves a proper explanation, which maybe we won't do now. But you've all heard of it. Anything in NP runs in exponential time, so that certainly implies what Casson said. But it's certainly believed that many, many exponential time things, like anything that gets done in polynomial. Like anything that can be done in polynomial space. Anything in NP can be solved in polynomial space. Anything in polynomial space can be solved in exponential time. So according to our usual conjectures, there is a massive gap between just being exponential and being empty. Then Cooperberg. Mod GRH said that it's in co-NP. So NP means the following. It is a polynomial time algorithm, but it doesn't take as input only just the manifold that you feed it. You have a manifold, one model, it's S3. It also gives, takes an input a certificate. You can think about it as it takes an input the solution. It's a little bit silly to call it that. The certificates Calling that. The certificate certifies that this is indeed S3. And if it fails, it means a failure of the certificate. It does not mean a failure of the manifold to be S3. So if you're in NP and you have the right certificate, you can verify 10 point time, which can't be better. If you don't have the right certificate, well, you have no choice but to try all certificates or have somebody verify provide you with one. It's still good because they provide you with the answer, but you can verify that the answer is correct. The answer, but you can verify that the answer is correct. And what does in coin be? The complementary problem switches the SMOs. So, what Zendner did is that, you know, he said, if the manifold is not S3, I'll give you a certificate for that. And he need a general agreement hypothesis, which doesn't matter to us because we're not number theorists. But anyway, that's so there's a lot of nums there. Yeah, oh, there's a little hole that isn't there. There's a little hole there isn't there. So let's just leave this as a homework. Check n equals 4. Decidability of S4, that's homework. All right. And so, and if you do find the answer to the homework problem, just let me know. I'll write it up for you. Okay, so there's a ton of stuff to write on the board now, much more than we have time for that. But one definitely interesting thing. But one definitely interesting thing is the sideability or recognizability of S2 process2. Five years ago, four years ago, a few years ago, Cameron Gordon proved that you cannot recognize 12 connected sum of S2 process 2. Martin Tancerin proved that to nine connected sum of S2 process two, which is not altogether a bad thing not to recognize that's a simply connected manifold, right? S2 cross two is simply connected. Simply connect it. But yeah, I don't know of anybody that has any progress about whether you can or cannot recognize S4. So let's go move on to this corollary. So we can call the problem embed k into n and then To n and the instance, the input is a k simplex. And the question is, k simplex, let's call it x. And the question is, does x embed in Rn? So you fix your n, you fix your k. And so there's a very beautiful picture for n greater than or equal to 4. And the picture looks like this. This. Here is your k-axis, here is your n-axis, here is your n equals k line. We actually should have started by saying that k is less than n. If k is greater than n, you can't embed the tetrahedron in a plane. Yes. Right. Thank you. So it it's it's just going to be never over here. To be never over here. Here, there is a region when k is less than n over 2, and then it's always. Like, for instance, maybe you want to try to embed the graph in R3. Go for it, that's not a problem. So that's just transversality. There's another line here, which is k is less than 3 over, no, 2 over 3. 2 over 3n plus 2 over 3. Plus two over three minus two over three and in this region here it's polynomial 2 over 3n, so 1 half n is easy. That's where transversality tells you that things embed. 3 halves n, 2 thirds n, excuse me, transversality does not give you the things you intersect, but you have no triple points. Not intersect, but you have no triple points. This region here is MP-HARD, and we'll discuss MP-HARD more in a second, but MP-HARD says that, well, we'll see what it says, but it definitely says that there's no polynomial time algorithm. That's another homogeneous. There's a little sliver over here. This sliver here is n is greater or equal to 5, not just 4, and k is n or n minus 1. In the case n we just discussed here, it actually also works for n minus 1. If you have a dimension n minus 1 complex, you can thicken it up in some finitely many ways and check if those and then so on. We know from here this is undecidable. The undecidable region is contained in the NP-hard region. And it's not a contradiction. NP-hard, as the name suggests, says that there is no easy solution. Undecidable says that there's no solution at all. Well, then there's certainly no easy solution. But the name NP is the name for given some type of algorithm. And if you're not used to the subject, NP-hard sounds like there should be some algorithm. NP-hard is not that there is an algorithm. NP heart is not that there is an algorithm, it's that there is no easy algorithm. Well, there's some conjecture in the picture, but I won't. Okay? So that's basically the picture there. And as far as I know, the question of whether this region NPR here, except for this little sliver, whether this region is decidable or not is still open. But if you don't write that down, leave it like this, it definitely looks like. Like this, it definitely looks like we know everything, doesn't it? That leaves my favorite dimension. So, dimension three. So, now where do we stand? It leaves a few dimensions, by the way, but the really small one, like embedding. By the way, but the really small one, like embedding graphs, you know about graph plane art and stuff like that. So let's go down to dimension 3 and stop there. So embedding two complexes in R3 and embedding three-dimensional complexes in R3. And so, did I write down the here? I don't know if I need to shake. Um Sedgwick Tanster I hear that name a lot Thagner I did not drive down the year I don't know I'm gonna get 17 anyway a few years ago decided so there is an algorithm that So there is an algorithm that takes an input, a three-dimensional complex, and tells you whether you can embed it in R3 or not. Then to the NP hardness, then SMA self and Sedgwick and Tancer. This is M.P. Harden, and we'll talk about. This is NP-Hard, and then we'll talk a little bit about what NP-HARD means. Okay? So that's bad news because it suggests that there is no efficient algorithm, but it's good news for some people here because some people wanted the hardness results. So what does it mean that it's hard? Specifically, NP-hard. So there are a class of problems called NP, and all the problems in NP. And all the problems in NP can be solved efficiently, efficiently means in a polynomial time if you're provided with something called a certificate. As it turns out, there is one class of problems within NP, which are the hardest problem in NP, and that's called NP-complete. And one of the NP-complete problems is a three-set, I'll describe it in a second, is a three-set problem. So if you can answer the three-set problem efficiently, you can Efficiently, you can answer anything in NP efficiently. And so, what does it mean to be NP-hard? It means you are harder than 3-Sat. There are thousands of other NP-complete problems, by the way. 3-Sat is the one we're going to use. And so, yeah, okay. So, there are theorems of Kenning and Svyatkova. And Svietkova and this paper of ours. And there's a whole bunch of theorems that are all kind of similar. And so let me show you just one of them. And I think this will help. We'll also help understand what an equal beat is. What the hell we just closed that weird window that was unusual? Oh, yeah. Yeah, okay, there. Here it is. So, three SAT is about satisfiability. And satisfiability means I'm going to give you a Boolean formula, which is a formula in logic, and I'm asking you whether you can find a satisfying assignment. Three-sat means. Sign. Three set means the Fourier has this form. It has triplets like this with orbs between them. And of course, this has two triplets, usually we'll have thousands of them, and ends between all of them. And the thing that links one triplet to the other is that you can have the same Boolean variable appearing in both, or one and its negation appearing in both. And so, how can I show that one problem is harder than three-step? The example here, which was proved by Kenyig and Suvetkova. Proved by Kenning and Svetkova, as well as us, is the question of trivial sub-link. So, ignore the fact that some of these are in orange for a second. This is a link with eight components. This is an eight-component link. You can see here, up here, you have clearly four Hofflings, right? And down here, you have a couple of working grids. And they're kind of blended together somehow. And so, the question is: this: I'm going to give you a link, maybe this one. To give you a link, maybe this one, and I'm going to give you a number. In this case, the number will be four. And I'm asking you whether this link has a four-component trivial sub-link. So whether you can find four components of this link that when you remove all the other components, you are left with just a trivial link, you know, the four components bound for disjointly embedded disks. And so now, if you don't ignore the fact that some of them are orange, the ones in black are supposed to form a trivial. In black, are supposed to form a trivial subject. Work? Okay, so the claim is that if you can solve this trivial up-sublink problem in polynomial time, you can also solve three-setting polynomial time. And how does that work? Start with your three-set instance, say this one over here. This has four variables: x, y, z, and X, Y, Z, and T. Doesn't matter if the sum of them appears with negation. Put a half hot frame for each one of them and decorate the hot frame by X and not X, and so on, you can see the decorations. Now, suppose that there is a satisfying assignment. Such a short formula will always have lots of them, actually. Suppose that there is a satisfying assignment. What can satisfy this? I can put x equals false, y equals true, then this is already satisfied. Already satisfied. C equals false. I mean, this is already satisfied, and C doesn't appear here, so we were turning on C. C equals false, and T now has to be true for this to be satisfied. So because Y was true and T was true, these are both satisfied. That's why. And now go and erase all the components that are labeled by the things that became false. Like we said x equals true, keep x, x is true, not x is false, remove it. We said, Remove it. We said y equals false, remove it. But not y now is true, so keep it. Keep the ones that are true. Clearly, you don't have any more Houghlinks, because from every Houghlink you chose one of the two rings, right? But you also don't have any more Boromian rings. Because the Boromian rings have this property that if you remove one, three, or all three rings, there is no linking anymore, right? That's the whole point of the Boromian, isn't it? The point of the bromination, isn't it? Well, to me, it is. So, since in every set of brominations, in this case, you removed exactly one, but you removed at least one, to satisfy this time, at least one has to be satisfied. The bromines fall apart and you are left with the trivial link, which is what you see here. So, the trivial sub-link is an example of a problem that is NP-hard because we could start off with. Could start off with a three-set instance and in polynomial time construct a link that has the right trivial sub-link if and only if the three-set is satisfied. Actually, only show the if direction, but the not if in this case it's really easy. An instance like this. You have a Boolean formula, it has triplets with pores between them. It has triplets with ors between them, and all the triplets together are gathered with ads. So SAT stands for satisfiability. And the three stands for these triples. So this actually was kind of what we used to show that embed 3 in 3 is also empty hard. So let me show you that one very character. So let me show you that one where it's okay. I wanted it on that page. I'll do that page later. You'll find it. And okay. So what we want to say now is a different question. I'm going to give you a three-dimensional complex, and the question is, does it embed in R3? So this is the description of the complex. First, you see that it's very similar to what we had before, right? Actually, the difference. Before, right. Actually, the difference is that we have these funny things here, these little chains, instead of having half ones. And so, this is a van surgery description, where zero is what I would normally call infinity, is just read it out. So, this complex is going to have boundary. Three over two is three over two, the insurgent coefficient. So, for instance, if you fill everything on in by one over zero, that would have normally given you s. That would have normally given you S3. Then, all the green stuff here, you can just erase it, and this gives you a lens space. And so, you have the connect sound, in this case, of four lens spaces, right? And I think this is the same Boolean formula from before. And so, but that's not what you're supposed to do. You're supposed to, then you know, that's not good, that isn't a bad idea in R3 or S3, if you prefer. And so, how will you get this thing to embed? thing to embed in let's say S3 if this Boolean formula is satisfiable just like we saw before before what do we said well if it's satisfiable erase the one that is satisfied we'll erase the one that is satisfied what does it mean to erase them do a one over zero name surgery so it's back to where it was in S3 and you can literally erase it it's a satisfying assignment you erase at least one ring from every one of the Bohrmian rings and those are false Every one of the Bohrman rings, and those all fall apart. Now, what are you left with? Now you're left with hot flanks. But if you do any surgery whatsoever, whatever you want, we did three over two, it doesn't matter. If you do whatever you want surgery on one component of hot flank, then you're left with the solitaurus. And there's a surgery on the other side that will undo that. There's actually a zero of them. One's enough. And so you can undo all these and get the thing to the S3. You should ask, okay, fine. If it's satisfiable, you can do that, and maybe I believe. You should ask: how do you know that if it's not satisfiable, you can't do that? And that's the problem. Actually, we couldn't do it on this one. We had to, I don't think it's worth our discussion right now, but we had to do some elaboration of this instead of the chain, exactly in order to avoid the situation that you have something that. To avoid the situation that you have something that is not satisfiable, but there is an accidental Dane surgery that still gives you a, or Dane filling that gives you a strain. And so that's basically what stands behind this. I want to make a summary. All right. So maybe I'll just ask you the question, pose the question. The question, pose the question. If you go back to the picture that we had before, one pretty easy, and forget that some of them were mini-rays. Look at all the eight components. One thing which you do, the component, is you can double each component in class between itself, and that's called the white-headed double. Specifically, if you do the untwisted positive white-headed double, then you have a lot of white-headed doubles of untwisted positive whitehead double. Of untwisted positive wise doubles of hofframs, hofflinks, and Boromian rings. And Adam Levine proved that those are not smoothly sliced. Whatever that means, it doesn't matter so much now. But this is about surfaces that are bound by this that are in B4. And I just wanted to mention it because there is a question that we answer here, but more interestingly, there is a question that we don't answer here. So the Here. So the setup now is this. We have S3, and in S3, we have a link. And of course, every link bounds a surface in S3 because S3 has no homology. But you can push this surface into B4. B4 has a lot more flexibility. So maybe you have a much better surface in B4. For instance, maybe you start with a ribbon knot, and then of course in B4 it has about this. And then, of course, in B4, it has to bounce in this way. And so it bounces on the surface here, which looks exactly like this. And it has some Euler characteristic. And so, what this doubling here proves is the following is NP hard. The instance is a link L in S3, and the question is: the Euler characteristic sub-4 means you're looking. Euler characteristic sub-4 means you're looking at the four ball and not at this least here. The Euler characteristic of the optimal surface that this link bounds in S3 doesn't equal zero. The links that we have there cannot bound anything with positive Euler characteristic. So really this says, is the optimal surface of zero Euler characteristic or negative Euler characteristic? That's NP heart. And the reason I wanted to mention this is just like you see here. Is just like you see here. This really played on the components, right? Okay, the question here is having a sublink. If you don't have components, you don't have sublinks. But over here, this link, this Euler characteristic, there's no reference to components here. And so my question is, and I believe this is quite open, is, is it still hard if you only allow knots in S three instead of links in S three? Because we have to play some of the components of each other. But it's not a feature of the question. But it's not a feature of the question, it's a feature of techniques. Okay, in breath, can you find a place in your notes? No? So I'll invite you to write them. Alright. I think that's it for the only initial part. Right, if I remove this? Okay. So, okay, we talked about sphere recognition, mentioned a little bit about S2 plus S2 recognition, but really because we're interested in the sphere recognition. You got your homework for recognizing S4R? Do Friday. We talked about embeddings and so on. So. So, so unknotting. Yes, unnotting is the next thing on our agenda. What do we call unnotting? Annot recognition. Okay, so there's a ton of work that's done on anode recognition. You can recognize the anode and of course the algorithm is too hacked in. Be kind of crazy not to put that name on the board. You can put Turing on the board too as the one master. You can put Turing on the board too as the one masky question. What do we know about this? Has Lagarius and Pierre? 99, this problem is in NP. So there is a certificate which is essentially maybe a bounding disk, which can tell you. Which can tell you that your not is, in fact, an unknown. Of course, the fact that there is a certificate in itself is not good enough. You need to have a certificate that you can verify in polynomial time. And that's not at all triggering in this case. This is also due to luck and we will discuss that result later, so we are later. It's also in CoNP. So, So, Co-NP again, you switch the roles of the yes and the no. To be in NP, I need to be able to give you a certificate that certifies that this is really the unlocked. To be in Co-NP, I need to be able to give you a certificate that certifies that this is indeed knotted. So, it's certifying knottedness. And this is Hooperberg, fifteen, fourteen. 14 and that's mod GRH. Then there is AGOL, which I don't know the year because he didn't publish it. And Lackenby all right. Let me try the year. When did Rug Lackenby do this? I don't remember the year. Anyway, and so Agol and Lackenby, the strategy there, why TRH comes in. TRH comes in? Presentations. You look at presentations in 2F, like GL2F for final groups and things like that. I should have been prepared with a better answer than that. I'm convinced now. Because that question always comes up. You have a presentation into GLN of a number field, and then to get it into a finite field, you need to identify a small power. The RH gives you exponential savings on and on. Exponential savings on and marking through that task. Thanks for selling it. And so Eagle and Lackenbit took the minimal genus ciphered surface bound by the not. And of course, then the problem is I can give you a ciphered surface bound by the NOT. How do you know it's minimal genus? So they use the theory of thought valuation to certify that the thing is actually minimal genes. And if the minimagus isn't zero, you've got your anomalous. Anonymous. And so the picture, I don't know why I didn't put the picture before. P are the easiest problems to solve. NP will be something like this. Co-NP will be perhaps something like this. And then NP-complete, there is also an analogous, of course, co-NT complete are the hardest problems within these. These and so this is in NP intersect co-NP and so if this is NP hard, that's a million dollars but I would guess that there is there are easier ways to get the money. More about unlocking that can be announced so okay, this picture suggests that Picture suggests that unlotting is certainly not empty-hard. It could be polynomial. It does not guarantee that it's polynomial because there could certainly be things in this intersection which are not polynomial. Who knows? Luckily we announced, paper not ready yet, a polynomial which is an algorithm, quasi-polynomial algorithm. So that's an algorithm. Algorithm. So that's an algorithm that is not polynomial, but it does run in time which is faster than exponential. So the question is: why are we working so hard? Just do the right amizer move, and I'm not in trouble. That's the easy way to go. And so, number Number of R moves needed and Hasen Lagarius when Bold. I think about 20 years ago. It's bounded by exponential. So that's not the world's best bound. And if you need to search all of them, then it becomes double. If you need to search all of them, then it becomes doubly exponential. But that in itself is the unknown recognition output. Because you don't need to search more than that. Hassan Novik, what was that one? Yeah, okay, this was in 01. Us in Novik was, I think, was in. I think it was in 10, but I can't remember with my handwriting here. Greater than or equal to, let's just write legal, greater than or equal to n squared. So they have an explicit sequence of anode diagrams with n crossings in the nth diagram, which requires n squared by the massive move to undo. And that can be And that can be bounded by some polynomial. It would be a big mistake to write down polynomial. It's big numbers, and I think it's degree left. But it's polynomial. And so, this, by the way, is why we said that LaConby also proved that it's in NP. I guess I didn't write it. But this also implies that it's in NP. And the certificate is very simple. I give you a diagram. The certificate will be this diagram. The next diagram and which Reidemeister move takes you between them. The diagram after that and which Reidemeister move takes you between them. It's a polynomially long certificate as it should be. And you just check that you get one from the previous one doing that exact Reid and Meister move. The last one has no cost. Okay? All right. So anyone. All right. So I didn't want to talk about something completely different, and I left myself seven minutes, which is very unfortunate, but it happens. So here's another question about complexity. What about the Jones polynomial? The Jones polynomial, you want to calculate the Jones polynomial. So Dominique Welch, I think, was the first to show that you will not calculate the Jones polynomial. It's not going to happen. Calculating the Jones polynomial at certain roots of unity. At certain roots of unity is sharp P hard. What is sharp P? Well, we have some idea what is NP. An example of an NP complete problem, not this one, is graph three colorability. I'm giving you a graph, three colors, color the vertices of the graph so that no two adjacent graphs are the same color. Sharp P, the sharp P version of that, I give you a graph and I don't just ask you if there is one. Tell me exactly how many. So it's obviously not easier than knowing that there is one. It is in fact in. This one. It is, in fact, insanely difficult. So we know that calculating the Jones polynomial is very hard. But maybe we can just approximate. So before I run out of time, just write a few results about this on the board that together gives an intriguing picture, I think. Friedman Kitaev and Wang No two they construct a quantum circuit, whatever it is, it outputs zero or one or it outputs It outputs 0 or 1, or it outputs yes or no. It outputs something that outputs yes or no. So that the probability that the output is yes, probably because I have some value, is the value of the Jones polynomial of whatever you wanted at t. And t here, let's fix our t, e to the 2 pi i over 5, so the fifth root of unity. You can use many other roots of unity. You can use many other roots of unity, but not all of them. Divided by something, unfortunate. 2 to the 1/2 plus e to the minus 1/2, and this is raised to the power that they call g minus 1. And so what happens here, they want to get the knot as a braid. Here is the braid, and this is in the braid group B, 2G, and they close it up as a flat picture, what they call not the way. Picture, what they call not the way we usually close it up going around, but this way. So G is just the bridge number of this specific presentation. But this note might have a much smaller bridge number. And if it's an unfortunately big bridge number, you are dividing by something which is exponential in the bridge number. So that's not an ideal picture. But it brings quantum computing into the picture, so that's good. And what's even better, I'm going to be very blessed because I have very, very little time left. Very, very little time left. And so, Friedman, I think it was the exact same year, Larsen and Wang, this is universal. So remember that our T That RT, don't take root of unity, which is 2πi over 1, 2, 3, 4, or 6. Take over 173 if you want. One of five works here. What does it mean? What happened here is you started with this picture, and this works for any root of unity, and you design a quantum circuit. What happens here is you start with the quantum circuit, and you design the link. That's what makes it true. The link. That's what makes it universal. Because whatever quantum circuit you want, now you want to calculate the output of a quantum circuit, they'll construct you a link that does that. And so I think we are not fair not to write on the board like Jaeger Berrington. Berington and Donnie Welch said that, oh, I already said that. Calculating exactly V L T is super hard, sharp P hard. This was in the 90s, in 90 actually. And so now the question, and I want to have time to. And I want to have time to discuss two more results, just to tell you what the result is. What about approximating the Jones polynomial? Who wants to calculate complex numbers? Approximate is good enough, right? And so Cooperberg in 15 showed that, okay, I don't have time to write the promise. To write the promise approximating, of course, he has a very precise description of what he wants to say here. V L T is sharp P hard. These results don't follow from each other's. Well, one does from the other. Why is this here? The way he shows that it's sharply hard is very funny. Behard is very funny. He uses the universality of the quantum computation. He says, You give me this thing, and I'm going to construct the quantum circuit. And the quantum circuit belongs to a complexity class, which is a kind of an exotic one. It's called post BQP. And so you get from here to this post B bounded error Q quantum, of course, P polynomial time, post stands for post selection. It was defined by. For post-selection. It was defined by Scott Aronson 20 years ago. And Scott Aronson said that this is, I'm being slightly inaccurate here. Sharp P. It's not sharp P. It's P P, but it's basically... It's just as hard to calculate. And so the point is, there's no quantum computing in this theorem. But the way this theorem is proved is going through a quantum complexity class. And so the last thing that I want to mention. So, the last thing that I want to mention is Eric Samperton, and I'm just going to write the title of his paper. Quantum computation, quantum computing is hyperbolic. I was going to write more details, but I have done. What does it mean quantum computing is hyperbolic? Quantum computing is Jones' formula. We know that. Jones will. We know that from the universality, somewhere other, this picture. Specifically, what he says is: what kind of links can I restrict myself to? And you can restrict yourself to a hyperbolic alternative knot, for instance. You can restrict in some other ways. You can be very restrictive in here. Great news, you can use hyperbolic geometry to calculate what quantum computer does. No, you can't. This is sharp P, section P P. It's actually PP. I feel guilty writing something that I know for sure it's just not true. PP. This is a complexity class that cannot be calculated. It is so much bigger than NP. And so, no, you can't use hyperbolic geometry to calculate these things. That just tells you that you can't use anything to calculate hyperbolic geometry. Not in this respect, anyway. Anyhow, I'm sure, sorry, I'm going a bit over time, but I really want to make a point at the end that in this line of work, That in this line of work, quantum computing comes into the picture in a very natural way, and you can use it to learn quantum computing. Maybe we can use it for error correcting and things like that. That's the very, very tough thing to do with quantum computation now. But at least in one case, it's quantum computing that answers the questions it's completely natural to ask in complexity theory. Anyway, I just wanted to get to this and I understand. I understand. Thank you very much. For the unknotting type problems, how do people usually encode the knot and how does the storage compare with the knots? Anybody wants to know? Anybody wants to answer? I don't know. And how much storage do you need for C crossings? They had a question now. She asked, how much storage do you need for C crossings? Like a small linear fuck factor? Yeah, or something. Well normally like, you know, if you would code a diagram, use PD code. Which crossing you say which crossings like this, like which crossing is this end attached to, which crossing is this end attached to crossing anything. I don't want to tell you which input at that other crossing control. That's basically just saying each processing is specified by the form. Besides the numbers is the number of processes. Size of the numbers is the number across the system. I think you can go between that and like if you prefer to present things as bridge diagrams, grade closures, that would also be fine. Like a bridge diagram, would that just be some grade on that version? So I didn't quite understand this in a freemankaya way. If you have a quantum circuit, and you're saying the probability that this quantum circuit outputs yes is that, right. And then I guess that value is not obviously between 0 and 1? I guess not. But I guess it is. Right. Yeah, so then the idea is that you run this quantum computation a bunch of times, and you figure out how many times it says yes, and now that's your approximation of the value. The frequency approximates that's all. Do you, in your gut, do you believe that force field recognition is desirable? I'm I I really wanted to think about that. Wanted to think about that, but I don't even know where to start. Does anybody have an opinion about that? I flip flops. Yeah. Yeah, I have no idea. I think you should prove it before lunch and disprove it after lunch, see which one works. Thank you very much.