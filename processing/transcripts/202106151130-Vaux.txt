Thanks for this invitation. First, I'd like to say it's a real pleasure to be back to Alberta, however, virtually, last time and the first and last time, it was some time ago, and it was quite an enjoyable moment. And actually, my first son made his first steps there. So this brings memories. Also, at this point, I must apologize because in preparing this. I apologize because in preparing this talk, I somehow recycled some handwritten material that I had written on the fly for a talk in a more blackboard mode. So you have the worst of both worlds. You have a fixed rendition of handwritten improvisation. So sorry for that. The the subject of the talk is just a a presentation of some structure that I have had the fun toying with. At the fun toying with. And it is a groupweight structure whose morphisms are permutation trees. So, before going into this, I will just give a quick refresher about the permutations and actions of permutations on this. I know everyone knows about it, but this is just to fix notations. And at the end of the talk, I will say a few words about the motivations of the work. Of the work, which are about understanding the Taylor expansion of Lambda terms in some way. But before this, well, let's forget about Taylor expansion and just focus on the subject and permutations. So when you consider a list of elements or of any set and a permutation, the permutation say sigma. Mutation say sigma acts, say it's called sigma, acts on the list just by shuffling, reshuffling the elements of the list. And the element at position i is now at position sigma of i. Okay, so this is this defines an action of the group of permutations on lists of the appropriate lengths, and it can be recast. And it can be recast as, well, in the definition of the free symmetric strict monoidal category based on the category A. So you have, take A, a category, and you form a new category whose objects are lists of objects of the original category. And the morphism is given from a list, say, A and to a list A dash. It is given by a permutation of the It is given by a permutation of the indices. Of course, the length must match. So you get a permutation which shuffles the objects and a list of morphisms in the original category which is compatible with this shuffle, meaning that instead of fi going from a i to a dash i, it goes to a dash sigma of i. Okay, so this picture should So this picture should explain how this generalizes the previous notion. Okay. Now the objects and morphisms I consider are trees. Let me be more precise about it. The trees I consider are labeled. So there are labels both on internal nodes and on leaves. On leaves, and here I distinguish between internal nodes of RET0 here and leaves. So these are just the same as, say, first order terms given on a certain signature and on a certain set of variables. There is only one subtlety. I do not specify the RT of a given function symbol. So a node label. So, a node labeled with some letter can have any number of sub-trees or sub-expressions. And from these trees, I can form trees annotated with permutations on the internal nodes. And the number of elements of lists that these permutations act on is the same as the number of sub-trees of the nodes they are attached to. The nodes they are attached to. So, here G, this node is labeled with G and it has three sub-trees, so the permutation acts on one, two, three. Okay, so the idea is that such a tree or such a term is a morphism from the tree obtained when I forget about permutation labels to the tree obtained by letting each permutation act on the list of Acts on the list of immediate sub-trees of the node it is attached to. So, more formally, we form a group OE whose objects are trees, just as before, and whose morphisms are labeled trees, trees labeled with permutations. And these two rules explain how the source and the target of the tree can be deduced from its structure. Its structure. Okay, so again, this should be reminiscent of the construction of the free symmetric strict monoidal category from a category, except that here we have also these function symbols somewhere. And in a sense, the groupoid we consider is a fixed point of the construction here. Okay. So, what do we do with this? This my focus is the degree of a term. So, what I want to understand is the degree of a term. And the degree of a term is by definition nothing but the cardinality of its group of automorphisms. So, here is an example. This tree here, it is of degree two because there are two permutation trees that map this tree to itself, the identity, of course. Itself, the identity, of course, but also the one obtained when we swap the two subtrees and then swap the sub-trees of the root. Okay? So the first swap just maps this to xy with the same structure, and the second swap at the higher level restores the original tree. Okay, and of course, because we are. And of course, because we are in a group point, the degree of a term is also the cardinality of any homeset from this term to any term in its connected component. Okay, and more precisely, the degree is the quantity I'm interested in, so it has a combinatorial flavor. This is what I want to count, but my To count, but more precisely, I'm interested in the degree of tree obtained by a substitution. So, what do I mean by a substitution here? Well, I take a term s and fix a given variable, say x, okay, and I enumerate the occurrences of the variable in the term from left to right, say, and pick some other trees, one tree for each occurrence of the variable. Of the variable, and I just replace each variable appearance with the corresponding tree. Okay, so substitution here is not from, it does not just take a tree variable and another tree to substitute for every occurrence of the variable. It takes a tree and another tree for each occurrence of the variable. So it has somehow operatic flavor. Periodic flavor. And in fact, if I restrict to the case of unlabeled trees, this is nothing but the definition of an operatic composition of trees. Okay, this substitution can be formalized or defined inductively, but maybe it's not really necessary that we go into the details of the definition. It's very straightforward. But let me mention that. But let me mention that this operation, of course, is only partial. In general, the substitution might fail if you do not provide exactly the same amount of trees to be substituted as the number of variable occurrences. So everywhere in the rest of the talk, it is implicitly assumed that I provide exactly as many trees as necessary. As necessary. Okay, so as I said before, my purpose is to understand or to describe or to compute, I don't know, to study the degree of a tree obtained by substitution. And I want to relate this with the degrees of the terms involved in the substitution. Or equivalently, I want to understand the automorphisms of a substitution and really a substitute. Substitution and relate them with the automorphisms on the involved subterms. And here let me mention that on lists of the degree of a list of terms is given by this free construction as before. It is the same as what will happen if we had a function symbol applied to this list of terms. Terms. Okay, so since I want to understand the structure of automorphisms on substitutions, well, it only makes sense to consider a notion of substitution on morphisms, because you will have, if you consider a term obtained by a substitution and the morphism starting from this, in a sense, you will have a part of this morphism. A part of this morphism will act on the term you substitute into, and another part will act on the list of terms you have substituted for the variable. Well, at least intuitively, it would work this way. So, given a morphism alpha and a list of morphisms beta and variable, I define substitution exactly in the same way as for trees without permutations. Trees without permutations. The definition is exactly the same. I just plug the trees of permutations instead of the occurrences of the variable that I substitute. But now the catch is that this substitution, it does not really act as expected. At least, of course, the source of the substitution is obtained by the substitution on the sources. But the target in general is not what you expect. Is not what you expect. Or maybe you know very well, you have already guessed what happens. Let's see this on an example. So, here I have again considered the same tree as before and annotated it with the swaps. So each internal node will be swapped. And as we have already said, this morphism maps the substitution. Maps the substitution well it maps this tree to itself okay let's call me this tree U. But note that this tree is obtained by substituting in this tree just an internal node with two variables I forgot to mention here I forget about let's say we have only one symbol okay this these symbols play no role here for internal loads okay so uh this tree is obtained by substituting uh those two sub trees Those two subtrees here. Let me this one and this one for the two occurrences of Z here in this tree, ZZ. Okay, but now this obviously this the components in this substitution are morphisms, but if I look at the sources and tag. That if I look at the sources and targets, this morphism maps the tree ZZ to itself. This morphism maps the tree XY to YX, and this maps YX to XY. But then if I apply these things in parallel inside the substitution, I do not get what is expected. Okay? So the target of a substitution is not just the substitution of targets. Of targets. Well, in this example, we understand immediately what happens. What happens is that I perform this transformation from T1 to T2, this transformation to T2 to T1, but then S is mapped to itself, but the two occurrences of Z here are swapped. So I do not get what is expected. More generally, or more abstractly, the situation. The situation is as follows. You consider the substitution here of beta 1, beta 2, etc. in alpha. So this maps this term, the substitution of T1, Tn2, X in S, to something. And this intuitively has this shape. So you get S dash, which is the image of alpha on top. Of alpha on top, but on the bottom layer, you get something else. So you can describe it as follows. You just let you first apply beta 1, etc., beta n on the subtrees T1, Tn. You get the expected T dash 1, etc., T dash n, assuming beta i goes from T i to T dash i. Then you perform alpha here. You obtain S dashed. You obtain S dashed as expected, but in doing so, you have permuted the occurrences of X, and thus you obtain not the sequence T dashed here, but some permutation of it. And this permutation is entirely determined by alpha, by the permutation tree you apply to S. So this operation, the permutation induced by a permutation tree on the occurrence. Mutation tree on the occurrences of a variable in tree in the tree, you can describe it directly. Well, it is quite simple. Well, let me not spend too much time on the case of variables, but in the case of a tree with a root and a certain number of subtrees, this will be annotated with a permutation sigma. And what happens? Well, you first permute. Well, you first permute the leaves, well, the variables, the occurrences of the variable x in the first tree using alpha one and so on with each alpha a. But then you perform sigma. So this will globally shuffle some subsequences of the occurrences of X. Okay, and these subsequences have lengths, the number of occurrences. Of length, the number of occurrences of X in each separate subterm. I have put here a kind of, well, I don't know if it is a nice picture, but I will claim it is a picture. And I hope it gives you the intuition of the operation. But in fact, you might already know about it. This is just quite standard operat structure on the sequence of groups of permutations. Groups of permutations of arbitrary lengths. Okay. And again, you can describe it more categorically by considering the tensor of the permutations induced by each permutation tree, sub-permutation tree involved in the substitution. And then you perform the other permutation, the one that labeled the root. But, well, Well, packet by packet, say. Okay. So now that we have defined this operation, and let me mention that this operation is obviously functorial once you have expressed it this way, meaning that the substitution obtained from a composition of permutation tree, sorry, the permutation you obtain, which is induced by a composition of permutation tree. Induced by a composition of permutation trees is the composition of the permutations. So you obtain simply by inspecting the definition of what is the substitution of permutation trees, you obtain a direct description of the target of a substitution of permutation trees. And the only thing that changes is this. Is this permutation inside of the list of targets? Okay, so if I unroll all this, what I obtain is an operation of substitution that takes a permutation tree alpha, a list of permutation trees beta. Say alpha is from S to S dash and beta is from T to theta. And beta is from t to t dashed. And what I obtain is a new permutation from the substitution here to the substitution here with this shuffling of the substituted terms. But if I'm interested in automorphisms here, well, let me remove this part. I hope my software will not crash. My software will not crash immediately. Okay. Well, sorry, I've been too quick here. Well, let's say I take S here. Okay. I want to get a T here. So let me start with T here. Sorry. Sorry. And to get the substitution of t for x here, I just need to precompose here with the inverse of the permutation. Okay, so I put this here. And then I obtain a map into the group of photomorphisms. The group of photomorphisms of a substitution by applying it by applying the substitution here to this kind of permutation tree. So let me sum this up. I obtained a map to the group of automorphisms of a permutation substitution from, well, I will not go into the details, but this is just the appropriate. But this is just the appropriate sum so that the previous trick here works. But and of course, this construction is injective because the construction of when you construct the substitution of permutation trees, you already know the shape of the underlying term. So this is just done by plugging things at the level of leaves. So you've got all. So you've got all the data you needed for this map to be injected. Beware that I do not claim to define, say, a morphism of groups. It is not even clear what this would mean as a group. This is just an injection. Okay, so I have a map to the group of automorphisms of the substitution. It is injective. It is injective. Can I hope it to be subjective in general? No, of course, because we have already maybe had a glimpse at this. In this term here, there are two morphisms. There are two automorphisms. It's the identity and the swap. But this term can be obtained by substituting y for x in the Y for x in the term x y. Okay, but now in x y, the only automorphism is the identity. And in the list reduced to the single term y, there is only one morphism, which is the identity. So you cannot expect this to be surjective in general. So what do we need to do for this to be surjective? So that we get a kind of description or, well, some information on the cardinality of. On the cardinality of this group of automorphisms. Well, the point is that we want the permutation trees acting on the term, the core term, the term into which we substitute, and the permutation trees acting on the terms that we substitute for variable occurrences. We want them not to interact. Okay. And intuitively, this means that we want the term S into. The term S into which we substitute to be well balanced in some way. And one way to do this is to impose a uniformity condition on the terms. And for this, we introduce a coherence relation on terms. Well, it is maybe it is too much, maybe it is too restrictive, but well, it works. So let's do this. The idea is that you consider variables to be coherent only with themselves. Coherent only with themselves. And inductively, a tree with a root, say a label with F, is only coherent with other trees with the same root, with the same label. And inductively, the sub-trees on each side must be pairwise coherent. And then you say a term is uniform if it is coherent with itself. And in this setting, it is. Uh, in this setting, it is indeed restrictive. Uh, it simply means that uh your uh tree the tree is organized somehow in layers, and each layer is uniform in the sense that there is only one label. Okay, with this condition, again, you just have to inspect the definition of the substitution to observe that. To observe that now the previous mapping is subjective. That is, for any morphism starting from, well, between some substitutions, the substitute, well, any morphism starting from the substitution and going to a substitution, provided the tree into which you substitute. Tree into which you substitute is coherent is uniform, well, it is organized as a substitution of permutation trees, and you get the surjectivity. So, in case S is uniform, we have a bijection from, well, between the group of automorphisms of the substitution and something where we have nicely separated S and T. S and T. Okay, this is not quite what we want, and I will simply skip over any further technical development, because my point here is not to show how I can manage to use group theory, and it is only basic group theory. But up to some work, what this bijection gives you is another bijection, which is as follows. You have a biduction between this group of automorphisms whose cardinality is M of S, this group of automorphisms whose cardinality is M of T and this group of automorphisms whose cardinality is M of the substitution up to this corrective term. So the cardinality of some So, the cardinality of something, and this is just the number of permutations that you can perform in T without changing the connected component of the substitution. Okay, so here is my nice result, and I claim I am very happy to have it. And I will finish this talk by explaining why. Meaning, why. Why does this interest me? Well, because there is this notion of Taylor expansion of Lambda terms, and I will just, well, give a glimpse. You do not have to read this at length, but the point is that this operation translates every Lambda term into a linear, infinite linear combination of resource Lambda terms, which are somehow. Resource Lambda terms, which are somehow finite multilinear approximants of Lambda terms. And the coefficients in this Taylor expansion can be shown to be exactly the inverses of the corresponding multiplicity degrees. Well, there is a catch. Of course, the only place where I want to permute trees inside these multilinear approximants is here in the multilinear application. In the multilinear application of a term to another term. And you can read this just to link this with the subject of other talks. This is nothing but the hence derivative of s computed at zero and linearly applied to t1 tn in the differential lambda calculus, which goes with differential linear logic. And so And so the result we have established can be used as one technical lemma in a more general theory establishing that Taylor expansion is somehow compatible with the dynamics of the Lambda calculus. And more precisely, you can show that You can show that you can put define a notion of reduction on resource lambda terms. And if you take the Taylor expansion of a Lambda term and normalize it in the sense of this dynamics, what you get is the Taylor expansion of the normal form of M, or if M is not normalizable, of the boundary of M. And at one point in this proof, by In this proof by Erat and René, you have to compute the coefficient of an element in the support of the substitution here, which is nothing but, well, this is the analog for the resource lambda calculus of the substitution in Lambda calculus. And this lemma, in fact, it boils down to the identity we have established. And well, it is Well, it is. We can apply the result we have established because the Taylor expansion also has a uniformity condition. But again, as before, the permutations in resource terms are performed only inside this multilinear application. Well, we impose coherence conditions only there. It is only the lists. The lists of arguments that are fed to a multilinear application that must be pairwise coherent. So, this ends the technical content of the talk and let me conclude with a few remarks. So, I do not think there is much, well, there are not really any novelty in this contribution, but we had the But we had a lot of fun with Federico playing with this structure. So I hope you share this during the talk. But in fact, the proof technique that we follow to establish this bijection is somehow a translation of the proof technique followed by Thomas, Erart and Laurent Rénier up to this functor. This functor that I have defined from permutation trees to permutations. So, nothing really new on this side. But on the other hand, it allows to hope for some connections with other works. There is one that pops up to my mind every time, which is Tsukada, Asada, and Ong's analysis of. Analysis of the model of generalized species of structures, which uses a kind of rigid version of Taylor expansion. And the objects we consider are really similar, but not exactly the same. But this leads me to hope that if we push the study a bit further, we may. Bit further. We might end up with a syntactic description of some interesting objects in the bicategory of generalized species of structure. And I guess, well, I hope we can describe explicitly a reflexive object, that is a model of the pure Lambda calculus, the untaped version of the Lambda calculus. There is a more bitter note, which is that somehow Which is that somehow the fact that we only establish a bit bijection here and all the structure is lost, it seems to me that maybe we have missed something on the way and there is still something more to be understood in this construction. And maybe you will have suggestions. So that's it. Thanks a lot for your attention. Thanks, Lionel. So let's all unmute. Thanks, Lionel. So let's all unmute and thank our speaker again. Are there questions? I can't see the chat either. No, I've been watching the chat. There's nothing in the chat at the moment. Sorry. Questions? May I ask a question? Yes. This is much headlong. So I was wondering, so you Um, I was wondering. Uh, so you talked about an approach on your work based on operat, and I was uh wondering if you have tried with colored operats to taking into account the labels. Well, of course, the name colored operators popped up in my mind, but I guess it is not exactly what we want because the idea of colour. What we want because the idea of color operates, at least as I understand them, is to type the well, what you get is some kind of compatibility conditions between the input and output of your trees. So, wow, sorry. So, here the colors do not, well, the labels here do not impose any condition on what compositions you are allowed to purchase. Compositions you are allowed to perform. So it does not quite match. Maybe the forget about labels, what you get that non-color operates. Okay. But I mean, if you I mean, i if you fix a variable, uh you you can put any kind of terms here. You can uh substitute this variable by with any kind of terms. There is no condition on the symbol that is, say, on top of the tree. Okay, okay, thank you. Yes, perhaps I have one question. Yes, thank you. Um, I was I was I've already I was I've always be always been puzzled by the role of uniformity and coherence in this story. So do you have any idea of how to go beyond? I mean or I mean because this story of commutation between Taylor expansion and BERM tree should be should should extend beyond determinism. Do you have any idea about this? The point is that The point is that here the solution to avoid the need for uniformity is to avoid the need for computing the coefficients in the Taylor expansion in advance. I mean, this result here holds only thanks to uniformity, the fact that we know in advance the coefficients in the television. We know in advance the coefficients in the Taylor expansion. But the compatibility of Taylor expansion with reduction does not is really does not depend on this. The only thing you need is a careful analysis of substitution. Okay, so this uniformity condition and this result is only needed because we want the coefficient here to be this. Yes, it's to have a kind of local quantitative account of reduction, but not. But not needed for the global thing. That's what you mean. Well, the point is that it is sufficient to prove that if you Taylor expand the substitution in the lambda calculus, this should be the same as first Taylor expanded Taylor expanded M, expanding screen M. Spray M then Taylor expanding N, then you promote, and this promotion here manages all the combinatoric stuff. And you substitute linearly in this way. And this equation, it holds in each model and it holds in the lambda calculus too. And you do not need any coherence condition. Any coherence condition for it to hold. So, this means that this is the key to obtain that Taylor expansion is compatible with beta reduction and thus with normalization. And this does not depend on uniformity. What uniformity allows you to do is to establish this component by component. Component by component, component-wise, somehow, because you know the coefficient of each component. Okay, yes. Other questions? So, let's thank our speaker again. Thanks, Adela. So, there will be a meeting in 30.