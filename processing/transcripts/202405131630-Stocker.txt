  Okay, yes, let's. Yeah, and of course, since it's a workshop, I hope we can do it more interactively, not only as a presentation, but please feel free to ask questions anytime. Okay. Yeah. Okay. Okay, so we jump right in. I can hear myself. Oh, this is a good problem. Yes, okay, perfect. So, ngisolf. You can find everything about ngisolve on their homepage. It's an open source finite element library programmed by the head developer in Joachim Schuberl in Vienna. And the first thing that I cannot forget: so, on the homepage, you will immediately see there is a user meeting coming up. So, I start with. There's a user meeting coming up, so I start with the advertisement. The advertisement part, the user meeting of the 2024 will happen in mid of June in Ghana. Registration is open. So if this introduction gets you excited, you're more than welcome to come. Yes. So this user meeting, now I will tell you a bit about the code and then we will jump into running some code that I will first show you and then. Some code that I will show you, and then you can start in there. Okay, so ngisolve is an open source software. You can find the whole source code on GitHub, it's available on github.com ngisolve. Currently, it's also quite easy to install since it's a C ⁇  code, but has a Python wrapper, so you can deep install ngisolve. We will try later. So, let me first tell you a bit more about the team. So, currently, I would say So, currently, I would say we have three head developers. Here, so from left to right, is Matthias Joachim and Christoph, of course. So, Joachim started the code with first only a measure, which was called NetGen, so NetGenerator, which then later became also part of the solving software. So, NetGen became NG, and this became NGSOL. And yes, of course, it's not only them, there's a big part of contributing. Is not only them, there's a big part of contributors. Um, it's also, yes, only my, I'm the only one with the picture. I don't know why. This, yes, already giving away that I'm not only a user perspective, but also contributor. So probably it's a biased talk. Now you know. Yes, so I was already saying that the code base is largely C ⁇, so that all the kernel, all the important computations are done in C ⁇, so that it runs fast. You can see 90% C ⁇. But it's wrapped in Python. So everything that we are going to do is from the Python side today. So we are only running in Python and interacting from Python. Just to give you a bit of an overview on the code, there's a core package that handles all the very basic things, implementing arrays, has a task manager to run stuff in parallel. And this is already included in Matchen, which I was mentioning is the measure. Then we have two subsidiaries on basic linear algebra. On basic linear algebra, so just implementing matrices, vectors, matrix multiplication, and so on. And then there's also a linear algebra package included that has some solvers and preconditioners, iterative solvers, direct solvers, you name it. But it also interfaces with LAPB and so on. So there are many options. Then, more importantly, so this is everything wrapped in or interfaces with our, what I would call the local part. So is in the So in the code, it's called NGFM. So these are all the local operations, the finite elements, integrators over the mesh. Yeah, so this is part of the local. And these interfaces then again, with our global part, so the finite element spaces will control all the finite elements that then again, again, connect to the mesh. Also, the linear forms and so on. Linear forms is part of this gold package. And all of this is wrapped up nicely with the bow in the Python. Wrapped up nicely with the bow in the Python interface. Okay. So there are also some other NGISOF extensions that I would like to mention, just to give you an overview of what is happening around NGISOF. There is a nice package, NGS-XFEM, that handles unfitted methods. So we will also have a talk tomorrow by Christoph with Drefts and Unfitted together. So they are the head developers. Christoph, then we have space. That's a space-time meshing in shift objects. I will also show some drafts methods on tense tomorrow in the afternoon. Currently maintained by Jego Vagrishnan, of course, maybe more. There's a very nice interface with the NGS, so with the PETSI, you can use the PETSI solvers. And yeah, so there's the interface for this. Currently, Ombat Sebinatis taking care of this. And then there's also the package NGS left, which Also, the package NGS left, which I will present tomorrow. This is mine, this accurate photo of me working on the code. Okay, most of what I want to present today is part of the NGISOF documentation, which is a full-fledged documentation in Jupyter notebooks. You can find it, of course, on the homepage. So I'm just giving a slide, a small part of this because it's a huge documentation with a lot of different topics. lot of different topics and I'm only picking cherry picking the parts that hopefully are interesting to you. So I'm focusing mainly after getting started with the basics I'm focusing on PG methods and yes PG methods mainly and also some plane wave business will appear. And then of course I will show how to implement the Helmholtz equation since I think this is the, I don't know, the grandfather of the draft methods in some way, no? Methods in some way, no? So then I will switch to the notebooks now. I will show some code, show some basic examples, and then I will pass the torch to you. Okay. So let me just maximize this. Remove okay. Nice. So first notebook. No, first notebook. Okay. Maybe we can slice it down a bit. So, but it's readable? Yeah. Okay. So first then she solved the example. We will start super simple with the Laplace equation on a square with a serial zero Dirichlet boundary condition. So this is our problem and it's a Python code. And it's a Python code. So we will start as usual in Python. We will get our packages. So this means we'll first import everything from ngisol. Then for to create the geometries, we actually use OpenCascade. So this is part of the NetChan. So we can import everything from OpenCascade. This will give us some super fancy geometries, but also the unit square, which will be our favorite geometry. And then the last line just imports a draw function. The last line just imports a draw function that will draw all our stuff nicely inside this Jupyter notebook. So, and as I was saying, will draw nicely, it doesn't draw, of course. I will quickly fix this, I hope. Of course, of course, yes. This will everything will be on the webpage, of course. I will share with you immediately. First, you present and then. Yes, yes. All right. Okay, second times the charm, hopefully. All right, beautiful. All right, beautiful. So this is our unit square. Meshed, meshed size, I chose 0.2. So you can see, yeah, with the unit square, we get a unit square from OpenCascade with the generate mesh. Nature generates a mesh. And then we wrap this into ngisolve with the command mesh. So now we have an ng-solve mesh that we can run finite element methods on. So, of course. Of course, with Python dot, this dot, we can ask some questions to this object in Python. Maybe we can ask the number of vertices and the number of elements. So it will tell us it has 39 vertices in the mesh and 56 elements. We can ask the mesh about these boundaries, which we will require to impose the boundary conditions. So the square simply has the bottom, right, top and left as boundary conditions. Bottom, right, top, and left as boundary or as boundaries that we can later explore. Okay. Then let's get into the bilinear forms. So to some finite elements. We first introduce the finite element space. I'm not thinking dg right away. I just want to do a classic standard finite element. So I construct the H1 finite element space, the conforming polynomials. The conforming polynomials with order one and the Stirichly boundary conditions on the boundary of our mesh. So I pass a Stirichley, bottom, right, top, and left, which we have just seen at the boundaries of the mesh. We can ask this finite element space, FS, then, for example, for its number degrees of freedom, which should equal the number of nodes in our mesh, of course. But Um, but so these are all the degrees of freedom that it has. Uh, while for solving, we will later restrict some of them since they are boundary nodes. Okay, then for drawing our shape functions, for example, we can construct a grid function. A grid function is nothing more than the vector of the coefficients of this of a function, our space, of the polynomials, and setting the whole. The whole vector to zero, except for one entry, will give me, of course, one of the boundary functions, one of the finite element functions. So you can see this is the head function on the boundary of the domain. And if I now try to guess maybe an ISA head function that is inside the domain, I will go say 30. Did I do anything new? No, I don't know. Ah, sorry. Is that true? Yes. said to yes of course i was changing the never change something lively i was yes i was changing the scale i was getting a supernova function thank you yeah absolutely um yes so this is a head function inside our domain uh now looks more like a head okay uh yeah so clearly this is the vector of coefficients that we were looking for okay so uh time to set up our bilinear form we will need uh trial and test functions so we can ask our finite element space for these symbolic Element space for this symbolic object of a trial and a test function u and v. And with this, we can then set up the bilinear form. We start with a bilinear form on our finite element space. In the case, if it's symmetric, so we have to store less entries. We can tell it that it's a symmetric true. And then we simply add our integral expression. So gradient u gradient of v times dx, this integral symbol, will give us the integral over the Will give us the integral over the whole so over the domain. Yeah, and with the a dot assemble, we assemble the finite element matrix for the linear form. We can put some right-hand side. In this case, I chose x as the right-hand side. And then we also have to assemble. Yeah. Yes. Yes. In this example, I chose zero. And as I now go to invert the matrix. So, as I now go to invert the matrix, I of course I only want to solve for my three degrees of freedom. So, the ones inside. So, I again copy the link. I don't know why this is happening. So, yes, so as I go to solve, I go to my finite element matrix. So, of the bilinear form, I get the matrix, this is part matrix. And then I call inverse to get the inverse. I only want to invert or solve inside my domain for my three degrees of freedom. So, I need to tell the solve. So I need to tell the solver which are my degrees of freedom that are left open. So I need to ask my finite element space which of your degrees of freedom are free. So this will give me an array of a bit array of ones and zeros corresponding to the degrees of freedom. Zero for the ones that are not free and one for the ones that are free. These are the ones inside. So the solvo can knows what to do. And yeah, with this we can solve. Yeah, with this we can solve this problem and draw a solution which looks like this. Okay. Can we get the what? So it seems that you're not working. What does it mean it doesn't work? No, this is the no, yeah, okay. This gives an object which is a solver. The inverse gives a solver and the multiplication is overwritten. It's not a matrix multiplication. It's smarter than that. But it looks nuts. Okay. Yes. So let me see what I have left in this notebook. Yes, just a quick closer look at this matrix and vector object. So for the grid function, I was saying the grid function is simply the vector of coefficients. So we can have a look at this vector, for example. So for grid function.vec, it will show me the read function.Vec, it will show me the my coefficients of the solution. We can look at our sparse matrix. Yeah, so of course, well, a large sparse matrix. So we only see the entries, which are non-zero entries in a sparse format. Yeah, anytime, yeah, we can try to get some help from the doc string. Many objects have a dog screen. Many objects have a dog string, like for example, the h1 finite element space. So, if you ask help for the h1 finite element space, you get this nice dog string showing all of the many things that are implemented and the flags you can set when you create it. So, the order, if it's complex, dearish, the boundary conditions, yeah, more boundary conditions, dimension of the space, digit charts we'll get to later, yes, and so on. So, you can see this is a big object, of course. Yes, finally. Yes. Finally, if you are not running in a notebook, I just want to point out that you can, of course, just program a Python file like you would use to simple Python code and then call it with a Python 3, or also if you have installed with the Natchen, and it will run your Python code. So you don't have to use the note, of course. Okay. So this was the first note. Any questions so far? They are was really now how I implemented them, or yes, sorry, yeah, yeah, was really just the telling the exactly was really telling the h1 finite elements basically usually, and then we we could also now we'll do again something on the fly, so of course it would be let's see what happens. Yes, but it's also the most error-product. So, if we can look again at the free-offs that I was mentioning, and if we print those, those brackets. Close the bracket. We can see what I was telling you earlier. So it's the finite element space keeps all of these degrees of freedom, which are 39, as we saw earlier, but sets the ones on the boundary, which are the first ones, as zero. This is what this command does. Yes, very good. Let's stay around. Okay. Um let's go uh personal tool uh done. Okay, so yes, uh what else do I have planned? Uh, I will so all of these notebooks and many more. So these ones are uploaded specifically on GitHub, so you can download them later, but all of these also on the NGSOP homepage. Um, so I will not go through all of So, I will not go through all of them. I think I will go briefly over the coefficient functions since I think it's nice to see how these types of functions implement the denote resolve. Then, probably I would skip the non-zero dirty boundary conditions since we are more interested in PG, I think. And I will go to Helmholtz and PG and see how much time is left after that. So, just very briefly on this type of coefficient functions. So, starting again with our beautiful unit. Again, with our beautiful unit square, and I just want to talk about how functions and how you can implement functions in EntrySolve and what is currently implemented for you to play around with. So, x, y, and z are symbolic variables corresponding to the coordinate axis, x, y, and z. So, you can already use them as functions. So, for example, this x minus x squared gives you a symbolic function that can be evaluated at points in the mesh. At points in the mesh. And so, as I was saying, x is a built-in coefficient function, so our set and y. So, we can draw this function, of course. So, this is x minus x squared. And we can evaluate it. To evaluate, we have to be a bit careful because we are still talking about the mesh. So, we cannot evaluate at the random point, but at the mesh point. And the mesh is, of course, handled from a net gen, which means these are this the net gen stores. Is the netchem stores the ref is from constructed from reference elements? So, this is why to evaluate at some point, we will first have to ask the mesh for that point because it has to construct a map integration point from this. So, we can ask the mesh, for example, the point 0.2, 0.2, and then we can evaluate our function at this point. So, if I just plug in 0.2, 0.2 here, it will not work. Yes, this is how you can evaluate functions. Okay. Okay, so going over some points, but I will, you can play around with it later. I will skip ahead a bit to show you that this is actually implemented in a symbolic way. So it's an expression tree. I think this would be quite interesting. So if we print this function, you can see how NGISOLS actually remembers your coefficient function. So it will tell you how we use the multiply of x with, and then again, a minus operation between 1 minus x. Operation between one minus x. It is exactly what I told you earlier. And this is how it's stored internally. And this also allows us to do, for example, symbolic differentiation like so. And then we can get the derivative here of the function. Otherwise, we can, of course, also interpolate this function first and then do all these operations in a non-symbolic way. So this is also something I wanted to show. We can again get our H1 finite element space. I'm only choosing order one, so we can then clearly see the difference between what is interval. The difference between what is interpolated and not. So I pick again my grid function, you remember from the last example, and then I can simply use a set to interpolate our function, my function. And if I draw it now, you can immediately see the difference to the previous one. So it looks a bit more linear on each element. And we can then, okay, we can integrate this, but we can also differentiate. And then we often. And then we are, of course, talking about piecewise constants after differentiating. So, yeah, looks like this. Of course, turning up the polynomial order to any degree will give you a smoother picture. Okay. Yes. Also works for vector functions. I leave this open. Now we can go to the more advanced business. So I skipped ahead over the non-zero reduced boundary condition. Over the non-zero reduced boundary conditions, maybe you can play around with it later and show Helmholtz equation and how to solve it. Important stuff. Okay, so Helmut's equation. I thought I would do a bit more of an interesting geometry for Manchester Solve. So we, instead of our favorite unit square, we are now looking at a circle with a boundary condition out there. With a boundary condition outer, and then we can remove this rectangle from inside the domain. We have something to bounce our waves off of. And then we again go for a conforming final element method, H1, with now the main difference, since we are solving in the complex domain, complex equals to true, which gives us a complex coefficients for our basis functions. Then to set up our bilinear form, To set up our bilinear form, we use again test and trial functions. Use a shorthand from what we use in the first notebook, simply t test and trial and test t and t will give you immediately u and p. Shorter. And I will put some right-hand side, this pulse, in the center of our domain. And here you can see that the linear form. So the linear form is again the gaut minus omega squared, utilized. Omega squared u times v, and then we, of course, our impedance boundary conditions. Yes, we have to remember that in Python, always the complex coefficient i is 1j. I'm not responsible for this choice. And as a right-hand side, I put the parts that I brought it earlier. And then we can solve and just. And Gisolf also gives us a nice animation for transferring back to the wave propagation domain. You can now see this the pulse interacting here with this boundary layer on the slit and impedance boundary conditions on the outside. Yes, so the waves are bouncing nicely off of this part. Yes, I should specify since I was which boundary conditions I'm using. This is important. I'm using this important. Sorry, I'm sorry, I forgot. So you can see here for the boundary, I'm now putting a boundary integral. Instead of the previous dx that we've been using, I'm now using ds, which integrates over the boundary. And if I only want to integrate over a certain type or part of the boundary, in this case, I only want the impedance boundary conditions on the outside of my domain, not on the square on the inside, I can tell him defined on. So this integral only runs over the boundary. This integral only runs over the boundaries I've previously defined as auto, which is the outer part of this. Yes. The wrapper, yes, yes, yes. I didn't, but yes. Yes, you can. I'm not showing this, I'm sorry, but you can. but you can you can similarly define so you can also use this defined on actually I will show something very similar later on so yes but not yeah but yes exactly you can use this defined on also for the volume integral you again in when you are setting up the mesh you have to define well parts of the mesh exactly or you okay if you have a varying coefficient it's different but if you're talking about zero coefficients I'm assuming you think Coefficients, I'm assuming you think of meshing two parts of the. Yeah, yes, yes, yeah. But like with a clear mesh boundary in between, so you already know at the mesh generation where your coefficients would be. Yeah, then this would be the way to do it. This is for you to find out later. And okay, it's not a Hermes problem in the end if I don't show a comparison to an exact solution with some pretty symptomatic part. So this is just a quick comparison of increasing the wave number. And I think we can nicely see this just what you would expect. And when you then play around with the code, I mean, changing P, you can. Around with the code. I mean, changing P, you can see how it affects this presyncotic behavior and so on. I think it's classic Hermot's business. Yeah, this was my Hermot file. Yes. I will not show it because it's a draft workshop. But it's on the homepage. Yes, yes. Okay, so yes, because time is running, maybe I let's see, if I finish with the usually, I will do this continuous Golagram method. Okay, so PG. This is of course important for addressed methods. We want to implement the so we want to use our piecewise polynomials in the first case. Polynomials in the first case, and then we want to implement these interior integrals over the boundaries of each mesh element that will give us the averages and jumps that again enforce continuity across inter-elements. Yes, between elements. So, I will simply show how this looks in the syntax of NGSolve to access these integrals. So, we start again with With our imports. Yes, I went a bit overboard and wanted to show it on a periodic mesh. So we only have to first play around with the interior facets, not also with the boundary. So here is the code, how to set up a periodic mesh. I will not go through the whole code of this, but in the plot later on, so you can see I'm identifying this point with this. So these are the Uh, this point with this, so these are the purple lines that you can see, and these points on this side with the points on the other side. So we have set up a periodic mesh, and now we introduce the broken polynomial space on this mesh. The standard broken polynomial space will simply be given to you if you replace H1 by L2. So, this gives us the L2 or the broken polynomial space on the mesh of arbitrary order. Then, it's important to not forget this digit jumps flag. Not forget this digit jumps flag. So, the reason behind this is that the degrees of freedom of the L2 space initially, of course, are only defined on the volume and are not coupling degrees of freedom. So, in order for the system matrix to leave space for this coupling between elements, we already need to tell him at the finite element, at the construction of the finite element space, that we will want to implement these types of jumps later. So we have some interaction between the elements. This is why we need this DGG. This is why we need this DG jumps to black. And then I wrap this in this periodic layer so that the finite element space knows that it's supposed to be periodic on the upcoming, so on its mesh. Okay, so I get the test and file functions. I define my jumps. Here the syntax for the jumps is the following. Every edge has a given direction. So then the output normal on each edge. So, then the output normal on each edge is fixed in the whole mesh. So, this immediately gives us one primary element on the edge. So, this is where the file function has function is u. And then the element where the normal vector is facing into is the other one. So, this is how we access u and your other. And your other will. So, this will give us the two traces of the finite element functions onto the edge. Okay, and then the jump, of course. Okay, and then the jump of course will simply be u minus u other. Similar for the averages. For the averages, we need the averages in the gradient. So gradient of u plus gradient of u other times one half. And I'm taking the du the n, so I put the normal vector inside here. But of course, depending how you like to write your PG forms, you could put the normal vector up there. Okay, so for the So, for the integration, we now are interested in integrating over the skeleton of the mesh. This is done again with the volume flag, with the volume, yes, finite differential symbol dx. But now with the skeleton equal to true. This means that it only integrates over the skeleton of the interior skeleton, the volume skeleton of the mesh. So, dx, because it's in the volume, and skeleton true, because then we are reducing again to one degree. Because then we are reducing again to one degree, one dimension less to the facets of our space. And with this, we can implement our DG by linear form for the Laplacian. Okay, I put the diffusion and reaction. So put something more. So we have Gardu, Gard V on the volumes, plus some reaction term. And then these are the symmetric and theory penalty for the Laplacian. So we first have the First, have the jump-jump term with the penalization coefficient alpha, and then minus the average jump terms and the symmetric one, each, so both of them on the skeleton of our mesh. Yes, I add this to the bilinear form, I assemble, I put some right-hand side, and so it looks like this. Okay, um. Okay. So, okay, we can again compare some matrix entries. Yeah. So finally, yes, I leave it to you to also put in some upwinding since we of course know that the DG methods are nice and don't need any further regularization if we have some upwinding. So you can try adding some convection into the mix of the diffusion reaction. Diffusion reaction. And even boundary conditions, so in the DG sense, super easy to implement. Here, the syntax is again, we want to integrate over now the boundary facets of the mesh, the ds and not the dx. And again, we put a skeleton since we're in the Digimettal. Yes, and they are easy to implement them. So I will leave it to you to test it out. But it's a piece of cake, and this is why you get this cake-shaped mesh to try it out. Yeah. Yeah, and put some, yes, you can put any boundaries and play around with that. Yeah, ah, this is what I was mentioning earlier. So, this is just a comparison between the two sparse matrices of our system. And this is what I was saying that it's important to put DG charms equal to true, because then it reserves in the sparsity pattern of the matrix, the off-diagonal blocks, which correspond to the inter-element interaction of the. To the inter-element interaction of our finite element basis functions. If you do not put them to true, you see we only get, yeah. Exactly. So yes, maybe I show briefly the last one and then we try to run the code. Okay, so the last one I wanted to show is an example of the coupling. So this is why I was already saying we have some, we can already We can already split the boundary into two different parts. And we will couple two plane waves on one part of the boundary. So the shape that we are going to look at is looks like this. Okay, as some material parameters hold in here. We want to solve a finite element method on the left-hand side, conforming finite elements. And then on the right-hand side, we simply want to couple to a set of plane waves that will be outgoing through here. Yes. Going through here, yes. So, this already is similar how you would do two material parameters, splitting the mesh already into two parts and then integrating separately over each of them. So, we can again mesh this shape using generate mesh. We use curve in order to better capture. So, we use transform finite elements to better capture the circles here. This will give us here some mesh deformation. Mesh deformation of the finite elements to feed this circle. And here, they're already the drafty part. We got us excited for my draft business tomorrow. So we want to have some outgoing plane waves globally. So not a PG space, but just a global plane wave on the right-hand side of our mesh. They can be implemented in NGSolve using. Using this as coefficient functions. So we put a set of coefficient functions. So of the sine times the exponential with these k coefficients for j running from one to five and the ky running from, I don't know, ky in what? Okay, has to be ky has to be written. Has to be hey what has to be written somewhere. No, it's the i is also one to five, and the other one is also one to five, I think. Yes, okay. Um, nevertheless, so this is how we can set up some plane waves. Now I'm just plotting them on the whole domain, again, animated periodically. Yes, so these are our plane waves on the whole domain, and now we want to couple those to a finite element solution on the left-hand side of the domain. Um, we need Um, we need two finite element spaces for this. So, the standard uh H1 conforming finite element space on the left-hand side of the domain, on the right-hand side, we want to construct a global space using these plane waves that we just built. So, we use our H1 finite element space only on the part of the domain that I previously called finite element thing. So, this is everything on the left of this order four, Dirichlet boundary conditions on. Boundary conditions on the left part, open boundary conditions where we want to interface, complex equal to true again. And then for the waves, we put together a global space, so these telling it that we are not confining it to one element. We define it on the right-hand side of the mesh, which is called waves. And we simply pass as a basis shapes, which is the coefficient function set here that we defined earlier. And then it knows that it has to use. And then it knows that it has to use these number of coefficient functions that we built by them as functions of a finite element space. We can also add an operator to differentiate these shape functions dn on the boundary. So we can add operations. We have defined the derivative of these shapes in here. So the d5 we have seen previously, coefficient functions, we can differentiate. Coefficient functions we can differentiate symbolically. So, with a d x, we simply compute the differential with respect to x of our shape functions, and we can tell our global space that this is how we compute derivatives. And then to introduce a bilinear form on the yes, of both the spaces, we simply compute our finite element space as the product space of the H1 space and our global wave space. Yeah, so we can see that we have four plane waves on the right, we have a large number of varied element functions, we are using order four, on the left-hand side, and our product space has exactly the sum of the degrees of freedom of these two spaces. Okay, so the Boeing forms, you already know how to do those. On the left-hand side of the domain, we simply want to solve this Hermes problem, and then we are. This Hermes problem, and then we are coupling over the interface with this coupling condition, standard coupling condition, and yes, putting everything together. So, this is simply double linear format written here implemented. Again, dx for the volume integral only on the finite element part of the space, ds over this phase in between, so which is called coupling. So, which is called coupling. Implementing this integral over there, we put some right-hand side, and then we can solve and have a look at the solution. Yeah, which is here. Okay, this uh they're a bit small, I guess. No, okay. Uh unfortunately, so Unfortunately, so yes, yeah, yeah, okay. This I leave for the user portion. Multiply and then put on the deformation, and it should work. Yes, yeah, okay, so do you have a single distribution that I want to recover the part that goes with the elements and the part that can I extract that from the matrix? In this in the solution or in the matrix? So you assemble the matrix, yeah, and then I imagine that I just want to extract one part. Yes. Yes, you I mean yes, you can. Yeah. If you want to solve the problem in the past. Okay, so I mean there are two ways of looking at this. If you are looking to solve on a subset of the degrees of freedom, we have seen that with three DOFs, you could pass any bit array. So you could put a bit array and select the, yes, it's easy to select the degrees of freedom of the first space, was the first 3400 something degrees. 3400 something degrees of freedom. So you could put those on. There's also always the option to export all these matrices and vectors to NumPy or SciPy as fast matrices and then play around with them. So yeah, of course. So there you are safe. Yeah. So two options, I would say, to do this. Sorry? No. No. I'm sorry. This. So yeah. So. Yeah, so as I was saying earlier, we have a LAPAG link. So you have all the UMFP LAPAG library to solve with. You can also link the MKL if you have it available on your machine. So you have a direct solver and NGSolver implements some iterative solvers and then there's also the whole PETSI package that you can link in that you can couple with. That you can couple with, but yes, it's not instead of that in front of matrix. Yes, yes, yes, yes, yeah, yeah. But it is a huge topic. Yes, yeah, I'm happy to discuss, but yes, yeah, this is definitely, yeah, yeah, but just in the name of time. Okay, so now it's time to run the code. This is my last slide. My last slide, and now it's time for you guys to try it out. And I hope it works. My suggestion to run the code would be the following: probably it's nicer to run in a virtual environment of pip to install the package. I discourage the use of Anaconda since I have some trouble with it sometimes. So I would set up a virtual environment of Python, a start environment, and then it's as easy as. Start environment, and then it's as easy as running pip install and resolve. To run the notebooks, we will additionally require Jupyter, probably market lib scipy, and this web GUI Jupyter widget thingy is responsible to draw the things inside the notebook. Yes, but to run the code, you only need this in the end. For the notebook, you need the rest. All the notebooks I've shown you can find on my webpage. As I was saying earlier on the H2O publish, there are many, many more. And to start a notebook server, you A notebook server, you simply move into the directory of the notebooks and run the command to be the notebook, and it starts exactly what you have just seen on your machine. Yes, and if you have questions, I will run around. And you can also form groups for sure. I know that Igo has a running code that he knows and they can share with you. And also, Chiaga knows how to work the code. So you can also gather around them if it doesn't work on your machine. You can play around with it. Yeah. Yes, good luck. Thanks, John.