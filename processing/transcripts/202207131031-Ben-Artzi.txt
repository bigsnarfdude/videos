Various types of resonances. So I'll start by talking about this abstract idea and then it will be applied to concrete problems. So what is the abstract idea here? So I have also the same picture here just so that it stays up. Up. So, what we are the idea of our work is to bridge a gap that appears to exist between the very abstract ideas coming from logic and theoretical computer science on the one hand, and then numerical analysis on the other hand. Meaning that we want to ask an abstract question about how to perform computations. About how to perform computations. So here's a question. So we have a set omega, and that's just some set. We have an omega with elements, and we want to compute something called xi. xi can be many things. xi can be resonances and the set omega can be a set of various problems for which we want to compute the resonances. Compute the resonances and so on. Psi can be the spectrum of different problems. And the image of elements in omega under xi live in a metric space. So we need to identify the metric space. And now what we want is to ask the question: does there exist, can we come up with a black box that will approximate Approximate the output in this metric space, and I require two things of this black box. I require that it reads only a finite amount of information at each iteration, and that it works consistently. So if, let's say, I want to compute the spectrum of elements, bounded elements on little, bounded operators on little L2. I have two different elements, but my algorithm had. Elements, but my algorithm happens to read a section of it which agrees, which has the same entries, then the output would be the same. So it needs to work in a consistent way. So that's all that I require of this black box. So think of like a Turing machine. But it can be more general than a Turing machine. And the question is: does there exist an algorithm, gamma n, as it marches? And as it marches, will approximate in the distance in this metric space. And so the surprising, well maybe not surprising, answer is that not always, and that sometimes you might require multiple limits. So you might require your black box to not just be indexed by a single n, but by n1 to nk, and you're going to need to let the limit Going to need to let the limit n1 going to infinity and n2 going to infinity consecutively without the ability to squash those limits to fewer limits. And the SCI, SEI solvability complex Unix theory characterizes this as well as air control. So we get sort of a structure which for logicians would be very familiar with, where we have sort of a hierarchy of classes of complexity, so it would keep going up. So it would keep going up indexed by so with 0, then 1, then 2, and so on. So I'm not going to go into what this is, but this would characterize problems that can be computed in finite time, problems that can be computed with one limit but with some form of error control, problems that can be computed with one limit without error control, and then two limits and three limits and so on with various And three limits, and so on, with various forms of error control. The pi, the things on the sides have different types of error control. And these kinds of diagrams for theoretical computer scientists would be very familiar. When I gave a talk on this a few years ago, not on computing resonances, but on the grounds of computing spectrum in Jerusalem, I was told the first time that we Logicians showed up to the analysis seminar. Right, so okay, so in terms of references, so the work started with Anders Hansen in 2011, and then we have a paper that maybe someday will get published that's on the archive that characterizes all this with several co-authors. Okay, so that's Co-authors. Okay, so that's the abstract side of things. Right, so let me continue on the abstract side and show you that this is more than just in our favorite kinds of problems. So as I said, you find logicians interested in this. But here's a concrete problem where this structure appeared before. So this is from a paper of Steve Smale in 85, where he looked at the space of He looked at the space of polynomials up to degree d. And he defines purely iterative algorithm, okay, some kind of rational map. So think about Newton's algorithm. We want to find zeros. And so he defines it to be generally convergent if basically for every initial guess that you have and for every polynomial, you're going to find a zero as using an algorithm. As Newton's algorithm iterates. And Newton's algorithm isn't generally convergent. So I think that Smale proved that, that for polynomials of degree 3 and higher, it is not. And so he posed the question, for higher-degree polynomials, does there exist a generally convergent purely? So maybe not Newton's algorithm, maybe something else, a black box, that will do it. That will do it. And so, Kurt McMullen, this I think was his PhD thesis, said that yes, for d equals 3, but otherwise, no, there is no such black box. So this was 87. Then in 89, together with Peter Doyle, they found something very interesting. That if for polynomials of degree four and five, it can be solved, but you Can be solved, but you need a tower of algorithms. And this is copied from their paper. A tower of algorithms is basically what I described earlier. So you take multiple limits. So a finite sequence of generally convergent algorithms linked together serially. So the output of one or more can be used to compute. So basically, you need to take one limit, you get something, and another limit, and so on. And they have an actual, in this paper, they have an actual algorithm. In this paper, I have an actual algorithm, and I think Peter Dahl on his webpage has an implementation of that, so you can code for that. Okay, so and this problem can be recast in our abstract framework, where you would require that your black box performs It consists of rational maps. So, okay, so here are the questions that I want to ask. So, again, this is the structure I have. And now I want to ask, does there exist an algorithm, so with one limit, for computing the resonances? So, this is what I call quantum, this is what I call classical. So, I want a one-size-fits-all. I want a black box that's good. I want a black box that's good for any nice, I'll say what nice is, potential Q, and I want to find the resonances of the shorting of the operator. So what I feed into my black box is Q. So meaning what? Meaning that my black box can come and ask for a point X, what's P of X? And it can do that finitely many times. And for the And for the classical, what I call the classical case, an obstacle, so we have an obstacle, we want that for any nice obstacle view. I want the resonances, so I want to compute, to find the resonances of the Laplacian on the complement of view in R D. Okay, and again, what do I feed into my black box here? My black box can come and add it to any point in R D. Is it or is it not in U? Or is it not in you? Can I tell it yes or no? That's how the blood walks look. All right, so here are the main results. So first the quantum case. So this hopefully soon will appear. So here, right, you know, before that, I'll tell you. So here we say that there is a limit, but you may ask, well, maybe sometimes you can't do it. So in the paper written with my co-authors, we considered the With my co-authors, we considered the spectral problem, and I'll give just three examples. So, one where we take the step omega to be all bounded operators on level two, another where we take, well, slightly larger set, but let's say self-adjoint operators, and one where we take compact operators. The metric space is closed set. The metric space consists of closed sets with the Hausdorff distance. Psi is the Xi is the spectrum. And now, so how many limits, the SCI value, how many limits are required? So we prove that in this most general case, you need three limits. So you cannot do it, not with one, not with two limits. In the self-adjoint case, where you know how the norm of the resolvent behaves as you move away, basically the important factor is knowing the norm of the resolvent. So if you know something about the norm of the resolvent, you can reduce the three limits. You can reduce the three limits to two limits, and well, if it's a compact operator, then one, as you might expect. Right, so okay, so we prove that there exists an algorithm, and these sorts of proofs, they're interesting, because you want a lower and upper bound. So, to prove that it's less than or equals three, you need an actual algorithm. You need to say, here's an algorithm that does it in three limits. To show that it's To show that it's greater than 2, you need to argue that there does not exist. So that's a completely different nature of proof. Right, okay, so we show that there does exist an arithmetic algorithm. So basically a computer can do it. So that says that this black box is not just a black box, it's a black box that performs arithmetic. A black box that performs arithmetic operations. And it can do it for any queue which is a compact support and once continuously differentiable. And also, okay, if we know a priori how big the support of Q is and how big Q becomes, if I have that a priori knowledge, then I can even do this computation with error control. And here's a comparison. So for this potential, we compare the algorithm that I'll show you very briefly. So there exists a very nice online algorithm of Bindle and Zworski. And so I don't know if you can see it. So their algorithm gives the docs here. Our algorithm gives sets. Our algorithm gives sets. So the disks around the dots are what our algorithm gives. If you actually run these things, their algorithm immediately gives you a result. Our algorithm takes a few hours. But our algorithm, I mean, so it follows this theorem and you're guaranteed to get the correct. To get the correct set. And again, if you know how POA these things, then you even know you know how long you need to run to get to a particular error. Right, okay. Now, what I call classical, so the obstacle. So here's an obstacle. And I want the Dirichlet resonances. So the theorem states that there exists also an arithmetic algorithm. You can approximate these for any. These for any. So I feed it any U, which is open, bounded, and boundary is C2. And this has actually been improved by Frank and our student, Stepanenko, Alexei Stepanenko, to, and it's a very nice paper, to also cover cases with like a fractal boundary. So they do really nice stuff with that. It's a really nice geometry. Right. Okay, so I have many slides. I'm just going to show you just the main idea. Right, so okay, so I start with the quantum case, okay, with the Schrodinger operators. So we want to find resonances of this guy for any Q like that. So, okay, so I'm not so good at these things. I'm going to do it very slowly. So, this is what. So, this is what I start with. Now, if you need someone to move terms from one side of an equation to the other, call me, because I'm really good with that. So, this goes here. And that's where my expertise stopped. Right, so now I'm going to call this V. This is probably all of you know. So, now I have an equation for V, but V is But V satisfies V equals minus QU, and Q has compact support. So I can stick in something that has a larger compact support and is one on the support of Q. So basically, V is the same as chi V. So why am I saying that? Because I can stick chi then here. And so this is what I want to look at. I want to look at this operator here. So basically, we are looking for poles of this operator where I inverted it. So this is what we want to find, the poles of this thing. Right, so again, repeat it. So how are we going to do that? So I call this guy here K, and what we need to do is get some quantitative resolvent norm estimates for this. And that's going to be done by defining a discrete type. Done by defining a discretized version, which I know that I can compute in finite time. And then I identify the poles of this guy via the poles of the discretized guy. Okay? Right. So, okay, so there's an abstract result that underpins this, which is a statement that if I know that I have a family of operators that are close somehow to Somehow, to projections. So, I have a few statements that are almost the same, but not quite the same. So, the differences between K and Kn and K and Kn on the finite dimensional space. So, okay, I don't have time to go into this, but if I have this thing, and this is the kind of thing that we verify for our case, this is just an abstract statement here, then. Here. Then, if I define a discrete lattice intersected with a compact set, so now I have finitely many points to check. And I check that this thing, which I can check in finite time, is greater than this thing. And here, AN is something that I should know. Then I declare that to be in the set. Declare that to be in the set gamma plus gamma n is going to be the thing that approaches here. So, again, so here's the definition of this gamma n. And so this, what we prove is that in the Hausdorff metric, this set of finitely many points converges to the set of z's in this compact set P, for which minus one is in the spectrum of kilo. Spectrum of kill. Okay? Is it clear why you take square roots of A? Right. Okay. So for that, there exists algorithms. So you can incorporate. So we also assume that we know what pi is, and we know what square root of 2 is. So since we're taking a limit into that limit, we can incorporate the computation of what pi is, for instance. So it can be brought into that limit. Brought into that limitative. If you claim that you have a problem that can be computed in finite time, then you need to say something. You need to say, does your black box know what pi is? But yeah, this computation can be incorporated into the single lambda. The sequence AN should also be diagnosed, right? It's a sequence that you know and we have it explicit. Right, okay. So this can be done with finitely many operations. And now I need to. Operations. And now I need to tell you how I define this Kn. Well, I define the Kn from, so I represent my operator with the Green's function. And basically, my Kn, I split my Rd into little cubes. And my Kn is simply taking the value of K at the corner of each cube and making it constant. And we should just show that that converges in the appropriate light. Okay, so I'm going to skip all that. Skip all that. So there's, we basically prove that that converges to the resonances for every compact set. And then you need to get this from one compact set to the whole complex plane. So you tile your complex plane with compact sets and you define the algorithm that takes all these combined. So that's the quantum case. Let me very quickly do the classical case. So first we assume that we know what the support is. So we assume that it's What the support is. So we assume that it's within some ball of radius r minus one, let's say. And then here we use the Dirchlet-Teneumann approach. So we write on this ball of radius r the outer Dirchley-Neumann operator in the inner. And then we say, so a resonance, so a K is a resonance if and only if this kernel is non-trivial. Is non-trivial. Okay, so you have something looking at. And now, what we do is, instead of looking at this problem, we rearrange these guys to have the form identity plus something. And that something turns out to live, to be quite nice, to live in a shabby class. And now, what we need to do is to identify, to work on this. So now we have some operator C that has to do with my. Operator C that has to do with my set U. I need to approximate that. And now I need to work with, so now we look at determinants to identify where this is zero. So to identify where the determinant of this guy is small. And in the end, I'll need to get rid of that. I assume that I know R, the support, so I need to get rid of that assumption. I'm not going to show you all that. So basically, what happens? So basically, what happens is, so you have an expression, obviously, for the outer Dirschley-Ten-Neumann operator, which involves Henkel functions. The inner one involves Bessel functions, and then something that has to do with the actual obstacle that you have. And then you rearrange everything, and you get things that are nice, so Bessel, Prinkel. So Bessel, Perkle, and this is just this here comes just from a diagonal with numbers with integers, so that's nice. And you rearrange that, and you get basically whatever you want. So you get that the kernel of this thing is the same as the kernel of this new identity plus something. Right, so now I need I need sorry, I need basically this, I need to work with this something, this CK. I need to approximate that, and this is the CK, and so first I have a statement saying that I can truncate the CK, and I have a quantitative way of doing that. And then I need, so the CK consists of the thing that has to do with the articles K. has to do with the obstacles k. So I need to approximate this k and that's tricky. Okay, so that's a rather complicated algorithm. Basically, so this is where the numerical analysis comes in. I need to write down what this k is. I can get some three terms. One is good, two are bad. And I need to basically have some finite To basically have some finite elements to approximate. Right, there, I'm skipping all that. You can do that with a rate. Okay, the proof of this is quite long, but it uses tools from numerical analysis, functional analysis, to eventually get a rate of convergence. So now, instead of my k, I have kh, where h is my mesh size. That's good. That's good, and I have a rate at which the mesh, the operator on the mesh, converges to my real operator that I want, actual operator that I want, and with rates. So now I'm going to link the n and the h and I so I have these things and eventually. These things, and eventually, so I get I can approximate my C with some CN, with all these things that I really skipped. And now what I wanted was the determinant, right? So I can, instead of looking at this determinant, I can look at this determinant, which I can compute because that's a CM. Okay? Okay, so now what does the algorithm do? So it's going to be similar to the algorithm before. I'm going to look at points on a finite grid, and I'm going to check when this determinant is smaller than something. And I can do all that with finitely many arithmetic operations. And the theorem says that this converges, and this is in a compact set. So I'm almost done. Again, you need to, so now you're in the lower half plane. You're in the lower half plane, so you need to extend this so you tile it with compact sets, and you get the whole lower half plane and pictures. And that's the end. So here is an example that we did. So here's the obstacle, this C with a mesh. The outer thing is the radius R. So here's pictures we get. Pictures we get. So I take two different sizes of the opening. So for a big opening, okay, so here the red dots are what the eigenvalues would be if it was closed. So I can make myself there. So for the big opening, here's a resonance, here's a resonance, and here's a resonance. So they've moved away from the eigenvalues. When the opening is smaller, When the opening is smaller, these resonances have moved closer. And here, this is zoomed in. So this thing here is zoomed in here, and this thing here is zoomed in here. And this is just for fun, just to verify that what we've done is right. So we look at this problem. We want to see if the wave can penetrate inside. So we take on the boundary, the fifth. The fifth, so some sign on the VR. And once for something that's near resonance, once for something that's not near resonance, you see when it's not near the resonance, you have nothing inside, and when it's near the resonance, it goes in. And this is an open problem, if you want. So we did, this is with the Neumann problem, which we sketch how that should be done. And we do the computation with a Neumann problem. And we do a computation with an Neumann problem with four disks. I can tell you why that's, for some people, interesting, and compare it to the literature. And here are the resonances, if you can find it. Thank you very much. Thank you. I think we may have time for a quick question. In this picture where you showed the tiling of the complex plane by cubes, it looked like you need to refine the size of the cubes when you approach the real axis. Yeah, but at any stage it's finitely many, and then we take a limit, and the limit will. Okay, we have four. On slide 25, I saw h to the one-third in it frequently. I'm not used to seeing it. Frequently, I'm not used to seeing h to a small power like this. Usually h or h squared or h cubed. Is this well that's the I mean, that's that's many sort of why one-third I can't, I mean, I'll need to look exactly. We don't we never claim that ever that anything is optimal, it's just an existence. I may have missed it, but do you have any But do you have any uh quantitative uh estimate for the distance between the resonance and the regular value so? Um so so okay, so I didn't I didn't show here in the quantum case I said that if I know a priori this various things about the um the potential, then I can do, but I didn't show that here. But yeah, if you know, if you have some extra information, then in your estimates you can you can improve the constants. So I wondered if you have any pictures of non-traffic obstacles other that aren't for this. Well, I mean, sorry. That's trapping. If I understand you correctly, oh, okay, well, but okay, so this, this, this, we did this because it's of particular interest. So this is. So, this is a cross-section of an oil rake sitting in the ocean. People are interested in how the resonances of that, so there's literature on that. But you could, I mean, so our algorithms are on GitHub. You can stick anything into it. I can check it out myself. You can stick anything into it. Great, thank you. Thank you. Thank you.