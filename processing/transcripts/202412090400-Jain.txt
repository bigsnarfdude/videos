Ah, okay. Yeah. Right. Okay, so let's start with the motivating question here. Okay, and this is related to the discussions that we have had during the day. Okay, so privacy amplification, let's look at the privacy amplification stage of the QKD protocol. Okay, so what happens? Protocol. Okay. So, what happens? So, you know, so there is a quantum part that happens before, okay. And then Alice and Bob end up with. So, after let's say information reconciliation is also done. So, they end up with some rocky X. Okay. And then Eve has some side information on this rocky X. Okay. So that's the status. And then they have to do something, you know, exchange some, run a protocol between themselves and then end up with, you know, the real. And then end up with the real key R. And this should be uniform and independent of EF. So this is the priority amplification part of QKD. Now, the usual solution that we consider here. Okay, so let me just say, okay, so what do we have? When we say that it's a rocky, so it has some min entropy given if, okay. And And then, yeah, and then Alice and Bob have to execute a protocol to generate R. Okay. And what is mean entropy? Okay, so mean entropy in a random variable is basically related to the maximum probability that the random variable takes. And conditional mean entropy is, you know, one way to just say, is define it is the maximum probability of guessing x given e. You can take it as 2 to the minus k and then min entropy would be at least k. Then mean entropy would be at least k. Okay? So let's take that as the definition. Okay. So now, so yeah, usually we use strong CD extractors for privacy amplification. Okay. And what are those? Those are basically functions. So here, so we have x and e, right? So x is the rocky, and e is the side information that e has on the rocky. And y. Has on the rocky and y is the seed, okay, which is uniform and independent. And then we have this mid-entropy bound, and then this is uniform, right? So the property that we have is that the extractor on X and Y, so these three systems, right, the extractor output, Y and E, is basically close to being uniform, tensor Y, tensor E. Okay, yeah. Now, Now, very good constructions of such extractors are known, which extract almost very close to mean entropy and also have seed length, which is very nice, polylog, and so on and so forth. Okay. So, classically, very good constructions are known for such seeded x vectors. Sorry, sorry, yeah, yeah, yeah, yeah. No, no, no, no, no. We will see. No, no, no, no, no. We will see. Yeah. Yeah, so the protocol is like this. So Eve will generate the seed at her end and she will send it to Bob. And we are assuming, as of now, a passive adversary. So the adversary can look at Y but cannot do anything. So then it will go to Bob and both of them will output R, which is the extractor output. Will output R, which is the extractor output. Okay. And because it's strong, that's why even the knowledge of Y will not hurt. Okay. Okay. So this is the thing. So this is what we do for the passive adversary case. Okay. Now, in case it's active adversary, it can change the messages being exchanged between Alex and Bob. And then, of course, that original thing will have issues. Okay. So what do we do? So in this case, what we want is that. Do. So, in this case, what we want is that if basically Alice and Bob, you know, if there's a lot of messing up that takes place here, then Alice and Bob are allowed to abort. Okay. So they should be able to abort. But if they don't abort, then their outputs, RA should be equal to RB, should be equal to R, and should be uniform and independent of the advertisement. Okay. So you want the security guarantee, conditional, non-abort. But they can abort if they want also. Okay. Okay. Yeah, yeah, yeah. Yeah, yeah, yeah, yeah. Those conditions will be there. They'll come in. They'll come in. Basically, if all these messages are the same, then they should not abort. So yeah. Yeah, okay. So, so, in order to deal with this case of active adversary, we have to consider a stronger object than just the seeded extractor. And so, the stronger object is what is called as so-called non-malleable extractor. Okay. So, the non-malleable extractor has these extra conditions on top of seed extractor. So, what is it? Okay. So, basically, the adversary you know, using y and e right can generate, can perturb to get y prime e prime, right? That's what adversary can do, okay? And however, what will happen is that if there was a mean entropy in x given e then you know you will still have mean entropy bound, right? Because what is happening is it's taking an independent y and doing some internal stuff, which is not going to change the mean entropy bound. So that's still there. So that's still there. And let's just assume that y is different from y prime for now, because the message is changed. Okay. So the thing that we want is this now, that the output of the extractor, the non-millimeter extractor, should be uniform and independent of this entire. So this collection of stuff. So these four random variables and this quantum part should be the same as or close to uniform and. To uniform and these objects. This is what all the objects that actually adversary has. So basically, the adversary is allowed to have a choice of y prime of its own and still be given the non-millimeter extractor output on y prime with x. And even though X and even the normal extractor output on the original Y with X should be uniform, independent of the adversary. So the adversary is basically allowed to be given one particular for one particular seed Y prime of its own choice the extractor output and even then the on the original seed should be secure. Um no, no, we will see the protocol. We will see the protocol. So, the so this is going to be our condition that we want from non-wellber extractor, and then we will see the protocol. Okay. See, that will become clearer with the protocol. No, it's a perturbed one. Original perturbed. Yeah. Which is also perturbed to E prime while getting, while generating Y prime and all that. Okay. Generating Y' and all that. So here's the protocol. Okay. So Alice would start with Y sent across, which will be maybe received as Y prime. Then both of them will generate S, which is the non-mailable extractor output of X and Y. And here S prime, non-mailable extra X and Y prime. And then there's going to be a, you know, a Mac in the second round. Know a Mac in the second round, okay? A message authentication code. So let's look at it. Okay, so let's go through it a bit slowly. Okay, so the thing is this. Okay, so eventually they're outputting RA R B, okay, which is extractor of X and B prime, X and B. Okay, so ideally we would like to have the B to be the same, okay? Because that will mimic the original situation of Y being the same. Original situation of y being the same. Okay. So let's see what happens. So why sent here? Let's take the case where it was not perturbed. So y was equal to y prime. In which case, s will be equal to s prime. Correct? Now, what is happening? There is an independent B that is chosen by Bob. Completely independent uniform using private randomness. Okay. And Bob calculates this P, which is sort of the signature of B using the B using the key S prime and this is the signature T okay and B and T are sent across okay and now if it's spread out B T spread out to B prime T prime okay now if S is equal to S prime max security will catch it correct because this is signed using S and it is changed so max security will catch it because it is because it the check is because it is because it the check is that t prime is mac of s and p prime okay so either any of these things are changed either the text is changed or the signature is changed that is called using mac okay and this is information theory constructions are there for this it is not a computational okay uh and now suppose y is different from y prime okay then what happens is that because of this property what do we have Of this property, what do we have? Have a look. So, this s is now uniform and independent of everything that E has. Okay, I have i prime s, you know. So, so basically it becomes independent v prime t prime because this, not just even bob combination. This s is uniform independent of even bob combination. So, therefore, it's independent of b prime t prime. It's just completely independent. So, this will not go through this. Independent. So, this will not go through this check also. So, in both cases, the check does not. So, either if there is a perturbation here, the check does not go through. If this is the same, but there is a perturbation here, the check does not go through. Okay. So, this is how the protocol is. So, this protocol was given by this people back then using non-millable extractors. So, this is where the utility of the name is. level extractors. So this is where the utility of normal level extractors sort of came in. Okay. Okay. So we can do that, except that this was when this was given. So now we need a construction of non-millimeter extractors, right? And ideally with a spoilog length seed, because the point is that if the seed is large, then the communication in this protocol is large. Okay? So we'd like to have a polylog length. Would like to have a poly log length seed, normal level extractors. Okay, and although this was the original motivation with which this was defined, you know, normal extractors have found a lot of other applications. One very notable one being in this breakthrough construction of two source extractors for polylog main entropy sources, this Chattopadhyaya Zuckerman construction. They actually used non-mailable extractors for that. Okay, so they found utility there. Found utility there and also in the construction of non-malleable codes. So, we'll look into what non-mailable codes are. So, in the construction of non-mailable codes, okay, and also further applications of those things, like for example, non-mailable secret sharing, non-mailable commitment, and so on, so forth, non-mailable signature schemes, et cetera, et cetera. Okay. So, okay, so yeah. So, what are non-malleable codes? Okay, so non-malleable codes. Okay, so non-malleable codes are basically, you know, basically capture this fact that, you know, if, you know, so you take your message S, you encode it, adversary tampers it by F, let's say F is the adversary tampering function, then you decode it. Then this decoded thing should either be the same as original messages with a certain probability P, and with the rest of the And with the rest of the probability, it should be df, where df is another distribution on your message space, but that's just completely independent of s. So it's like a fixed distribution. Okay? And this pf is also independent of s. So it's a fixed probability. That only depends on the adversary action. Okay? So no, that's the thing. Decoder cannot tell. So therefore, these are weaker objects than tempered. Than tamper detection. If there is temper detection, then they would have implied this. So these are even weaker. So this is what you get, but decoder doesn't know. Non-mailable codes. So this is non-mailable codes. Tampa detection. Yes, yes, yes, yes. So, tampered detection codes are also there. Yes, so tamp detection codes are also there. I mean, so the thing is that okay, the regular codes that we have are where you know, ideally you are able to detect the error and even correct the error, right? Error correcting codes. And then the error detecting codes are weaker where we are interested only in detecting the error, right? And then the normal codes are even weaker, where you kind of get error detection, but without the decoder actually knowing it. Yeah, exactly. So the thing is, you weaken these codes, but the point is, you can then handle a much larger class of adversaries. Because for erocratic codes, you have these bounds, right? Whatever, n over 2, n over 3, whatever, n over 3, whatever, some bounds. You have on the number of perturbation, right? n over 2, right? Error detection, you have maybe more, but whatever. Error detection is n over 2. Error detection is n over 2. Error correction is probably n over 3. N over 4, right? Yeah. Yeah, so here you can put out everything. Just everything. But of course, there's still caveats. We'll see. Okay. Non-millable. Non-millable. Yeah. Okay. Yeah, so these things can be thought of as a relaxation of error detecting codes. Okay, so what a very sort of well-studied model. So of course, one can argue that, you know, if you don't put any restriction on adversary, even non-mail records are not possible. So you have to put some restriction. So the very sort of a popular model. Very sort of a popular model is this two-split model, okay? Which is you encode S into two code words, X and Y, and you send the code words separately, okay, very far through different channels, okay? And the adversary can only separately perturb the two parts, okay, to obtain X prime and Y prime, and then the decoder acts on them, okay? So, joint perturbations are not allowed, okay. And now, this can be anything, you can correct all. This can be anything. You can correct all the bits if you want. You can do anything. Okay? Yeah. But separately. Separately. Okay? So this two-split, then one can consider three-split and so on and so forth. But the strongest is the two-split model. No, the functional, there is no restriction now. That's the thing. I mean, there's an implicit restriction that the function families are this F tensor G, but other than that, there is no restriction. Yeah. But other than that, there's no situation. Yeah. Okay. And kind of natural because it's possible that you are sending it to two very far away channels or something. And maybe adversary cannot handle both of them. Okay. Well, you know, one second late. Yeah. Okay. Yeah. So now in the quantum world, we can consider the two-split case where now the adversary can basically now share entanglement. Now, share entanglement. Now, in the quantum case, we have to allow shared entanglement between the two parts. Okay. Because if we don't allow, then it's just way too restrictive. Okay. So we have to allow shared entanglement and then the adversary can do these U and V actions, unitary actions separately on the two parts. Right. So this is the split state model. Okay. Yeah. So yeah. So for the quantum secure seated extract. Secure seated extractors, you know, there were constructions known, which were again, I mean, having parameters which are pretty optimal, close to the mean entropy, and yeah. Okay. No, no, no. In that case, if you corrected the first part, the receiver will receive independent. Yeah, no, no. If either x is different from x prime, even in one bit, or y is different from y prime in one bit, what the receiver receives is junk. Nothing to do with the message. Okay? Yeah. Yeah. Exactly when x prime is equal to x, y prime equal to y, then the receiver receives it. Yeah. Okay. So it's not, yeah, so it's not obvious that such codes are possible. Yeah. Okay. So the thing is that there was, yeah, so for Cedar extractors, there was these constructions known, like, you know, Travesan's extractor basically also works in the quantum case. But of course, I mean, there were non-trivial arguments. I mean, there were non-trivial arguments needed to argue the security of Terrace sector in the quantum case, but then it was done. And then, you know, yeah, so therefore, you know, seeded extractors were there with good mean entropy and good seed length. Okay. Oh, yeah. Okay. Yeah. So they were securing as quantum side information as well, which gave you know a privacy amplification protocol with a quantum adversary, passive quantum adversary with polylog communication. With polylog communication. Okay. And against, yeah, and non-marriable extractors for classical adversaries were also known, you know, by this construction by Chattopadhyaya, Gogul, Gohel, and Lee with polyg seat length. Okay. Now, yeah. So they, of course, gave the protocol in the classical case. Okay, and as quantum side information, the best non-variable extractors, which were known prior to our works, is this lease extractor, but that required linear seed length. Okay. And yeah, so it gave a PA protocol with linear communication. And then the question was, can we get it with polylog seed length? And that is what we do. We actually get quantum secure non-molever extractors with polylog seed length. With polyloxy length. Now, the thing is that there is a particular quantum only technical difficulty that is faced, and we'll get into that in a bit. Okay. Yeah. So non-malleable codes. Yeah, non-malleable codes also known in the classical setting. You know, we knew non-malleable codes with whatever polyrate and negligible error. And then eventually, And then eventually, you know, with a series of works, you know, we are able to get, I mean, not we, but they able to get a concentrate a non-mailable code with negligible error. So concentrate non-milligrams codes were there, okay? In the two-split model, in the two-split model. Okay, so what is the quantum only difficulty? It is as follows. So the thing is this. Okay, so see, the adversary is modifying Ey to an E prime. series modifying EY to an E prime yy prime right generating a y prime now what happens okay classically okay what is the situation we're starting with X C tensored Y right so given E X and Y are independent okay and now with this tampering it still holds that is given E prime X and Y Y prime are independent classically okay because if it's a Markov chain to begin with Because if it's a Markov chain to begin with, and you do some local operation, it remains a Markov chain. But this breaks down in the quantum case. Okay? So you no longer have a Markov chain just by doing local operation. You can start with a Markov chain, but do local operation, it's no longer a Markov chain. Okay, and there are easy contract samples for that. Oh, for example, it take an EPR pair, okay, and take ket zero. Okay, so ABC, AB is EPR, C is KED 0. B is EPR, C is K0. So it's a Markov chain, right? Like A, B, C is a Markov chain. Now you just do a C naught, make a GSC state, okay? Okay? Now it's no longer, because the condition which information then is one. Okay? Yeah? So therefore, these things go wrong in the quantum case. But fortunately, it's a quantum only problem. Fortunately, it's a quantum only problem, and therefore a resolution is also a quantum only resolution, which uses pure states, which are a quantum only object. The thing is, our adversary model changes in the quantum case, basically. In the classical case, the typical adversary model is that you have adversary, for example, for two source cases, right? Two source extractors. Given adversary, you're X and Y independent. That's your typical model that you work with. Given adversary, E, X and Y independent. See E, X and Y are independent. But it's the same E. In the quantum case, our E changes. Okay? So we'll see. Okay, the model. Yeah, so we introduced these two new adversary models. And we showed that these adversary models are stronger than all other. So in the quantum case, in the multi-source case, in particular, there were several adversary models considered. And it was not clear which is stronger than what. Not clear which is stronger than what, comparing between them. There's a bunch of them around. So, what we show is that our adversary models actually can simulate all other adversary models. But not that they're super strong, because there are extractors that can work against those adversaries as well. So, we show the inner product is a good two-source extractor, even for these adversary models. And using that, we construct a non-mailable extractor, C-Day non-miller extractors, and two-source non-mailable extractors in these models. Okay, in these models. Okay. Sorry, what? Yes. Yeah. Yeah. Yeah. Properties of inner product, yes. But but of course, not in our model. Because our model was not, he didn't consider our model, our adversary model. Okay. So, yeah, so we construct non-millimeter extractors which can extract up to actually k over 2. We just write k over 4 here, but it is actually k over 2. Bits as long as say, yeah, d is poly log. Yeah, so with poly log c length, we can do that. So we basically take the CGL construction, which is the construction for normal restructurings in the classical case, and we just argue its quantum security. You it's quantum security, okay. The construction is CGL construction, right? Okay, so this gives us a PA protocol with polylog communication against active adversaries. And then we also consider this other thing where, you know, instead of tampering being done one, you can do tampering like three times. Yeah. And then you have each YI is different from Y. And these three time tamperings are actually useful because it was used, for example, by Ichato. By Ichatabada, Zukarman, for the construction of their polylog. So you need a stronger T-time tampering security as well. Okay, and for the two-source case, we are also able to get a non-molemic extractor. But now the mean entropy is very close to n, like n minus small o of n, actually. When we have main entropy, n minus molo of n in both the sources, then we have a normal restrictor. Yeah, and then there we use the fact. Yeah, and then there we use the fact that the tool source is a good extractor against our adversary models. And also, we give it for T tampering. Okay, so using this, we get a bunch of results. So first is we get a rate half, two split, quantum secure, non-malleable randomness encoder. So what is randomness encoder? It is basically a non-malleable code, except for the fact that the encoder is not getting the message from outside. It is generating the code along with Generating the code along with the message together. Okay. Basically, it's not getting the message from outside, but it's generating the message and the code together and then sending the code. So that's an MRE. So we get that, but it's a very useful object. This object is very useful to actually then go ahead and generate non-mailable codes with good rates. Then rate one-third, three-split, quantum-secure, non-mailable code. So quantum secure means that the So, quantum secure means that the encoder and decoder are classical, only the adversary is quantum. Okay. Then we get rate one over three, three split quantum non-mailable code. By quantum non-mailable code, it means that the message also is quantum. Okay, the message is also quantum. Okay, then rate one over five, two split, average case, quantum secure, non-mailable code. So, in the two-split case, so this is three-split. So, two-split case, we are able to get it, but only when the message is maximum. The message is maximally mixed. Okay, the message is maximally mixed. And then rate one over lemon, two split average case quantum non-mailable code. Sorry, quantum secure means here the message is classical but uniformly distributed. Here it is maximally mixed. So, using these things, we get a one over polyrate to split quantum secure and quantum non-mailable codes and also a TR. And also a T out of P quantum secure and quantum non-mailable signal sharing schemes for these parameters of T and P. Okay. So basically T greater than or equal to 3, less than or equal to P, which is less than or equal to, you need this for the quantum case, this 2T minus 1. Okay, so how much time do I have? Two minutes. Oh my goodness. Okay. All right. So then. Okay. All right. So then, okay, so let me just quickly explain this thing about the adversary. Okay. All right. So we can see one thing that, you know, okay. So basically our adversary model is as follows. The thing about the adversary model is follows. You know, whenever you're going to consider, so there are, we talk about two sources, right? So we'll have X and Y as two sources. And because it's classical, we'll always think of anything which is classical. We'll always think of anything which is classical with a copy of it, x hat, okay? X hat is just like a copy of X to make ensure that X is classical. This whole thing is a pure state, okay? This whole thing together is a pure state. X and Y are two classical random variables, which are having copies X hat, Y hat there. And then N is held by Alice, M is held by Bob. Okay, so what's our model? It's a K1 Q2 QPS state if there is a minimum. If there is a min entropy in X is at least K1 given what? Given everything that Bob has. Bob has what? Y, Y hat, and M. Okay, these are the three registers that Bob has. Alice has X, X hat, and N. And this H-min bound is there. So you see, what are we talking about? We're talking about immun entropy in X given what Bob has, and immun entropy in Y given what Alice has. So you see the difference with the classical case, right? The difference was always like minentropy in X and Y. Always like minentropy in X and Y given E, the same E. But here we're talking about mean entropy in X given Bob and minentropy in Y given Alice. And this helps us to get around this issue of the Markov chain breaking down. Okay? I mean, the classic case also, you can think of the two copies of E, right? And then you can talk about, oh, min entropy next given this copy and minentropy given this copy. And this is with Alice, this is with Bob. But the point is. But the point is, in the quantum case, it's important to consider it like that. Okay, you can't just condition on one fixed register E. There is no one fixed register E on which you can condition on and define things. So, using this model, we are able to basically get around stuff. And, you know, so there are two important things that are used by in the CGL. By in the CGL construction, one is this alternating extraction and this flip-flop primitive. So the CGL construction is basically a composition of a lot of different alternating extractions, a lot of different composition of extractors, basically. Okay. Composition of a lot of functions. And so we're able to basically argue the quantum analog alternating extraction in our this K1K2QPA model and the min entropy loss also as well. So, what is this alternating extraction? So, what is this alternating extraction? It's as follows. So, let's say we have this Alice and Bob. There's a pure state XASB. Okay? Yes. Why is it a good definition for two-source adversaries? It's because we are able to make a non-mailable extractor and get the application of privacy amplification and get non-mailable codes and et cetera, et cetera. And get non-mailable codes and etc. Yeah, yeah, yeah. Okay, so here, let's say we have a pure state XASB, okay? Yes, as I mentioned, I mean, it's important for us to keep the whole thing as pure all the time, which is the quantum only thing, okay? Because that is important. Because we're going to do an Ulman sort of an argument which which requires purity. An argument which requires purity. Okay, so XA has B is a pure state. And suppose we have the situation that X, there's minentropy in X given Bob. Okay, Bob has S and B. Okay, and then S is also independent of Alice. So S is like a seed, right? Independent of Alice. XA. S X A is uniform tensor X A. Then what happens? If you now use an extractor, extractor, regular extractor. Extractor, regular extractor on XNS, then the output T now has this property that now T becomes independent of Bob. Okay? Everything that Bob has. So you start with an S which is independent of Alex, you get a T which is independent of Bob, and you repeat this, this alternating extraction several times, okay, in the construction. So that happens. And this alternating extraction argument breaks down. So in the classical case, they were always doing it by conditioning on a proper register. Doing it by conditioning on appropriate registers and then arguing about conditional independence, right? But the point is, that is not there. You don't have this conditioning. But you still have to argue this. And we can argue this because we're working with this other model. Okay? And this is just the mean entropy loss under control, which is, I think, you sort of believable, which is just that, you know, you start with the mean entropy next given Bob, and then we exchange. Given Bob, and then we exchange messages, and then the min entropy still is high if the total number of messages coming from Alice to Bob are bounded, right? So that's fine. Okay, so yeah, so finally, the thing would be to try to get two source, sorry, two split concentrate non-mailable codes. Okay. Yeah, trace an extractor as a regular extractor. That is for the two-source case. For the seeded case, we are able to get polylog. Yeah. Okay. So, yeah. Yeah. Okay. So maybe, okay, question is like, can we use our non-mail extractors to try to get something like a, you know, two source for polylog mean entropy, like this equivalent of Chhattavadhyaya Zukarman, okay, in the quantum case, maybe. Okay, in the quantum case, maybe. Then, yeah, can we get non-mill extractors of better mean entropies? And then for the non-mailable quotes case, basically try to get constant rate quotes in a two-split model. Okay, that'll be interesting. And then, yeah, whatever. These are based on these works. Yeah.