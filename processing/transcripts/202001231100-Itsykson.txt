that is almost tied for all constant degree graphs. And this is a joint work with Artur Rizano, Deniel Sebonov and Petrus Mednov. I will just very quickly remind Norsemote Nifomo. We have a graph and we have charges of any vertices. We have variables assigned to edges and for every vertex we consider parity condition that the sum of Parity condition that the sum of h is equals to charge of these vertex. And the hopulus corresponds to linear system model two. And formula usually represents this entire normal form. And the fact that we have about second formula is the following. Second formula is satisfiable if and only if for every connected component, the sum of charges is even. Okay, in this talk I will discuss only resolution process and its subsystems. I will not give a definition, but notation. S of phi is a shortest resolution diffutation, S reg of phi, shortest regular resolution diffutation of formula, and this is shortest three-like resolution futation of the formula. And also, I defined W of phi of minimal possible widths with resolution. Possible widths with resolution. Okay. There are a lot of results about our balance on refutation of Satan formula for particular graphs. For example, first proof complexity paper by Satan, which he proved on super polynomial regular resolution infutation of Satan formula based on the Greed graph. And the type bound was proved later by Denschoff and Brees. By Danje van Bries. And Urkert proved Lauer bound for specific expanders. And Ernst Winterson, by size-width relation method, proved that it holds for all expanders. But in this talk, I'm interesting not for specific graphs, but for large permanent graphs. There is no upper bound for regular reputation of For regular reputation of every 18 formula, it is upper bound by as exponential in width, time polynomial in the number of vertices in the graph. It was proved in the paper by Iknosha Port. And it is constructive, there is algorithm that finds this refutation in this time. And uh there is famous Okutz conjecture that regular resolution polynomial simulates general resolution for 18 polynomials. We consider this a stronger conjecture that the size of resolution of potential state formula is due to the omega of the width of the graph. But in this formula, with the graph you mean three width. With widths of the formula. Resolution widths of the formula. In this formula, this conjecture is false. This counterexample, just a star graph, it is false because this formula has large width, but this is a tree and the proof has linear size. There are several ways how to fix this problem. For example, we may conjecture only for bipartite graphs, by connected prographs. But in this talk, we can see that this can, this is probably And this is probably true for constant degree graphs. Okay, what we have for constant degree graph? There is a recent paper by Nicola, Navit and Jacoba that study different complexity parameters for changing formulas, space, widths, and length. And for constant degree graphed widths, it implies that the width of the future of changing formula up to constant degree. Of taking formula up to a constant factor equals to the three widths of the graph. It holds for constant degree graph. And there are several known series of graphs for which we know this inequality from size-width relation and using this. We know that graphs with large three-widths for large three-widths, this equality For large tributes, this equality holds. Likhnovich and Trasborov proves that this equality for inequality for graphs with bounded cyclicity means that graph can be covered by constant size cycles such that every edge is covered constant number of times. And for example, using certification, it's easy to see that it calls for graphs with double d's. Every edge has parallel code. There is an approach connected to this grid minor theorem, and Nicola will speak about it today later. Grid Minor's theorem says that every graph has a minor twidds T times T, where T is polynomially connected with a three widths. Originally it was proved by Roberts and Samor, but not with polynomial Samework, but not with polynomial function here. But in this form, it is the result of Euler Churroi. This theorem is known for delta 1 over 10. It's the result of previous year. But it is necessary that delta is at most 1 half, because if you consider click and it can be applied for hosted theorem Theorem proved that states Lao Barn for depth degree fregium. And Nicola will say how it gets that it works for bounded degree freedom for every graph, where we have three widths instead of four. For resolution, this method gives the following Following estimation where delta is a constant from with minor theorem. Okay, but we want somehow to improve it. For three-like resolution, there is no lower bound from size with relation for concentrated degree graphs. And there is such upper bound with logarithm factor here. And I don't know whether it was known before whether It was known before whether this upper bound can be achieved or not, but we will show that it can be achieved. Both of these bounds can be achieved, particularly like resolution. Okay, our main result is the following. We prove that a regular resolution of tension-stating formula is at least omega of three-width of the graph divided by logos like number of number of vertices. And uh this theorem uh This theorem, this bound is almost tied up to this logarithmic factor for constant degree graph because we have upper bound two to the all 2 for constant degree graphs, but it holds for all graphs. The plan of the proof, and it may be more interesting than the results itself, is the following. We have two parts. In first part we show that if we have regular resolution of tension of setting form of size s, And there exists a read-once branching program computing satisfiable setting formula based on the same graph of size s to the of the number of vertices. And after it, we prove that size of any red-varcem program computing satisfiable setting formula is at least 2 to the omega of 3 bits. Read once branching program is a model computation model. What's the output for the input and the output? We have value of all variables at each output, true or false. Okay, and the let's speak something more. This result, if we start to quit. If we start with three line refutation, we also get a pre-dance branching program, but here we have the same size. And it can be imagined that if we start from 3 like, then we may not get a reward branch program by decision 3, but it is not true. For the very simple control example, if we consider path with double tags, it is, of course, tree-like refutation of such. It's tree-like refutation of such staging formula is polynomial, but such formula has exponential number of satisfying assignments, and in the decision tree it should correspond to different leaves. Okay, and something about the second point of the plan. There is a previous result, proved by myself and Labinsky, that the advanced approach from complexity of satisfyable city formulas is at most At most this, and at least this, and here we also use Widminer's theorem, and that's why we have this constant. And we were motivated in studying Riba-Pichran previously by OBD proof system, which naturally connects with problem complexity. Now we establish a connection with regular solution. We also give an example of Of fermion of concept-degree graphs with non-trivial tribute, such as the advanced program complexity of such setting formulas, straight-setting formula, matches with the upper bound. And the corollary of this is using this, we get the real is maximum at the the non-upper bound match, and that the regular resolution Should be exactly 2 to the set of 3-widths because we have upper bound and using this lower bound. And this is also an example of a formula where we separate relike and regular resolution on such a formulas. I don't know if it was known before. Okay, this is our result, and now I will go. And now I will go to say you more about the proofs. We start from the first part, we will convert regular refutation of the setting formula to reduce batch program computing stable setting formulas. First of all, I will remind you of the definition of a dwindle-based program. We have a function from Boolean variables and some modules. We will represent it with a rectangle graph with a unique source. And things of the And sinks of the graph are marked with elements of x. Here we have just two elements. Every node is labeled with a variable with total going to one. And given a value, we make calculated the value of the function and it is in the corresponding thing. The branch program. The branch program is read once is if in every path in this graph every variable appears at most once. And in read once branch program we have the following nice property that of course every node of the branch program calculates some function. And in red once the to its form, the function calculated here is the function calculated here by restricted by substitution this variable but by this variable. This video. It is true only for the original answer branching problem. Okay, there is a well-known search problem stated with every unsatisfactory formula. Search phi. If phi unsatisfied formula, we consider the following problem. Given an assignment, find a clause falsified by this assignment. And this is well known that if phi has a regular solution. Phi has a regular resolution rotation of size S, if and only if there exists a Redland Branch program of size S computing, solving this such problem. For searching formula, it is more convenient to consider a slightly different problem when we're searching not for falsified clause, but for but for falsified results of the graph. The vertex of the graph. The vertex, the particle condition is falsified. And it is simple that if we can compute clause, it is falsified, when we also compute vertex, it is falsified by assignment. And we are going to prove that for revised branching program, computing as it is favorable, stating formula. As it is failed, the stating formula is at most computing the search vortex to the logarithmic factor, to the logarithm of number of vertices. Okay, and let us, it's rather interesting question to compare in more detail such vertex and search clause for certain formulas. Of course, these two problems are equivalent for decision trees. But for But for Liberts Branch problem, the situation is quite different. If we do not restrict degrees, then there is an example graph with n triangles with common edge. And for this graph, such vertex is simple, but such clause requires exponential because there are exponential number of clauses, and that can be uniquely falsified. If the griefs of If degree of graph are bound by Logarithmic, there are also, conterexample, complete graph from Logarithmic number of edges or vertices. And it is easy to see that such vertex can be performed in linear time, but this is a regular resolution refutation of stating formula, and it by size with relation can be shown that it is at least super polynomial. Uh but what happens for constant degree graphs, I don't know. Constant degree graphs, I don't know. I conjecture that these two problems should be equivalent. But this conjecture implies stronger inequality that I can prove. And this is because of stratification, because stratification is not very important for such vortex. It will imply the size of the diagram at most wise, but for such clause and for resolution, it We can use this bound, and that's why if these two problems are equivalent, then we will have for regular resolution this bound. Okay, let's discuss the structure of red vast branching program computing satisfiable setting formula. Setting formula has this nice property that if we apply restriction to it, Apply restriction to it, two variable X E, the E and H. It corresponds to deletion of H E from the graph and modification of the endpoints, of charging of endpoints. If zero we do not modify charges, and if instead it's one we modify charges. And there is one interesting case when E is a bridge of the graph. In this case, for Of the graph. In this case, for one value, we will get an unsteady stable formula, but for our value, we have stable formula because two disconnected components. And if we assume that our diagram is, our branch program is minimal, then here we should go to the zero C. Okay, and let's speak about structure of Friedland's branch program that computing uh search vertex problem. Search vertex problem. It's also true that if we have some vertex, and here we compute such vertex for this graph, and here we should compute such vertex for a graph where we delete edge and modify end of. But it is not so trivial what happens if we substitute bridge. And it is non-trivial structure lemma that in fact in minimal diagram computing structure, it should be. Computing search vertex. It should be the following. If we substitute a value to this, in one son, we will have to solve search vertex problem for one component and for others, for other connected components. It is essential that it should be so, but it should be proved by this necessary so. And using this characterization, Using this factorization, we see that the structure of two branch programs computing such vertex and sustainable since Fermah varies similar. The rules if E is not completely the same, how the graphs change graphs and also charging functions. And for bridge case, Breach case, uh it we have slightly different rules. Here we should separately investigate to connect a component and here we uh have both of them. And uh we will transform branching program for search vertex to branching form to computing the disfabled sentient formula by induction from things to to the sources and uh for And for every node of branching problem computing such vertex, we create a node that computes satisfiable setting formula but we will ch we will change a graph in charging function in one vertex to become the formula status fiable. And the base of induction is very similar, it is very simple. And if we go up from the bottom, if E is not a bridge, we also have this vertex, this node and this node, and we may add just this node, like we have here. And the only problem is a bridge case. Here we have to separate. Here we have to separate, and here we should have them simultaneously in one. But it also can be done because by induction hypothesis we have different program computing setting formula on this component, on this component, and w now now we just should make make a conjunction of them. How we may make it? We just copy, for example, one of this diagram. one of this diagram and attach to the one thing the second diagram. But we in this in this case we should copy this because this diagram may be used somewhere else. And this is insert to copy leads to this logarithmic blow-up. Well i it should be proved that the blow-up is logarithmic, but if we Is logarithmic, but if we clever decide what to copy and what not to copy, it can be proved that it is logarithmic. Okay. And the second part of the proof is the proof lower bound on the size of the branch problem, computing satisfiable sensitive formulas. And this proof consists of two parts. First of all, the proof that minimum First of all, we prove that the minimal Redlands branching program computing setting formula is indeed OBDD. It means that all variables in every path have the same order. And after it, we prove lower bound for OBDDs. Okay, let's consider a branching program computing staging formula. Let's consider some node of it. And we know that this node computes some staging formula based on the set of edges E2. E2. And hence we know the number of paths from S to accepting sing. This number of paths is exactly the number of satisfying assignment of changing formula that is computed here. And we also can estimate the number of paths from the source to S. How? Because every such path modifies setting formula in the same way. The resulting setting formula is The resulting setting formula is the formula computing here. Here, all these parts should be a satisfying assignment of a changing formula based on the complement number of on the complement set of ages. Okay, that's why the number of such paths is a processing number of final summit of this staging formula responding to this graph. And the key notice that if we have Notice that if we have not a Redwand-batch program but OBDD, then we have equality here because all paths start with this set of edges. And hence we have that in readman branching program there is at most this accepting path passing through the through the node. And for minimal OBDD there are exactly this number of accepting paths passing through the word. Pass passing through the node. And now we are ready to prove that minimal advanced Berschief program is at least minimal obedi for taking formulas. And let D be a minimal obedient, and for every node we consider AS, the number of accepting paths going through this node. And for every accepting path P we denote by gamma of P this sum of negated values. This sum of negated values. And let P be a set of all accepting paths, a number of it equals to a number of string assignments. And the size of branch program minus one is this sum. We sum for all paths, these numbers, and every this will negate one of the AS will create it to one for every node. And this is at least number of excepting parts. At least number of accepting paths times minimal, MAP at last star bear minimal. Now we consider OBDD that corresponding to the order of these minimal paths. And for OBDD we have A prime and gamma prime numbers. And we know from the previous slide that gamma of P prime is at least gamma prime, or gamma of P star is at least gamma prime of P star. And hence And hence we know this and this is the number of this final sign of tammo times gamma of P prime and since it is at most here and this is exactly the size of dd minus 1. Minus 1 it is because we have also zero sink, there are no accepting paths in fragility. Okay and the Nabos Uh and uh the number s fine assignment of every 13 formula can be calculated by this simple formula. And why? We just fix uh spanning forest, we substitute arbitrary all other ages and then the ages from spanning formula will be determined uniquely. Okay, but using these, if we consider a node on the minimum of BDD, computed setting formula, then OBDD computed setting formula. The number of we make the number of nodes in every level. It is the number of satisfied assignments divided by the number of accepting paths goes through this label. And we will get this formula. It is very interesting. 2 to the number of vertices plus number of connected components in the graph minus number of connected components in graph G1 and G2G1 at the ages that we read before. We were read before our node MG2 ages after. And this value can be represented by the following game. We have our graph and we have copy of vertices without ages. And we get one edge from here, move it here. And every time we compute the value, the sum. Compute the value, the sum of connected components in both of these graphs. And the alpha zero is an initial value. And we have to do it such that the difference between initial value and the minimal value of connected components should be the minimal. And the payout in this game is a difference. And the minimal payout in this game, we call it as a component. This game we call as a component width of the graph. And it is straightforward that complexity of PTT is at most, is up to parallel factor 2 to the component width of the graph. And after it, this is a pure graph characterization. We prove that this is at most half tree width, and at least half tree width, and at most the path is the graph. At most, the path is the graph. It is non-trivial, but it can be proved. And finally, we will have our bound that we have because it is at least 2 to the compo eats. Composed is at least one half of 2 eats. Okay. And the open questions is it possible to improve this bound without logarithmic factors. This is bound without logarithmic factor. Is it possible to prove that he bound for unrestricted resolution? And is it possible to separate such vertex and such clause for concept degree graph? Okay, thank you for your question. 