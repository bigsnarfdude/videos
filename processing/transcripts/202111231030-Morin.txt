Thank you, Pyotr. So, I'm going to talk today about a local version of Vertex Ranking, which some of you may have heard of before. This is joint work with Vita JIT and our shared PhD student, Mir Nush. So, I'm going to talk about vertex colorings today, which are just functions. Functions from the vertices of a graph onto, and I'll say integers, but any sort of totally ordered set, because we'll be talking about colors being greater than or less than other colors. So we need a total order for that to make sense. So a sort of well-known definition is the so-called centered colorings. And in a centered coloring, we require that every Every connected subgraph of your graph has a color that appears only once. So, a unique color inside that connected subgraph. A variant of that is vertex ranking, in which not only should every connected subgraph have a color that appears only once, but actually the maximum color in there should appear only once. So there's a unique maximum in there. Well, instead of looking at whole subgraphs, you could look at paths. So it's the same property, but you only have this restriction on paths. So every path, the largest color in that path, should appear only once. Or you could even talk about an endpoint version of this path problem in which one of two things has to happen. So if you look at any path, its two endpoints have different colors. Its two endpoints have different colors, or if they have the same color, then in between them on that path, there's something of a larger color. And if you think about this for a little while, you'll realize that all of these definitions are the same thing. So these are all equivalent and they're all equal to what's called the tree depth of your graph. Okay, and what about tree depths? Well, tree depth. Well, tree depth is a little bit annoying because it grows even for without bound, even on paths. So an n-vertex path has logarithmic tree depth. A complete binary tree of height h has tree depth about h. And well, planar graphs, they have tree depth upper bounded by, I don't know why that says square root of log n, that should say square root of n. And in general, it's actually known that if you have large tree depth, it's coming from either a long path, a large complete binary tree, or a large tree width subgraph. So it's tree depth is kind of like tree width, but there's also these really low tree width obstacles as well. So what about some local versions of these things? We'll be seeing a talk that includes one of these. Seeing a talk that includes one of these local functions. P-centered coloring is the same sort of property. Every subgraph, connected subgraph, should either have a unique color or it should have a lot of colors, more than peak colors. So if there's a few colors in there, one of them should appear only once. Otherwise, there should be a lot of them. There's a version of that called P linear coloring that has been studied and it's the same thing. And it's the same thing, but it only applies to paths. So every path should have a unique color, or it should use a lot of colors. And the version that I'm interested in and I'm going to talk about today is L vertex ranking. This is a little bit different. So with L vertex ranking, we only consider paths in the graph of length less than or equal to L. And for this talk, length L path has L plus. A length L path has L plus one vertices and L hedges. And so on this, on every such path, there should be a vertex of unique maximum color. So the largest color that appears on this path should appear only at one vertex. So I'll pause now and ask if anybody has a question about this definition. So, every path that's not too long should have a unique maximum color. Okay, so when you have P or L equal to one, all of these things are exactly the same as proper colorings of your graph. So that's fine. But when you fix P, the first two of these things end up getting bounded for really big graph classes. So that's. So that's good. But what about this third one, L vertex ranking? What if I fix L? Is this going to be bounded for some reasonable graph classes? Well, there's some results about this. So chi L is going to denote the minimum number of colors needed to color with to do an L vertex ranking. So there's a result due to carpus nymph. So there's a result due to Karpis, Nyman, and Smorodinski, which says that even for a tree, an N-vertex tree, and even for L equals two, so these are paths with three vertices, so they call this a unique superior coloring, you need log n over log log n colors. Or so you can do log n over log log n, and you, for some trees, you need log n over log log n colors. Over log, log, n colors. Same author, so well, so before that, that's annoying because that's not much better than what you get for tree depth. You save a log-log n factor, but not much. But the same authors show that for planar graphs, for any fixed L, you can color them with order log n colors, which is of course much better than the root n colors that you Colors that you would need for these other tree depth color. But still, there's a question here. So planar graphs you can do with log n colors. Trees require log n over log log n colors. Trees are planar graphs. So the only lower bound is log n over log log n, and the only upper bound is log n. And so the question that The question that prompted this, that I set out to answer, was which of these is the correct answer? Is it log n over log log n? And the answer was somehow on my first slide pictured there. Neither of them is correct. The truth for planar graphs is some planar graphs require log n over log, log, log n colors and every planar graph. And every planar graph can be done with log n over log, log, log n colors. For brevity, I'll say that the answer is three logs for planar graphs. It's two logs for trees. Okay, good. So I'll just mention now that I'm not going to do calculations in this talk. This talk mainly not because they're super difficult, but they work with iterated logs and towers of ease. And I don't find these a natural, they're not common for me to work with. And I just imagine that in a talk, all that we'll do is detract from people's understanding rather than help. So I'll focus on sort of the ideas. And if you care about the details, you can look at the paper. The paper. The only thing for brevity, I'll say log to the c like this in parentheses means the iterated logarithm c times. It's not log x to the power c. Okay, so where do these three logs come from? So we know that trees have a required two logs. The same proof that is used for trees to prove the, well, the lower bound immediately applies. Well, the lower bound immediately applies to outer planar graphs, and the upper bound you can use the same kind of proof that's used for trees to prove that outer planar graphs, two logs is the correct answer. But if you try and do that for two trees, we'll see today, so that's just a little bit up from outer planar graphs, suddenly it jumps. The answer is three locks and And now, if you go to planar three trees, there's no jump. So the tree width is up, but these things are planar. It's still three logs. But if you go to three trees, suddenly the answer is four logs. Okay, and then you get to planar graphs and the answer is three logs. So why is this? Well, given the topic of this workshop, it's maybe not going to be a surprise, but it's because But it's because every planar graph is contained in the strong product of H times P times a clique. And what is H? H is a planar 3 tree or a planar graph of tree width at most 3. That's what Torsten thankfully taught us yesterday. Thank you, Torsten. Okay. Um, okay, so how do you prove this? Well, if you believe these uh these two statements, if you believe that planar three trees can be done with log n over log log n, log, log, log, whatever, three logs, and you believe the product structure theorem, then the proof is actually quite easy, which I'll do now. Um, and that uses a lemma that says if you take the strong product of If you take the strong product of H and R, these are two graphs, and you look at the linear coloring number, you can upper bound that by the linear, so that the L centered, the L vertex ranking number of H times the distance L coloring in R. So the distance L coloring is a coloring in which two vertices will have to. Two vertices will have to receive different colors if their distance is less than or equal to L. And the proof is kind of easy. So for the product, I will use a product coloring. So I'll take an L vertex ranking of the graph H, and that will be the sort of high order comparisons between colors. And if I have to break ties, then I will. Then I will use, I'll take a distance L coloring of R, and now every vertex in the product has an H component and an R component. So I have now this two-part coloring. And so why does this work? Well, if you just look at some path P in the product and you project that up into H, well, that projects into a walk in H or A walk in H, or if you've ignored the ordering, it projects into a connected subgraph in H, and the diameter of that subgraph is at most L. And since you've taken an L vertex ranking of H, that means there is a vertex there that has the highest color and that's unique. Now that's not good enough because back in the product, there's actually that one. There's actually that one vertex in H could correspond to many vertices in the product, but that's okay. Take those vertices and see what they project onto into R. In R, there are two vertices whose distance is at most L. And we've taken a strong, sorry, not a strong calling, a distance R coloring, a distance L coloring of R. So in R, those two things receive different colors. And in fact, all the things which And in fact, all the things which have a maximum value in terms of the coloring in H, they will all get different colors in R. So we'll be able to resolve the ties, even if it's more than a two-way tie here. So there's a unique maximum in this color. Easy. And so how do you use this lemma? Well, we know that this planar graph G is contained in H times. is contained in h times a path times uh times k3 so call p times k3 call that graph r p times k3 is pictured here it's in the the that graph on the the left side of this picture and it's not too hard to convince yourself that if you give me three l plus one colors i can distance l color that thing that's just uh just cycle through the colors as you Just cycle through the colors as you walk down the path, and you'll never see the same color within distance L of itself. Okay, and so now you're done. You use lemma zero and you're good, as long as you can show that this planar three tree H can be colored. Uh can be colored, can be vertex ranked, L vertex ranked with log n over log log log n colors. That's just the only thing left to show. So the talk is going to be over soon now, right? Sounds easy. Actually, that's the hard part. And so the application of the product structure theorem for this is actually the standard argument. It's used. Argument that's used a lot for these coloring problems. The hard part is going to be studying these planar three trees and proving this result. So just before I do that, I'll take this time to advertise simple tree width, which Torsten mentioned, just because it's something I didn't know about before this, although it comes up naturally in many things. And many things. And for this problem, simple tree width is exactly the right parameter to study. If you use tree width, you don't get the correct answer. So, simple tree width, the graph has simple tree width if it has a tree decomposition in which each bag has at most T plus one vertices. That's the same as tree width. But if you look at any subset of T vertices, that subset should appear in a That subset should appear in at most two bags of your tree decomposition. And that's the simple part of it. And if you have such a tree decomposition of your graph, you'll call it a T-simple tree decomposition. And I think why simple tree width maybe isn't well known and it gets ignored is that it's sandwiched between tree width and Tree width and tree width plus one. So it's kind of like in many cases, you only care if the tree width is a constant, in which case, so is the simple tree width and the difference is at most one. But for us, this actually makes a big difference. So what do these simple, so edge maximal, simple tree width graphs look like? Simple one tree is just a A simple one tree is just a path. A simple two tree, that's an edge maximal outer planar graph, triangulated polygon. A simple three tree is a planar three tree. So that's this graph that you get by starting with a triangle and sticking your vertex in the triangular, in that triangular face and connecting it to the three vertices of that face, and then repeatedly doing that, sticking vertices into faces and connecting those vertices into the three vertices of the. Or the three vertices of those spaces. And then there's something known about simple four trees, but I don't claim to understand what that means. So the theorem that we'll end up proving is a bit more than we need for planar graphs. It's that the answer for simple T trees is a T log answer. Okay. And so in our And so, in our case, t equals 3, that's where the three logs come from. So, both upper and lower bounds. And the lower bound already works if you are only interested in two vertex rankings. So that's just paths with two edges and three vertices. And the upper bounds for any fixed LANDACER- Okay, so let's try and sketch the lower bound argument. So, the first thing to observe is for the lower bound, it's enough for us to actually work with not necessarily simple T trees. In fact, we'll work with just T trees, normal T trees, and show that the lower, but there's a stronger lower bound. It's a T plus one. It's a t plus one log answer. And since the simple tree width of h is less than the tree width plus the tree width of h plus one, that's good enough. So we need to show that there are t trees that require log n over log iterated t plus one times. And as a side effect, every two tree is planar. Tree is planar, which means then our lower bound for two trees is log n over triple log n. So that's a planar graph that requires that many colors. So that'll establish the lower bound for planar graphs as well. Okay, so I'll start by reproving this result for trees that appears in the Karpis, Nyman, and Smorodinski paper because it has a Paper because it has a lot of useful, it gives us a good view of what's happening. So, let's start with something really simple, a star that has k plus one leaves. And I'm going to insist that the leaves are colored with the colors one through k. Or if you like, I'm interested in, I mean, one through k are the colors that I'm allowed to use. So, if I do that, then I will find some color. I will find some color that appears at two leaves, right? I only have k colors, but I have k plus one leaves. So some color is going to appear at two of those things. And there is a path between those two things that goes through the root of the star. So that's two equal colors and a path that joins them. So the thing and something in the middle must be larger. That's the sort of requirement. That's the sort of requirement, the definition of this thing. So that tells me that the root of this thing must have color larger than that common color. That common color is at least one, so the color at the root of this star is at least two. Take a whole bunch of copy of those things. So now I have a whole bunch of roots, all of which receive a color which is bigger than or equal to two. And that means they have. And that means that if I put a vertex adjacent to all of those roots, the same argument implies that the color at the root of that thing is bigger than or equal to three. And now you just iterate this until you get a tree of height k whose root is colored with the color bigger than or equal to k. And this gives you a tree that has about gives you a tree that has about k plus one factorial nodes and uses k requires k colors and if you work that out if you call it n k plus one factorial that means it's using log n over log log n colors so the the key thing to that happens here is um there's pressure from the lower levels of this tree to This tree to use a higher color at the next level up. And that starts right away at the bottom of this tree. Now, if I want to do the same thing for trees, here's how I do it. It's the same idea. So, but I get to use induction now because I already know, I mean, I can induct on, assume that I have the right result for. That I have the right result for T minus one trees. So I'll use that. So instead of taking starting at the bottom with the star, which is just a bunch of, in fact, a star is a root vertex adjacent to a bunch of zero trees. So now I can start with the root vertex, which is going to be dominating a bunch of t minus one trees. So I'll take a t minus one tree, and it's going to be the one tree and it's gonna it's gonna be the lower bound construction for for uh for t minus one tree is just big enough to require h colors so requires at least h colors which means it's going to have some color in it which is bigger than or equal to h take a whole bunch of copies of those put a dominating vertex on top and now the color at that dominating vertex so again if you take enough copies some color If you take enough copies, some color gets repeated. The color of that dominating vertex has to be bigger than that common color, and that common color was at least H. So now this thing, this color jumps. And now you can see that this should lead to a better lower bound because the color didn't just increase by one. And so that's what you do. So now at the next level, you will take You will take many copies of this thing that you've just made. So, and now you'll connect them, the roots of those copies, up into up into that graph H prime, which is the T minus one tree that requires at least H colors. So, at the next level, there's going to be a jump from H up to 2H. And repeat this, check that the thing. Repeat this, check that the thing that you made is only a T tree. That's all straightforward. And now carefully choose H to get the bound you want. Clear? Good. Yeah, and eventually it's the same results. Okay, so what are the lessons here? Well, so in these lower bound constructions, So, in these lower bound constructions, I built them in layers starting from the bottom, and it turns out that those happen to be BFS layers of the graphs that I constructed. In fact, not totally obvious, but they're BFS layers, but the top layer or somewhere around the second from the top layer, that layer, that the vertices there, they're kind of a bag in a tree, a natural tree decomposition of this thing. So BFS layers seem to be a relevant thing. And the other thing I mentioned already is that the lower layers, so layers I plus one up to the bottom layer, they create pressure to use a large color at a vertex in lower. In the ith layer. So that means that for our upper bound, we need to take these things into account and deal with them. Now, there's some limitation, which is that the lower bounds were for L equals 2 already. We're trying to prove an upper bound for larger values of L. So that's actually going to mean that. Actually, going to mean that where does the pressure come from on layer I? It doesn't just come from layers I plus one up to the end. It actually starts coming from layer I plus L. So there are paths that begin in layer I that end in layer I plus L, which then that tells me something about the colors that I need to use in layer I. Eye. All right, so a lot of information on this particular slide. I won't panic though. The picture tells it all. So I'm going to use a BFS layering of the graph that I'm trying to color. The top layer, layer zero, will Layer, layer zero, will actually be the vertices that are in a bag of a T-simple tree decomposition of this graph. So that's just a helpful thing to do. So it's not BFS from a single vertex, but it's a BFS from a clique. Okay, good. And I'm going to have to prove something stronger. It's going to be inductive, so I'm going to need a stronger inductive. So, I'm going to need a stronger inductive hypothesis. So, I will let you pre-color the vertices in the root bag. The condition, there'll be some technical condition that says you can pre-color those vertices, but you have to use big colors, sufficiently big colors. And that's carefully quantified, but I'm not, I told you I'm not going to show formulas here. So, those. So those can be pre-assigned. And when I do the coloring, the next L layers below that layer zero, they're not going to receive big colors. In particular, they'll receive colors which are smaller than all of the colors used in that top layer. From layer L plus one onwards, I can start to use the big colors again. But those next layers, they're not going to receive big colors. And why would I want? Big colors. And why would I want to do that? Well, that's just going to help. I mean, what's the intuition? Well, the intuition is that if you have a path that uses one of those vertices in L0, I don't want to have to worry about what happens to it when it goes into those layers L1 to L. It's going to already be the largest largest. Already be the largest color used in that path. And I don't have to worry about paths that go from L0 to LL plus one because those paths are too long. Okay, so just an example. The base case here is when t equals one. This graph is a path. If I look at a tree decomposition of a path, this typical bag has an edge of the path. Bag has an edge of the path in it, the two endpoints of an edge. So, this is what it looks like if I take a BFS tree of a path rooted at the bag and the tree decomposition. Somebody gave me two large colors to put at those two vertices. And now I have to complete the coloring. And actually, for a path, it's kind of easy. There's nothing too difficult here. The only thing that I Here. The only thing that I should do is make sure that in the first few layers, I use only the small colors up until the L plus first layer. Then I can use big colors again. All right, so that was the base case. Now the inductive step. So now I have H, which is a simple T tree for some T bigger. T tree for some t bigger than or equal to two. I have this BFS layering of H, which is given, this pre-coloring of the things in the first layer, which happens to be a bag in the tree decomposition. The colors of those things are big. And then I'll split into two cases depending on how many BFS layers there are. So, one case, which intuitively sounds like it should be easier, is if there's not very many BFS layers. Very many BFS layers. So maybe there's only L plus two BFS layers. Well, okay, sounds like it should be easier. So if it's easier, then let's prove something stronger. And the stronger thing that will prove is everything that I said before, but even more, that layer L plus one, I will even let you pre-assign some lower bounds on the color. Assign some lower bounds on the colors used there. So, of course, they can't just put arbitrarily large lower bounds on the colors to get anything reasonable. You have to quantify this, but there's some global condition on the colors, the lower bounds assigned to that thing that if that's satisfied, then I'll be able to prove this stronger result. Result. And the question you might be wondering is: well, why can you suddenly prove a stronger result? What's special in this regime? Well, here's where you get to use induction on the simple tree width. And the reason you get to do that is this last BFS layer here is the graph induced by that has simple tree width t minus one. So we have a somehow a stronger result that we can. A stronger result that we can use to help with the fact that somebody has put these annoying lower bounds here. Okay, so that I won't, that's all I'm going to say about that. I'm not certainly not going to prove that, but it's there. Okay, and then the second case is when the tree is not so shallow, it has many layers, more than L plus two. So this is what the picture looks like: L0, some layers that should receive small. Some layers that should receive small colors, this LL plus one, and then a bunch of stuff hanging off the bottom there. So if I look at these vertices in layer L plus one, well, if I actually take away the top L plus one layers, I get a bunch of components at the bottom. If I look at one vertex in layer L plus one, it is adjacent to some of those components. So I can think of that. So, I can think of that roughly as the size of the subgraph hanging off that vertex. And actually, that gives me an idea of how much pressure on the color of that vertex could come from that subgraph that's hanging off there. If that vertex is going to need to have a high color, it's because there's some big subgraph hanging off of it, which puts this pressure on it, just like in the lower bound. Just like in the lower bound. So I add those things up and I carefully say what a particular size subgraph means in terms of the lower bound on the color assigned to that vertex. And so now I get some lower bounds on these colors. And if you do this really carefully, And if you do this really carefully, those lower bounds you get on those colors are compatible with the stronger theorem that I just showed you on the previous slide. And so since they're compatible with the stronger theorem I just showed you on the previous slide, that means there is a coloring of those first L plus one or L plus two layers that satisfies all of the conditions, including these lower bound conditions. Now, Now, the colors that were assigned by these lower bound conditions, I mean, these lower bounds, they were chosen based on the sizes of these things hanging off those vertices. So now I throw away those top layers, and I have a bunch. And I have a bunch of maybe this layer L plus one and onwards is disconnected. There's a bunch of things there. In fact, each of the components there looks like, you know, there's a bag in a tree decomposition that's the root layer. And then the rest is a BFS layering. The rest is a BFS layering starting from that bag of the graph that happens to be attached there. The layer, the vertices in that bag, they've been colored already, but they were colored with big colors. I mean, big enough. The sizes of those colors that I used to pre-color those things came from the size of the graph that was attached there. That's where the lower bound came from. And so those lower bound, the colors here are compatible with the With the whole theorem. The whole theorem said you're allowed to pre-color that first layer as long as you use big colors. And I've done that there. So that's the sketch of the proof with no numbers, no calculations, but that's the idea. Okay, so these were the results. You get matching upper and lower bounds for simple T trees. Simple T trees. From there, you get matching upper and lower bounds for T trees as well. For planar graphs and bounded genus graphs, the product structure theorem gives you matching upper and lower bounds. That's the three log answer for those things. You get efficient algorithms that run either in linear time or in log n time. And actually, if And actually, if anytime you have product structure, you get a sublogarithmic upper bound. But now it's log n over some iterated log. And the iterated log, of course, depends on the tree width of H here, the number of times you iterate. So here's an open problem that probably, I mean, that surely has nothing to do with product structure. Sorry. Sorry. For de-degenerate graphs, these are the bounds known for even two-vertex ranking. The answer is somewhere between n to the one-third and the square root of n. That's what you can solve. So thank you for your attention.