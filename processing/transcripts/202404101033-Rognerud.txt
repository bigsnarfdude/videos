Close to algebra. And I should say that, yes, wet will be an algebra. So K will be a C. And for me, an algebra is associated with K of R is one and uh most of the time it is finite. Finally, not enough. Okay. Maybe it's not so important, but most of the time, at least in my mind, it is. And I should also give an example of what I have in mind. I'm not very vigilant of equivalent or more generally passaging of equivalent. passage of equivalent modulation. Or a particular example of this, if you have P finite poset, you can I will also look at the incident such as of my poset. And yes, since I want an example, probably that this is my pro set. This is my first pro set. These are probably the only two examples I have. So, how can we compare algebras? Well, it's a very vast subject, so I should start with the most basic notion of comparison, and of course, it is the notion of isomorphism. So, I will not spend much time on it because it's a very basic notion. I will say that. Basic notion. I will say that two algebras are isomorphic if there exists a K-algebra homomorphism between the two, so with one, so set one to one, which is K-algebra algebra. Okay, and for us, clearly, the two algebras, they are the same. It's not a very important notion, but I should say that if you play with your computer, this is very hard to try to test if two algebras are isomorphic. So this is very hard with the computer. So if the algebra is not finitely of finite dimension, it's not a decidable problem. If it's finite-dimensional, I think it is a disable. I think it is a decided problem, but it is quite hard to. So, what do you mean by hard here? I think it implies the world problem for finitely presented groups. For example, for a finite field, if I have these algebra that can I look at all matrices. Exactly. If if if you have a finite dimensional algebra or a finite field, you can compute everything, but compute everything, but it's probably not a good way of doing it. And it's still very very difficult. Yeah, I don't yeah, I don't really want to speak too much about this, but let me just tell you about a conjecture. The isomorphism on which is still open. You take G and H two P groups and you take K to be F P and you assume that the group P and you assume that the group algebra are isomorphic. So the group algebra of the two subgroups are isomorphic. Does it imply that G is isomorphic? H has a group. So this is called the modular isomorphism problem and for P at equal two in twenty twenty two. Sorry, I don't have the name of it, but I don't have the name of it, but because it was not paper. But the first contra example was only 2022. Yeah, exactly. And the example is not that big. It's only 512 kilometers. And for P is other. So, yes, it's a computing isomorphism using the computer. And uh yes. The next notion I will introduce uh will assume that you are able to compute. Otherwise you cannot um okay. So we will assume that we are able to to decide the trajectory. So what is the next basic notion? The next notion is equivalence between category of models. These are moric equivalence. So we will say that two algebras A and B are more equivalent. If there exists a functor between their category, let's say of height module, which is an equivalent to C and I will denote M is uh A is Morita equivalent to P. So, this is really a good notion because most of the time we are not interested in the algebra itself, but we are more interested by the representation of this algebra. So, this is the derivative notion. And it turns out that these are very easy to characterize. This is a very point and more easy. 58 we know precisely whether this occurs. So two algebras or two rings are beta equivalent if and only if there exists a special module inside the module category of B. So there exists P, or B module module which satisfies some condition but I will just give the condition and then maybe we discuss what I mean. First condition is not difficult. We want P to be a projective module and a finitely generated. So P is finitely generated and projective. The second condition is probably the more difficult. We want P to generalize the module category of P, and I will explain what it means in a moment. And the last condition, we want P to be related to A. So what is the relation? We want the isomo an isomorphism between algebra A And if you have this paper dot, you have an equivalence category between the two. So one on two is called cogenerator. And yes, maybe just what is genu what generates means? What generates mean? So you want that for every module there exists a direct sum of P at subject up to your module. Yes? So you said the first problem was hard, but the second one was easy, but is it three? Uh yeah, I I think the so the the answer is easy, but if you want to compute uh using your computer you need to check isomorphism at the end. Uh so I yeah, this will occur everywhere in the yeah, all the time in the talk. So if you cannot do this, uh you cannot compare uh using the tool like Wikipedia. We assume that we can look I'm still confused. When you say hard, you cannot compute or you cannot. It cannot compute or you cannot compute in no I mean I don't mean it it I don't mean it in a precise sense. If you give your algebra the two algebra if you give your computer the two algebras, it takes a lot of time to do it. So but you can still compute. If you work over a finite field with a finite dimensional algebra. So you have one finite dimensional algebra, let's say a hundred dimensional, another hundred dimensional uh Hundred dimensional uh over a finite field. You look at all the invertible matrices, then you check which of them is, you know, the incomable one. For example. So you can compute, but exponential. There are some clever algorithms using group nerve bases and this kind of stuff, but it's always takes time to compute. So there's no polynomial time algorithm for this? I don't know. I don't think so. But I don't know. Well, I think graph is. Well, I think graph isomorphism is also a subclass of all these, and that is already polynomial. Nobody knows it. So I will not be tied. But yeah, I don't see that. Okay, so this is Monita Swed. Maybe let me just explain how with such a module, yes, why such a module appears and what is the relation between the module category if you have such a The module category, if you have such a module. So if you want to prove this theorem, actually, it's not so difficult. If you assume that you have an equivalence between the module category of A and the module category of B, then you need to construct a special module inside uh B. So you need a special module inside A. Um here you have one, which is a free module, but one Free modules, and this will be one module. And because A satisfies all this property and all these properties are preserved under equivalence, this will be the P. And then the endomorphism of P is very easy to compute because it's the endomorphism of F of A, and we know that an equivalence of category is a fully facile functor. So this is So this is the ontology of A of the system. So this is one side, one direction for the proof. Just send A to some C. And the other direction is more difficult, but not so much. You have this module, you want a photo. Okay? So P, it's a P module on the right. P module on the right, but it's also a module on the left over the endomorphism algebra of P. And the endomorphism algebra is A. So P is an AB binodule. And if you have an A B bimodule, you can do a tons of product with it and you have And you have the tensor product over A with and this is the founder from the first metric category to the second. And with this property, which is exact, if we have the electron with this property, it will be a liquid electron. Yes? So the product actually decides the model that you get the that these uh that this uh equivalence is actually size. Yes, exactly. So is any equivalence of categories uh categories of multiple? Uh I think so, yes. I think so. If in a Baylorian category. Yes, it's for that reason that I put all modules here, because I want an ability particularly. And actually, it's even better because if you start with F and you do this game, then F is actually exomorphic to this terms of protein. If you don't have a unit, but you have like enough identity. You have like enough identity, so certain things are still true, but a little bit more. Exactly. It's a little bit easier. And there is even a version of Freib with many objects and that every equivalent is except, but if they are equivalent, you can find languages even in English. You have to be careful with your end of your end home language. Okay. Yeah, maybe this one is a little bit worse. Yeah, maybe this would ratio f something with that would be helpful. At least if f is right exact, it is so this is Morita's theorem. And this is a very, I think it is a very good theorem because it gives you an easy way to compare. So I just want to give a quick example that we already saw in CPASTOR. Let's say you start with A2, just the field K. So you have the category of K module, which is category of K vector space. And if you want to construct an algebra that is more intellectual, you need to find a module. A module that satisfies all of this. And what you can do is, of course, you can take this module to be K, but it will not be very good, but you can take P, then it will still satisfy the different axiom of a progenerator. And so the category of vector spaces is equivalent to the category of module over. Of module over the endomorphism of k to the endomorphism of k to this matrix ring n. Okay, so we see that commutativity and field, these are not property preserved by paramodic components. And a slight generalization of this: if you take your favorite finite group and you do basic character theory, you know. We know that the group algebra is the product index by the PFC director of the group of some matrix over C. And then you apply Morita's theorem. One you see that this is Morita equivalent to a product of field. And in particular, you see that you cannot reconvert You cannot reconvert the algebra from the modulus of that. For a group algebra, you can only remember the number of convicts it has. That that's uh the drawback, and it's also a good uh sign. You can compare very different strategies using And the bad side, the bad news for us is you can always recover one algebra, at least when you work over finite-dimensional algebra and you look at the module category of finite dimensional modules, then you can only cover one algebra of this. What is this L J plan? So you want to take all the projective in the composable All the projective in the composable each of them only once again. So you ask I not isomorphic to J, then I have this J. This is a cogenerator and homomorphism algebra of P is the unique basic algebra. Is the unique basic algebra having this category. So let's say, let's say if A is finite-dimensional and basic, then this is isomorphic to that. And what does it mean? It means that for basic algebra, Molitas here is the same as isomorphism. So for basic algebra, And basic algebras, for example, uh class algebra, for finite number, modulation, incidence algebra of the coset, multimodation is just the same. So this is why you don't see a lot of Moritas yield when you work with finite dimensional algebra. Where in the first sentence you assume your algebra to be basic. But the fact that you can assume your algebra to be basic is a consequence of your basic. If your algebra is not basic, it is not. If your algebra is not basic, it is not basic, then you can continue with the basic. So this notion is too strict for us. We need something weaker than this. And okay? So let's try to do something weaker. And uh this will be tilting theory. And you'll be the PDD file score. So the history of teaching theory is quite maybe I don't want to spend too many time on it. But yeah, the history is quite long. But yeah, the the history is quite long. The s probably the starting point of T theory is this uh theorem of Kappill which classified the quiver, the pass algebra of finite quiver of finite representation type is of finite representation type if and only if the equivalence d case. So this is a very nice theorem, probably one of the starting points of the theory. And if you read the first proof, at the end of the proof, one consequence is the number, so the corollary of this classification is the number of indecomposable KQ module when it's finite. Only depends on the underlying graph, not the orientation. But it's really a consequence of the result, not part of the proof. And you can ask yourself, well, why? Is it true that when you change the orientation, the module category are Morita equivalent? So, they are not. Let's do an example. Yeah, just a quick example. We can look at these two algebras and we could try to check if they are multi-equivalent or not. Because they are basic, this is the same as isomorphic. And these are not isomorphic as a pair of because they don't even have the same energy. So KK123 multiplied is not mole equivalent to but still they have the same number of indecomposite models. So many people try to to understand this. Uh first there there there has been the notion of reflection functors, Of reflection functors, then the notion of APR tilt, and then Brenner and Butler they realize that there is a more general notion of tilting module, and then Apple, yes, Apple is for part four. So let's tick with Kenner on the so in order to understand this, this uh we ended up with the definition of t. Okay, so definition is one. Okay, so definitely one. And this will be very similar to Morita cogenerator. So I will give the definition and try to explain the idea of the definition. So an A module, T is a T module if it satisfies many. It satisfies many properties. First property, second property, third property. Maybe I start with the easiest one. Well, no, this is the easiest one. So the projective dimension of your module as a right module should be at most one. So if it's a progenerator, a projective dimension is zero, it's okay. Then you want the extension. You want the extension between your module to be zero. So if it's a projective generator, this extension is zero. It's okay. And then you want some kind of generating property. Generating property, which might be a slightly we said at the beginning, you want the module A to have a resolution, core. A res a resolution, co-resolution of this one by direct summit of direct sum of t. So direct summit of finite direct sum of t for t t module. So I will try to unpack I even give the definition. And then explain the consequence of the existence of such value. So, yeah, maybe, in my opinion, the worst part of the definition is this one, but it's very nice because it turns out that we can replace it by something much nicer. So, mark property. Property 3 can be replaced on X theorem by ongat by asking that the number of indecomposable summons of T up to isomorphism is the number of C multiplies up to isomorphism. So it's a much nicer property. Unfortunately, this is a very bad property if you want to generalize. This is why I gave this the original definition. But for this setting, this is equivalent. Just asking as many decomposable summons as if there are simple objects. So example. So example. Example. Of course, code generator is a T. Code generator is a T. So Morita theory is part of TTC. First good news. And the other good news is there are many more. So I will just give probably one or two in this talk, but there are many more. The value is, in general, there are infinitely many more. So there are infinitely many non-isomorphic TT non-base TT. It can be, right? It can be. Sometimes there are finite. There can be only one, or there can be definitely. So there can be only. So there can be only sometimes if your algebra has a finite global dimension, then only the project will satisfy this. So only a progenerator will be infinite. But if your algebra is like a pass algebra of a finite paper, most of the time they are infinitely answerable. Let me just look at my notes. Yes, maybe. Yes, maybe we do an example. Yes, so it's time to do an example, concrete example module. So I will keep my algebra pass algebra with basic level and I will try to do it every s every time. Yes, to do it every s everything. Okay, so this is my algebra. The issue on the right-hand equipment is on this. Okay, and then I need a module and I want a TT module, so it should have as many summons as they are simple. So I will take this one. So we take this one, this one this will be T will be three plus one, two, three plus one. Another, yes, of course I realize the definition, but we need to check that it is actually a T T model. So for condition number three, we will use this one. It has three in the composite person. This is a projective resolution of this. Projective resolution of atmos one. This is three because this is a unit determining algebra. So this is then we need to compute extension. This is projective injective, so it does not appear in the computation of x1 and this modules here and one they compare. Any self-extension none they confirm. Any self-extension on the computer, any extension. And yes, if you want to find some of them, there are five D for this one. Five like a Catano number five. Okay. So, yes. So, yes, we have a tilting module. Now we want to do Moritasio. But it will fail, of course. It's not a pro generator. But let's try to look at how bad it fails. So, if we want to do Moritas CRB with our TT module, the first idea is to look at the endomorphism algebra algebra R of T. So this is uh the endomorphism I check R. And this will be my second key. I can mark it as here. And then the beginning is the same. T is a left module over its endomorphism at Georgia. So you get for T a functor like this. So you have the pump functor. We have the pump functor that goes from the module category of A to the module category B. And you have the adjoint, which is the tons of product of and you would like this to be an equivalence of category. But it will not be an equivalence of category because, for example, T is not projective, so this is not an exact function. So this is not an exact functor and there will also be some other problem that um so there are two categories that are associated with T. So T comes with two categories, one which is good with respect to monitor theory. So this is the So this is the category that I want to denote fact of T for the module generated so these are the modules for which there is a subjective map from direct sum of your x. If you have a progenerator, this is the full module category. If you don't have a progenerator, it is smaller. So let's look at the example So T this module in the Auslander Reichenquiver, this is objective, this is subjective, this is subjective, this is objective, objective, objective. So the module generated by T, you have this, and you have this. And this is your category faculty. Okay? And for a tectonic module, okay, yeah, maybe I don't like this for a moment. So this is the good category. And the bad category is, if it's an equivalence of category, it does not fill any module. So the bad category is the kernel of this motor. So these are the module X such that on A X is zero. And usually And usually we denote it like this T orthogonal. Okay? So this is the kernel. And for a T T module, it turns out that this is also the kernel of the functor. This is the kernel of x1. Okay, so let's go back to the example. What is the kernel of the ohm functor? Well, you look for a module. Well, you look for a module such that there is no map from a module from a direct summary of T. And the only one with no map is T x So this is for free coming with the and the nice uh property is that Property is that these two categories together form something very nice called the torsion. Oh, it should give a name. So this will be T of T for torsion, this will be of T for torsion T of T and V of T torsion air for the rotation. So, what does it mean? Basically, it means this. You have a nice category that is closed under extension on summons, another nice category that is closed under submodule on extension, and every object in the module category, there is a short intact sequence. So every module is almost either in T or in F, or if it's not in F or in T, it's made of two pieces that one is in F, one is in T. And we can check here, this is the only module that is not torsion free of torsion. Torsion free of torsion, and we see that it is an exact sequence with a torsion part of torsion. Okay, so we are almost to Perner-Bengla's theorem. The last part we need is quite amazing when you think about it. If you have a T module, you look at the endomorphism algebra, and it turns out that T is also a T module of an endomorphism. So in particular, it splits the module category of B into one torsion part and one torsion torsion part. The only draw there is only something that we already saw in C. That we already saw in CRS talk actually sees us less module, so we will use k-linear duality to using k-linear duality, we get get a torsion air for the module category of the user algebra. Tension pair. So X T Y T. Let me just give the definition and then we'll compute the example. So the T of T should be the kernel or the tensor product. And why you the camera was the first thing I found So anytime you have a tifting module, uh the you have this bunch of categories. This bunch of categories. One for the starting module category and one for the module category where the endomorphism algebra. So maybe we need to draw the endomorphism algebra of this. And what is the endomorphism algebra? Well, you can see it here. You have, let's say that this is T1, T2, T3. You have T1 is a submodule of T2 with a quotient T. Is a quotient of T3 and there is normalism. So there is a zero condition of this. So the pass algebra will be like this with a zero condition. And the Auslander-Reichen quiver will be like this. Okay, and then Okay, and then if you compute the torsion part and the torsion free part, this I will just delete. So this will be the torsion part, no, the torsion free part and the torsion part. And if you have good eyes, yeah, my brain is not so good, but if you have good eyes, you see that see the same category. This is one half class here. Right. Vernum trash you m. Yes. So under this assumption, you have A and B finite dimensional nature, you have T or T T module, and the first functor on T T is an equivalence of category between the torsion part of T and the torsion part of T. So this is, yes, A modular is P modular. And there is also an equivalence of category given by the X functor between the torsion feed path. This is Voner Butter's theorem. Yeah, much more complicated than Morita's theorem. But if you have a co-generator on this this becomes zero, this becomes a two category, this becomes a model category. Uh this is the classical model equivalent. This is the classical multiple equivalence. If you don't have a progenerator, you can still do something, but only for part of the module category. Some part of the module category, they coincide with other parts of the other module category, and some part they just disappear or dispute. Yes, this is one of the class here. I'm really old school. I will rephrase. Old school, I will rephrase it in a minute, but this old school from a point of view is very useful in computation. I like very much this problem. I'll leave Robin Ford and a small comment. I think this is also where the name tilting comes in. Yeah, exactly. Because you really tilt between the torsion and portion thing. Yes, exactly. So the name tilting. Yes, thank you. Yeah, so very nice. Very nice here. Not so natural from the categorical point of view for the moment, but this is vulnerable. So were we supposed to have some notion of equivalence here? Yes, sorry. So these are equivalence sort of categories. But uh so f for the for the moment I So for the moment, I'm not sure I understand the question, but for the moment, associated to a T T module, we have two equivalences. But not more. We don't have equivalence between abelian categories. Observed equivalence is no longer between the multi-category or between a pair of important full subcategories of technology categories. So, for the moment, yeah, it's not more than that. I will give a better formulation from the theoretical point of view. Yes, I don't know how bad I am with the time. Okay, so let me just skip what I wanted to say. So, there is this notion of APR tilt, which can be used to if you have a quiver which is a tree, and if you have a sink in your In your uh in your quiver, you can build a tilting module such that the endomorphism of the tilting module just reverses all the arrow going into this. So there is a tilting module which is called FTR for outstanding Python which can be used to reverse all our sink or At the sink or the source. So, in particular, any two orientations of the same tree are related by a sequence of tips. And if you remember, I wanted to understand Gabriel's theorem. So, this is one way of understanding Babylon C. So, any two orientation of three are related by a sequence of T2. Okay, this is uh so the next step is to find a good formalization for this kind of equivalence, of pair of equivalence. And probably you already see what is the good generalization, but that it took almost 10 years to. But here you are already deriving from and here you are already deriving from also. Should go to derived category. So this is the last question I want to discuss there are imbalances. And I will adjust the brief from this section and then present a simple. So definition, we will say that A. Definitions, we will say that A and B, two finite common algebra, they are an equivalent if they exist but triangulated equivalence between their bonded so this is uh the definition. So this is the definition and yes this is an example almost an example given this one must be also very careful yes thank you thank you thank you yes otherwise you cannot it was true it was true yeah not a very interesting notion but By now the direct category you mean the direct category of chain complex image is constantly by finite dimensions. Yes, and also finite dimensionalities. If you allow that like a minus around the army, yes. Uh I I think in the definition you should require uh at least like for the definition you should you should not ac require any assumption. Player any assumption. But for finite dimensional energy class, yeah, it's the same as this. Yeah, I'm slightly more comfortable with this law. But you should not if I have only one solution for the definition of this. How you can already there is a theorem uh saying that there is a list of equivalents between A list of equivalents between various triangulated categories and their whole equivalent. So, yes. Having an equivalent between the full derived category is the same as having equivalent between the perfect derived category, which is the same as having equivalent between graphs. Okay, so there is a theorem which is due to Which is due to return in 89, but highly huge influence of Apple. We have the answer for this question when two algebras are derived equivalent. So, A is derived equivalent to the E if and only. This is like Morita's theorem, you want an object. We want an object which is nice, and the endomorphism should be exomorphism to B. So there exists T, an object in the such that many properties I think four properties. Uh first you want B uh A to be isomorphic to the endomorphism of T. Of T. Then you want T to be small, so you want T to be bounded complex of finitely projective V module. Then you want T to have no self-extinction, and finally, we have to have a second. And finally, we want T to have some kind of generating property, which is that the smallest triangulated category containing T and the direct summand of T is the perfect direct T. If you have this, you have a device equivalence. Such an object is called a T complex. 0.2 I correlation is 0. I should not be 0. Thank you. Yes. Yes. Thank you. Yes. Um this is content. T complex. Complex. So, this is the answer for this question of constricting derived equivalence. And of course, if you have a tilting module, well, a tilting module is not a tilting complex, because it's not projective, but it's any projective resolution would be a tilting complex. When T is quasi isomorphic to the T T complex. And when you have a T T module, the functor R Om, it becomes an equivalence of category between the bounded derived category On the derived category, what should first be on the derived category? This one is appenduscular, or not a plus. You really have an equivalence, but not between modules, but this idea like the let me try to show you examples. Examples. So, this is very abstract. I should say that in general, it is very, very hard to prove that two algebras are derived equivalents or they are not derived equivalents. Finding such an object is very hard. In general, I don't know how to say it in English, but like uh yeah, trying to find something very small in a huge quantity of data. Quantity of data. Yeah, exactly. Exactly. So let me show you examples. So, yes, sorry, load type. So, this is the same example as before. The tifting module that we saw before. So, this, this, and this. Oh, it is impossible to do. Sorry, the same file by the on the other tablet, it was okay. Uh but yes, so the the tilted module was this, this, and this. This was the torsion part, and the module category of the other algebra was like this. Um for the derived category, because A is hereditary, the derived category is just a repetitive shape like this. Uh the other algebra The other algebra is not hereditary dimensions of relation, it's propagated too. So there is one complex, indecomposable complex that is not a module that appears in the right paper. And here you see that this kind of weird matching between the torsion part, torsion free part, it becomes really an equivalence at the level of the activity. So this module here. This module here is sent to this new indecomposable object, or this module is sent to a shift of an object. So, this is the first example. More example. So, I say that between two orientations of the same tree, you have an APR tilt. So, it means that the bounded derived category of a tree equivalent does not depend on this orientation. Only dependent on the German course. Yeah, sometimes for free you have a tilting module. So in the theory of quasi editorial algebra, there is the work of Bringel that gives you for free a tilting module. But as I said, most of the time you have infinitely many tilting modules and more infinitely many tilting complexes. So this is the example of the Kronecker fever. So the Aussie. So, the Auslander Reitan quiver or the Kronecker quiver is like this. You have the two tubes and you have the pre-projective part, the pre-injective part. And how do you build a tilting module? You just take two successive elements. This is a tilting module, this is a tilting module. So you can even build a poset of TT module and the poset is like uh infinite total order like this. We have a first copy of n and then a copy of n up here. Of infinitely many T modules. And it's even worse than that because the endomorphism algebra of all this infinity is always the same. It's always the kind of job. But so it does not give you any equivalence. There are the equivalence substance. So, yes. So, next example is to say that Morita equivalence was still strict. Maybe this is not enough strict. You have many, many weird coincidences, existence of derived equivalence between very different algebras that you don't really expect or you don't really explain from a philosophical point of view. From a philosophical point of view. So this next slide. So this is an example that we saw in Sira's talk. When you have pass algebra of a finite quiver of type K, you can build the Auslander algebra. Just take the Auslander Eight and quiver and you put the relation of the Auslander Eighten quiver. This gives you an algebra. You have an algebra, which is very nice, and it turns out that this one is derived equivalent to the algebra of this poset, this grid, 5 by 2 grid. So, this is the theorem of La Cadi, and it works for any pass algebra, an accurate equiver with an even number of vertices. But if you put an odd number of vertices, well, it's not the case. And it's not even there. And it's not even directly equivalent to any tensor product of thinking. And this I don't explain. This is just like this. Yes? The thing on the left is finite type, right? Yes, this is my next example. Okay. Yes, so finite representation type is not preserved by derived requirements. Is that a good thing? Because now I'm tempted to try to understand modules on the right by moving them to the left. By moving them to the left. Yes, but so it's an equivalence between categories. So the indecomposable on each side they coincide, but it's the indecomposable in the derived category. So it's possible that to start with an algebra with only finitely many modules indecomposable, but in fact, even there are infinitely many complexes in the composable Well, you can say the endomorphism is local. I will show you an example, more examples of this in a minute. But I would argue that when we are interested in processing tomorrow, we are actually interested in the right category. Yeah. So that is actually is actually quite interesting to me. So most of the time there are many more. So I I will show you the the example. The example. I wanted to explain it, but maybe we could just look at it for the moment. This poset that we already saw in, I think, your talk, it's a poset of finite representation type. It's even better. All in the composite interlaps. And it's directly equivalent to a poset where you remove this, you put it on the bottom, and so you have like a And so you have like this kind of, I don't know how many. And if your range are large enough, then this is white. So this is always finite, only internal in the module category, but in the derived category it is white. This is right. I don't know what to say. This is this is how it works. Um, so it goes the other way. It's not like you're replacing something wild or something finite. Something wild or something finite, it's that by going to the right category, you may define anything wild. Yes, yes, I think. If you start with something wild, yeah, it's already wild. But maybe, okay, so ten minutes, give me five minutes to just. But I mean, we're not doing that, we are in the derivative to begin with, right? So it depends who you ask. I mean, if we if we do the system model, well we start with the chain complex, then we actually interest them with our model. Then you may forget about the Then you may forget about the fact that this is a homology of something. Yeah, so let me just give a very concrete example of constructing derived equivalences for posets. So this is due to Latka and E in 2006. And maybe I should draw just to explain. The idea is you take two posets, X and Y is a morphism between X and Y, a value. Between x and y, and then you construct two big posets. You construct, you take the different union of x and y, and you construct two partial orders on this. The first one is you put x smaller than y using the morphism f, like this. You want to compare an element in x with an element in y, so you just push it using your morphism and you compare in y. So this is the the first So this is the the first uh process. You put X below. And the other one is you put Y below X. And you want to compare Y with X, you just push X with F and to another posit. And the CRM is the two constructions, they are directly equivalent, and it is very useful in this very particular case. You take any possible. Case, you take any posset, you take y to be just one element, and you don't have any choice for homomorphism, you just send everything to the element. The plus construction is just add a new top element to your poset. The minus construction, just a new bottom element of your posset. So, for example, in this case, this squared, you see that this is the plus constant. you see that this is the plus construction of this poset. So it is derived equivalent to the poset where you take this and you put at the bottom input. And here it's the same. You have plus construction for this poset, so this is the R equivalent minus construction. And yeah, if I have one more minute I can just show you computation Computation, what you can do is the computer if you want to check derived equivalence. So, the idea is it's very hard to check derived equivalence. But it's maybe not so hard to check that two algebras are not derived equivalence. You just need to compare some invariance. So, that's how you do it. So, let's hope it works. So, this is a Sage program, and I want to compare poset of size first. Size 4. I will use a derived invariant, which is called the Coxeter polynomial. So I look at all posets of size 4, connected posets of size 4. I compute for each of them the Coxeter polynomial, which is a derived invariant. And then I look at the equivalence class for this. And clearly, if two posets are derived equivalent, they are in the same equivalent class. Okay? So here we see that there are three equivalence classes. Maybe we look at the Uh maybe we look at the at the the second one because I know so here are the cosets in the second equivalence class and you see that they are all of type A. So we know that they are equivalent because they are orientation of the same tree. So the equivalent Uh so the equivalence class of this uh coxeter polynomial uh is good enough in this case. Uh let's look at the first one. This should be of type T. Yes, so here it's a D4 with an annotation D4, with an annotation D4. This one is not a D4, this one is a D4, but this one it's like this. It's you remove the top element, you put it on the bottom, it's a D4. Put it on the water z4. So, yes, for very small posets, just looking at basic invariants, you can conclude. And of course, if you look at not so small posets, so it's only poset of size 6. So, this is for having the same coxeter polynomial, there are 21 equivalence classes. And then I look at a slightly stronger invariant, which is having costatives. Having cocaine matrices conjugated over Q, F2, and F3, and you see that there are already more equivalence classes appearing. And yeah, I don't think it's an interesting task to check that they are all equivalent, but clearly you can play this document the computer and if you believe hard enough that your two algebras are direct equivalence, maybe you can prove it. Once you be in it, it's not so difficult to cover 15 components. And it just tells us that if we have, if the two outputs, or the two points are in different classes, they can't be derived equipment. Exactly. So you could still have derived equipment. But not. Yes, exactly. So maybe there are there are some classes that should split into several more classes, but at least when your objects are not in the same, they are not different. Yeah, and this is quite easy to check. You see, I put my computer on here. And here, are there any more questions for Bethesda? Yeah, I mean, just because I don't know what the conditions here, but so usually when you walk. So usually when you work on hand user category and bounded, the way you try, at least in GMSP, the way you try to decompose a project is by finding classical generator to generate the category by value shifting and find the codes. How strong it is to say I have an object in my DAR category and I want to break it into a set of management classes. I think if you if you add so if your algebra is finite dimensional and you work in the perfect error category it is complete so you can do it concretely I don't know how easy it is to so as soon as you are with a character and and so that so what is behind here in the composable we just So it is the idea behind that to say that if you have a graphics complex, it's almost a complex of certain number of things like that. Uh well it's a yeah, it's a complex of b it's a bounded complex of project, so Complex or projective, so I guess, yes. So, yeah, I don't know what I can say about the indecomposable. I don't know if there is something we can say. They can be in this case, in this case, the indecomposable is very easy actually. It was already on the board. So the the outside on the right-hand quiver has something like this. One to one. Uh To 1, 2, 2, 3, and the indecomposable is this one. The mu in decomposable is this complex where you map the top of this one to the software of this one. And if you compute the on the morphism, it is this is k. So this but of course it's a the best situation. It's a only measure bar that is uh one t. That is one tip away from energy target. So this is the best situation. And in general, I do decomposability in chain complexes is always an issue. And for example, if you gave Z1 or when we drove ZMOT six, I believe we need splits. But if you look at projective uh prototype that is actually chain complex that's in the components. Chain complex that's in the component. Possibility is not a good notion by jking the component of the derivative. More questions? That was just a comment on the because early in the talk with the Marita theory. There was a question on that whether the Marita theory might transcends to ratings with the final process. The comment is that it it does, but for the expression of a network of weight.