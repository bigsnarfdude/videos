Okay, so the ordering principle says that if we have distinct real numbers A1 through AN. Through a n, then one number must be smaller than all the others. Okay, so as I'll discuss, the Audio principle is a very interesting example in improved complexity. So, a bit of history. So, a bit of history about it. So, question of Berkeley. I conjectured that it's hard hard for resolution. A stall mark, I've refuted this by showing there exists a resolution proof of size O of n cubed based on induction. On induction. But why is it an interesting example? As I'll describe now, it's a tight example for the size-degree size-width trade-offs or resolution. So as Bapuna and Valesi showed, As Bopuna and Veleszi showed, the ordering principle can be tweaked so that there exists And uh there exists a uh there exists a resol resolution proof of size O of n cubed. All resolution proofs have have linear width, right? Have have linear width, sorry, have width omega n and all axioms have constant have constantly. Okay. So if if so if we recall the size degree trade-offs, so in Paliato, Pudlock and Seagal showed that if there exists, so importantly, four zero one variables. If there exists a polynomial calculus proof of size S, then there exists a polynomial calculus proof of degree. O of this the square root of n log s plus k where k is the maximum axiom width. And an analogous, so as shown by Bethelson and Wiggerson, an analogous statement is true for resolution, size, and width. And as was recently shown by Albert and Tobas here, the analogous the same bound holds for some of squares. Yeah, I didn't maybe I misunderstood. It says it's hard for a resolution and there is It's hard for a resolution, and they said it was conjecture. Oh, it was refuted. Yeah, I mean, yes, Commissioner Berkeley first introduced it and conjectured it was partial resolution. Stallmark refuted it, and then it was realized that it gives a tight example for the size-to-size-width trade-off resolution and the size-degree trade-offs for polynomial calculus. Should that be root n? Yeah, n squared variables might be. I was about to get to that. So yeah, I should say that feel free to interrupt me at any point. Interrupt me at any point at the app queries as you've been doing. The resulting exact. Oh, so I have not yet stated my results. I was giving exactly how to why it's an interesting pixel. So the number of variables is n squared. N squared. Yes. So here. So note the number of variables. Yeah, so actually I should describe the axioms corresponding to the negation of the ordering principle. So when I say approve the ordering principle, it's really a refutation of the following axioms which correspond to the negation of the ordering principle. So here we have variables x, i, j. So here we have variables xij, where we want xij to be true if ai is less than aj and false if ai is bigger than aj. And then we have the following axioms. So the ordering axioms are that for all distinct i and j, either xij or xji, and not xij or not xji. So this says either Ai is less than HA or vice versa, but not both. But not both. Transitivity. So we can't have Ai is less than Aj, Aj is less than AK, and AK is less than AI. And then these final axioms which say for every J there exists an i such that Ai is less than Aj. Okay, so as you noticed, so the number of variables here is m equals m squared. So the size-width trade-offs. implies that there exists there exists a resolution proof of width O of the square root of O of the square root of m times the log n cubed is right. The log n cubed is negligible. And k is, you're using k equals n or you're adding extra variables? variables. So that's another good point, which is why for it to be a tight example, the axiom has had to be tweaked. So these axioms here already have with them. So the tweak is that But let's say you only take a subset of the possible j's and of the possible i's and say that some i in this subset is less than a j. Yes. Why is that a problem that it has with n? If when n is square root of n? Because that's your target. Because item two would be trivial otherwise. Oh, okay. Yes, okay. Okay. Yes, as it says, item two is trivial, but it could be tweaked so that it's not trivial. So the ordering principle shows that the size width the size width trades can't be can't be improved. The okay. Okay, and so I should note that Bonnet and Galesi's result can be generalized to polynomial calculus. But a natural question, asked by Mark Viniels here, is what does SOS also need a degree omega of N? Omega of n to prove the ordering principle or is or is a smaller degree sufficient? And so our results is that our argument is sufficient, that there exists an SOS proof of degree O of the square root of n log n. Of the ordering principle. And in the current preprint, so I give a proof sketch that any SOS proof requires super constant degree. super constant degree. However, I believe that this is an artifact of this is an artifact of the proof, which I believe can be avoided. I'm working on that now. I believe it should be omega square root of n. So this, so I believe this upper bound is So I believe this upper bound is essentially tight. So for P C, the degree low bound, linearly the degree low bound is known? Who's this class in the test? Who's the author of the barn for our PC? Actually, I feel off top of my head so that us. Are you? Okay, so uh are there any any questions on on this background before uh before I describe how how how the upper bound works? Uh how the upper bound works. Do does it matter which encoding of clauses you're using? So I think I don't want to say definitely that it doesn't matter, but I think it should be true for most encodings. Uh yes? Uh is lower bound true for so-called index degree? Then we care about And we care about number of indices that appear on the second place. Oh, it's it works only for general degree. I think that I believe it it holds it hold for index degree as well. The lax action there is not a constant width, so the scale? Yeah, the the that's exactly right. That's why Uh that's exactly right. Uh at that point in order to get any symbol it has to be tweaked. They made it commutative so it's uh disjunction if they edit it. They used extension variables as in the original as opposed. I mean maybe that's implicit to picking a subset of things. They actually did extension variables for the prefix sums. Prefix works and it still holds. First of all, the graph or the principle would like to send Marco in the graph. Macbeth and address that okay, so that's so here the oh yeah yeah that's that's good. That is not substitution. So in order to show this upper bound, I actually like to view it as the failure of a lower bound. So what we'll do is we'll construct natural pseudo-expectation values. And then we'll And and then we'll and then we'll show that they fail at degree O of the square root of n log n. Okay, so as a reminder, I've written, so we have a system of polynomial inequalities. Pseudo-expectation values are linear map of polynomials of degree of most d to the real numbers, satisfying the following conditions, which you'd expect any actual expectation over a distribution of solutions to satisfy. And also note that the equations for the ordering principle, we have analogous equations for ordering and transitivity. So I like keeping things in terms of equality. I like keeping things in terms of equalities. So the constraint that at least one Ai is less than Aj, I'll express it as the sum over Xij is one plus Cj squared for an auxiliary variable Zj squared. And that is the effect of saying that this sum has to be at least one. And Zj is not a Boolean. It's yes, as Zj is not. Okay, so how do we construct these pseudo-expectation values? So the idea is And the idea is to take the expected values for a random order. As it's articulate, if p is a polynomial in the xij variables. We'll take the pseudo-expectation value of p to be the expected value over a random ordering of k. So let me give some examples of this. So the pseudo-expectation value of xij would be one-half because Would be one-half because take a random order, half the time AI will be before Aj, and half the time Aj will be before AI. If we look at the suit expectation value of say Xij XKL, so here there's two independent choices. So this gives one-fourth. But so the pseudo-expectation value of Xij Xik. Xik. So what would this be? 1 third? 1 third, because the probability 1 third i is the first among ijk. And student expectation value of xij, xjk would be 1 sixth, because this requires the precise order, Ai is less than aj and aj is less than a k. So now what about the variable zj? That's the idea here is that each zj could be could be positive. Could be positive or negative. So if a zj appears to an odd power, then we just give it expected value zero. So if j is a non-empty subset of n, And p is a polynomial of the x hij variables. Then we take the pseudo expectation value of the product of these eight dj variables times p, to just be zero. And then And then if we have a zj squared, note that zj squared is the sum of rhythm equal to j of xij minus 1. So zj squared is a polynomial of the xij variables, which we already know how to handle. Okay, so I see I'm low on time, so I'll just say that the so how can this thing If you think about it, it turns out the pseudo expectation as E tilde can only fit, only non-negativity of squares can fit. As our goal is going to be to consider the current, we have to go As our goal is going to be to construct H so that the pseudo-expectation value of h squared is less than zero. And it turns out it's sufficient to consider h, which only depend On the number of elements before A1. As a particular, let's take let's define. Let's define wj to be zj squared, which again is the sum over i dot equal to j of xij minus 1. Okay, yeah, let's take 51 minutes. And okay, and then we'll consider H H equals W1, G of W1 for some polynomial G. And now note that the pseudo-expectation value of H squared is the pseudo-expectation, sorry, not W1, Z1. So Z1 squared is W1. But the pseudo-expectation value of H squared is the pseudo-expectation value of W1 times. value of W1 times G of W1 squared. What is G? G is a polynomial which we'll choose. So our goal is to construct G of W1 so that the seed of expectation value The pseudo expectation value w1, g of w1 squared is less than 0. And now observe w1 is the number of elements before a1 minus 1. As it said, so W1 is uniformly distributed on between minus one and minus two. Okay, so one way to pick this polynomial G1 would be to make it non-zero at minus one and zero everywhere else on all the integers in between. Unfortunately, this would require a linear degree, but this is over kil. But this is overkill. All that's actually needed exactly. So it's efficient, and g of minus one has a large has a large magnitude, and g of w1 is bounded. And gw1 is bounded by 1 for all w1 and 0, between 0 and n minus 2. And exactly as I heard whisper, here we can use Chebyshev's polynomials polynomials and degree roughly the square root of m. Roughly the square root of n is sufficient here. Okay, so I should note: this argument only shows that this particular pseudo escutation value fails. In order to show that there's SOS proof, we have to either show that this implies that there's no possible pseudo-expectation value, or it constructs the proof explicitly. That takes a bit more work, but I won't discuss. Work, but which I won't describe here as a run out of time, but it can be done. Maybe one or two quick questions. Trying to kind of in the talk we heard yesterday, what is the polynomial size complexity of this principle? Very interesting. Okay, I I see I I I'd have to I'd like to think about that for a bit. So this, how important are these non-Boolean Z variables? I mean, if you try to do this with the graph case principle instead, or just converting to 3CNF with auxiliary variables, this wouldn't work. So the issue is that either moving The issue is that these are Boolean. I have to double-check it, but I think you could just replace zj squared by a sum of like squares of n auxiliary variables, and you could then take those to be Boolean. Yeah, but I would rather it would probably be the above. I mean, do it increase the number of variables? Ah, so here it would increase the number of variables, but it wouldn't increase the degree for some of the squares. At both of the square, but we're looking at sized degree trade-offs. Any other questions? No, that's kind of security.