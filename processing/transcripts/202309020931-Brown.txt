So um I'm from a good chemistry company and we're a spin-off from uh OneQbit. So we have deep foundations in quantum computing but we aren't very much a chemistry company now. This is our main product is ChemistCloud. So you've got this virtuous cycle. We have this high accuracy, massively parallel calculation, which the the theory behind it. The theory behind it comes from a lot of research in quantum computing. And our biggest calculation is: we did a p-cast molecule with an absolutely massive full configuration interaction space. It's n to the 151 or something. But obviously, there's approximations that we use, and we used a million CPUs to run that kind of machine. But then we can feed that high. But then we can feed that high accuracy calculation into training data sets, and then we can get ML speed up so that's new. But in the future, we're hoping to put some quantum computing in there to get some high accuracy data to make our product better. So that's where I come in. And this is the software that we use to do our research. It's Tancello, it's open source. Tangello, it's open source. And what we noticed when we were using other software packages is it's quite difficult to modify some algorithms. So we try to make things as modular as possible. And we focus on toolboxes. So our big area is you have different toolboxes that you can feed into different algorithms and problem decomposition is used for our main product, but Used for our main product, but there's a few in the package which I can point out later. So that's the main goal of this package, is to facilitate research. It's not to do active experiments. We do have the interfaces to do that, but it's to explore different algorithms really efficiently. It's the goal. So, and of course, with hardware experiments, we also have some measurement. Some measurement protocols and resource estimates. So you can design a successful experiment if that's what you want to do. And this is the outline of what we have. So toolboxes, there's a big list here. Cuban mappings, measurements, algorithms. We do have a few implemented, but that's not our main focus. It's the toolboxes. So you can design it yourself and plug and play. And we do have some fault-tolerant stuff, like quantum signal processing. Stuff like quantum signal processing and linear combination of unitaries as well. And then on the right, the problem decomposition. Right now, quantum computer is very quite noisy, so you have to make your problem quite small. So these are different ways you can embed your larger chemical system that you want to look at on QNET and other methods like that. As I've been harping on here and modulating. As I've been harping on here, modularity is key for us. One does not simply just do VQE. You've got to choose your mapping, your measurement protocol, your embedding. And then whether you use ADAT VQE, Orbital Optimize VQE, Cuba coupled cluster. And then you need to track your computational resources quite a way in order to have a successful hardware experiment. Experiment. So all of this is just an options dictionary that you pass in to BQESolver or any of our other algorithms we have implemented. You can swap it out just with a, for example, changing the back end is as simple as a keyword, and you can even put in your own optimizer if you want, and it'll call that to optimize your entries. You can also run your code on You can also run your code on anything you want. So there's simulators, we have QPU connections to a bunch of different things. And you can also define your own, if you have a special software or special computational technique. You just need to define a couple methods in a class that you take a parent class that you define that has most of the methods. Define that has most of the methods, and you need to define, I think, three different functions. You could, whatever way you want to simulate your system, you can do it easily and put that into BQE solver or whatever algorithm you want to use. We also have translations between all these backends on the right here, so you can go back and forth, and that's both circuits and operators. So you have an operator that So you have an operator defined somewhere else. You can input it or output it to any of those backends. And that's just the simple translate circuit or translate operator on the top right of the screen there. So we have two repositories that are Apache 2 licensed. You can do whatever you want with them. So there's Tank Jello, that's where the So there's Tange Jello, that's where the software is, and then we have a bunch of helpful notebooks you can look at and Tange Jello examples. And you're welcome to contribute anything there. And there's also just some non-refined scripts, so it's not all very nicely laid out. It's just that's for the tank shell examples. And we had a blog, AWS Quantum blog post that. AWS quantum blog post that had a mix of a hardware experiment and a fault tolerant algorithm posted on the AWS quantum blog on MAFIS. So I'm just going to do a couple of examples here of keeping up with the state of the art and how easy that is with Tange L. So there was this GraphQC algorithm, which is another problem decomposition method that was That was maybe about a year ago now. So, one of the people in our group decided that they'd like to implement that. And how this works is you, it's the helium molecule cluster, and you have you determine, I guess, matches. So if they're close, you get, you incorporate a two-body term and a three-body term, and you run those calculations. Calculations, and that can all be done, small calculations on the form computer to get the full energy. So, this is from our toolboxes. They realized that you could use molecular computation to get the integrals, qubit mappings if you wanted to change that out. Onion is what they call basics on the code, and that's available in the tangible examples repository. Here's another simple QMMM. This is with electrostatic embedding. So we don't have this implemented natively, but if you took the integral solver PySCF, which is our interface to PySCF, then you just change a few, I think it was five lines of code to include the part. Lines of code to include the partial charges from your force field. And you could run VQE or ADAP VQE using just that small change and any of the other algorithms there, just by including your new integral solver into when you define second quantized multiple. We don't have any specific like Specific back end to a device because that can get quite expensive. But you can do this quite easily. So there's all the code you need to run on IBM. And those are the only three functions you need to implement in order to run on any device of your choice or simulation method. So he ran this calculation. I think it returns like 0.2 or I think it returns like 0.2 or something, but it took four hours on the device just cloud lengths, but it was that simple. Now I'm going to shift gears a bit to a research topic that I've been working on using I was using Changello, but it's related to density functional theory. So that's how I So this is how I try to argue that we can use T D D F T to calculate potential energy surfaces on future quantum computers. So for those who don't know density functional theory that well, you have a full interacting Hamiltonian here of your chemical system, and you replace it with this fictitious non-interacting system where you have this cone-champ potential here that tells you that. Tells you that is only defined such that the densities match. So there's your, this is your con-chan system. That's the density there. And of course, for the full system, it's a multi-dimensional integral to get your density. So, in standard DFT, you have energy functional and And the external potentials are defined by the functional derivative with respect to this functional. So, in this, for an external potential, it's just a simple integral over your density, and you get, and that just returns your external potential. The Cohn-Sham potential is the same thing. You have your functional derivative with respect to this functional, but this is in general not known. Not known, there are very good approximations, but it's very difficult to generate these. On a quantum computer, generally you use phase estimation in the fault tolerance setting. So that's the circuit there, and you have these time evolutions. So u is e to the i h t, and you just do multiples of it, and then to get accuracy epsilon, you need about Epsilon, you need about one over epsilon time to evolve. So maybe a thousand atomic units if you want it. Chemical accuracy or something. Adiabatic evolution is something that you can use to prepare states in quantum. So you have two different Hamiltonians, A, H A, and H B, and you want to, and you can. And you can define a path between them such that at 0 it's in HA and at 1 or at T it's in system B. And if you go slowly enough, then if you start in an eigenstate of A, you'll end up in an eigenstate of B at the end. And the evolution time you need to successfully complete this process depends on how fast the Hamiltonian. How fast the Hamiltonian changes and the gap between the nearest nearest eigenvalue. So it's a different accuracy compared to before for successfully preparing a state. In DFT, there's something called an adiabatic log integral. So if the densities are known and the comb chain potential, And the Kohn-Shan potential along a path between A and B. And you can get the Hartree exchange correlation energy difference by performing this integral on the right over here. So you don't need to know the functional, you just need to know the potential and the density along a path between A and B. So now you can just reference, you can you can just reference, you can get the energy difference by only referencing the Cohen-Champ potential if you know these densities and the potential of the path. You don't know the ionization energy, but you know the energy difference between those. And that's enough to generate a potential energy surface, because that's all that's basically real. So here's the algorithm and it's laid out in that paper. And it's laid out in that paper at the top there. But you've got the input is going to be some state of system A, some ground state. And you can prepare that using quantum signal processing, adiabatic evolution, or Lanchaus, quantum Lanchaus, if you wanted to. And from that, you need to obtain the one RDM. I've measured that. I've measured that some way, and that's not it. That's a fair number of measurements, but it's not that many. And you obtain your con-chan potential, your initial cone chan potential from that, and the initial cone-chan orbitals. Then you propagate on the quantum computer and you measure the density along the way. That's not thematic measurements, especially for the basis we use. Especially for the basis we use, which is a grid basis. And second quantization, you can do that all in one shot at a time. And first quantization, it's a full frequency dictionary, but you sample each electron independently. So the more electrons you have, that's the connection you look at. And the reason we use that is this algorithm works much better with a grid basis, and also the quantum simulation is more. Quantum simulation is more efficient there because uh the kinetic energy operator is diagonal if you take the fast Fourier or quantum Fourier transform. And then from that you can you have to do some process you have to also you need to get the second derivative of the density to feed back in, but uh from that you can propagate your cone-chan system just by measuring the density of the quantity. Measuring the density of the quantities in there. And out of that, you also get the cone-chain potential from the classical Cross processor. This is the model system that I tested it on. It's frozen core in one dimension, so Lih, so it's hydride. So it's a two-electron system. This is what the potential energy curves look like. Is what the potential energy curves look like for here. And the Hamiltonian that I'm evolving is from 0.25 to 4.5. So you start where correlation is lower and the state preparation should be easier. And then you follow the path along the potential energy curve and you end where the correlation is higher and state preparation would be more difficult. Would be more difficult. So here's where Tangello comes in. I saw this paper, the discrete clock algorithm, that's claimed to be very efficient for time-dependent Hamiltonians, which is what I'm doing. So that's now implemented in Tangelo. And then I sample the density at discrete times. In this case, I did high accuracy or perfect sampling at a few time points. At a few time points, and it was 75, and then I did an interpolation between it. Yes, the second derivative does look bad, but it turns out that the energy accuracy you get at the end is well within chemical accuracy. So there is some forgiveness, I guess, in this algorithm. The integral, I guess, can all these squiggles around the correct and the cancel out or something. Another way you could do it is doing much shorter time steps and lots of noisy measurements, and then you can do smoothing of it. So that's the measured are the blue here, and then the smooth data is the orange. And you can see the accuracy of the second derivative of the density with respect to time versus the exact. And it's a bit better here. So this is probably the better way to go. To go. And across the whole potential energy curve, you can see that the accuracy is within chemical accuracy. And the smooth data or exact data, it works pretty well either way. So you don't need to get perfect accuracy on your density measurements to use this algorithm. Back to Tangelo. Back to Tangello to finish up. Coming up for us, if you're at my Triple E Quantum Week, we have a tutorial so you can play around with Tangelo. And there's also, we also have a talk in the chemistry, chemistry, yes, I guess a chemistry workshop there that we have a talk about non-unitary systems. We just recently. We just recently released Tangier 0.4, and this is what's included. So, we have a symbolic simulator. That was a back-end we implemented. Combinatorial qubit mappings to decrease the number of qubits. And the classical back end is a new feature as of 0.4. So you can easily integrate your own preferred quantum chemistry package just by, once again, I think three functions. I think three functions as a on top of a data class. And we have a notebook on restricted heart tree fog and dbent for battery chemistry. This is kind of our roadmap for what's coming up soon. We're going to try and improve the efficiency of our connection, the algorithms, circuit optimization. Circuit optimizations, QPE is implemented and develop, and we're going to support multi-base devices. So as I said, it's Apache 2.0, and these are some of the people who've contributed to our package. And thanks to all the people who have helped out. We have a newsletter, anything else? I don't want to stay up to date. Thank you.