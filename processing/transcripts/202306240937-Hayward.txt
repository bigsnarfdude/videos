1987 to 1989 at Rutgers, Ryan Hayward. He always tells little stories about me when he introduces me. But I don't have a, couldn't think of a great story. But one really fun thing we did is go see Michael Jordan play with his team, the Chicago Bulls, against the Knicks with Ryan's dad in about 1988, before they won any championships. Before they won any championships, but we could tell they were going to win some championships. And I think the tickets were $10, and Ryan's dad paid for all of us. So without further ado, Ryan Hayward. Thank you very much, Mark. Okay, so unfortunately, Shinyua Chen, who is the author of these slides, couldn't make it today. He's ill, and so chose not to come. So, chose not to come so that we wouldn't get ill. So, thank you for that. So, I'm going to give his slides. He is a graduate student at the University of Alberta. He's working with me, and we're also working with Camilla and Luke this summer. And what we're trying to do is what Chanu is trying to do is get our hex solver to So 10 by 10 hex positions faster. Okay. Okay, so how many of you know the game of hex? Yes. Game of hex. Yes? No? Okay, so it's a two-player board game. The board looks like this. One player has black stones, and that player wants to join the two black sides. So you can see this black edge at the top and bottom. And then the other player has white stones and wants to join the two white sides, so that's the left and the right. And on a turn, you color any empty cell with your color. Or you can put a stone. Or you can put a stone of your color down by an empty cell. So this game is over. Who has won? Black has joined the two black sides. This game is over. Interesting properties. It's impossible for the game to end in a draw. If you fill the board, then one player by that time will have already joined their two sides. On a board with the same number of rows and columns, Columns. So this board has got the same number of rows of columns. One, two, three, four. I believe this is 11 by 11. There exists a winning strategy for the first player. And the proof is existential. So we don't know how to play to win. We just know that there exists a winning strategy for the first player. On the other hand, if you're playing for money, count the rows and columns. Count the rows and columns because if they're different, whoever has to go further, yeah, whoever has to go further is out of luck because the other player can win very easily, even if they go second. And there's a pairing strategy. So, for example, this is the some small size board. One, two, three, four, five, six. This is a seven by six board. And if you just follow this pairing strategy, even if you're second. This pairing strategy, even if you're second, then you're going to win. Black will win because the two sides are closer together. So if the opponent played as a stone, put the stone there, so there's a white stone there. It's an eye, so you find the other eye and you put the black stone there. Just follow that strategy the other way. Okay, so here are the winning first moves for this board. For this board, 8x8 board for black. So black plays first. Every cell that's got a blackstone on it, if you play there first, you have a winning strategy from that move. And these values were found by computer search, and we're interested in doing better. We're interested in. So we're interested in larger size boards. And right now the limit is 10 by 10. So in 10 by 10 we have found some winning first moves, but not all of them. Okay, so what are some of the ideas that we use in our solver, our computer solver, to find these waiting-first moves? One is the idea of some sub-games which can decompose. Some subgames which can decompose the search. These are sub games based on connections. So a virtual connection for a player, say for, in this case, red, suppose we're looking at part of the board and we see this is red and this is red and those two are empty. Well, we can see that red can force this connection between these two stones, even if the other player at some point puts his Player at some point puts a stone down there. So if the opponent puts a stone there, then we can play there. If the opponent puts a stone down that one, we can play there. So if you make a note of that somehow in your solver, it will speed things up. Here is a more complicated virtual connection. So this redstone can be joined to this red side, even if the opponent plays next. Even if the opponent plays next, as long as these cells here are empty. I don't know why that is. Okay, so that's the main thing with sub games. And then the other idea is we're just using a particular search which is based on an idea called proof number search. So the original version is proof number search. We're looking at the depth first version of that. And then we're further modifying the idea of. Further modifying the item by focusing the search in a certain way. So I'll say a few words about those things. So, first of all, what's proof number search? So, we're going to do a search of all possible continuations of the game. There's too many, so we won't complete that search. But imagine you started a search of all possible continuations of the game. So, you're partially along your search, so you have. You're partially along your search. So you have, at some point, you stop. And where you stop your search and complete it at a certain point, you've got a position. We call that a leaf node in your search. You have these leaf nodes. And we want some indication of how long might it take for us to finish solving from this incomplete search. And one measure is this notion of proof number. So if we look at the tree we've got, our search. We look at the tree we've got, our search tree. We look at all the leaf nodes, and we ask ourselves: what's the smallest number of leaf nodes? Where when we solve those leaf nodes, they all turn out to be wins for us. What's the smallest number of those things we would need in order for the whole search to be a win for us? And that's called the proof. And then similarly, you have a disproof number, smallest number of leaf nodes that would all have to be lose. That would all have to be lose for us in order for the original search value to be loose. Have we lost a connection? Some reason I'm just seeing... Oh wait, okay. Sometime the camera will focus on the slides on the one that I see here. It depends uh which one we prepare. That chat GPT is sneaky. That Chat GPT is sneaky. Okay, so let me just give you a quick example if you haven't seen. How many of you have seen proof number search before? Yes. How many of you have not seen it before? Okay, great. Okay, so here is a tree, partially expanded. First number is the proof number, second number is the disc proof number. So here, can we see why is the proof number here 2? Number here, too. So this is player to move, then the opponent moves from here, then the player moves from here. Alright, so what's the smallest number of leaf nodes we need to be true in order for our fruit to win in order for us to win? It looks like it's a two. Why isn't it two? Anybody say why is it two? So we move first. So if we move down to here. So, if we move down to here and say this is a win for us, and this is a win for us, so now we're here. The opponent can go either there or there. The opponent goes there, we go to the win for us. The opponent goes there, we go to the win for us. So, if those two nodes are wins for us, then we're going to win. So, it turns out the smallest number of leaf nodes that need to be true in order for this whole thing to be true is. True, in order for this whole thing to be true, is two, and I'll let you work it out. It's three if you want to go in. Okay, so that's the definition of proof number and disproof number. And there is this interesting property that there's always going to be at least one node in your tree with this property. And here's one such node right here. So, right now we don't. Right here. So, right now we don't know what the value of that is. It's going to be either win for us or loss for us. If it turns out that it's a win for us, then the proof number, after we've discovered this, will go down by one. And if it turns out it's a loss for us, then the disproof number will go down for one. Down by one. So there's always a notion of you're making some progress no matter how that thing turns out. So proof number search is the following thing. Repeatedly, thing. Repeatedly, find the most proving node and expand that one. New tree, find the most proving node and expand that one. That's the idea of research. Okay. So focus depth first proof number search. So proof number search I've told you about So proof number search, I've told you about, if you're running proof number search on a computer, then you'll discover that if you don't think about things too much, you're always jumping around different parts of the tree because your most proving note goes from, say, over here to now another part of your tree over there, and that's not good. So you want to do things mostly in depth-first fashion. So there's a way to implement this thing where you're a way to implement this thing. Yeah, there's a way to implement this thing that's essentially a depth-first version of this, and that's very efficient for computers. So I'll leave that for there. And then lastly, what is focused depth-first proof-number search? We're interested in solving 10 by 10 hacks. So we're going to start with proof number search. And the problem is at the beginning, all these nodes, because our search is so shallow, they really all look the same. We can't tell. The same. We can't tell that any of them is any better than any of them. So, at a certain point, we're essentially doing a breadth-first search at the beginning, and that's just really inefficient. So, what you want to do is you want to gamble and say, well, can we not guess that some of these nodes are more likely to be wins than others, and then just focus our search on those? So, focused depth-first proof number search is a fairly simple heuristic for. Fairly simply heuristic for doom and folks. Okay, so that's essentially what we've done so far previous to this summer. And so for 10 by 10, for example, we solved one position on 10 by 10, but it took a 24 processor machine about a year of CPU time. Corey's shaking his head. That's no good. So, what we want to do is we want to reduce the search time. Is we want to reduce the search time. So that's the project for this time. How can we reduce the search time? Alright, so one of the things we want to do is hopefully we want some better focusing. What are some better ways of figuring out what's going to be a good winning move? And one way is to do what mathematicians would like to do. Mathematicians. Mathematicians, there's a long-standing conjecture that if you play on an N by N board along the short diagonal, the centermost cell, that it's a winning first move. As far as we know, that's true. It's been verified up to 10 by 10. What if we wanted to prove by induction that that's true? Well, if you want to prove by induction, then you want to somehow use the information you gain on a smaller size board to help you on the next larger size board. So, can we use any of the ideas of, say, Use any of the ideas of, say, a winning strategy on 9x9 max to help solve 10 by 10 max. And that's one of the things we're trying to do this summer. So one way to turn a 9x9 board into a 10x10 board into a 9x9 board is you just put down a row of stones, white stones along the white edge and black stones along the black edge. And now whoever wins this 10 by 10 game is going to be whoever wins this 9x9 game on the smaller one. On the smaller level. So that's one of the things that we're trying to do. It's fun to have students because you can say we and you mean them. Isn't that right, Luke and Camilla? All right, so here's an example of the 8x8 board. We've cut a couple of stones down. We know how to play perfectly here. What if we use that search? Here, what if we use that search? Which doesn't totally make sense because at a certain point in time you're going to have these other locations. It's like, well, whoa, whoa, whoa, where'd that come from? And then you have to just do some search. But anyway, this approach looks to be promising. I want to just mention there is a very beautiful proof, strategy, the complete strategy of how to play in this. In the center and win on the 9x9 board, this was found by Jing Yang, very strong Go player. Also got into hex. So he's got a beautiful proof of and strategy for 9x9 hex. And we had a student in our group a few years ago, David Pankratz, wrote a beautiful visualizer. So you can actually click through this strategy, the whole thing, and you can just see it a play. So one of the things we're hoping Play. So, one of the things we're hoping to be able to do is use Jin Yang's 9x9 strategy, embed it somehow on the 10x10 board in a way that looks like it might be, often give us good-wing moves. And that seems to be the case. So we're optimistic that that will work. Okay, I mean, obviously obstacles. Obstacles, sometimes we make mistakes, so you have to be able to recover everything. Another idea that Shen Yu is working on is going, so one idea that I've just described is kind of based on proof by induction. Smaller board sizes will help us with larger board sizes. Another idea is just to fine-tune the focusing method we're using. method we're using. And so the focusing method was first introduced by our PhD student, Phil Henderson, about 10 years ago. And now we're just fine-tuning that. So Shinyu's got some ideas and he's making some good progress in those two. Look, we even have graphs. Awesome. Awesome. Awesome. All right. I'll think I'll end it there. Thank you very much. Well, kind of starts at 10, so we have a minute or two for questions. Does anyone have a question for Professor Hayberg? Or for Shinyuma? Have a question. So, as I understand it, A big approach that's out there for Go and what have you is this neural network. Yeah. Yeah. Train them. Yeah. You don't really know what's going on after a while. I mean, how competitive are your approaches with that approach or did that even have? Okay, so there's kind of an apples and oranges thing going on there because the neural nets are fantastic for players. Fantastic for players. If I just want to be better than all the humans in the world, neural nets are fantastic. But if I actually want to be able to prove to you that I'm making a winning move, there's more work to be done. So this approach here has to do with that. With that end of the spectrum, it's like, well, we need a proof. And when I say a proof, it's like I need you to be able to verify that independently that this is a proof. This is a proof. So these are different techniques. How we would use, so a good way to use the neural nets here would be to use neural nets to guide our search. So our search will be very efficient if we're always guessing at winning move among all possible moves, and then you can just do things in total depth-first fashion, and you never have to backtrack. Tracking, your solver will essentially just be a verifier. Yeah. Yeah, just a comment to that. You can train neural networks for predicting the size of the proof, right? So that's one. But usually the neural networks are trained just to win the games as a strong heuristic, right? But you can change the target that the neural network trains and feed it data that shows. And feed it data that shows how large is the proof for certain positions, and then it can predict how large will be the proof for other positions, and then it can try to go for the cheapest proof. The problem is it takes about a thousand times longer to evaluate the positions of the neural network than with these other things, right? So your proof would have to be a thousand times smaller to make it worse. Can we go through the three display thing? Sure. Okay, so three, if this turns out to be a win for the opponent, what's the smallest number of leaves they could set in order for that to be the case? And let's see. So if we So, if we go down here, we're going to lose. How are we going to lose? As long as at least one of these is a win for this part. So, one here, and there has to be one here, because if we go down here and they're all wins for us, then boom. So one of these, set one of these to be we lose. Now, if we go down here, the opponent gets to pick. They can pick to go down. We go down here, the opponent goes down there. Down there. And now we need both of those for them, and then they're gone. So it's a one plus two. And yeah, there's a simple rule for computing proof numbers of a node from the proof numbers of its children, and there's a minor and max involved, and there's a sum of groups. You're very welcome. Thank you all very much. Okay, so it's coffee now, and I think the talks resume again at 10:30. Enjoy your half-hour break.