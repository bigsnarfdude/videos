So, okay, Maria, go ahead. All right, so thank you for coming. Thank you for making this happen. My pleasure to be here, even if it's not all the way then. And so, what I'm going to do, I'm going to talk about this idea of potential maximum clicks, which has been driving a lot of research recently. It started about 20 years ago and then it's It started about 20 years ago and then it slowly caught speed. And now suddenly there are a lot of theorems coming out of it. So I'm going to try and explain slowly what it is and where it started. And then toward the end I'll talk about the new theorems. But much of it will be things that we're all doing. Alright. So okay, so first of all I want to have some terminology. So if I have a gravitational So if I have a graph G, a field is a bunch of normal majors that I'm going to add. So f subset of 2 to 3 is minus CO horizontal medges is a field for G if when you add this edges, the graphic has to be Where this edges become corners, becomes corn. And then sometimes I write G plus F, sometimes I write GPRAD, and I'll call G plus F the chordal completion. So G plus F is a chordal completion. So the feeling at the edges that we had the coronal completion is the graph that we get at the end. This distinction is non-standard in the literature at the moment, but I find it convenient, so I'm going to use it. How is it? Can you see and hear me and see what I write? All right. I can hear I can hear you. I can't I can read some of it, not all of it. What is that big complicated thing you said at the start? What is that big complicated thing you said at the start? Uh so F is a set of non-edges, product squares which are not edges and uh then you add them together for a log. Okay, I see. Okay, it says two to the V G, doesn't it? Yes, so it's a set of all pairs, but not those other paragraphs. I mean okay, but two to the V G is a set of all subsets. That's what okay, I thought I was reading it wrong. But you can read it just fine. But you can do it just fine. Okay, good work, yes. Okay, and we are okay and then the potential maximum click is a click of some portal completion. P of C if X is a maximal laptop closer to the screen so that we can only see. The screen so that we can only see the half of the yeah, because so what's happening is too far? Yeah, maybe too much on the screen. Oh, yeah. To the right, I mean to the right? No, okay, that's the first question. So we're seeing some of the wood, but So we we're seeing some of the wood but uh not seeing some of the wood. How is it? Is it good? I'm sorry. Yeah. Okay, it's good. This is good. Okay, better? Yeah. Okay. Um I guess we can maybe bring it a little closer and do one board. Try that. Yeah, that could be better actually. Yeah, yeah. Just using one board would be better. Ah, way better. Thank you, Richard. Thank you, Maz. Is the camera kind of jumping to the left? Maybe tilt it up a bit so we can see the top half? Yeah. Right now we can see the bottom half and the wood below it. Oh, it's just uh it's fixed. Is this a maybe there's a technical difficulty? It might be too high. Ah, sorry, okay, very good. All right. You don't think that's the center of the Okay. All right. Much better. Good, extra. Okay, so X is a substitute of verse 10 PMC if it's a maximal click of some minimal fission. And so, what's minimal? Minimal means edge minimal. So the set F, you can't make it smaller for it to be a cord of condition. If you need anything from F, then the graph that you get is not working. If you add any fewer edges, then the graph that you get is not working. And the reason those PMCs are a good thing is because you can connect them to tree. You can connect them to 3D compositions. You take a chordal completion, and then you take a 3D composition of that chordal completion, and there every peg is a maximal pick of the graph you started with, but then it's also a 3D composition of your, sorry, take a minimal coral composition, take a 3 decomposition where every bag is a clip. That's also a 3D composition of the original bag. And the bags are. And the bags are precisely not precisely, but every bag is a PMC. So if you can list all the PMCs, then you can then there's a certain nice 3D composition so that you've listed all its bits. And I'll explain this in more detail, but this is sort of the idea. The reason we are interested in potential maximum blocks is because we can use them to construct nice G computations. See y's uh useful function of and as I said, I'll say this in more detail, but this is this is our interest in thesis. Now Our interest in PMCs. Now, why PMCs? Why not just sunbags of some 3D composition? Well, PMCs, you can sort of grab them. They are subsets of the vertices that have properties that you can think about. It's hard to look at this verticet and say, is this a good bag of a TD composition? It turns out it is easy to look at a vertical set and say, this is a PMCO, this is not a PMC. And that's because of the following theorem. So two facts about PMCs. Actually, maybe let me write it here because I'm going to do proofs. Write the theorem where you can see the theorem and the proof at the same time. So, PMC one if x is x is the PMC. C is only if one for every uv in X that are not adjacent in G, there is some component in which some component that you get by denoting X in which both you you only have neighbors. So this is component C of G X. C on Q big X such that both U and V have numbers. C and then the second rule is X, so there is no full component for X. And what's a full component? Full component just means a component that batches everywhere. Components. We could see of p at x is full threads if every x max has. Alright, how is this? Can you see? Can you hear? Hello? Yes. You guys are good? Alright, so let me show you some of this. I'm not going to do Some of this I'm not going to do if and only if, but I'll do one direction. I'll show you that these conditions are necessary. It's something easy PMC when these conditions must be satisfied if necessary. And okay, so let's do the first one. So here's x, here are components that you get by deleting x, here's a non-edge, and suppose there's no component where they both have neighbors. Well, so whatever. Well, so what are we thinking about? We've added some edges to the graph, and the graph became chordal. And in particular, we make this central part a click. And in particular, we added this edge. It was a non-original graph, but we added it. But I claimed we didn't have to edit it because there's no path between them except in this clip. So deleting this edge will not make a hole. And so I had two. The whole. And so I had G plus F, and one of the edges in F was UV, but actually, I didn't need to add UV. If I didn't add UV, I would still have a quadral completion. So that would still be a quadral completion, so that's not me. Okay, so that's the first step. The second step is there's no full component. Well, so suppose there is a full component. So this is. So this is a component that attaches everywhere in G, right? This is X, this is a component C that attaches everywhere. So now I want to think about G prime. G prime. And I want to look at the products in C that have maximal neighbors in X in G prime. In geography, that we can see have maximal neighbors in X, in G prime, in the graph where the H is error. So here this V has some neighbors in X prime. It's not complete to X prime because remember, sorry, it's not complete to X because X is a maximum click of this column completion. So now we're complete to X prime. So it has some neighbors, but it's not complete to everything. But it's not complete to everything. But everybody in X has a neighbor in C. So let's choose somebody here, somebody who is in X, has a neighbor in this graph, in this component, but not at tracing to V in Jupiter. And this was the component, so there's a path between M. Now, he is not better than V. So He has a non-neighbor among the neighbors. This is all in G prime, okay? This is all the G prime. Now look at him, and the idea is now to take this path. But I'm going to shortcut. Maybe he has more neighbors here, so I'm going to shortcut. I'm going to go like this, complete here, and that's an all in G prime that's supposed to be born. This is not a triangle because this is not adjacent to that, and this has no lips. Alright? So that is second rule. So, okay, that's good news. Questions? That's good news. Questions? That's good news because by the way, I just want to say I'm too far from the screen to see raised hands. So if anybody wants to say something, please shout out. So this is a characterization of PMCs. And what it allows you to do is test if a certain set is a PMC. The reason we like PMCs better than general beds of 3D completions is because Beds of 3D completions because somehow we can graph them, we understand what they are. So, this allows you to tell or to test efficiently if a set is a PMC. The next thing is, second fact about PMCs. Two. If V is a G and X is a MC of G V three, then exactly one of X. X and U and P with the PMC and G. For our application that will be algorithmic, we don't actually care about exactly, we care about it most, because I can always look at this having checked with the PMC or not. What I care is that somehow they don't explode exponentially with PMCs. But in fact, it's exactly one, so let's see that. Okay, so I'm now into, so this is X. These are. So this is x. These are components in the graph with v delete. And now I'm going to f v as an inverse. And so that's when I'm trying to ask, is x a PMC? This is another picture. That's when I'm thinking about whether x plus c is a PMC. So then it's the same components that I had before. And V has neighbors as well. It has neighbors as side. So, this is sort of the same graph, it's all in G, but the difference is here I'm thinking of X as being possibly a PMC, and here I'm thinking of X plus C as being possibly plus C. Okay, so let me first show that they're not both PMCs. Well, if this guy is a PMC, then look at V and the components where it has neighbors. I claim every. I claim every product here in either relation to V or has a neighbor in one of these components. Because remember, we have this rule: every non-H has to be covered, every non-H has a neighbor in some component. So any non-neighbor in V needs to have a neighbor in the component where V attaches. Okay, so everybody here is either adjacent to V or has a neighbor in none of these components. But now you look here and now look at this component. That's a full component for us. That's exactly what we proved to everybody here. That's exactly what you prove that everybody here is either adjacent to V or has an ever in one of those. So that's not both PMCs because in order for every known H to be covered here, you would get that this is a full component there. And you can show exactly why. All right? Questions? Okay, so now I'm going to show you why this is such a wonderful program. And I'm going to do a toy example which I worked on all by myself at home. It came out differently every time. So we'll see how it goes. So there's something called survival sequences. It's not very relevant at the moment. But what it does, it retrospect, as I said at the start, eventually our goal. As I said at the start, eventually our goal is to enumerate all PMCs. We try to enumerate all PMCs. This gives you a start. This will not always succeed, but it gives you a start. So what you do is, pull, construct all this. And what you do is you build your graph one word at a time, and you add the MC's. And you add PMCs, and you build a set of PMCs each time you add a vertices. You update your list of PMCs each time you add a vertices. Should I turn the camera a bit so you can see me? Thank you. Since I'm really very good about not using the second word, can make it more personal. Okay. Yeah. Okay, thank you. Well, no, thank you. Okay, hi, good to see you everybody. All right, so that's what we're going to do. Alright, so that's what we're going to do. So I'm going to build my graph G, there's some graph G, the PMCs of which I'm trying to record. So I'm going to build G one box at a time. So G0 is just the empty graph. And then in general, Gi is... So from GI I'm going to go to Gi plus 1, which really is GI plus number V plus 1 or something. And And I'm going to maintain a list of PMCs that I've constructed so far. So here I have at least xi of PMCs, and then here I'm going to at least xi plus 1 of PMCs that I upload. And the thing we just proved tells us something very useful. It tells us that as I go from GI to J plus 1, so I can go through the PMCs that I've already constructed one by one and see: should I add Vi plus one to them? Should I add Vi plus one to them? Should I not add Vi plus one to them? And for some, the reason is, for some, you get that without adding as a PMC, for some, you get that with adding as a PMC, but it won't double, it will stay the same size. So I construct Xi is list is of GI by EMC Act two. Act two get x i plus one from x i by following reference in xi and to x i plus one either x plus b i plus one or just x. And whichever one is a PMC. And by PMC fact 2, and I'll never be tempted to add both of them, so x equals 1 so far is at most, a size at most edited x. Okay, so that's good news. It's not as good news as one might per second hope because there are some PMCs in GATS 1 that don't come from PMC. GF plus one that don't come from PMCs of GF. I will not see the trace in the PMCs of GM. But the thing is, these are the only ones I need to worry about. All I need to ask myself, when I add a forex, how many new PMCs does it make? And if it's probably many, then it's a week. Another and these new ones without and remember my goal is to hopefully list all PMCs in polynomial time and then and then use it. And then use it for algorithms. So, if I could prove that at every step on addegorx, I don't have too many PMCs, then I would be done. So, let me try to prove that if G is before free, then G has at most that is an accumulation. Yes. Okay, so let's see. So let's see if it works today. So I'm going to go through this surviving sequence, and by what I just explained, all I need to understand is how come I just added the vertex and there's a new PMC and I couldn't see it before I added this vertex. So we're in some step g i plus one where I just added g i plus one and there's a new There's a new EMC Y, which means Y is not in XI. Okay, so what does it do? We need to understand what this PMC looked like. And not what I was doing, but how come I didn't see this PMC before? So there are two cases. Case one, two cases. Case one the i plus one is in y, case two the i plus one is not in line. Okay, so according to my notes do case two first. Okay, so here is why here are some Here are some. So let me. This is a picture in GR without V. And then when I add V, it has neighbors and some components. So how come this was not a PMC before I added this forex, but now it is a PMC? Well, there are two rules you need to size have to be a PMC. Every non-edge is covered and there's no full component. You can check that this will not have a full component. So some non-edge of this. So, some knowledge of this wasn't covered until 8 and 5. So, what does that mean? Okay, so they so somehow these guys, they have neighbors, both have neighbors in this component, but they didn't both have neighbors in any of those. But they didn't both have neighbors in any of those components, so it's generally something like this. And but the graph was before free, so if you think about it for a minute, that means that V is adjacent to them both. Otherwise, you would get it before. So this knowledge suddenly became covered, and it became covered by V. Now, let's look at other people in this PMC. So here's somebody else. This is A, and this is B and this is. This is A and this is B and this is C. Let's look at C. I claim any such C is adjacent to A and adjacent to B. Because suppose this is a non-edge. Well, let's look at the original graph of the graph before I did the Elbas one. This non-edge was covered in some component. I don't know where, but there was some component where this non-edge was covered. These two were either adjacent or this non-edge was also covered in some component. But if they're non-mutations, then I need a component to go between them. This component is not that component because these two didn't have neighbors in one in the same component until n and v. But then what is this? This is a path, and it's long, right? This one we know is at least two edges. This is at least one edge, but it's a before. But then it's a before. So everybody else here is a common neighbor of A and B. Everybody else in B. Everybody else in this PMC is a common neighbor of A and B. So now, okay, so now I claim I can describe all of these PMCs. Look at every pair AB and take all its common neighbors except one. So I need to go through all pairs AB and through all of those, or maybe not the normal, I just did him. So just go through all pairs A A B and take all their common neighbors. And that's some polynomial many sets. And in particular, you'll contain this one. Will contain this one. So y is an opportunity for some norm like AB. So only n squared options. Okay. Now let's do this case. So now V is not anyway. V is not in y. So this is why. Now V is in y straight. So this is y and V is in it. So let me draw it like this, just for convenience. And there are components here. So now if we uh just a second. Just a second. Okay, so right. So, why wasn't this a PMC before? Every non-edge is covered now, every non-edge was covered before, so that means something, one of those was the full components for that before I added it. So there's some component here that attaches everywhere there, but not a tree. So now there are two options. Maybe V has a non-number here. V has a non-member here. So now remember, this is a PMC, so there's some components where they join by path. And then, yes. I have a question. You're excluding P4? Yeah. But P4 free graphs are caudal anyway, aren't they? No, they can have C4s. Oh, yeah, okay. Oh, yeah, sorry, good. Okay, keep going. And it's not a deep theorem, I just it yeah, can show something. I just can show some here, and it's not, and it's not. I'm sure this is not useful for anything, but you can see a lot of the ideas, and they're all easy. That's the only reason I'm joining. All right? Okay, so they're joined in some components like this, and he has a neighbor here, and V doesn't, but that's P4. So that's if V had a non-neighbor here. Now, if V is complete to this, so V is complete. So, not if so, v is complete to this. But then, what happens? Then, this is a component of non-neighbors of v. So, what you do is you look at g n plus 1, delete, n, v plus 1. And then you look at components of that. And then you look at the neighborhoods of these components. And for one of them, for whichever one is this one, you're going to get exactly this set. So you need to entry. So here is the list absolutely possible. Okay, so I've listed n square, at most n squared sets, right? Actually, I've listed n sets. I've listed n sets, and at least one of them is this. So that's again. So that's again at most n options. So then what I'm going to do, I'm going to add to my set x n plus one these n squared options and these n options. And then I'm not trying to construct a set that only contains PMCs and trying to throw in everybody who looks like a PMC. Then I can actually test and I can trim it because you can test informal times something is a PMC. But all I need to do is figure out which of those then to put in, which of those Which of those n to put in, which of those n squared to put in? And xi plus 1 remains all along. At every step, xi plus 1, to go from xi to xi plus 1, at most I'm going to add n squared sets. xi plus 1 is at most xi squared, and so g has x n Thank you. All right, which is what I wanted to prove. I wanted to prove that P4 Fiblap Labs had a few PMCs. All right? Okay, so now I told you everything about PMCs, and I'll find language to tell you why you care. So I have a suggestion. If if somebody were willing to carry the camera side to side, you could use two boards and just move the camera every time you change the board. Would that help? Time you change the board, but that would help. Thank you. Somebody from please willing. We're all two meters apart here, by the way, just in case the police comes. Luke did that yesterday. It was very successful, I thought. He carried the camera off side to side all the way across the room, and he used all the boards, and it worked well. So, if G has polynomial many case, then we can compute in polynomial time weighted alpha. And I'm going to generalize this theorem in every possible direction very soon. But this is sort of a basic result that started this whole area. Started this whole area as far as I understand. Okay, so because and I say it has permanent many PMCs, what I mean is, and you can list it. I probably won't say it quite often, but and Okay, and the reason is, so you take your list of cases dynamic problem. So you take your you take so you have this least five of all PMCs. Have at least five of all PMCs. Now, I claim among them, you contain PMCs that behave nicely with respect to your best independence. And then let's say I is a maximum state. So now I want to say some of this PMC. To say some of these PMCs behave nice with respect to I, what do I mean by that? Well, remember, a PMC means it's maximum takeable cordal completion. Now, I want to think about my favorite cordal completion, namely one that doesn't touch I. A cordal completion is I would if you know No edge of the feeling is incident with the productivity. Right, so not only I want somehow the idea is I want the cordal completion that where I would still see I, but I'm asking for more. I'm asking that you're not even allowed to add the edges that there is one. To add edges that our incident was one person. Okay, so the first fact is that there are eigencorporal conditions. And that's because your family tie, here's the rest of the graph. Just made with a click. And now remember, I wanted it to be a minimal cord of. And now remember I wanted it to be a minimal cordal confusion. Well, so make this minimal. You edit some edges, but delete the ones you don't need. And uh s this at the moment is a split graph, so I can afford to delete some majors and uh and and make recording completion. And make the chord of completion mean. Okay, so there is an I good mean of chord completion, and every maximal thick of this chord of completion is a PMC of my graph. So it is in this least pi. So now we do dynamic problems, right? So G has a G decomposition. Let's call this G. Let's call this G fraction. G has a G composition where every bag is the maximal flick of K prime, every bag B, and B intersect I S not. It's a B is a click of a graph where I So B is a clique of a graph where I is still stable, so B intersect I is ignorant. Now, if I actually give you this 3D composition, you know how to find that, right? You can just do dynamic programming because you know that the intersection of the solution you're looking for with every bag has size at most one. Turns out you don't need to have precisely the bags of the decomposition. It's enough to have the list of kind of all candidates as long as you are guaranteed to contain all the best. To contain all the bands of this decomposition in your head. So let me write this down more precisely. So dynamic programming. Now we can do dynamic programming. So I'm going to compute, I have my pi, and I'm going to compute a function mb. Function M B F C where this is the maximum weight of an independent set I such that I is in B, U in C and I in the set B X and here X is in V X has the most one and C is a component of E. Alright, so certainly you can do this, right? Just start with small components and keep computing and X is a set? X is a set, yes. And X is a size is not set. Right, so I have so the idea is B are the bags of the 3D composition, but I can't tell you which are the correct bags, but I do have some set of sets pi which include which contains all the bags of this 3D composition. Then for every B pi, I'm going to look at a component with B. I'm going to look at the component with B deleted and I'm going to I'm telling you which and you know for every product of B I'm going to look at the the heaviest independent set in here and then I'm going to continue all right so okay so this is sort of the simplest so the only thing I'm saying is that you don't need the 3D composition as long as you have a bigger set of potential bags and all the bags of the correct TD composition And all the bags of the correct 2D composition are in it, you're going to find your independent. That's the only difference between this dynamic programming and the dynamic, the standard thing you do when you have a 2D composition. All right? Okay, so now let's try and make it stronger in all kinds of ways. So, first of all, this one doesn't need to be a one, as long as it's some fixed k. As long as it's some constant. As long as it's some constant, I'm happy. That's again the same deal. Now it's not going to be one work, it's going to be some set, but side at most k, fixed size, so I can try them out. But also here we designed all of this to calculate max weight independent set. But actually you can do better. The right way to think about independent sets in this context is an induced subgraph of G of three with zero. G of 2 with 0. So instead of that, I want to think about induced subgraphs of G of 2 with the most k. I'm going to write something and I'm going to start with that. So this is still, I guess I should have mentioned some names after that. So everything I told you so far is from papers of Bosch and Juliet. And now I'm going to tell you something. And this, as far as I understand, is so that's from Tara Ambushami Marching Me March I will have epicenter. Alejandro Jamachevsky and a very strong theorem. F is an induced subgraph of G of Q and Q and I have some G decomposition of F. Yes, and G decomposition. F of Mitsuki. And now, suppose there is gene composition of G T X such that for every band. For every bag, there is, so there's a 3D composition of G and the 3D composition of X. And for every bag of the 3D composition of X, for each of them, there is a bag of the 3D composition of F so that this bag of G intersects F precisely in that way. For every bit at least. For every bit there is such that B and the size is substantial, pure. So suppose, and suppose I have a list of sets almost there. Suppose I have a list of sets that contains all the bands of these three compositions. such that every the next is equal. Then we can find F in. Let me spend some time explaining this because I said a lot. So here I had a, I was interested in a max weight independent set and I knew I had a GD condition of G where every bag intersects with the dependent set. Interstate with independent sets in most wonderful. Here, instead of being interested in the max weight independent set, I'll be interested in the max weight subgraph of theories at most k. You don't have to say that, but actually you do have to say it. You have a max weight. So here I have a ma in bounded period subgraph of G8 of max weight. Of G8 of max weight. And now I'm telling you that there is a, I promise you that I give you a set of subsets which is analogous to what I had for independent sets, meaning there is a 3D composition of my fixed tree-width subgraph F and a 3D composition of my big graph where I'm searching for F, that somehow they're consistent with each other. For every bag. For every bag of the genie composition of the big graph, the way to intersect the little graph is contained in the back of the gene composition of the little graph. Then you can find the little graph. And I'm not going to explain, but it's exactly the same dynamic programming, except here exercise at MOSC. And instead of looking for an independent set, you look for a subgraph of two bits at MOSK. Maria, you said you could find F. Just one second. What you mean is that you can find the biggest weight thing that is treated at most K? In fact, I could find F, as you know, by guessing sympathism. In fact, what I explained so far is only that I can find the max weight. So far, is only that I can find the max weight set. In fact, I can find it, but let me just fix this: max weight seduced subgraph i three with the cost k. Here it's k. So let me not start with everything at once. Let me give So I would say at once, let me give this tool. I can find F, but it's not sugar. And we can find maximates A three. Okay. When you say polynomial time, are you also assuming that the least pi has polynomially many elements or? Pi and the o. Okay. Yes. Okay. So what that tells you is that if you have a family of graphs with polynomial many uh PMC's uh sorry, that doesn't tell you anything. Sorry, that doesn't tell you anything. Let me back up a little bit. Okay, so this is a dynamic programming. I'm going to strengthen it a little bit more soon. But I think what I'll do, I'll leave this here and I'll use the other board. And then when I'm ready to strengthen this, I'll come here. Try this again. Okay, so. Okay, so this theorem, as it is, it's not very useful yet because there's an assumption here. Suppose there's a gene decomposition of G such that something, something, something. So that's the first point I want to address. This suppose actually, it's not a suppose, it there's another theorem that tells you there is such a trigger function. So, this is not an assumption, this is just given that. And let me tell you this theorem. And we thought it was our theory, but it's not. And we thought it was our theorem, but it's actually a theorem of for mean, Todinka and Bilder. And I'll state it differently from the way they state it. I'll state it the way I understand it. There is a three so again F is a subgraph, induced subgraph of G of Quit plus K and then C s X F is a three width is a three decomposition of F. Of F of grades k then there exist the tree decomposition tree x of g such that one for every band of g intersection with f is one of those the f x plus that. X was that being perceptible F is objective. And then the second factor is a miracle. Every X is a P of C. Alright, so just to get the first step, it's not So, just to get the first step, it's not so complicated because you take a G decomposition of F and then you throw all the other verses of G into each bit. So, just the first step doesn't tell you anything, but not surprising. But the second step is a miracle as part of the bag has a very tight structure. It's actually PMC of the graph of salad. Of the graph of select. Turns out it's actually not such a miracle because what you do is you do the first thing that I said: you take a GD composition of f and then you throw the rest of the verts of g into every bag, and then you make that lexigraphically minimal in terms of the sizes of the bags, and then you get this. But I regard it as minimum. Okay, so now your statement one: should it be that every bag of the big Q composition? Bag of the big G composition index XF in the subset of the bag of the small one? Sorry, I misread it. That's what it says. Okay, sure. That's what we say. Okay, that's fine. I think their theorem actually says exactly because they also tweak the 3D composition of F, but it doesn't matter. But the reason it becomes a subset is because you can split it, but then you could also split it in the 3D composition of F. But it doesn't matter. Okay, so now we have this. Now let's go back and appreciate how this theorem is. So there is a 3D composition of G, size of this and this is that. So now we know which 3D composition we're going to hope for. It's the 3D composition that I just described for you, where every bag is a PMC. PMC. So position of G such that for every B, this happens somewhere. So now suppose we're given a least pi so that every B is in pi, then we can compute max weight and use sub rough of two is the most key. Sub induce subgraph of two is the most key. Well, but now this is something we've been talking about all along, right? If I'm in a family with polynomial in many PMCs, then I can get such a least point. So it all sort of ties back together. It's back to searching for PMCs. If they're polynomial in many PMCs, then I can solve this much more general problem. I can find a max weight subgraph of two at most scale. So there may be an segments then so this is good. So, this is good. So, now I'm going to abandon the 3D composition. I'm going to go back to PFCs. What should so far? So, this is somehow this quality, it's very wasteful. I'm asking to have polynomial many PMCs, but all I need is a polynomial size set, set of subsets that contains bags of this uh special T decomposition image. Special TD composition engineers. That's special TD composition entities. So maybe we shouldn't be so greedy, we shouldn't try and list all PMCs. Maybe it's enough to only list some important PMCs. So at the end of the day, not need to. To list all these enough to list those that are in our Table T computer, and this idea was first. And this idea was first proposed by Lokstanel, Snatcher, and Millinger. And that allowed them to calculate max weight stable set of defaults. So, what they did was, if you think about it, P5 graphs had exponentially many PMCs, but they were able to restrict their attention to a smaller subset, only a polynomial set subset, enough so they could do. Enough so they could do the dynamic programming I just described, and then they could find this polynomial subset of polynomial set of subsets that contains all the important PMCs, and then it would solve this problem. And then, okay, and then you can do it again, I mean not do it again, you can do it much harder and get P6 free. And that's, I'm sorry, I don't remember who did it, but it was sometime later in a bigger group. It was sometime later in a bigger group of people. But then it gets harder. And the reason it gets harder is because there are extra many PMCs and you don't know what to do with them and all these tricks don't work anymore. Okay, well then it turns out, so let me give you an example. Here's a graph. You take two clicks of size n over 2 and And then you take a match in between them. So this has exponentially many PMCs because you can take, so what do you do? You take any subset of this and then it's complement here and you take one more vertex, one more vertex, one fewer vertex. Yeah, one more vertex. You take one One more vertex. You take one more vertex, and that's a PMC, or something along that sort of thing. And you know, you can choose any subset here, and they're exponentially many. Okay, so and you know, this is a very modest graph, it doesn't contain all kinds of things. But the thing is, it's not, remember if we are sort of thinking, let's go back to looking for max weight independent set. For max weight independent set and thinking about chordal completions that dot times the max weight independent set. Well, there aren't very many of those because what two independent sets here look like in general, an independent set is it works like this and it works like that. And now add all the edges that are not instant with this and not instant with that. And that's a chord of completion. And they're only n squared of them, right? So somehow they're only n squared called completion and they're all very simple. Coral completions, and they're all very simple. So, definitely looking for all PMCs as an overflow. We should try and grab those very simple coral completions instead of trying to list all PMCs. So that's our newest result. And in order to do that, we start thinking about something called, we start thinking about something called PMC containers. So given So given F in V of G and X in V of G, C is an F safe container for X, if two things happen first of all, it's a key. First of all, it's an x is contending C. And second of all, you don't add any verses from f. x intercept f equals symptoms. You can make this a little more general, but let's stay with this level of general. So a container for x is a superset of x, but you didn't spill into f anymore the next. Spill into F anymore than X used. So then it turns out that in order to do all of this, all this dynamic programming, you don't need to have PMCs exactly. It's enough to have PMC containers. So let me fix this theorem one more time. So F is a new sub of G of G, maximum weight, T And here, in addition, edge, it X is lexographically maximum on the vertices, and then we're looking for a next maximum. And then you have a 3D composition of F with K and there is a 3D, we already know there is a 3D composition of G with some mass properties with respect to the 3D composition of F. To the 2D composition of F. And now, here, suppose we're given a set pi of subsets of G, of subsets of verticals of G, so that every B in X has an F six container. So I don't need to include the bags exactly. It's enough for every bag to include a container that doesn't spill into a. That doesn't spill into F anymore than XB. Then, same thing. We can find the max set dependencies. In fact, here we find exactly F. So then the crawler is if there are polynomially many XAFE PMC containers. Then we can find max weight induced subgraph of Jews at Moscow. All right, so and again, let me not explain this to you any further. But the point is now we're not hunting for PFPMCs anymore, we're hunting for supersets of PMCs. Set of PMCs that would remain F-safe and which they're polynomial. So, for example, in this picture, so for example, in this picture, what are the containers? So, for every A and B, I'll take V of G delete AB. AB and then maybe for every A take V of G and also don't take all V of G. And I claim every PMC is contained in this or in that. Okay, so it turns out you can generalize it. And what we were able to do in these containers is program. Is prove the following. So I want to think about the class of graphs, right? So here we were thinking about P53 and P63. I want to think about graphs that have no whole lengths six and no this. This and no. So, this is carefully crafted to contain Lochstan Petrole results. So, then there's so and that's a theorem of again Tara March me. Not true. Me, not true. And find x rate a graph of relative most k in the graph. So that means what? That means you can find this even includes, like I said, P5 graphs, includes all graphs with no whole of length, piece five. And so you can find, as I already explained, max weight stable set, but there's another sort of natural problem you can. But there's another sort of natural problem you can solve in this framework. Smallest set, so minimum weight set that hits all cycles, minimum cycle transfers. So what does that mean? That's like finding a max weight 3, right? Minimum weight cycle transfers are the same as max weight 3. So the same as max weight induced subgraph of 3 is 1. So then this also solves that. Probably next. And the reason you could do that, the reason you could solve this problem is because there are many containers for PMCs. So this is good. Never going to say this again. Never come to say this again. Every scene exists party in your view, nothing which you're fine. I have size something like n degree 88, maybe. I'm not sure if it's 88 or 60, say 100 and f such that for every group that we can use. S G with G with A every bag of an F consistent that should be funded the decomposition of G has a container as a As an container. What does this mean? For every new sigma of t is at most k, and then I look at the 3D composition of G that I get from a 3D composition of F such that every bag is a P of C of G. So that's what I mean by consistent. And then, so there's a set of. So there's a set of polynomial size, and every bag of this F consistent 3D composition of G has a safe container in pi, F safe container in pi. There's a superset of this bag in pi that doesn't spill into F. And two, same one, and as we only explained in the broad strokes in two Aria, the exponent there should depend on K. What's the exponent? There should depend on k. What's the exponent of the v of g in the size of pi? So there should be like 100k or something like that. There's all of k there. I think it's all of k. Yeah, thanks. Anything else? Okay, so let me let me stop talking about this, and now I have uh five more minutes. And now I have five more minutes. I just want to say one more thing briefly. So, even though I started by saying PMCs are easy and we have an if and only if characterization of which sets are PMCs, there's something that's even more natural from the point of view of graph theory and it's closely related to PMCs, and that's minimal separatence. So S. So this is something clearly new, right? You don't need to have followed anything else to follow it. S of VG is a minimal. If these two components of GDF S are full or S. At full means everybody attaches. So this is S, at least two components, maybe the more real components, but at least two that attach everywhere in S. And it turns out that there's a connection between PMCs and minimal separators, because if you take a PMC, Because if you take a PMC, in fact, if X is a PMC and C is a component of the bit X, then the adhesion of C, the attachments of C in X, the X, this is C, these are people in X that attach in C, this is the minimal separator. Then N of C. C separator G. So obviously C is one full component for this set, but it turns out there's another full component. Turns out there's a component, it's not hard to see, but there's a component that contains all of this, and that's other full component. Okay, so there's some connection between menial separators and PMCs, and it's a theorem. And it's a theorem, right? So remember, our goal is always to list all minimal separators, to list all PMCs. In fact, it's enough to list all minimal separators. If given a set sigma, A set sigma of subsets every name separator of G and sigma can compute in time along. Oh no, you see sigma sets phi all g and phi, the size of phi is polynomial in real g. All right, so knowing we are. All right, so knowing mineral separators is as good as knowing PMCs. And now you can PMCs. You can say, well, it's kind of a waste. I don't need all minimal separators probably. It's probably enough to just know those that appear as fashions of PMCs. And there's a And there's a conjecture that it's enough to just know those, but we don't know that yet. This is the only theorem that we have. But then it's an actual question to ask which graph classes have polynomial minimal separators. C that exists for each graph classes C that exists a constant such that every G in C has it most B of G to C you know set up. And you can construct all kinds of necessary conditions. For example, if you have a hole and you have a bunch of things that look like this, a bunch of edges with nested attachments. Any edges. Order an edges. With nested attachments like that. That has exponentially many. That has exponentially many minimal separators because, for any choice of the vertex from here, you know, the vertex from each of the stages, you get the minimal separator. And you can make this just message that you can have one neighbor, you just have two neighbors. Okay, so this has neighbors. And then there was a conjecture that tried to characterize classes with polynomial many separators by forbidden mid-due separators. The Barbados conjecture. So I guess it's I'm not sure. I think it's me and Dr. Meon and Christina Bushkovich and And I think maybe it's just us, maybe somebody else, that if G has no reason, no theta, no pyramid and no. And uh no, what we called turtle will turtle a thing like that then pollen when separate and about a year ago now we proved this so three of us together with Stefan Thomas proved this for even Holfigraphs. And just recently, with Tara Abashami and Schmuilde Beck, we actually proved this conjecture. And now that you're true, obviously there is a much worse exponent C and one last thing I'm going to say. I know I'm over time, but I just want to say. I know I'm over time, but I just want to say one last thing. So, there is a stronger conjecture you can make, and this is if an only in the sense that if you draw any of the assumptions, you get exponentially many minimal subgraphs. This is a minimal set of induced subgraphs you need to exclude. But tended to be used subgraphs. But you can make the concerns even more economically. So, is it all option? Question as a conjecture. G has very many minimal printers not contain. Contain K creatures. I'll tell you what a K creature is, and then I'll stop for something. What a K creature is imagining what's going to scary. It's a maximum of size K. And then there's a connected subgraph here containing those guys. I'm not saying it correctly at the minute. Yeah, okay, it doesn't make sense. There's a connected subgraph here containing attachments of all of them, and the connected subgraph here containing attachments of them. Here, containing the actions of all those. And there are no edges, you know, the only edges from this part to that part are the edges of the match. So, obviously, this has, you know, if case B, this has exponentially many separators because you can take any of A and B and a subset of A and a complementary subset of the B's, and that's the minimal separators. But is it true that if you have exponentially many separators, then you have a cake. Then you have a k click. That we don't know how to prove it. All right, thank you very much. I'll stop here. Okay, thank you. My attempt at clapping again, I'm sorry. So, any questions? No, okay. Thank you very much. Should we tap the time, ask one? Yeah, go ahead. Maria, hello. Yes, hi. The last conjecture, is it different of the CRM in the sense that it would be a kind of if and only if? Or is it just an improvement on on the CRMs? It would be if and only if because uh Because why? Because this really has exponential many separately. You just take so what am I trying? At times I can convince myself that this is definitely much better, but sometimes I can. So, for example, if you just take one prism or one pyramid, that does not have expansion many separate. It's just you can construct. Just you can construct something that contains prisms of pyramids with extension many separates. But just this graph does not have expansionary temperatures. But this one does. So that's a sense in which it's better. But if you have a creature, you have one of the three path configurations or a turtle. Any other questions? Okay, so again, thank you very much. Thank you. So there's now a break. Nicolai will start at 20 to the hour, 20 minutes before the hour. Is that right?