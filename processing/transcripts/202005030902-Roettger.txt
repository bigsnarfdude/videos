Wow, they're gonna be taller than me soon. Welcome to the second day today of the talks. Today, we are going to start with Eric Rotger's talk on some primality tests constructed from a cubic extension of the locus functions. Please welcome Eric. Thank you. I just want to start off with, well, thanking the organizers. This has become one of the things that I've been doing. This has become one of my favorite conferences to be invited to, even though this is a strange year. I'm still really happy to be doing this. And it's a really nice community to be a part of, and I'm really happy to be a part of it. So thank you, the organizers, and thank you to Burrs. And I see the same community at other conferences too, and I really like it. Okay, I wanted to show two backgrounds I wanted to do for my thing. And I'll say why I rejected the first. And then I thought it was too busy, but I thought it was funny. I thought maybe having a kid dancing for a seven-second loop might get annoying. I don't know if you can see that. Oh, yeah, there we go. But then instead, I thought this calm background might be the nice one to go with. And you might recognize it. It's an image of a beach that Hugh and I have just walked along. Just walked along. Maybe it's his own. And you might say to yourself, but there's only one set of footprints. And it says, because he was carrying me. Just like this talk. All right, let me share this screen here. Make it big. Does everybody see that? Yeah. Okay, good. Thanks, Renata. Okay, so I recently Hugh invited me to work on this paper. He had an idea, as he often does, and I think it was a good one. I lazily stole the title of the paper, and I said, some primality tests constructed on a cubic extension Luka functions. Okay, I'd like to say there's a slight lie here. There's a slight lie here. I'm only going to mention one test so that you know I focus on just a sufficiency test. There is a test in the paper that does sufficiency and necessity, but I don't do both. Okay. Oh, can I also start with a quick Professor Guy story? That's okay. Mine's very short. Mine's very short. I think Renaud might have met this talk. Rena, do you remember that? Well, this is a funny statement. Slightly over 10 years ago, we were at a talk of Professor Guise, and he mentioned the new result he had. And then he looked into it and he saw that someone beat him to the punch. Do you remember who beat him to the punch? To the punchline? Professor Guy. He had already figured out this result in the 70s. When he looked into it, it was himself. And I thought, it was hilarious. Anyways, That was hilarious. Anyways, imagine having done so much that you can discover something and not realize initially that it's you who discovered it. That's not my life. Okay. I'm going to mention the Luka functions. You know them, and I'm going to say a few properties. I'm going to mention a generalization. Certain people here are going to be very familiar with them, especially Renata, because these are the exact same generalization that was in my PhD thesis that you were on the committee. That you are on the committee. So you've read this fully. But, anyways, here's the Lukov functions. Here's a Benin's formula for them with the alpha and beta zeros of this quadratic. We make these integers p and q relative prime Lukov functions. All right, you know those. I'm not going to dwell on them. There's addition formulas for Lukov functions. There's also multiplication formulas and other things. I mention these only because I want to say if you have a generalization, you'd expect your generalization to have like thing. Generalization to have like things. There's a law of apparition for the Luka functions for the U of N here. So it's epsilon's Legendre symbol, and you know that if R sum prime does not divide 2Q, then it divides this term of the Luka function. All right, there's primality tests based on these. Okay, so I want to talk about a generalization of these primality tests, but Luca developed primality tests for these numbers and. These numbers, n. You can see n had this form was plus or minus one, could easily be factored. In particular, it often was n plus or minus one was a large power of p. So you do a yeah, p plus or minus one v n. Luca restrict himself to primes two, three, and five. And then the most famous example, I didn't get into details at all, but I think everybody here is aware. The most famous angles would be the Luka-Lamer test for a private LD. This be the Luka-Lamer test or probably all even Versen numbers, right? So, what we're going to talk about today is an analog of this up to here: an analog of the Luka functions, and then how we make an analog of these numbers, and then also have some sort of generalized Luka sequence that does something like this. Okay, historical motivation. Luka wanted to do this, he stated that this is a trans. To do this, he stated it. This is a translation. He believed higher-order recurrences would develop similar tests. He didn't come up with any, like, he died young. So, you know, he wanted it. It's a good enough reason. So be motivated the heck out of this talk. All right. All right. He suggests a function that would work. This is one part of it, but you'd expect there to be two of them. So he had. Of them. So he had maybe half the idea here, but he didn't have its counterpart you'd used. But we do, in fact, use this something. The notation is a bit strange, but anyways, we do something akin to this. You know, I just realized, fair warning, I only really wanted 20 minutes for my talk, and I prepared a talk that I think I could do in about 20 minutes. And I have a habit of going maybe too quick. So if anybody wants to stop and say anything. Stop and say anything, no worries. We have the time. All right, this is one more quote. Yeah, theory of recurrent sequences is an exhaustible mind which contains all the properties of numbers. Well, maybe not. But anyway, maybe I cite hyperbole, but again, this is Luka's quote here translated. Okay. So I hinted at one of these already. Luka had one of the two functions you want to generalize, but if you're not. One of the two functions you want to generalize, but if you're going to have a full generalization, you'd expect these functions to come in a pair, just like the Lukov ones did. Both functions satisfy a linear recurrence. Oh, these are properties of Lukov functions, sorry. But you'd want to generalize each of these. So you have a pair of them. They satisfy a linear recurrence. Okay, so the Luka one's of order two, second order linear recurrence. One of the functions is a divisibility sequence. The function that Luka mentioned in his quote is a divisibility sequence. And then you'd want to make Sequence, and then you'd want to mention there are addition formulas. I showed they had theirs earlier in the slide, another important feature. And then there's multiplication formulas, these help get the things you need. Okay, okay. So here's a cubic generalization. I don't go through it much, but it has all those properties. Okay, so before we had the Luka case that was based on this quadratic, but now we have alpha, beta, and gamma. Now I used alpha and beta again, but this is a different alpha beta. These are the, and gamma, these are the zeros of this qubit. At gamma, these are the zeros of this cubic. PQR integers, the same way p and q are integers before. I use lowercase for the other slide. Here's the discriminant here. It's slightly longer, more convoluted. We used the c sub n notation, but this would be similar to what the capital U sub n that Luka mentioned. And then the counterpart, the thing that you needed, we called W of N, and here it is below. And this would be the analog of V sub n in the Luka case. Okay. And Okay, and okay, so it's hairier, right? I mean, you go up to a cubic. Oh, and when you do a cubic, this is now a six six-order linear recurrence. Okay, so this is the generalization, okay? So, all right, so here's, I mean, the details don't matter, but look, both of these, I use X because X could be either C sub N or W n, but both of them satisfy the same six order linear recurrence with different starting conditions. All right, so. Conditions. All right, so that's one of the checkpoints. It's a linear recurrence. And okay, there's addition formulas that it doesn't matter if you look at the terms carefully, but notice when you do C sub n plus 3m, before you just have this doubling, you could just do one previous term, but now you need three terms back. So we have n plus 2m, n plus m, and n m. So you have to go three back. And so you have to go three back. I think that makes sense. It's a six-order later recurrence. This will be important later when we're calculating sequences: how many previous sequences we need to calculate the next if we're using those to calculate. All right, this is also a little bit of a nuisance. There's ranks of apparition. We say ranks, not rank, because it could be the case there's multiple ranks of apparition, it gets hairier. Okay, so it's a Okay, so this is just a definition saying, look, there could be more than one rank of apparition. And it's important to know when. Yeah. Okay. But we have a sense of what's happening. We can classify the primes we're dealing with following Adams and Shanks here. So here's, this would be our quadratic that defines our recurrence. Then we say P is an I prime if this polynomial is irreducible. If this polynomial is irreducible, there's no zeros in F of P, or there's one zero in a quadratic, or if it splits completely, you say S prime. All right, so this is how we classify the primes. And then for each, well, with this, we can have a law of apparition. So there's only one, you can see here, the S prime case, we can have up to three ranks of apparition. But for the I prime, it's only one. Prime, it's only one, and for the Q prime, it's only one. All right, so that if you're going to design a primality test, you'd want an I or a Q. It's less hairy. For our cases here, we're going to make use of the I prime, but sort of backwards. Here I say, here's a PQ and R, and then we say we can do this, run this work and say, oh, what is it? And we say it's an I prime. But to know a priority, it's an R prime will take more work. Will take more work, and that's part of the new results here, or we rely on old results. But, anyways, but it wasn't in my thesis, uh, it's in this new paper because the paper's not published yet. We submitted it to Fibonacci Quarterly. We're waiting. If one of you are reviewing it, don't rush, it's okay. Anyways, but notice the rank of apparition here for the I prime case divides p squared plus p plus one, so it's a square and plus p plus one. That's going to be. Square and plus p plus one. That's going to be important in a minute, so just file that away in your mind. Okay, next slide. So we're going to look at a sufficiency test, not a necessity. You can bulk it up, but I programmed it just for sufficiency, for the primality of particular numbers n, such that n squared plus n plus one is divisible by the large power of some prime p. Okay, so notice that n squared plus n plus one. That n squared plus n plus one, that looks like the q, no, excuse me, sorry, the i prime case. Okay, this is the other hairier part. If you look at thinking or send numbers, or the ones Luka tested, it was always plus or minus one, right? Remember, it was like some large power of p, and sometimes there's other tests where you put some value a in front of it. Often it's plus or minus one at the end. Ours is not plus or minus one. The number we're testing is a bit hairier. The number we're testing is a bit hairier, more work to get at. Okay, so I just want to mention how we get to the values of n to be tested. And I do an example, you know, sort of silly and small just to get there. But we're going to let this lambda n p and lambda bar n be the two solutions of this congruence s squared plus x plus one squared zero mod p the n. And then we're going to solve it for p first, and then you can solve it for p squared, pq downwards by a Hensel lifting process. Anyways. Hensel lifting process. Anyways, and then since there's two solutions, we just call lambda n the without with the smaller of the two, lambda n p. All right, and oh, and for this test, we need p's convergence one mod three, so we restrict that. Uh, for execution of test, they did uh, well, I forget now, seven was the first one for the primes. Okay, all right, so I'm gonna go gamma and one of these two, all right? One of it's either the small one or the big one that's the It's either the small one or the big one that's the solution from the previous slide. And if I want the next one, we do these following steps here. This is kappa n, we just solve this, and it's always an integer. And then we solve the next one for a new n. It's a little more work. If you're programming it, you can use some sort of an extended Euclidean algorithm, some step for speed. And then our solution, the next one is gamma n plus one. The next one is gamma n plus one, it's just this gamma n plus p the n times u n. Okay, so we can get the next from the previous. So when you're programming this, you just you solve the next one, you run whatever test you want to run, and then you calculate the next and you onwards, right? You just, and then we're going to run our test, well, say for some iterative loop of ends. All right. So this is our number we're testing, and it's similar. Here, we let A be some fixed integers. We let A be some fixed integer such that P does not divide it. So this is, you know, there's other tests akin to Luka's where you allow this value of A out in front. And, but rather than plus or minus one, we're doing this plus gamma n, where it's either lambda one or two. You know, there's this lifting process up to some, solving that thing over and over again. Do you see that? And so here, n sub n could be n sub two if you only lift it once, n sub three if you lift it, you know, you just lift it. Lift it, you know, you just lift hands three times, you know what I'm saying? And you can keep going, and each time you do it, you find a new n you can test to see if it's prime. All right, so this is the type of numbers we're testing. This is a really, I mean, this is the most obvious example, as smallest you could do, just so you can see the steps. If you let p equals seven, you can check that two and four are both solutions to x squared plus x plus one screen or to zero, one, p. That's so small you do it in your head. So pick gamma one. Pick gamma one seven, oh yeah, gamma one of seven, pick it to be lambda one, the smaller of the two, pick it to be two, okay? And then you can solve two squared plus two plus one over seven, okay, that equals one, all right? So, uh, oops, missing an equal sign. There should be an equal sign, it should be capital one equals, sorry, okay, that's, I'm prone to such things. I'm, I'm, I do that, okay, and then you mu one, anyways, and then uh, when you solve it, the gamma two and you work it. The gamma 2 and you work it through as it had that you get 30. So now you have, oh, and I just picked a equals 1. You can pick anything, right, that's relatively prime to p. So I have 1 times 7 squared plus 30 is 79. So we could test if 79 is prime. I did this by hand ahead of time before I programmed it, just to make sure, and then it's prime. Okay, you can see that, that my test was working, like that at once, well, test works. Look, he was very. Test works. Look, he was very smart and he came up with some very good tests. When I implemented it, I do very dumb things. So I check, you know, to see if the software is working right. So it's handy to do these little examples ahead of time. Okay, these tests would be useless if you couldn't calculate them in a reasonable amount of time. The fastest way to calculate these terms that we're going to need C sub n and w of n is with these auxiliary functions x sub n, y sub n. functions x sub n y sub m sub n here and what do I say about this yeah it yeah so yeah it takes 12k modular multiplications the modular here is going to be n sub n the number we're testing and yeah we're going to run a double and add algorithm all right so here we have some starting conditions so now We have some starting conditions, so now I'm saying it. Sorry, I should go back. Ah, sorry. There's these f's and g terms, g1, and then you'd have x, 1, design. Oh, if you're reading a previous paper I've done, I was clumsy, and even my thesis, when I switched sections, sometimes I would continue to use N for iterative processes. So in this particular portion of my thesis, Particular portion of my thesis, and even papers afterwards, where I use this, I sometimes have n used twice, and once it's used in a funny way for this iterative process, and once it's used for the sequence. Here I switch one of them to M. It was my mistake. Yeah, Edge is a second mistake, but I'll mention it. Okay, so here you have F0, F1, F2, and F3. Okay. And F3. Okay, so you'd say, I mentioned before with the addition that we needed at least three steps back, right? But if we're running a double and add algorithm, either we use F0, F1, F2, and then G0, 1, 2, or F1, F2, F3 for the double and add step, okay? So we need these four for each case. And so you have this initial sextet SM, and you can calculate, you can either double it, S2M or S2M plus 1. Or S2m plus one with these appropriate formulas, and here they are. And these follow from identities working with those sequences, and you can get them, and then you use these auxiliary functions, and you build it up. I would also like to state, I made a second mistake in my thesis that I never really knew about till now, and a confession even maybe. Often, when I had to calculate these sequences to think about them or do something with them, I would do it the dumbest way possible. The dumbest way possible is just use the sixth order linear recurrent. Possible is just use the sixth-order linear recurrence and plug in the terms, initial conditions, and go through. It's slow, but it's easy, right? Here, our test relies on doing it this way. So I actually had to program it this way. So I always had this result, but never really did it. And I'll tell you, actually punching it through and programming it properly makes you learn something. And what made me learn in this case was I had more typos in my PhD thesis, my F of 2M plus 3 and G of 2M plus 3. 2m plus 3 and g of 2m plus 3 terms had sign mistakes. And if I were really honest here, I'd blame Renata. Why didn't you catch these while reading the thesis, Renata? Come on now. Who says I didn't? Okay. And then there were like a dirty Easter egg from my past that, how to put it? It was like a trap I laid for myself more than a decade ago. Myself, you know, more than a decade ago to look stupid later. So, I discovered that if I was calculating sequences that were all doubles, everything worked out fine. But as soon as I did a double and add, I had a mistake. It went all haywire. And it was because of the, you definitely use these two m plus three terms. Okay, anyways, those are fixed. We can do a double and add algorithm. That's that's part of the battle. I'm doing for time. Okay, I'm good. Okay. Good. Okay. The okay. We want an irreducible polynomial modulo R sub prime. This is we want we want the I prime case. Okay. Results of Lamber tell us how to do this. So these are all the results. So if Q some prime is not R is converted to one mod three, and you have R raised to the Q minus one over three is not coming to one mod Q, then this you can this. And this, you can this polynomial for P1, Q1, and R works here. So that's what we want. We want this polynomial. When I was programming it, I just made a big list ahead of time of Q values, and I would test this condition and see if it works. And if it didn't, I would just reject it, move down the list. Okay, so I cooked these up ahead of time. All right. And I made a real long enough list that it worked for all the primes I worked up to, but I didn't do it in the software. Okay. How's this handy? How's this handy? Okay. If alpha one is a zero in the first little bit, then we can have, we can put this alpha based on a, b, and c here. I didn't want to get too thick into the details. We cannot have b equals c equals zero, because then alpha is not fr. But how to put it if you do this. If you do this and then you solve using what p and q should be based on this alpha, based on this a, b, and c, you can work it through and you get values for p, q, and r for your polynomial for the thing you want to work with in terms of a, b, and c. So now I can say once I cook up to q, I can just choose any a, b, c I want, such that b and c are not both zero. All right. And then I have the field I want so that my, my, my, So that my my my I so I know I have an I prime, it's an I prime case, right? So all I have to do is choose an A, B, and C, any of them, just the B and C denote zero, and R does not divide R, which isn't that R. Okay. Okay. Two conditions for our test. The first one maybe is obvious. Not a gamma N or gamma bar n as a divisor of n. If it is, then it can't be prime. Don't test it, right? It's a primality test. The second one's maybe less obvious. ones may be less obvious, but if you solve this, then n is a square and again not prime. So we start off by, before we run our test, we check to make sure neither of those are the case and they're easy to check. And then if they are, we you know you stop, you stop the primality test. Okay, so those are two conditions that must hold. Okay, and this is the main theorem of the sufficiency test. Okay, DN DN is this new term I were introducing. It's just the greatest common divisor of C sub N and Wn minus 6Rn. This is the sixth order linear recurrences we have to play with. And then conditions one and two hold. Okay, so we know it's not that perfect square. Gamma N doesn't divide. And then we set M to be this term where H is bound between 1 and N. The little n here is again determined by the big N so n that were 10. The big n that we're testing, you know, which step of the lifting we're on. The G C D of N and delta R is one, we check that ahead of time. And n sub n, oh yeah, if n sub n divides these two terms, then it's prime when a is not too big, okay? Less than two as p to 2h minus n, okay? That's that's the test, okay? That's or that's the theorem, all right? So, but Theorem. All right, so, but to do it properly, we have to, there's two steps, right? Well, that's really one. Yeah, you have to be able to calculate with the double and add algorithm, those sex sets, and then just interpret results. Like I check to see if your A is too big or not, and these sorts. I check to your initial conditions are good, that the Q is okay. So, all right, so this is the X and Y we defined earlier, these auxiliary functions. These congruences are true. Okay, so H is the least value I, so this is true. Now, okay, we want I actually to be at least one for our test to mean something, but it could in fact be zero. It could be three congruent to three and zero right off the start. And for us, that's sort of bad because our test isn't conclusive then. All right, so here's the first algorithm. It's not so bad. You solve for x1. You solve for x1 the same way you solve for. Solve for X1 the same way you solve for, you run the algorithm once with the very, you solve for the initial conditions. Anyways, so you, the double and add algorithm, run the double and algorithm once you have them. Okay? Or you solve for them. And then, yeah, and then, oh, sorry, you solve, sorry, you solve for X1, you get those, or it's not hard. And then you run the technique once to solve for XW, and XW is just R squared plus R plus 1 over P the N. Later, that R is going to be n sub n during our test, right? But this is just for. Test, right? But this is just for some arbitrary R, you can calculate it. So you run the double and add algorithm once, and then you check if the first time through it's three and zero. If it's three and zero the first time through, then your H can't be between one and less than N. Like it just doesn't exist. So you stop, okay? Otherwise, you set I equal to one and you calculate it in turn. But now your initial conditions are XW or X P W each time you loop it through. Each time you loop it through, and you just loop it through over and over again, running the double net algorithm over and over again, okay? Until you're told to stop. You're told to stop when you get three and zero, and H is not zero, and you have the value H you want. And now, sorry. Okay, sorry. You can run this in a sufficient test. This is just one step. This has to cover two slides. Sorry. All right. So our test is essentially just our theorem. We first check. Essentially, just our theorem. We first check the conditions one and two hold. It's not square, gamma doesn't divide. Then, if it does, if they don't hold, then it's not prime. We're done. You select a Q. I had a whole list of Q's that satisfied those conditions so we could have an irreducible case. You grab one. You select some triple of A, B, and C such that B and C does not equal zero. So you just, you do them. And then you just get to compute P, Q, and R. So you have the nice irreducible case. The irreducible case, and you check the GCD of these things is one. If not, and is not prime, we turn it terminate the test. Okay, all right. Next, if it's the very first case xw is three and yw1 is zero, our test is inconclusive, okay? And the software, I mean, we implement it, we just say, oh, indeterminate case one, we don't know, okay? And I and I include the values of A, B, and C, which we don't know. include the values of a b and c which we don't know under okay and then uh if not you just run algorithm one again and you replace r with n sub n and you keep calculating until you find this it loops through until you find this h and then if you recall during the theorem a had to be less than some amount if it is less than that 2 times p to some power then n sub n is prime it's sufficient to say that we know this number is prime if if it's greater than we terminate again we say oh we don't Then we terminate again, we say, Oh, we don't know. It might be prime, it might not. Okay, what do I say about this? Um, these cases do happen. Okay, I'm almost done. Well, this is good. I'm glad I'm almost done. Okay, so I was going to, I use Maple. I don't know if anybody's going to ask. I used Maple. Why did I use Maple? I don't have Magma work. We have a license for Maple. I'm comfortable. Does anybody use Maple anymore? Am I the last one? Am I the last one? I don't know. It's not so popular as it used to be. Anyways, I like it. Okay, so I used Maple. I wrote a program that does the sufficiency test. And here there's tables. Up ahead, this is the case where P equals 7. My initial conditions for A, B, and C are here, 010. And then I have two different starting conditions, either lambda one is two or four in this particular case. Four in this particular case, if you recall from the slide of the example. So, this is the one where the initial zero is two. And then I cook it up from there, okay? So, for different ends, we keep lifting, lifting, lifting higher and higher. Okay, so this is a table of all the cases where our test says these numbers are prime. So, it's prime here, where a is one and n is two. Well, that's the case where it was 79. That's the one we did by hand. But these are all prime now. know these are these are all prime null uh oh and i went up to uh 60 for for uh for my values of a and i went up to uh i think it was 500 for my for my values of n and these are all the primes that it finds under the that range for p okay notice here i put round brackets around this one and square brackets around this one i want to say something about those in in a second um the round The round well, I'll say this now. Sorry. The round brackets and square brackets mean these are interesting. This is a table of primes without brackets, but if they do have those brackets, it's the indeterminate cases, okay? Round brackets, indeterminate case one, square bracket, indeterminate case two. Okay. Here's a very, very, very similar table, but now here's a round bracket here, and you can say it's now in three case, indeterminate case one, indeterminate case two, indeterminate case two, indeterminate case two. Independent case two, and determined case two. The indeterminate cases two seem more common, which is actually kind of nice. And then the indeterminate case one. I'll say why it's nice in a second. Here's a different problem. P is 13 now. Okay, fine. And then the lambda one now is three. Here's lambda one bar is now nine, but same thing, different table. Okay, so the computational results are largely what I worked on. It took effort of some sort. It took effort of some sort. Okay, I just want to say one more thing of interest, maybe something interesting. Okay, in the few cases primality is unsuccessful, well, I won't say this as a slide. If it was circumstance two, every case I had, I just changed A, B, and C. And then I ran the test again. And for all those cases, those numbers are prime. Okay? So it wasn't inconclusive if you just try a different A, B, C. So you just run the test again. ABC. So we just run the test again. However, this was surprising. Sometimes you get surprising things when you actually write programs that you don't see coming. I had a bunch of cases where I had circumstance one, and if I changed the initial conditions, I still had circumstance one. If I changed the initial conditions, I had circumstance one over and over again. And I thought this was interesting. And I told Hugh, and he thought I had screwed up, which, you know, honestly, good assumption, right? I hadn't this time, okay? This time. This time, okay. This time. He, upon some digging, if you actually look at these numbers, it's hard to tell from the slides earlier, but one's 961, and that's 31 squared. 361 sets off another one, that's 19 squared, and 529. These are all these indeterminate cases. One, this is not that shocking in hindsight. We have a result, even in the thesis, I'm sure Renata remembers every detail, where if you have a sum prime r. where if you have a sum prime r if r divides that d the d1 of some particular sequence i think d sub r squared plus r plus one okay then then if it's an i prime then you also have the r squared divides it okay so this it takes some work to get from there to this but it it actually makes sense in the end so you can think of these as some sort of maybe like almost pseudo prime like thing happening because they work for all different initial conditions All different initial conditions. Yeah. I'm surprised nobody liked my footprints in the sand. Anyways, that's the end. Thanks, guys. Thank you, Eric. Are there any questions? I want to ask a question. Did you guys look at all? I mean, is there any hope of kind of analyzing, let's say, the Analyzing, let's say, the probability of encountering one of those bad cases. I mean, in practice, it doesn't sound like they're a problem because you can always just find different A's and B's and C's, and they work. But did either one of you look at this? No, but can I, if you, you might have noticed all the indeterminate cases wanted for these very small, like not all, but who knows? But they seem to happen early on and not so much later. Maybe it's an obvious probability thing happening there, too, but no. But no, no, that's work that someone could do. It's a good question, but I mean, there's some funny divisibility going on, I guess, that doesn't happen with big numbers or whatever. Yeah, yeah. I just want to say thank you again to the organizers. I really appreciate this. My annual report at my job appreciates this. Get to give a talk. Get to give a talk and thank you for logging in on a Sunday morning. Thank you for joining us. Eric, can I ask a question? What is the running time of your algorithm? Oh, it's in the paper. Is it here? The test will run in big O log N cubed. But I mean, really, the details is that you only sorry. Sorry. Here, these things here, a lot of these multiplications are redundant. It's the same one multiple times. So it's kind of buried in here. You can do either a double or a double and add, and 12. Both of them are just 12 multiplications. So, and then since you're doing just a binary expansion, whatever you're calculating, and double and add is pretty quick, even though it's. Double and add is pretty quick, even though it's a sex set, you have to go three back. It's not so bad, okay. Thanks. But that's what dominates the runtime, right? It's basically just this double and add algorithm. Yeah, yeah, it's the bulk of all the calculations is just this thing running, to be frank. Cooking up the queue you can do ahead of time, you get to choose AB and C, just willy-nilly, and make those calculations so small that it's almost nothing. It's almost nothing. I guess I should mention that Richard, in his later, latest years, actually spent a lot of time working on recurrence relations. And I think he and Hugh wrote a sequence of paper, but they were fourth order. Sorry, can I? I forgot to say that. This paper that Hugh and I worked on is a bit of an addendum to a paper that Hugh did with Richard that I was also a part of. Did with Richard that I was also a part of. So, not only did Richard work on the fourth-order ones, he spent some time looking at these six-order ones too. And some of the papers have both in them. So, yeah, so this has a link to Professor Guy in it too, because it's, yeah, anyways, it was some primal tests that he looted Lucas, and he worked on with this. And this, a lot of the results we point to in this paper. We point to in this paper, or in the previous paper, my thesis. Like, I should have said that, sorry. I think he was quite intrigued by this idea of multiple ranks of operation, actually. Yeah. He was looking into that. Because if you get to higher order sequences, you start getting even more ranks of operation. And I think he was quite intrigued by that idea. Let me just stop sharing. Let me stop share. Thank you again. Any more questions?