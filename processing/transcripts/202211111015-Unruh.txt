Perfect. Okay. Yeah. Hi. I'm Leonard. I'm a PhD student at Imperial College London. I work there with Leonid. And yeah, together with Santiago, we're working at the moment on a method to identify bacterial strains in metagenomic data. And yeah, so let me first talk a bit about the background and like our end goal. Background and like our end goal, and like a bit of the motivation behind this. So, at the moment, if we look at current methods, like for example, Craigen, we are able to take a metagenomic sample and extract the reeds that belong to certain species, identify reeds and which species they belong to. And then, also looking at other methods, we're also able to, like, at least to an extent, identify antibiotic resistant genes in metagenomic samples as well. Metagenomic samples as well, but both of these analysis, like so far, are very separate. So, we're not really able to assign antibiotic resistance genes to a particular species, let alone to a strain of the species. And that's, of course, very, very important if we're looking at things like outbreak surveillance. And yeah, so that was like the original motivation for why we wanted to identify strains and which genes and in particular. Like which genes and particularly antibiotic resistant genes they actually have. So, what we're aiming to get to in the end is what you see here on the right. Basically, we want to be able to say, okay, we've got all of these reads from the species, and we are able to say we have two strains, both at the relative abundance of 50%. And they have this allele for gene one and this allele for gene two. And yeah. And just saying that. Um, and just saying that for now is um like our goal. And then, um, any further applications are possible, like once we have achieved that. And there's a whole bunch of potential applications, for example, just as I mentioned, the assignment of antibiotic resistance genes to strains. Then we can also get more information on within or between sample diversity of a species, which can help in, say, for example, when we look at the dynamics in microbial communities. In microbial communities can help with outbreak surveillance, potentially also with tracking of spreading. There's a whole load of potential applications that this could be applied to. So we think it's a very important challenge to tackle. Yeah, so what do we actually do? So we've decided to work on an example. On an example species for the development of this method, and we've decided to work on acetyl Nitobacter Baumani. So, with Santiago, we obviously have an expert on Baumani in the team. And we are actually using as a reference database the data set of 1,500 Baumani assemblies that are very high quality that Santiago mentioned yesterday in his talk. And yeah, given that we have this like And yeah, given that we have this high-quality database, we felt very confident in developing our method based on this. So, and this database, like or the assemblies in this database, we refer to as library strands. And strain being here, just like an operational term. So, any unique assembly would say is a strain. And then, so that's one backbone of our data. And then, on the other side, we also have, of course, the metagenomic sample. Of course, the metagenomic sample in which we wish to infer which strains are present, and then we go for some pre-processing. And in the end, we're going to put it into like an optimization routine. And this optimization will return some solution that will give us the number of strains present in the metagenomic example, the relative proportions out of all Baumanni reads, and the core genome alleles of the different strands. Strands. Okay, so and first, let me walk you through our pre-processing pipeline through which we go to get the input that we actually are going to use in the optimization. So this is split up in two parts. First of all, we have got the library strains. And from these, using Panaru and Proka, we create a pangenome. And in this pangenome, we identify core genes. So all the genes that are present in 100% of the In 100% of the assemblies. And we create a database of core gene variants. So for every core gene, we have 1,500 variants. And they're not necessarily unique. And yeah, we have that for every one of the core genes. And on the other side, we have a pipeline for the metagenomic samples. So first of all, we extract only those reads from the metagenomic sample that we believe to come from astenitibactobomba. Leave to come from Arsenal to Bactobamani. For this, we use Craton 2 at the moment. And then with these reads, for each read, we determine which gene this read likely belongs to, or which core gene, if any. And yeah, then we put these two pipelines together. And for each read, we map it to all the variants of the gene that it's assigned to and get a mapping error between the read and the different. Between the read and the different alleles or variants of the core genes, and what we end up with is a symmetrix that looks somewhat like this. So, say for read one, we can say that for the gene it's assigned to, it has when aligned, it has zero errors or zero mismatches to the allele that strain A has for that gene, but two mismatches for strain C. So it's most likely come from strain A in this case or strain B. From strain A in this case was strain B. And yeah, that's basically our basis for the optimization. Now, for the optimization itself, let me reiterate like the output that we actually want. So we want to know the number of strains in the sample, their relative proportions, and for each gene, which allele of that gene the strain has. And at the moment, focusing only on the core gene, hopefully, at a later stage, also incorporating the accessory genome. Accessory genome. And for this, we use a mixed integer linear program. So, for everybody who hasn't heard of this, it's basically just a linear optimization and a constraint. We have some linear function that we wish to minimize. And we also have linear constraints. So, for example, we say here that x can't times b can't be bigger than c. See, and the mixed integer part from here comes in because we say that some of the variables are constrained to be actually integers. Yeah, and it's a very useful, useful optimization tool to have. And so we want to solve our problem using this. Now, to define our problem a bit better, we have to make some assumptions. And first of all, we say, okay, each read is going to map to exactly one gene. And if it's One gene, and if it's a bit ambiguous, we enforce it. We just choose a random gene of the ones that the potential can align to. And then we also say we have a we know that there is a maximum number of strains within any sample or a maximum number that we can infer however you want to want to see it. And then also we prefer more parsimonious reasons. So we say, okay, if we have, if we can explain what's present in the Was present in the sample with less strains, then that's better, then we prefer that. And then on the more biological side, we also say, okay, we say that the strains we find in the metagenomic sample are going to be somewhat closely related to the library strains. And what this means is: say we have a strain in the metagenomic sample, and we estimate one, and 80% of its alleles match. Its alleles match with a library strain, then that's more likely to be the strain that's actually in the sample than a strain that only matches in 70% of its alleles. And then we also referring back to the matrix I showed you earlier, we say there's a maximum number of nucleotide mismatches between the reads and the alleles. So if there's more than this many mismatches, we say the read can't come from this allele. But if there's less, then even if it has If there's less, then even if it has some errors, this could just be due to sequencing errors. And then, lastly, we're also saying that the paired gene coverage by reads is proportional to the strain relative abundance. So, say, for example, we have a sample in which a strain is present at 30% out of all Baumani strains. Then, for each read, for each gene, we would expect that 30% of the reads that we observe for the gene are also gonna. Observe for the gene are also gonna come from that strain. And yeah, then what do we actually minimize for? What are our criteria that we minimize to get our solution in the end? So first of all, we say, okay, we want to minimize the number of allele mismatches between the estimated and the line strains. So basically, referring back to like the strains being similar to the ones we already know. So here again, Know. So here again, if we manage to estimate a strain that 90% consists of allele from our library strain A, then that's good. If it's only 50%, that's not so good. And then we also want to minimize the read and allele nuclear attack mismatches. Because obviously it's better if we assign to read to allele with where it only has one mismatch instead of like three mismatches. And then referring to the last. And then, referring to the last assumption I mentioned, was we also minimized the difference between the proportion of the estimated strains and the proportion of the reads assigned to their alleles. So, if we have a strain and we estimate it at 30% relative abundance, then for all the different genes for the alleles of that strain, we would expect that roughly 30% of the reads would map to that. Reads would map to that, and we would try to map as many reads as possible, or as many reads such that it's as close as possible to that proportion. And then lastly, for the parsemani criterion, we also minimize the number of inferred strains. And yeah, so basically what we're doing at the moment is we're tuning this method on simulated data, and we have two data sets. And we have two data sets that we are tuning it on: one with one strain at 100% relative abundance, and one data set with two strains at 10 and 90% relative abundance, respectively. Both are simulated at 10-fold coverage. And for the one-strain sample, we can so far say that our method reliably identifies that there is only one strain present and sometimes identifies the And sometimes identifies the correct strain, depends a bit on the parameter settings. And for the two-strain symbol, in contrast, our method also so far is able to say, okay, there is more than one strain present, and one strain is at a relative high abundance and one, two, or three strands at less abundance. Though here we are still struggling a bit to identify exactly which strains are in the sample. Yeah, and obviously that's a much harder problem, especially if you look at the sample only having like 10% of one strain, which had a 10-fold coverage, basically means a one-fold coverage. So you're not going to have as many as high coverage there, which makes it harder. Yeah, and then for our future work, well, first of all, we want to further tune the hyperparameters of our model so that we have a consistent performance. So, that we have a consistent performance on our simulated data. And we're also working on improving runtime, as this is at the moment a hurdle to actually tuning it and actually always finding a solution is at the moment not always possible or not possible in the runtime we have actually on our cluster. And then we're gonna, once that is done, we're gonna validate it on further simulated data sets and Data sets. And yes, and we have then this method for the whole core genome. And in parallel, we also are going to apply it to only to the MLST genes. And then instead of the library strains, we're going to infer the MLST stain type and we're going to compare those methods. And then lastly, we're going to apply this method to a data set of over 200 wastewater metagenomic samples that we have. Genomic samples that we have. And yeah, that is it from my side. Any questions? Oh, yeah. And so, yeah, I want to thank again Leonid and Santiago for their help with this. And yeah. Thanks very much, Leo. We have time for a couple of questions. Any takers? Hi there, this is Anne from Hi Leo, this is Sam from Wagga. Yeah, great talk. Really interesting tool. I was just wondering, you might have covered it. I might have missed it. So how do you deal with where a read might map to multiple strains with equal probability if there's been some recombination in the core gene between two different strains, and you have sort of a mosaic read that maps the two? So, yeah, basically, that happens. Yeah, well, basically, that happens quite a lot, right? So that we have a read, like, because also a lot of the codings are actually like the same across different strains. And so we get often that like read has so what I assume you mean is that like read one here is maps equally well to strain A and strain B, right? Yep. Yeah, so that does happen quite often. And that is exactly why we say we have this minimization criterion here. Minimization criterion here that there are leave mismatches that we want to minimize those, right? Because we assume, okay, no two complete profiles are going to be the same for reads. So it's not going to match equally well to strain A for all the reads. Not all the reads are going to match equally well to strain A and through strain B. There's going to be at least some disparity. And so if we have the choice between strain A and strain B, A and strain B, both being applicable for this read, then if we say, okay, for like most of the other reads, they map to strain A better, then we prefer to choose strain A also for read one, because then we have a more consistent allele profile. Great, thank you. Hi, Leo. We have a question in the chat, and it's from Medique. Can your method differentiate closely related strains like a few SNP support? Like a few SNP support? Um, so I can't uh tell you very much about it at this stage. So, um, looking at the tuning that we have run, sometimes you get a different strain out, like say for the sample with one strain in it. And usually, this different strain is very closely related to the true strain. True strength. So at the moment, not reliably, but we're aiming to get there. All right. Thanks very much. So now we are hitting the coffee break and we will be back in 23 minutes with Nicholas Croucher.