Okay, okay. Okay, we have it. This is grand. Okay, so I start now. Okay, first of all, I would like to thank the organizer for giving me the opportunity to give this introductory talk, let's say, partial introductory talk on. On geometric approaches to Linear Codes. I would like also to thank all the people that are here attending this Friday afternoon session. Well, it's not afternoon for everyone. So this Friday session, let's say. Okay, so my talk is, as I say, is meant to be introductory and to Introductory and to explain some connection of linear codes with a geometric perspective. So that's how I plan to, let's say, divide the talk. I will give a brief overview of the main goals. Then I will focus on codes in the admin metric. And for this, I will give a geometric interpretation. I will give a geometric interpretation and geometric interpretation of several kinds of codes and several kinds of aspects of linear codes. I try to put together some of the topics which have been covered in the last four days, not all, unfortunately. Then I will switch on the rank metric, and also in this case, I will give a geometric interpretation. And then I conclude with the sum rank metric, which I know has been briefly covered during the conference, but still I would like to tell something about it. So here we are. So I took some this. I took some this sentence. I'm not sure from where, but from somewhere. So, what I like to say about Korean theory is just the theory of subsets of a certain metric space. I mean, this is very short sentence. Of course, there is much more about it. However, so for what I will present here, I will not talk about subsets, but subspecies of a metric space. Spaces of a metric space. So for me, I will for me, I will always consider. So the field, I will always consider essentially a metric space over a vector space, B, over a field, finite field, of course, will be essentially always here. So when I say metric space, I mean an instance function. And for me, linear codes are vector subspaces of a vector space. Species of a vector space together with this distance function. And one of the most important parameters is the minimum distance. So, no matter what is the distance that we consider, but the minimum distance is a parameter which is essentially the which is just the minimum distance of two different code words. I mean, I know this, all of you know this. All of you know about what I'm saying now. So, but yeah, whatever. So, but yeah, what I want to say in general, I will cover metric codes. So, vectors, so space of vectors over a field with the admin distance, which counts the non-zero entries. So, which is given by the weight, the amin weight, which counts the non-zero entries of a vector. Then we'll consider rank metric codes. So, in this case, in general, In general, so one considers space of matrices and the distances induced by the rank. And for what concerns some rank metric codes, they are a generalization of both, essentially. And so I will consider two copies of the space of matrices in which the weight is induced by the sum rank. So which essentially is just So, which essentially is just the sum of the ranks of each component. So, code words will be tuple of matrices and the weight. So, this is the general framework. The sum rank weight is just given by the sum of the ranks. However, for this talk, for having an easier description, geometric description, so we'll always consider finding Consider a finite field, the ammoniometric case. For the rank metric case, I will consider actually space of vectors over an extension field, FQM, and linearity for me will be over FQM. So Albert already presented the rank-metric codes as I presented before. So space of matrices, I will talk about rank-metric codes with the additional property of a linearity. Additional property of a linearity over this extension field, as Umberto, for instance, say the S3D, which is also good for applications. And also for the sum rank metric case, I will consider linearity over an extension fit. So I will consider L copies of Qm to the N and the sum rank weight. The sum rank weight is exactly the ranks, always the sum of the ranks of each component. So the aims are the following. So I first want to give an equivalent geometric descriptions for codes in this matrix. Then, I mean, actually, what I will do is I will focus a bit more on the aiming metric. So, and I will explain some classical connection, some reinterpretation of basic things and also of new topics in some sense, so of new results, so giving a geometric interpretation. And finally, I will study one-weight codes. So, we'll essentially use the geometric description to explain some results on one-weight code. Some results on a one-weight course, known and new. It depends on the method. So, this is the sketch and the aim. So, for this, I will start with codes in the ending metric. I mean, maybe there is not real need of fixing this setting because we already seen several times, but anyway, so I will consider NK. So, I will consider n k code. So, codes of length n and dimension k or a finite field of q. And in this setting, so one important thing is the important object is the generator matrix for a code, which is just a cadence and matrix, so whose rows form a basis of the code. So, depending on Depending on the setting, I mean, I will consider NK or NKD. So, this is the minimum distance, and so I can omit sometimes during the talk. If it's not relevant, or if it's relevant, I will write it in this way. So, for giving a geometric description of the linear codes in the MEM metric, I briefly introduce what is a projective space. And projective space is just space is just uh uh is just the quotient so this the the set of non-zero vectors handled with an equivalence relation which identifies non-zero multiples of vectors so for uh in other in other words so we can say that if we study subspaces of a n of a vector space over fq so dimension Q so dimension subspaces of dimension i are projected subspaces of dimension i minus one so a one-dimensional subspace is just the span of a vector which identifies exactly one element so one point so dimension two are lines and so on so when i when i talk about either planes i mean dimension k minus two uh in a projective space or dimensions k minus one in a K minus one in a vector space. And now I want to introduce the notion of what is a projective system. So projective system is just a multisat, a finite multisat. So it's identified by these three parameters, N, K, D. Of course, you will, you, you may know why I used exactly the same parameters. So they are multi-sat, so there can be multiplicity. So, there can be multiplicity of endpoints counted with multiplicity. So, in the project in the K-minus one-dimensional projective space of a finite field FQ, which are not all contained in an hybrid plane. So, and the parameter D in our projective system is just n minus the maximum cardinality of this projective system. Projective systems of B intersected with the hyperplanes. And why I introduced this, because this is actually a tool and another way, equivalent way of seeing linear codes in a geometric setting, which allows to transform the probability. Transform metric properties of the codes in geometric properties. So the nice thing is that metric properties are transformed in intersections with hyperplanes or with other subspaces. And the theorem, well-known theorem, is that there is a one-to-one correspondence between equivalence classes of non-degenerate NKD codes and equivalence classes of projective NKD systems. And KD system. So I'm not going to the details. Equivalence equivalence of codes is just monomial equivalence. And non-degenerate means that we have no coordinate which is identically zero. While equivalence of projective system is just the equivalence for the project up to the action of a projective general linear. Just to understand what is this connect, so how this correspondence works, it works in the following way. So, if you have a code and you fix a considerate generator matrix for the code, so looking at the rows gives you the code itself, but if you look at the columns, then you can take them as projective points, so in a projective space of In a projective space of dimension k minus one. And this gives you the projective system associated. So the idea of putting equivalence classes is just to have a well-defined correspondence because code has more general matrices and can this gives different set of points, but they are all equivalent. And the idea is that if you consider a non-zero Consider a non-zero vector of length k, then if you consider the hybrid plane, which is the orthogonal of this vector, u, as I wrote, so this hybrid plane contains exactly n minus w points in p if and only if the code word u times g has exactly weight w. So in the I mean weight. So why, as I said, so why do Say so, why doing so? I mean, yeah, is what I explained before, essentially. So, this allows you to transform and to have an equivalent point to equivalent object, but from a different perspective. And this sometimes can be easier. So, this correspondence, for instance, tell you via this correspondence, you can see, you can give a geometric You can give a geometric interpretation for some parameters of the code, and not only parameters, but related objects, such as the weight distribution, supports, generalized weights, but there are many more. So I'm going to go into details of some of this interpretation, but let me say just an example. So if you consider the set this code, three-dimensional code. Code three-dimensional code of length seven over F2. This is known actually. What is you may guess what is this code? Anyway, so this is a three-dimensional code. And what is project, the associated projective system is the set of columns. So I here list all the seven points. And indeed, this is an example. So just to tell you how it works. So if you consider a vector in F2 to the three, then u times g as weight four. U times g as weight four, and indeed, if you consider the intersection of the projective system with the hyperten given by u this is exactly the this intersection is exactly the set of these three points 010101 and 111. And the weight is seven minus discardinality. Okay, so let me say now something more. Now, something more about classes of codes. So, it's well known that there is a bound between the parameters of a code, as you have seen several times. So, this is the single top bound, and Andius codes are just codes attaining, so meeting this bound with equality. And what is in a geometric represent perspective, these codes have been studied actually, they are called. actually. They are called, they are known to they are known as n art. They are just set of points in a projective space, in a k-1 projective space, which are in general position. So it's the usual way of calling them, being in general position. So every k of them spans the whole trajectory space. So and let me say something that indeed. So what is That indeed. So, what is known as the MDS conjecture? I'm not writing it down, but so the MDS conjecture was phrased by Segre actually in terms of n arc, so in terms actually of points in general position. And yeah, by the way, this is kind of clear. This is a just I want to add a comment because when so during so Alberto. So, Alberto talked about density of codes, and this is our very easy, actually easy way to see that MDS codes are dense with respect to his notion of density. So, for Q, for a fixed end and Q growing, because actually being in general position is an open Zariski condition and so going. condition and so going with the going for with two large this tells you essentially that every almost every time attempts to have endpoints in general position about mds codes we know very famous class of mds codes so one of the most important and i would say class of codes at least from an algebraic point of view From an algebraic point of view, is given by read-Solomon codes or extended read-solomon, doubly extended read-solomon. This is a general way of seeing all the possible variants of read-solomon codes. In general, one may take a set of representatives of the projective line and And so let's say n distinct points and then take n non-zero elements, beta one, beta n, and just considering the evaluation together with this multiplier of all the polynomials of degree, so homogeneous polynomials in two variables of degree k minus one. Of degree k minus one together with the zero polynomial, and then consider exactly this set of vectors. So this is MDS code, it's well known, and these are, let me say, double-extended Ritz-Solomon codes, especially if you consider the set of representative to be the set of representative of all the points of the projective line. So giving rise to Andy's. So giving rise to MDS quotes of length q plus one. From a geometric perspective, this is well known to be to correspond to the rational curve of degree k minus one. So which is just the evaluation, so the embedding, so Veronica's embedding, Veronica map, sending the projective line in this curve, so this rational normal curve given by This rational normal curve given by this parametrization. Okay, so these are all known stuff. At some point during the conference, I remember, I guess, so it was the first day, so Emina mentioned something about minimal code words. I guess it was Emina talking with Jacomo, but I'm not fully sure. So forgive me if it's wrong. But anyway, so Anyway, so I would like to talk a bit about minimal code words and what the correspondence says from a geometric point of view. So in this moment, I want to consider a linear code with a generator matrix G and P, associated projective system in the sense that P is really the set of points given by the columns of G, not just one another. Not just one another representative in the same equivalence curves. Anyway, so the notion of support is well known. So for a given vector of length n, the support is the set of coordinates in which the vector is non-zero. And a minimal code word in a code is just a code word such that it's A code word such that its support is minimal with respect to inclusion in the set of all non-zero supports of the code. And actually, what is a minimal code? So minimal code is a code in which every code word is minimal. And so these are notions and objects which are. Objects which are studied and are of interest for recovering for locally recoverable codes as well. I mean, like minimal code words of the dual gives the set of entries that you need to recover like an erased coordinate. And like this is a very interesting notion. This is a very interesting notion, also from a combinatorial point of view and from a geometric point of view. And indeed, from a geometric point of view, we recently shown the following results. So we have, we can say that a code, so a code word, u times g is minimal. So if and only if the The span, so when you intersect your projective system consisting of the columns of G with the hyperplane given by U, so the orthogonal, then this span again the whole hyperplane. And the code is minimal if and only if the associated projective system has the property, as the same property for every. Property has the same property for every hyperplane of the projected space. And these objects are called, are known and are being studied for other reasons, actually. They are called strong or cutting block inside. I mean, there are also other notions, so other names that have been given to these objects. So we grouped this together with General Farrano. General Farrano and Martino Borello. And we also studied additional properties, a new construction in another joint work with the same authors and Alberto Magniari. So I want to give now another geometric interpretation, or well, this is not really a geometric interpretation, but a geometric construction, a geometric way of constructing this object. These objects, so minimal codes. And this is explained. I want to give a very easy explanation how to construct cutting or structural blocking sets. And this is in the projective plane. So if one considers the union of three lines, which are not all intersecting in the same point, then one can see that this is actually a cutting or a strong blocking set. A strong blocking set because I mean, hyperplanes in this setting are lines. So, what can happen? Well, one the lines of frequency can be one of the three lines. And well, of course, then the intersection span the line itself. Or maybe you can have a situation like this. So, the line intersects the union of the three lines in three distinct points. Of course, if you the span of these three points give the line. The span of these three points give the line itself, or can be something of this form. So it can intersect two lines in the same point and the other line in another point. So that's why we take the three lines to be non-intersecting all at the same point. And also in this case, I mean, the span, so if the intersection is given by two points, and the span is again the line. So, this is like a picture to explain how to construct, for instance, minimal codes or strong blocking sets. And now I want to talk about a bit about locally recoverable codes, which was a topic introduced the first day. I'm not giving really the real definition here. I just want to sketch what is the aim. So, one want. What is the aim? So, one wants a code C, which has the following properties. So, you can give a coordinate, so a partition of the coordinate set into subsets of the same size, R plus L, in which every time you consider L coordinates in one of these recovery, one of these sets, AI, then they can be. Then they can be recovered by just contacting the remaining coordinates, coordinates node. And so this essentially means that if you punch the code everywhere else and you consider only the remaining that remains after punching everywhere else and on the set of coordinates AI. So every time you coordinates AI so every time you want to have an MDS code of parameters of these parameters R plus L and dimension so length R plus L and dimension R and you also would like to have global property so as John was saying so you you want to be able to recover additional erasure even if in the unfortunate case that you have more erasures happening all in the same block. In the same block. And this is given, I mean, this global property is given by the minimum distance, which has to satisfy, which satisfy this singleton-like bound for locally recoverable codes. So let me say something about how to geometrically construct this. An idea, at least. So this is a geometric interpretation that we gave in this joint work with Trisamen Bogarta. Joint work with Trisamu Bogart and Elena Orlem and David Karcook and Mauricio Velasco. So, the main idea is that we have we want these global properties, and these global properties are given by taking a rational normal curve in the whole ambient space, PG in the K-minus one-dimensional projective space. And then we want local properties. So, what we do is we consider the points and we group them. them maybe some of them maybe some some of them we want to discuss some of them in groups of cardinality r and now in each of this so if we consider now the span of this every set of r this will be a subspace a projected subspace of dimension r minus one and inside this subspace we take rational smaller Rational smaller, so let's say of smaller degree, rational normal curve. And then, I mean, for we need to remove some bad points because something bad can happen. And in order to have a better minimum distance, it might be useful to do that. So, we did a study on interpretation of this kind. We were focusing actually more on partial and yes codes, but yeah, more or less the idea is the same. So, this is. So, this is a nice interpretation of a geometric interpretation. I mean, it coincides with some, in some cases, with some already known construction of partial MBS codes, actually. But I think it's nice to give a geometric interpretation also of this object. And now, want to finish, conclude the part on the Emming metric. It just taking the example, going back to the example in which we saw this code and the associated projective system. And as I was saying before, I want to focus on one-weight code. And the fact is that this code is a simplex code. We know that. So it's the three-dimensional simplex code of F2. And so it's a one-way code. So, it's a one-way code with weight four. And the associated projective system actually is the wool space. And one can ask, of course, is this a coincidence? And well, the answer, of course, is not, because there is a classification result for linear coats with one weight given by Bonisoli in the 84, essentially says. 84 essentially says that the having a one-weight code is equivalent to have so is equivalent to a so yeah is equivalent to have a projective system which is exactly the whole projective space in which every point is taken with the same multiplicity so and uh this is if this happens indeed the parameters are given by uh by this so r times By this. So R times Q to the K minus 1 divided by Q minus 1. This is the size of the projective space. And the minimum distance is R times Q to the K minus 1. So R is the replication factor. And indeed, this coincide with the replication of R copies of the simplex code. And the main idea to prove this, I mean, there are, of course, several proofs, but one of the ideas is really to The idea is really to use the fact that if a code is one weight, then we have a geometric interpretation and we can say that every either plane intersects the sect, the associated projective system of a one-weight code in the same number of points. And the example before was exactly these parameters: q equals 2, k equals 3, and r equal to 2. Q equals 2, K equals 3, and R equal 1. Perfect. I want to go to codes in the rank metric. And for me, codes in the Rankmetric for this talk are FQM linear subspaces of FQM to the N. And I consider so codewords as vectors. This interpretation is not new, of course. Is not new, of course, and so I consider dimension as the dimension of FQM. And the rank weight can be taught as either taking a vector and expand the vector forming a matrix, or intrinsically as the dimension of Fq of the Fq span of the coordinates of the vector. And also, in this case, we have a minimum Planck distance, and we have seen. And we have seen already several properties of rank metric codes. But I want to just give now the analog of the interpretation, of the geometric interpretation. So the analog again will be explained via generator metrics. So since we have an FQM linear code, we have the decoders are The decoders are vectors, and we have a generator matrix. Like, doesn't change, it changes the metric, doesn't change the generator matrix, of course. This is a, this doesn't say anything about, it does not depend on the metric. And in this case, a code actually is a non-degenerate. This is a bit different, but if the columns of G are actually linearly independent, this is something that one can prove. Is something that one can prove and coin all the notions of non-degeneracy coincide with this property. And now I want to introduce Q systems which were actually introduced and studied independently, I would say, by Shiki and by Rambena Risoa. So Toboikas is So, Tao, I guess it should be here in the audience. And so, yeah, in this case, what is a system, a Q system, is an n-dimensional FQ subspace of FQM to the K. So, we are considering an FQ. So, even if we are in the space of vectors over FQM, we consider an FQ subspace. And with the probability that if you The probability that if you consider the span of this subspace with respect to the large field, the extension field of QM, we recover the Woolangen space. This means essentially that it's not contained in an hyperplane, in an FQM hyperplane. And the parameter D is n minus the maximum dimension over FQ of our space with FQM hyperplanes. So this generalizes the notion of projective C-spirit and adapt them to the case of rank metric codes. And also in this case, we can transform metric properties in geometric properties. And the theorem is as before. So there is a one-to-one correspondence. Equivalence classes here are equivalence. Here are equivalence linear equivalence of rank metric codes, so linear isometries, and equivalence classes of NKD so Q systems are always considered using the action of the projective general linear group over a QM. But anyway, so this is technical. I just want to say what is the explanation, so how to get the correspondence and the correspondence is as And the correspondences again, we can take the generator matrix, the rows generate the code, the columns. Now, what we do with the columns, we actually take the FQ span of them. So not the FQ almost, the FQ span. And vice versa, if we have a Q system, we can choose an FQ basis, put the FQ basis as columns of a generator matrix. Columns of a generator matrix, and then the associated rank metric code is the row span of the generator matrix. So, this is the prevalence. And so, in general, what is the correspondence? It works in the following way. So, it's given by this lemma. So, in the end, what we get why we have this correspondence is because we have this result. So, the ad-min weight of V times. weight of V times G, so where G is a generator matrix of a code, is equal to N minus the dimension over FQ of U intersect V perp. So V perp is the hyperplane, the orthogonal with respect, so of the V with respect to the standard inner product, and U is the F span of the generator, of the columns of the generator metric. And also in this case, I mean, this is helpful because we are. This is helpful because we have constant weight if and only if we have constant dimension in the intersection of U with the other things. And so this is just an example. So if we take F8, so Q equals 2 and M equal 3, we take a code generated by this matrix. So what we do is the associated system is just the span of the columns, F2 span of the columns. Q F2 span of the columns, which is given by this set, so A beta, where A is in F2 and beta is actually in F8. And if we consider a code word, a code word is given by B times G, so B is the message, what we get is that the rank weight of B times G is 3. We can see it, actually, it's easy to see that this is 3, and it's actually equal to N minus the dimension of the. minus the dimension of the over f2 of u intercept v perp because if you compute u intercept v perp then what you get is just the f2 span of the vector 1 1 and just to give an example however so what is what one can do is actually define a simplex the analog of the simplex code The simplex code in the rank metric, and this is given in the same way. So, what is the simplex code in the aming metric is obtained by taking as a projective system the Woolambient space, so the Wool space. And also in this case, one can define a syntax of mathematic code in the same way. And it turns out that this is equivalent to all the following. Equivalent to all the following properties. So to having a non-degenerate code of length k times m or having essentially the q span of the columns. So the associated system is the whole space FQM to the k. And this is equivalent to have a one-way code with minimum distance m or equivalently that the dual of c has minimum distance greater than one with As minimum distance greater than one, which automatically implies equal two. And equivalently, C can be described as the code generated by this generative matrix. So identity, alpha identity up to alpha up to the n minus one identity, where alpha is an element that generates the extension field. And what is possible to prove that. Possible to prove there's a characterization theorem about one weight code in the rank metric that every one weight code is essential. So there is only one weight, only one one weight code in the rank metric, if we assume FQM linearity. And this is the simplex rank metric code. And the main idea is to transform the problem in the geometric perspective. So we have that. Perspective. So we have that constant weight if and only if constant dimension of the intersection. And yeah, I mean, there are one can do a bit of double counting and the proof follows. It's not difficult to prove this result, but the crucial thing is to have the geometric interpretation. So this was proved by Tuvo in Tuvo in this paper. There is also another proof in our preprint. So, in our actually, not anymore, pre-print, so which we prove together with Gianni Alfarano, Martín Borallo, and Alberto Ramagnani. So, what is so about one-weight codes, what we have is that for MIM metric, there is only one way, one code. One way, one code essentially up to replication, which is the simplex, and for the rank metric, the same. So we have this simplex rank metric code, and it's the only one. So now what is the natural question that we asked at some point was what about the sum rank metric? So, and this is the last part of the talk, which is a joint work with Paulos Antonas Taso and Ferdinando Zulo. Paulos Antonastas and Ferdinando Zulo. Yeah, briefly, I want to sketch what is the setting. So we have an extension field. So in this case, we have L in positive integers, N1 L, and so capital N is the sum of them. And bold N is the vector of N1, so given by the. Of n1, so given by the ni. So the fqm to the bullden is just this direct sum, which is naturally isomorphic to FQM to the capital N. So every element, every vector of length n can be identified with a tuple of L vectors, U1, UL, which lives where every UI lives in FQM to the end I. Qm to the n i. So the sum rank weight of a vector is just the sum of the rank weight of each block, as Umberto was saying yesterday. And as Umberto was saying, you recover the amino metric by taking n to be, so n i to be all one. And if you take only one block, you recover the rank metric. And what is a some rank metric code? It's just an FQM linear subspace of this. Space of this vector space FQM to the bolden or FQM to capital N, as the same, and then we denote by bolden kd just to take trace of the blocks. And every code has a generic normal matrix, which can be divided in sub-matrices, G1, GL, where each GI is of size K times Ni. And in this case, if the columns of each GI are FQ linear independent, then the code is non-degenerate. I give it as a definition, it's equivalent to all the other definitions that you can find, at least about FQM linear, some rank metric codes. And this is an example just taking always F8 and three blocks, one of length three. Three blocks, one of length three and two of length two. This is a general matrix, and then we compute a code word which is just a vector of length two times g. And this is divided in three blocks, where the first block has rank weight two, the second has rank weight two, and the third one has rank weight one. And so the sum rank weight is five. And so this is an illustrative example. An illustrative example. Just I want to. Sorry, I'm going a bit faster, but what I want to say is that in this setting, we have a geometric interpretation and we can define the analogs of a Q system or of a projective system. So it's something that makes both the things. So it's a generalization of both, which specialize in projective systems and in Q systems, depending on if we take one of the two cases. One of the two cases. And it's the following: it's just a collection, a sequence of L FQ subspaces of FQM to the K, such that they all together, so the span of them over FQM span the whole space, generates the whole space. So they are not all contained in the same hyperplane. And the parameter D is just n minus the maximum of the. The maximum of the sum of the dimension of FQ of UI intersect an eigenplate. So, also in this case, this transform, we can transform by this point of view, we can transform metric properties of some rank metric codes in geometric property of this few multi-systems, let's say. And again, there is a, as expected, As expected, there is a one-to-one correspondence among these two objects. So, some rank medical codes which are Q am linear and these Q multi-systems. And the explanation is as you might expect. So, taking a generator matrix, this generator matrix, as I said, is divided in L blocks. And for each, so considering the rows gives you the code, considering the columns and taking considering the columns and taking the FQ span of each of the for each block you take the FQ span of the columns then you get this U1 U2 up to U al and yeah this is the main idea this is how it works I mean here are technicalities you have to be careful about equivalence but this turns out to be well defined when you restrict to equivalence classes and yeah And yeah, so in this case, the main so why this works and how it transforms metric properties into geometric properties via this lemma. So that if you take C with a code, so non-generate code with the generative metrics with the L blocks, and then we take as. And then we take as Q multi-system the collection of U1, U2, UL, which is given by the FQ span of each block. Then you can read the sum rank weight of V times G, so a code word, as N minus the sum of the dimension of RFQ of each UI intersect with the hybrid plane. intersect with the hybrid plane orthogonal to B. This is a generalization of all the results, I say, for the ending and the rank. And so this point is or the final question essentially is if we can construct one-weight codes in the sum rank metric? And the answer is yes. Of course, we have the special cases of the Ming and the rank, but we can construct more general. So not only the So, not only the extremal cases. And is it, I mean, another question is: is there a unique one-weight code also in this case? And the answer actually is no. There are many inequivalent and with different non-zero weight. And I will tell you why. So, the idea is always to have a geometric, to use the geometric interpretation and to say that we want to have constant. We want to have constant this sum of this sum of this dimension to be constant. And there is a way to construct, a general way to construct, and it relies on, let's say, on the action of a group, which is the general linear group. And we consider this action as follows. action as follows. So we can so on the space of vectors over a Qm of len k just gl k naturally at so by a multiplication. So if you consider as a matrices and this action can be extended to the set of n-dimensional vector q subspaces. So just instead of considering the action on a single vector you consider the action on subspaces and then And the main thing is that the main result is the following. If we take a transitive group, subgroup of GL of the general linear group, and we take union, possibly union of, but let's say an orbit. So this UI form an orbit of the induced action of G on n-dimensional FQ subspaces. Subspaces, the associated code is a one-weight code. This is a general result, and like we applied it for constructing simplex codes, so the analog of a simplex code, and it's using the singer subgroups. So, singer subgroup is just a cyclic subgroup of order of GLKQ to the n of order q to the k m minus one. So essentially. Minus one, so essentially is a copy of the multiplicative subgroup of the extension field of QKM. And they are all conjugated. This is known, this is something known in the literature. And actually, conjugated subgroups give equivalent codes. And the main idea is how to construct, actually, how to see this code. How to see this code, you can take the minimal polynomial over FQM of a primitive element of the extension field FQ to the Km, K times M, and take the subgroup generated by the companion matrix of P. So the companion matrix will live in GLKQM. Actually, this is technical, but you can consider an induced But you can consider an induced action, so up to equivalence of codes. You can consider an induced action of a quotient group. So you can consider just essentially this group modulo FQM star, where FQM star means lambda identity for lambda non-zero element in FQM star. And we called and simplex code. They code whose orbit essentially, which is an orbit of this action. And it depends on which orbit we take. So we can fix one subspace and consider the whole orbit after acting on it via this G bar. And this construction actually generalized. This construction actually generalized simplex coding M-ming because the transitive group actually transitively acts on one-dimensional subspaces because this is the second of the M-ming metric. So, and the orbit has to be the whole space. That's why we got the simplex code in the M-ming metric. And for the rank metric, we are forced to have L equal one. So, actually, having a full orbit, which So, actually, having a full orbit, which is only one element, then we need that the Wool space, so the space, the system U, has to be the Wool space. And this corresponds to the simplex magnetic code. And I conclude with an example, which is the following. So, actually, we are we have to consider two extension fields. So, we have F4 and F16, and F16 is actually just to construct the To construct the companion matrix MP, which is given here. And we take G bar to be this set of representative, so of the first four powers of this companion matrix. For instance, we take now V any one, we take this span of the generated by these three vectors. By these three vectors, and what is the three simplex code is actually given by the orbit of this induced action by G bar. So it's A. So now the action of M of this of the first, so A is just identity of M's A. Then we have all the elements of G-bar detects, and we put all together as blocks of our big generator metric. Of our big generator matrix. A indeed is just form, we put as columns this basis of B. So alpha 1, alpha squared 0, 0, alpha. And this is the wool matrix, and the only sum rank weight is 9. And in general, there can be many, and it depends really on the choice of B. So in this case, it's nine, but there could be, we could construct one with the same parameters, but with a different one weight, with a different weight. And the fact is the following, which concludes the presentation. So is that the only weight is given by this formula. What is this formula? What does it mean? So if since for our construction, we start with. Since for our construction, we start with D, an FQ subspace of FQM to the K, and if we assume that this is not containing an hyperplane, then we have actually, this is a Q system V, and D, we can think of D as an associated rank metric code. Then the only non-zero sum rank weight of the weight of the syntax code start obtained by starting with V is the is this formula so it depends only on the sum of the rank weight of all the code words of the code and just to say this is not constant in con in construct in in contrast with the to what happens with them in matic the sum of all the weights in the rank metric is not constant It's not constant. And yeah, I conclude. So this gives many equivalents simplex, inequivalent simplex codes. And I conclude. Thank you for your attention. Yeah, thank you very much, Alessandro. Are there any questions, remarks, or whatever from the audience? If not, then let me ask something. Oh, yeah. Oh, yeah, somebody asked. Yeah, please. Yes, I have one question, Alessandro. Yeah, and when you give the geometric representation for a linear code, just the classical linear code with the Hamil. So it seems that for you, as you are taking the projective points, well, the coefficients are not important, right? So you take the monomial equivalent. So this means that the L C D property, so do you know. CD property, so you know the L C D property, right? Yeah, so you lose all the also the exception of toven, you lose those properties, yes, there are properties that so I was wondering if it is possible to use a fine geometry so you don't lose those properties. So, in this case, okay, okay, I can tell you something. So, this is a way of seeing so you can. Way of seeing so you can think of actually instead of going into equivalence classes, it's a bit more delicate because then you have you need to do, let me go back to the to the beginning. I don't know how to go maybe here. I start doing this. So the fact is that you can you don't have any more representation. Or represent a one-to-one correspondence. You can associate to each generator matrix a set of vectors, so not a set of projective points. So this is the thing. Maybe you can still avoid this. But yeah, you can do something. So instead of going in the projective space, you can stay in the lecture space. In the vector space, Fq to the K, and think of instead of considering essentially projective points, which are the one-dimensional substances, you just consider the set of vectors. I guess this could tell you something, but I don't know if you're... I mean, this for sure in this moment, in this way, you distinguish equivalent code, but I'm not sure if. I'm not sure if there is a way still that to maybe yes, there might be a way in this doing this to look at L C D properties at photograph properties, things like this. Might be. Thank you. Thank you. Yeah. Are there any further? Any further questions or remarks? Yeah, I have a question for the, oh, sorry. Go ahead. So here's a question from Oaxaca. So, here's a question from Oaxaca. So, for the construction of the locally recoverable code from the, you had the rational normal curve up there. I guess there's two questions. So, the first question was: I guess I would kind of think when you're doing this partition into subsets of things that maybe on other, on homogeneous spaces, there'd be some analog of having good locally recoverable codes. But you said there were some bad points, which is this is this because of the finite characteristic aspect? Because I mean, every point on the rational normal curve is basically the same. Is basically the same. So yeah, I'll. Okay, can sorry, sorry, I don't want to interrupt you. So. No, so there were two questions. First was what was this issue with the bad points on the rational normal curve? Is that a finite characteristic phenomenon? And then the second was maybe, again, if you're looking at sort of sets of partitioning sets of points, a natural candidate seems like it would be homogeneous spaces or something like this. Homogeneous societies. Let me. let me let me answer the first first let me answer the first question so the bad points um so okay this is this depends a bit so but the bad points pops up when you construct this small so this smaller smaller degree rational marks because what can happen actually is that there are points which are aligned Which are aligned in that with respect to different, so you have several at this point rational normal curves, okay? And what can happen is that there are some points which are aligned. And in principle, I mean, this is not a real, a big, big problem, but if you want to study the very, very extremal, I mean, aligned what they, when I mean aligned, yeah, let me say aligned, but they are. Let me say a line, but they are not optimal in some sense. So, and when you study really extremal situations, so when we studied the Bashel and the Scotts, this was a problem because that was the fact that was the problem because there were essent having points which are aligned means that doing operations and doing operations on the code, you don't have any more an MDS code. You don't have anymore an MDS code, but that was about the global property. So we have to remove some of them. So essentially, what we did is if we had some aligned point, we removed only one of them from one curve. Then we add another set of aligned points and we remove. Line points, and we remove only one of this point, but from another curve, and so on. So, this helped us in keeping balance the cardinality. So, from each curve, we add exactly the same number of points. And yeah, this is essentially a problem because when you restrict these curves, you study these smaller curves than among Smaller curves than among each other, you are adding other points, not considering this curve. And these other points can be bad. This was the thing. So the bad points are not really removed on the original big rational curve, but from the small ones. Okay, let me interrupt everything here. I think some of us are waiting desperately for the break, which is here by open. Is here by open. See you in roughly half an hour back. Thank you very much, Alessandro, again. It was a very nice talk. Thank you. Let me add that if there are some more questions, we could all meet in gather. So you can.