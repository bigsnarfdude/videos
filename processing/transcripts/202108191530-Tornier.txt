Yeah, I don't think, yeah. I mean, I could either share my whole desktop as I'm as I'm doing now or switch between things, but it's easier this way, I think. All right, okay. I think it's time to start. Okay, I think it's time to start. So, our next speaker is Stefan Tonier from University of Newcastle, talking about a gap package for self-replicating groups. All right, thank you. I should have asked you. You're happy to be recorded. Yes. Okay. Recorded and publicized. Yes. Okay. Thank you, Colin, for that introduction. And thanks to the organizers for the interest in my. Organizers for their interest in my work. So, yes, I want to speak about a GATT package for self-replicating groups. And let me first give you an overview of my presentation today. So, I'm going to start by defining what I think is a self-replicating group, and it's going to be a group acting on a regular rooted tree, like the one that you see here, where every vertex has two children, and which goes on to Goes on to infinity. So the gray layer here is meant to indicate that this pattern keeps going. So you have an infinite regular rooted tree of some degree, in this case degree two. And a self-replicating group is going to be something that's a group acting on this tree that replicates itself in the sense that if I look at the stabilize of some vertex, say this left child of the root. Child of the root vertex here. If I look at the stabilizer of that and act on the tree below it, then well, you can see that that tree is naturally isomorphic to the whole tree, you know, just as a graph. And I want the action on that tree to be exactly the same as the action of G on the whole tree. So that's going to be what a self-replicating group is. And then I'm going to go through two examples of these. Before pointing out reasons why you should study these groups, and there are some recent striking results by George Willis, but also other results by many other researchers that spiked my interest in these groups. And then once we've done that, I want to go towards that gap package. So I want to study these self-replicating groups by truncating the tree. By truncating the tree at some depth, and then study the finite permutation group that you get on the leaves of that truncated tree. So I'll talk about what that gap package is up to at the moment, and then I'll be very interested to hear if you have any comments or suggestions for that, because it's still in development. All right, so let's start with. Okay, so I should say there are a number of related concepts in this space, such as self-replicating groups. Such as self-replicating groups, self-similar groups, groups with property are groups with property are n finitely constrained groups, branch groups, and the list probably goes on. And I bet there are some similar notions that I'm unaware of. And what I'm going to talk about are actually groups that have property R or property Rn, which is a strengthening of what people usually call a self-replicating group. But I'm going to ignore that mess and just call them self-replicating. mess and just call them self-replicating anyway because if you don't know about all these things then that makes more sense and if you do know about these things then well you know that I'm wrong all right so then I should also say some researchers in this space that came to my mind are Lauren Bartoldi Rotislav Gikorchu Gupta and then there's Daniel Horodam who wrote his PhD thesis with George Willis I think it's about six years ago or so and he introduced these properties R and R. Introduce these properties R and Rn that I'll be talking about. So that's what all this is based on. But then Nikrashevich, Sitki, Zoran, Sunik, George Wilis, and again, the list goes on. So let's start with the definition of a self-replicating group. So to make precise what I mean between saying that the tree below some vertex is isomorphic to the original tree, I'm going to label the vertices of this tree. Going to label the vertices of this tree. So let x be a set of size k at least 2 and look at this infinite regular k regular rooted tree. So in this case, k was equal to 2. And now I'm going to label the vertices of that tree by the words over the alphabet x. Okay, so for example, if the alphabet is just 0 and 1, and I'm in the two regular case. The two regular case, then, well, words over that alphabet are the empty word epsilon, which is at the top here, 0, 1, and then 0, 0, 0, 1, and so on. So you label these vertices in a regular fashion. And I also want to fix one particular element of the alphabet, call that x naught. So then here's the definition: a subgroup. A subgroup acting on this infinite regular rooted tree is self-replicating if two things happen. First of all, I want the action to be transitive on the first level, or in other words, on words of length one over the alphabet. All right, so in this case, I would want the full symmetric group on two elements acting at the first level. And then I want this condition about the stabilizer and trees being isomorphic. So, the way that works is I look at the stabilizer of x0. And let's just say x0 is zero in this case. So then I'm looking at that stabilizer acting on this tree below, hanging below zero. So I take an element of that stabilizer and I map it to That stabilizer, and I map it to an automorphism of the full tree. And to describe that automorphism of the full tree, I'm going to say, what does it do to any word, to any vertex in the tree? So take the word, prefix it by x naught. So for example, if I took the word one and I prefix it by x naught, I get zero one. I'm here. And then I can act on that by g, which fixes zero and Which fixes zero and takes this, you know, somewhere in this subtree. And I want this map to have image precisely G. Okay, so this is a homomorphism from the stabilizer into the full automorphism group. So the image is going to be some subgroup, and I want that to be precisely G. So intuitively, what this means really is the action below zero is precisely the same as the action. The same as the action on the full tree. All right, so that's a self-replicating group for me. And so that has a few consequences. For example, the group is actually going to act transitively not only on the first level, but on every level, precisely because of well, precisely because of the two conditions. It acts transitively on the first one and then on the second. Transitively on the first one, and then on the second one, since I'm acting like g below any of vertex zero, I act transitively on those two, and then I can take zero to one and also act transitively there, and so on. So it's it's level transitive, if you like. And another consequence is going to be that the action of the stabilizer of any vertex, you know, could be further below, somewhere in the tree, below that is also equal. Below that is also equal to the full action on the tree. So the group really replicates itself in that sense. All right, let me give you two examples that look very similar, but are actually quite different. So I'm going to take a prime number p and I'm going to take as alphabet the numbers 0 up to p minus 1. So I'm looking at a p regular. P regular rooted tree. And this picture precisely corresponds to the case where p is equal to 2. I have labels 0 and 1. Okay, so now let's look at the boundary of that tree. So all infinite sequences starting from the root to infinity, or if you like, infinite words over that alphabet. I'm claiming that that I'm claiming that that set is a natural bijection with the p-adic integers. So, how does that work? I take a boundary point omega, which is an infinite word with letters w1, w2, and so on, which are all elements of that alphabet. And I send it to this periodic integer, formal sum, where I really just take these elements of the alphabet as co-existent. Elements of the alphabet as coefficients for the p-adic number. So, you know, for example, if I took the end all of whose coordinates are zero, then that in this picture would correspond to the left, the leftmost ray of that tree. Okay, yeah, so the boundary is in bijection with ZP, which is good because that's something. Because that's something I can act on. And I want to act on this boundary with Zp itself. And the action is just going to be a p-adic integer acts on that by adding it to the end. Just a plus omega. P-iadic addition. Yeah, that's an action. So ZP is. Yeah, that's an action. So ZP is a group under addition. All right, so why not act like that? And I'm claiming. So now I'm acting on the boundary and acting on the boundary, of course, induces an action on the tree, you know, where for any vertex completed to an end, act on that end and then truncate it back to the tree. And I'm claiming that that's a self-replicating subgroup of this regular rooted tree. Subgroup of this regular rooted tree isomorphic to Zp. So let's think about that. We'll have to figure out what the stabilizer of the vertex zero is. And if you think about it, the stabilizer of zero is just going to be PZP. You're looking at p-adic integers that when added to a p-adic integer, which starts with a zero, is still zero. Which starts with a zero is still zero. So that should be any p-adic integer which starts with a zero, which is precisely p times z p. So here's a picture. So let's think about why that is transitive on the first level. Well, again, so you could just take the p-adic integer a, which is the sequence one, and then just zeros. If you act on that, If you act on that, if you act with that on this vertex zero, you get to one. So you're transitive here. And then I want to think about: well, why is it self-replicating? So the stabilizer of zero is this PZP, and how does that act on the tree below zero? Well, it's, I mean, I'm exactly adding p-adic integers that start with a zero to p-adic integers that start with a zero. P-adic integers, let's start with a zero. That's precisely the same action of just adding p-adic integers to p-adic integers. So the action below here is set p again. So it is self-replicating. And now what I've drawn in blue here is the action of the p-adic integer 1, so that's the sequence 1 and then just zeros on this second level. So for example, the vertex 0, 0. Vertex 0, 0. If I add 1 to that, I get to 1, 0. And then if I add 1 to that again, I get 1 plus 1, which is 0. Carry the 1, so I get to 0, 1. And then I add 1 again, I get to 1, 1. And then if I add 1 to that, well, I have to carry the 1 two times, so I get carried away, so to speak, and get to 0, 0. Alright, so that's the action on the second level, for example. The second level, for example. Now, here's a similar example. Instead of saying the boundary is isomorphic to Zp, I could also take power series over Fp. You know, power, it's exactly the same space. I take an end, an infinite word, over the alphabet, and I send it to the formal power series. Sorry, this B should be a W. Changed notation there yesterday. Changed notation there yesterday. Just a power series whose coefficients are the letters from that end. All right. So then again, I have an action of power series on power series just by addition, a plus omega. And again, I'm saying that that is self-replicating. So as before, the stabilizer. As before, the stabilizer of zero is just going to be, you know, I have to add, I have, I take power series that start with zero and I want the first coordinate still to be zero. So I better start with a power series that starts at t and not before. So that's the stabilizer. And again, you can convince yourself that that's transitive and the action on the tree below zero is the whole. On the tree below zero is the whole thing. But the action on the second level is quite different. And that's just because of the arithmetic in Fp of T. So now zero, zero goes to one, zero. But then if I add one again, the power series, those coefficients are one and zero after that, I get back to zero, zero instead of getting to zero, one as before. And similarly here, And similarly, here I have this order two thing going on as well. So, in fact, it's going to be the case that for the p-iadic integers, the action of one on any given level is cyclic, whereas here I have a bunch of transpositions. So, in fact, it then turns out that this group here is That this group here is the closure of a cyclic group, which makes sense because Zp is the completion of Z, and here it's not going to be topologically finitely generated in the boundary, in the limit case, acting on the whole tree. So there are two examples to keep in mind. Now, let me talk about the greater significance of these groups. So here's a summary of Here's a summary of recent results by George Willis primarily, and these are really quite striking, I think. So basically, he says there is a correspondence between pairs of TDLC groups and automorphisms such that the scale of the inverse of that automorphism is bigger than one. Okay, if you don't know about the whole scale. About the whole scale and tidiness business, I'm sorry, I don't have time to go into that today. But let's just say that's sort of the generic situation, I think. If you have a TDLC group and an automorphism, then typically, or at least there are many examples where the scale of alpha inverse is bigger than one. So that is this S here, it's an integer-valued function, and it's related to the modular function. Okay, let's just leave it at that. So, basically, pairs of TDLC groups and automorphisms. Pairs of TDLC groups and automorphisms, they are in correspondence with subgroups P acting on a regular tree, so a truly regular tree, not a rooted tree, of degree scale of alpha inverse plus one. You know, the same as in many other talks this week, just a regular tree. So, subgroups of that which fix a Of that, which fix a boundary point omega and which are also vertex transitive. Okay, so that's a that's a whole different object, I would say. And then those are also in correspondence with subgroups with self-replicating groups acting on regular rooted trees where the degree is precisely this scale of alpha inverse. Of alpha inverse. So let me tell you a little bit about how this correspondence works. So the first one, this is probably the most mysterious one, and that's a result due to Baumgartner-Willis from 2004, who say that if you have a TDLC group with an automorphism like that, then there's a subgroup associated to that automorphism. Which acts on a regular tree, fixes an end, and is vertex transitive. So I'm not going to go into that much more. But once you have that, you can look at a point stabilizer in that group P. Okay, so now you have a group fixing an end and you also fix a point. And then you look at the rooted tree that hangs off V and points away from the Away from the end, okay? That's a regular rooted tree. And then they say, well, he says that the action on that rooted tree is self-replicating with respect to a suitable labeling of the vertices. All right, and in the other direction, if you're in the middle here, you have a group which fixes the boundary point and is vertex transitive, well, then it's easy to go to the left. You know, that is a The left, you know, that is a TDLC group, and the automorphism of non-trivial scale that you want is conjugation by a translation towards that end, which exists because this action is vertex transitive. And here, if you have a self-replicating group acting on some rooted tree, and you want to get something acting on a full regular tree of degree one more. Tree of degree one more, then you have to come up with a clever labeling of that tree, which singles out an end. And then you have this sort of local action type condition where if you go from the rooted tree into the big tree, you know, tree pointing away from the end, translate that somewhere in the tree, and then go back from that to the rooted tree. It is an element of this particular self-replicating. Replicating. So, at first, I would say this class of self-replicating groups might seem quite special, but it really is, it comes from general TDLC groups and their automorphisms. And just to give a little bit more detail here, in the case of the p-adic integers, the TDLC group that you would start with would be the p-adic numbers, all of them, which is a topological group under addition. The automorphism. The automorphism would be multiplication by p, which is an automorphism of scale one, but its inverse has scale p, which is bigger than one. That's what I want. And then the group here in the middle, the one acting on the regular tree, it is going to be a semi-direct product of Qp with the group generated by alpha and this alpha. And this alpha is going to play the role of a translation, and then you have to see how QP acts on that tree. And the P head is going to be precisely the ZP that we just talked about on the previous slide. And maybe I can say that it is in general going to be the case that P has this form, some subgroup of the original group, semi-direct product alpha. Semi-direct product alpha. And in this case, that subgroup happens to be precisely equal to the original group, but it doesn't always have to be like that. And in the case of the formal power series, it's quite similar. You start with the formal Laurent series, which is a TDLC group under addition. You multiply by P. Again, the scale of the inverse of that is P you get this group acting on a regulatory. Group acting on a regular tree. And if you restrict it to the rooted tree pointing away from the end at some vertex, you get power series. So that's one reason why one might be interested in studying these self-replicating groups, but there are, of course, many others. I mean, they were the first examples of groups of intermediate growth, and they were also the first examples of non-elementary. The first examples of non-elementary amenable groups they have applications to just infinite groups, fractals, and again the list goes on, I would say. All right, so that's that. Now, how am I going to study these groups computationally? I mean, they are TDLC groups, they act on the full tree. I'm going to do that, like I said, by truncating the tree to some level. I'm just looking at the clock. At what time did I start? Seven, twenty-five minutes. All right. All right, so now I take this regular rooted tree TRK, but I truncate it at level n. Okay. And again, I'm going to label the vertices of that as before, but now I only have to use the words. Use the words whose length is at most n. It's the very same picture as before. And again, I fix a point in the alphabet. So then here's the definition. A subgroup of this finite tree is going to be self-replicating if two conditions are satisfied. Again, I wanted to act transitively on the first level. And the second condition is similar to before. Second condition is similar to before, but now if I take the stabilizer of that vertex x naught at level one and I restrict to the tree below that, it has depth one less than the original tree, right? Because I'm now looking at a finite tree, whereas before it was infinite. So, but if I do the same sort of thing before, as before, I take a word, I prefix it by x naught, and then act with g, I want that to. I want that to, you know, sort of act like G, but not exactly. I have to take the restriction of G to level one less than the depth of the tree. Okay, so I have this tree below X naught and I put it back to the top, but now it doesn't reach to the bottom anymore. So that's where this n minus one comes in. Yeah, but otherwise very similar. And indeed, Otherwise, very similar. And indeed, so this was a theorem from Daniel Horodem's thesis. If you start with a group acting on the full tree and it's self-replicating, then if you restrict that to some level n, or in other words, if you truncate the tree at level n, you get something that is self-replicating in this finite sense. I mean, that's not very hard to see. If you act transitively on level one of the level Know if you act transitively on level one of the full thing, then if you restrict, you still act transitively. And if you act like G below some vertex, then if you put it back, well, you still act like G. So that's the easy direction. But then in the other direction, if you have a sequence of self-replicating groups acting on finite trees, one for every n, and if they are compatible in the sense that the next one always restricts. Next one always restricts back to the previous one, then you can take an inverse limit of them, and the result is going to be a group that is self-replicating acting on the infinite regular rooted tree. All right, so that's the reduction step here. I want to study the group acting on the full thing by truncating to some level. And the two concepts are related by this theorem. By this theorem. So let's get into this gap package then. So, this is something that George Willis initiated in one of our conversations, I think, almost a year ago, actually, and which we then pursued together with some local students in Newcastle, Samuel King and Sarah Shota, over the past year. And, like I said, this package is still in development. Package is still in development, but I want to show you what it's up to by now. So, our objectives are the following: first of all, provide some basic methods for subgroups acting on regular rooted trees. So, first of all, you know, generate the full automorphism group of one of these finite trees, which is an iterated wreath product. But then, for subgroups of that, provide methods like Methods like you know, ultimately provide a method that says whether or not it's self-replicating, which means, okay, you have to check is it transitive on level one? For its elements, you need to be able to compute how does it act below a given vertex and then compare that with the original group. So you need restrictions as well, that sort of thing. And then using that, establish a library of self-replicating. Of self-replicating subgroups of these truncated trees. So for every k and n, I want a list of all these self-replicating groups in the finite sense acting on that tree. And notice that if n is equal to 1, so what does that mean? I'm looking at the tree of depth 1, then what am I looking at? So then the second condition of this definition of Of this definition of self-replicating is void, and I'm only asking that I have a group that's transitive on those vertices. So, this library is going to extend the library of transitive groups that's already inside GAP for n is equal to 1. And then once you have a library, well, you want methods to go through this library, right, to search the library. And I imagine this to be quite similar to how you would go through the library. To how you would go through the library of transitive groups. You can access these things and ask for groups with certain properties and so on. I'll show you in a minute. And then, well, a library by itself, you know, if it just contains the raw data, it's not very helpful. I really want to identify known families of self-replicating groups and constructions in this library. So, for example, if at some point that group really comes Point that group really comes from the action of Zp, I want the library to tell me that that's the case, you know, rather than say it's the 14th group on degree two, level three, whatever. And we've also thought a bit about providing methods to visualize this library. And speaking about vision, if you feel like your vision becomes blurry, that's because I've used different shades of gray here to indicate to what. To indicate to what level the development is up to with these different objectives. All right, so let me jump into GAP now and show you how all of this works. And then my question to you is going to be, since this is still in development, if you have any suggestions or comments on that and if you, you know, if you would do it differently or change something or add something. So let's do that. Oops. So I'm going to move. So, I'm going to move the presentation to the left here and jump into the terminal on the right, which I hope people can see. So, I'm loading a gap session here, maybe a little bit bigger, and then I load this package, which at the moment is called SR groups for self-replicating groups. So, then, like I said, it starts with providing a method to generate these automotive. Generate these automorphism groups. For example, OT23 should be the automorphism group of the two regular rooted tree truncated at level three. So that's a tree which has eight vertices. And I'm going to call them one up to eight, you know, enumerated from left to right, if you like, with respect to the previous labeling. That is just what GAP does automatically when you talk about iterated wreath products. About iterated wreath products, so that's very convenient. Let's do it that way. So I can swap the first two leaves, I can swap leaves three and four, and so on. And then say I wanted to check if this is self-replicating, I would have to do something like take the stabilizer, maybe let's call this group G, and then I would have to do something like take the stabilizer inside this group. Inside this group of the leftmost vertex at level one and the leftmost vertex at level one. Fixing that is like saying you fix the first two leaves setwise. Okay, so this would be the stabilizer of the leftmost vertex at level one. And then if I had an element of that stabilizer A, I would have to compute how does that element To compute how that element acts on the tree of depth two below that vertex. So that's something we've implemented. Let's say I have an element A acting on a two regular tree of depth three below the first vertex one. That's going to be some action, some permutation of the four leaves below that vertex, but taking into account that that tree is isomorphic to That tree is isomorphic to the tree of depth two. So that has four leaves and it's some permutation. All right, so that's the sort of thing which goes into providing a method that checks whether a group or not is self-replicating. And in this case, I'm looking at the full automorphism group. So, of course, that's self-replicating. Other things that are relevant is I need to be able to look. I need to be able to look at the restriction to the level above, and I call that the parent group of something. So, in this case, I have the automorphism group at level three. If I restrict that, I get the automorphism group at level two, hopefully. So, this should be equal to O T22, which it is. Okay, another concept that Daniel Horodam introduced in his thesis is that of a maximal extension of Extension of a self-replicating group. So he proves that whenever you have one of these finite trees and a group acting on that, which is self-replicating, then there is a largest group which acts on the tree that is one level deeper and is also self-replicating and restricts back to that group. And he calls that the maximal extension. Okay, and it's Okay, and it's some permutation group. And in this case, we would hope that that's just the automorphism group of the full tree at the next level. But if I had started with a subgroup of OT23 and taken the maximal extension, it would be some subgroup of the full automorphism group at the next level. All right, so that's the provide basic methods for G part. Then I said we want to establish. Then I said we want to establish a library. So we've done that in the cases that were computationally feasible so far. And it's a bunch of text files. And now you want to be able to access these groups. And that is quite analogous to the transitive groups library. So you could ask something like: are the self-replicating groups of the two regular tree at depth 3 available? At depth 3 available in the library. Okay, they are available. And in fact, the largest depth for the two regular case we've done this for is level 5. And then at 6, they're no longer available because we haven't pursued that with all our computational resources yet, I suppose. So it's up to level 5. And you could also ask. And you could also ask which levels are available for a certain degree. So for example, if I look at the three regulatory, then okay, at the moment only levels one and two are available. And in fact, after that, at the moment, we only have the transitive groups, you know, which are already there in the transitive groups library, because it's it's very uh intensive computationally to compute these things. To compute these things. All right, so let's dive into this a bit. We could ask how many self-replicating groups are there in the two regulatory at depth two. And this says there are three. And those three groups are the one coming from the p-iadic integers, the one coming from the power series, and the full automorphism group. Automorphism group. So I could now go into that and access these groups. I could say take the two regulatory at level three, the first group. Okay, it just gives you back this thing because we haven't named that group yet. But the point is, if I ask what is the structure of this thing, oops, should have been at level two. What is the structure? What is the structure of that thing? It's precisely that cyclic group of order four that we've seen in the diagram before with the blue arrows. And the second group is, well, it has the structure C2 sign times C2, which is the one we've seen with the power series. And then the last one should be equal to the full Full automorphism group. Oops, yeah, except it's at level two and not. Yeah, okay, now I've used last too many times. There you go. It's isomorphic to the full automorphism group at that level. Right, so that's the idea there. And then you can see how far we've gone. Then you can see how far we've come with this library. If you ask how many groups there are at depth five, there are 2,400 groups. And now, what's interesting about that is, so you have 2,000 groups at level 5, right? But that also means that if for each of them you compute the maximal extension and you keep doing that up to infinity and you take this inverse limit from Daniel's theorem, then you get a self-replicated. Then you get a self-replicating group. And these groups will all be different because they are different at level five already. So you have 2,400 different self-replicating groups acting on this two regulatory already. And then you can filter through this library again in the same way you would filter the library of transitive groups. You could ask for everything that has degree two and level four. Two and level four, and for which the function is abelian returns true. Okay, and then it tells you: okay, the first, the ninth, the thirteenth, and the fourteenth group at level four, they are abelian. So you have this library, and you can, you know, search through it and do your analysis. And like I said, if you do this for groups at level one, then you should. At level one, then you should get back the library of transitive groups. So, the way we've done this here is we name these groups precisely in the same way as they are named in the transitive groups library. Yeah, so that's the establish a library and provide methods to search the library part. Now, the identifying known examples and constructions at the moment. Examples and constructions at the moment, we're just doing these transitive groups. But what we really want to do is, you know, if you have a large list of groups, you know, rather than naming them one up to 15, you really want to say, okay, some of them come from periodic integers, some come from power series, some are maximal extensions of groups at the previous level, and so on. So I want to get some more meaning into this library. And then the last. And then the last part: providing methods to visualize the library. That's not really in a presentable state yet, but I can show you what I mean by that. Say I had some group acting on one of these trees. So let's say two regular depth two, and I take the first group. Now I could ask: what are all the groups at the next level that produces? The next level that projects back onto this one. And that's a bit of a long command, which I think I'll have to rename at some point. But you ask for conjugacy class representatives of self-replicating groups, sorry, self-replicating subgroups with projection conjugate to this particular one. Okay, that's a bit long, but that's the way it is. And you get a list of two groups. A list of two groups, each of them acts on the tree at level three. All right. Two groups project onto that particular one. And if I do the same thing with the other two groups that I have at level two, I find that, okay, I get a few more projecting onto the Laurent series example. And I get even more projecting onto the full automorphism group. So I think of this. Group. So I think of this library of having a tree-like structure itself. For a given degree, I have as many roots as there are transitive groups of that degree. In the case of degree two, that's just one. Then at level two, I have a number of groups. They all project back to the first one and then so on. And they have different number of children depending on the groups. So I would like to visualize that tree. So, I would like to visualize that tree and then analyze that because there are some conjectures and statements in Daniel Hordem's thesis that say, okay, certain groups, they have very few extensions, you know, at any degree and certain have very many and so on. And then ultimately, I want to go back to the so once I want to basically use that package to. Basically, I want to use that package to go back to this greater significance picture here and really translate that back to the TDLC group side. So you can think of this as sort of a, well, I think of that as sort of a self-replicating spectrum of a TDLC group. You take the group, you take all its automorphisms whose inverse have scale bigger than one, you get a self-replicating group. And then, well, that's some spectrum of self-replicating groups, if you like. Self-replicating groups, if you like, and what is that? And how do properties of the group correspond to this group, this collection of self-replicating groups? So, in that sort of situation, I think a package like that can be quite useful, but maybe you can make use of that as well. All right, so that's pretty much all I wanted to say. So, I'll stop there. And really, if you have any suggestions or comments, Or comments, please let me know. Thanks, Stefan. So, yeah, anyone got any questions or comments? I have a question, and I'm sorry to ask it almost, but anyhow, I noticed you're using gap and not. Using GAP and not magma. Have you been talking to the magma people at all? Is there a possibility of implementing it in magma too? I haven't talked to the magma people yet, but I would keen to do that. The reason I'm using GAP is that's the first computational package, you know, software package that I found many years ago. And that's what I started using, and that's what I'm more or less proficient with now. But yes, one. But yes, why not use Magma indeed? Well, both really, but it would be a shame for Magma not to have it in a sense. Hello. Another obvious question. Is this available anywhere? This is in development state on GitHub at the moment. I will definitely send. I will definitely send you a link to what it's at now, and you can download it. Yes. And since you have experience with this calculation, so how often does it happen when you start with this automorphism on the George Willis side and you arrive at a self-replicating group? How often they are actually finitely constrained? Do you have any feeling about that or experimental results? Oh, I have very little feeling about that because I haven't really looked into that yet. Really looked into that yet, but maybe George has an intuition whether or not these should be finitely constrained. Thanks. Could I say something? I think the finite constraint corresponds roughly to, I think, the K-closed groups we've looked at for groups acting on trees, regular trees. Groups acting on trees, regular trees. So I think typically they won't be finitely constrained. I think that's maybe there's a theorem there that says the automorphism has to be such and such, and it then corresponds to a self-replicating finitely constrained group. So we don't have such a theorem yet, you're saying? Such a theorem yet, you're saying, no, okay, that's right, but yeah, that would be interesting to look into k-close groups of which we have many examples. Yeah, thanks. I have a very vague question, and that's okay, so there are other packages. Okay, so there are other packages in GAAP, even for self-similar groups or what was Laurent's package called functionally recursive or something like that, FR groups. Maybe Zoran knows better than I do. Are you using them? Could you maybe exploit what they have done already, build on top of that? Build on top of that? Yeah, I'm not using them. And I will admit that I found out about the self-similarity package only yesterday as I was preparing this talk. But it is, I looked a little bit at that and I think it's quite different. I think it's more of an automata style definition of these groups. Yes, but for instance, you see the adding machine already, right? The P-addix is already given. Peanuts is already given by an automaton. So maybe a lot of the groups that you're dealing with are already defined by automata. Well, that's another research question then. You know, how many of these 2400 groups come from that setup? And yeah, that's something I haven't done, but yes, that's worth looking into, comparing these packages. So one, did can you comment on that any further? I think it's called what autumn F something package. The package? Yes. Autumn GRP, I think that's the name. Rachel wrote it in the chat. Autumn GRP. That's right. Autumn. And you're right, Alejandra. Laurent's packages function in recurrency groups. Groups. Well, going back to this, how many of these 2000 groups are defined by automata? Well, I don't know. It's a well-posed question in a sense, because these 2000 groups are just finite groups. They are like what I would call pattern groups. They are the groups from which you can build this huge, uncountable, self-similar groups because you're just using these pieces as patterns. So, what's hard. So, what Horadam is calling extension, it just means you use these patterns and you extend them on the next level by being compatible, you know. So, you just build bigger and bigger groups. So, these 2000 groups are just 2000 finite groups that can be used to build this big compact closed groups. And also, it's interesting to reduce this number because I'm pretty sure that, I don't know, conjugation will give you the same group basically. Will give you the same group basically. So you can see that. Yes, but the library is already up to conjugation. Okay. Yeah. I think there's, you know, there's three groups at level two, then there's 15. And then another question that I had is, well. Go ahead. Sorry, my internet connection is bad. I don't know when people are talking. Another question that I had is: you know, there are actually some people that are. Actually, some people that are attending this conference at the same time as they are attending a conference in Ober Wolfak on computational group theory. Where the result is transitive, right? So, transitive at the first level and also self-replicating implies that you're transitive on level whatever it is that you care about. You're transitive on every level. I'm sure it. On every level, I'm sure. Hang on, Alejandra. I think this time my internet connection cut out. Could you repeat what you said after Ober Wolfach? There are people in Ober Wolfach and at this conference. The Ober Wolfach conference is on computational group theory. They might, perhaps, I don't know whether they're at this audience, there might be, you know, there's probably people that care about computational finite group theory that might be able to tell you more than me. To tell you more than me, and it, and what I'm saying is that you care about subgroups of wreath products of groups that are also transitive, because transitive on the first level and self-replicating implies transitive at every level, in particular at the last level. So it might be that there are already methods in maybe even in GAAP to deal with all these transitive, imprimitive subgroups. Subgroups transitive imprimitive groups, subgroups of wreath products. I don't, I don't know. Um, yeah, I think at the end it comes down to being able to compute conjugacy classes of subgroups of this full automorphism group. And yes, maybe somebody has written an that's just conjugacy classes of subgroups of iterated with products of symmetric groups. That's right. That's right. And what I'm saying is, I'm using the general purpose algorithm to do that at the moment. But yes, perhaps somebody in that field has written something that's adapted to the situation and more efficient. Yeah, I think the overlap with Hoba-Wolfach is unfortunate. I would like to have talked to those people there as well, but that's the way it is. Well, no, it's fortunate. You can talk to them now. Maybe you can ask them, hey, who's talking at the next session? At the next section. All right. Okay, so let's thank Stefan again. And we've got a longer break now. And we've got a longer break now. Next talk is at 7 p.m. Amp Time.