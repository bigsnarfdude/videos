Okay, yeah. Very good. Alright, hello everybody. Good morning, good evening, good night. Wherever you are. We're happy to continue with the discussion today. We have three topics. We have three talks starting around now. Our first speaker will be Tristan Buckmaster. We'll be giving a talk on self-similar blow profiles for 3D Euler. So, Tristan, go ahead. Thank you very much for the invitation. It's great to be here. Great to actually go somewhere for once. I wrote this talk in the last couple of days, so I mushed things, and I just realized I have not listed any of. That I just realized I have not listed any of my collaborators on the title page. So, my collaborators are Yonji Wang, Chinyang Lei, who are from the geophysics department in Princeton, and Javier Gomez-Serrano, who's in Brown at the University of Barcelona. So let's just start with a nice problem that a lot of us would like to solve. So, we all know the incompressible 3D Euler equations. 3D Euler equations. So the open problem is: does there exist smooth, finite energy initial data which will lead to a singularity in finite time? So this is a fundamental problem in PDAs. And so, yeah, this is sort of a motor wave. This is a problem we're interested. So if we assume axis. If we assume axisymmetry, then we end up with these equations here. So here is. The infinite domain. So this is in the infinite domain. To begin with, and then I'm going to switch. Well, it's still in an infinite domain. So this is just the axisymmetric Euler equations. So one thing to keep in mind is half the papers published. Papers published in the literature have the wrong sign. So that's, I hope, in, I hope for at least this version I've got the correct sign, yes. But that's one thing to mind if you ever work in this area is that get the sign of this right-hand side correct. And I'm talking about published papers here. Half the published papers are the wrong side. So this is just the So, this is just the axisymmetric equations. Now, I want to introduce the Lu-Hau scenario. So, the Lu-Hau scenario is axisymmetric Euler with a boundary. And the boundary is a cylindrical boundary. Now, you can, so this is in the X3 direction for cylindrical polynomials. So, you can either consider it inside the cylinder or outside the cylinder. The cylinder or outside the cylinder, it does not matter. So, Lao, How consider inside the cylinder, I prefer to consider outside the cylinder, but this is the picture. A singularity will form on the boundary in this point. There's a hyperbolic point here. And so we'll restrict to the exterior domain. And so, in 2014, they provided compelling numerical evidence that under this scenario, a seed That under this scenario, a singularity can form. And they show this by showing a dramatic growth in the vorticity by a factor of 3 times 10 to the power of 8. The numerics also suggest an asymptotic self-similar scaling at the time of the singularity. So if you zoomed in at this point here where the singularity is occurring, you'd end up with an asymptotic self-singularity. End up with an asymptotically self-similar solution. I'm going to make this precise in the next slide. So, what does this mean? So, what I'm actually going to show you is that as we zoom in on this singularity, we'll end up with the 2D Brucines equation. So, this is the 2D Brucines equation. So, here theta is the temperature, and the temperature is just a vector. Just a vector. And let us make a self-similar Ansatz by assuming that the velocity, the temperature scale in this manner, and this choice here is the only choice that would be compatible and would end up with self-similar equations. You end up with these self-similar equations given by here. Getting by here. Okay, now if you can show that there exists a smooth solution to these equations, which is nice in some sense, which means that it doesn't grow too much at the boundary, then one can use such solutions to construct blob solutions for the LoHAL 3D Euler scenario. And this we already know how to do. To do. So you can notice one thing to note here is that the solutions you construct will have infinite energy. But that doesn't matter as long as they're nice in the appropriate sense, you're able to cut them off and turn it into finite energy solutions which blow up in finite time. And all this is known. So the hard part is finding these nice smooth solutions to these equations. Solutions to these equations. And so this, I didn't write this here, but this here we're going to consider this in the here we're going to consider this in the half plane, so when x2 is greater than 0. And we're going to assume the non-penetration condition on the boundary. And so the idea is that when you zoom in here, you end up with. You end up with Business. So, this will look like a two-dimensional half-plane. And as you zoom in, you end up with these equations. And I'm going to make this precise in the later slides. So it's useful to take derivatives of this equation. And so I like, so if you take the curl of the velocity and you take the derivative. And you take the derivatives of the temperature, the self-similar temperature, you end up with these equations here. Of course, you have to impose that theta and psi, that they are a gradient of a function. That you can resolve for theta. So, in addition, we'll impose these conditions. So, we'll impose that. So we'll impose that u1, theta, and omega are all odd in the y1 direction. So we're going to consider this in the half plane. So they're all odd in the y1 direction. U2 and psi will be even in the y direction. U2 will be zero when y2 is. When y2 equals zero, this is a non-penetration condition. And we'll assume that the theta, in order to solve for theta, we'll assume that it's zero on the y2 axis. And then we have a symmetry to remove, related to symmetry of the equation. You're not going to be able to solve this uniquely without having an additional condition. So we assume that the derivative That the derivative of the vorticity in the y1 direction is minus one. And we'll assume that the derivative u and phi, psi all vanish at infinity. And if we can construct a smooth solution to this whole system, then we would know how to turn this into a smooth initial data, which leads to finite. Initial data, which leads to finite time blowout for the Boussines equation, and therefore finite time blowout for the Euler with cylindrical boundary. Now, let's look at why does the Boussines blowout imply Euler blow-up? So, let's rewrite the Euler equation in self-similar variables. So, I'm going to write just the velocity in the The radial direction and the axial direction x3. And we write the theta component of the vorticity in terms of omega. And then we just we call this quantity r u theta squared, the derivative of this with respect to r to be psi, and the derivative with respect to x3 to be to be. To be phi. Now we make this self-similar scaling. We make this self-similar. So here, unlike before, I'm going to allow things to depend on time. So you're not going to get a stationary solution to the self-signal equations. So this is a common trick. But the difference here is that S will be, instead of at time t when you expect at t equals one. At t equals 1 when you expect the singularity to occur, you turn that time 1 to be infinity. So, this is just a common trick. And let's consider these self-cylinder coordinates. And the only difference in the Boussines equation is I'm assuming that the cylinder is at r equals 1, so I'm subtracting 1 from the radial component in terms of sus and the components. In terms of susime collapse. So you end up with these equations here. And what I just wrote is: I just wrote the susimla Boussines equations plus errors, B1 and B2. So you end up with exactly the same equations plus these two errors. And so what are these two errors? They're these ugly expressions here. The important thing to note is it has this explanation. thing to note is it has this exponential factor in the front. Now as long as lambda is greater than 1, then these errors decay exponentially fast in terms of self-immer time. So in particular they can be treated as decay enforcing. So as you zoom in the difference between Euler with cylindrical boundary and boost constant vanishes. So, in order to construct your blow-up solution to the Euler equations, you'll have to prove some stability properties of the self-send solutions to the Business equation. But this has been done in other settings. So, let me now talk about some recent results. So, Chairman Howe recently showed that Recently, showed that there do exist self-similar blow-up solutions to the Bussen-S equations, the exact same equations that I gave before, in the case that the solution is C1 alpha, for alpha very small, so for non-smooth solutions. The result itself is built on the groundbreaking work of El Gindi, who considered the case of 3D Euler in the whole space. Case of 3D Euler in the whole space, and there was later work by Ljini Gul and Max Moody that proved the stability of these solutions. And he also proved the existence of C1 alpha solutions in the case of Euler in the whole space. So one thing, okay, so let's just have a look at what these solutions look like. So they make So they make an additional non-smooth change of coordinates and they end up with an approximate solution given by this formula here for omega in terms of phi and psi. And so in particular, they can take psi equals zero. Basically, what they can What happens is that there's an exact link between alpha and the self-similar primary lambda. And so what you can think of, how you should think of these non-smooth solutions is that for a whole range of lambda, you can solve these equations and find solutions to these equations. Although the solution, Although the solutions you find will be non-smooth. And these are the solutions that Chen Hao and Jindi found. They found the non-smooth. And this is common, this is the same case for, say, the Berger's equation. You can also find non-smooth solutions for the Berger's equation in the same sort of way. But there's, as for the Burgers equations, there's discrete values of lambda where you actually Lambda, where you actually get a smooth solution. So you have to simultaneously solve for lambda and omega phi psi. But in the non-smooth case, you don't have to solve for lambda. And in particular, when alpha is very small, then it can be approximated by setting psi equals zero as well. So you end up with much simpler equations. So, you end up with much simpler equations. And basically, a bunch of terms drop out as you take alpha to zero, and that's why if you take a limit and you scale by lambda, you end up with this approximate solution. Okay, so now the problem is to construct a smooth solution. Another thing to point out. Another thing to point out is that one reason why you're interested in smooth solutions rather than the non-smooth solutions is that the non-smooth solutions are likely completely unstable. And stable, it's not like they have a finite modes of instability, they are just completely, utterly unstable. So it's the smooth solutions that will have, that will either be stable or they'll have a finite co-dimensional space of instability. Dimensional space of instabilities. Okay, so what we did is we, and so this is how my collaborators Yeonji Wang and Jing Yao Lei enter the picture. So it's a funny story in the sense that I was working with an undergraduate student. Undergraduate student who was working on ice sheet formation, where they were trying to discover the viscosity of ice, ice given like satellite pictures of Antarctica and given some model equation for the flow of ice on Antarctica. And it was an undergraduate project, and they're using these physics. These physicists form neural networks. And Yao was the supervisor for this undergraduate project. And I saw that this could be useful in solving it. So it's very difficult to find these self-similar solutions. And I thought immediately that this is a numerical approach which is very much suited for solving this complicated problem. So the setting is that we have a network for each variable that we want to solve for u1, u2, omega, phi, and psi. And we have input variables, which are the coordinates. And you feed this into the neural network, and it spits out the solution. Solution. And so these are the, it has, in our case, we have five hidden layers and each layer is there's 30 units in each layer. And so this gives you a representation of the solution and then you want to optimize. So it becomes an optimization problem. Okay, so then how do you So, then, how do you optimize? So, we'll have two types of cost functions. One will be a condition loss, which is related to the boundary conditions. So, for example, for the non-penetration conditions, we look at the mean squared error associated with the non-penetration condition. So, remember, we want to have u2 to be zero on the boundary u2 equals zero. Q2 equals 0. And NC is just the number of points that we will test. And then we also have equation loss. So we write down the governing equations and we end up with a residue error and we calculate the mean squared error of each residue. So here we have, this is the equation, this comes from the equation of omega, this comes from the equation of phi, this comes from the equation of. Of the equation of phi, this comes with the equation of psi. This one comes from the condition that this is a gradient, this comes from the divergence free condition, and this links the vorticity to the velocity. And so these are the residues that we have to minimize. And so this is the solution we get. We get, and so this actually looks slightly different than the one that we have in archive because we used a different convention for the curl on archive, which is minus the regular condition. So things are just flipped, that's all. And the self-similar scaling parameter we get here is lambda is 1.9. And so here is omega, here's phi, this is psi, this is the This is psi, this is the velocity in the y1 direction, the velocity in the y2 direction, and here the errors. And the important thing is the errors are order of magnitude smaller than the actual solution itself. Now, this is just an initial result. We know how to reduce this error by a lot. And I'll talk a little bit about I'll talk a little bit about that later. This has to do with normalization, and we already have a technique in order to reduce this error to, say, 10 to the minus 8, but we haven't implemented it. So again, when we're looking at the equation loss, we're testing it at different random points. points yi and we use we use a simple you can use a more complicated set of co-location points but this is the and indeed we use a more complicated set of co-location points when we do initial training but in order to get the final result we don't need that so here we have a bunch of random correlo prediction points and then we have a high Co-location points, and then we have a higher density of co-location points at the origin where the most important information happens. This is where the non-linear behavior happens. And this is where things become linear. So we just set two windows. And actually, this is in a sort of a semi-logarithmic scale. So this is we set y1 to be sine h of z1. So this is z1 here and z2 here. So this allows us to actually. So, this allows us to actually have a much larger domain. So, I can't remember what sine h of 15 is, but it's a very large number. And this is the error loss in the training. We actually use two different optimization algorithms, one which is very good at avoiding local minima and one which is very good in terms of convergence. Which is very good in terms of convergence. And we use 10,000 co-location points. This runs on a single GPU and takes eight hours or so. Now, so I've just presented a solution with some errors, and then one question is, why should you trust me? Why should, I mean, sure, I show you the errors. I mean, sure, I show you the errors look small, but we need some additional validation of this argument. So when we did this, we validated it against known results. So some of the known results we did is we first did Bergers, the Bergers equation, where we were able to find the Sociomer solution to Burgers, which is the easiest case. We did Gagorial, which I'll, or the generalized De Gagorial model, which I'll mention in this. Model, which I'll mention in this slide. And we also did look for the non-smooth solutions that I described before. And we could find non-smooth solutions which are close to the approximate solutions of the Hao-Chen paper. But let me just show you a simple case. So this is a 1D case, and A is a parameter, and the And the actual de Guerrero model corresponds to A equals 1 and in the next slide I'll go through this, but A equals minus 1 is the CCF model. So here's the equation and here's our self-similar Ansatz just like before and we end up with this self-similar equations here. Now we make the symmetry assumption that a man Symmetry assumption that omega and u are odd, and we fix the derivative of omega naught to be two, which removes one of the symmetries from the equation. So the rigorous, yes? Okay. Rigorous results. A equals 0 is the Constantine-Lax-Maider model where you can write down the solutions. A equals minus one is the Cordoba-Kordova-Fontelus model, where they show by By a simple virial argument, that you have singularities, although it's not known exactly what these singularities look like. A greater than 1, but A small, you can perturb off the A equals 0 case and show self-similar blow-up. This was done by Avajindi. A equals 1 is the de Gregorio equation, which was proven by Chen, Hao, and Huang, which uses a computer system. Which uses a computer system proof. They find a numerical approximate solution and then show that there exists an exact solution close by. Now, Lushinikov, Sniemtev and Siegel also have a numerical result on this equation for A between minus 1 and 1 and actually they take a departure range of parameters and this is the most complete numerical result where they show. Complete numerical result where they show you, it's not a rigorous result, but it's the most complete numerical result for this equation. And this just shows the agreement between when we apply our method to this equation, this shows the agreement between the results of this paper and our method. And here, the blue circles are Blue circles are from the pin, and the red line are results from Rishmakov. And this is the self-similar scaling parameter versus the parameter A. And here we have just the various different solutions you get for different A's. And for the very simple case A equals 0, you see that you get an exact match. Get an exact match. I'll leave it there. Very good. Thank you very much, Justin.