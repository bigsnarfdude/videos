In parallel, Thomas's conjecture has been proven for countable chains and countable directions of chains. Also, the alternate Thomas's conjecture is true for Rayless graphs, chains, countable NF0 categorical relational structures, countable universal theories, countable co-graphs, and direct sound of chains, and also for countable inference posits. So here I gave you just a list of positive real A list of positive results for this conjecture. In 2008, Atsushiteno, a former PhD student at the University of Oxford, claimed that there were local finite trees having an RB3 finite number of siblings. But the ideas were never published because they were ambiguous. And after contacting him and receiving his manuscript, we... Script, we, I mean, me and my supervisors revisited and verified his ideas, and we could give a rigorous exposition of locally finite trees having an arbitrary finite number of siblings. And here I am going to talk a little bit about those counterexamples. In fact, for any positive integer, we can construct a locally finite tree. A locally finite tree with exactly n siblings, such that the graph obtained by adding an isolated vertex to that tree does not embed that in that tree. And also there is a self-embedding of t such that the difference of t and image of t under that self-embedding is non-empty and finite. And the latter implies that temporary. implies that Tionkin's conjecture is also false. And clearly the first statement says that both Thomas's conjecture and Bonatari's conjecture are false. And these trees can be adapted to construct partial orders with the same result. That is, we can construct partial orders with Partial orders with arbitrary finite number of siblings. And this one here, this implies that Thomas's conjecture cannot be extended from chains to partial orders because we know that it's true for chains. But this one says that for partial orders, it's not true. All right, if I want to give you the Give you a general image of that country example. I need to have two main structures. The first one is a labeled tree, which is constructed as follows. Suppose it's a subdivision of complete minor tree. First, I start from this vertex with label zero. With label 0. Any vertex of label 0 has exactly two neighbors of label 1 and any vertex of label non-zero has exactly three neighbors of label label of this vertex minus 1, label of this vertex, and label of this vertex plus 1. And we can continue. So here I start with 0, it has two neighbors with. 0, it has two neighbors with label 1. This vertex has three vertices of label 0, 1, 2, and this one has three vertices of neighbors of label 1, 2, 3, and so on. And corresponding to each vertex of label L I attach a path of length 2L plus 6 plus 2 vertices at the end of Plus two x's at the end of that path. So these gadgets make this label tree unique. And the next structure that we need to have is two types of vertices. We call them tree vertices. Tree vertices, sorry, array vertices. And we have only two types of vertices, type 0 and type 1. Type 0 is that one with a path of length 2 plus 2 vertices at the end. And type 1 is a vertex such that to which the path of length 2 plus 3 vertices is attached, right? Is attached. So type 0 embeds into type 1 because here we can send this vertex to here, this vertex to here, this vertex to here, and these two go to here, but not the other way around. So type 1 cannot embed into type 0. So what does it mean? It means that if we have a double ray with only these two types of vertices, Vertices, then I can construct two types of double rays. The first double ray is this one, 000, the left-hand side, and 111, right-hand side. And type, the other one is 000 and then 1, then 0, and then 111. So I can embed this double array to here. I mean, yeah, for example, I can set this. Yeah, for example, I can send this zero to here, this one to here, zero goes to one, and so on. So this double array can embed into this one, and vice versa. I can send this zero to here, zero here, one goes to here, one goes to one, and so on. So these two double arrays are mutually embeddable, but they are non-isomorphic. And then I attach a copy of those labeled trees to each vertex. To each vertex, and then for this double ray, I call it T00, and for this double ray, I call it T0, T1, 0. And this structure, this locally finite tree, is constructed step by step, inductively. So this is the first step. Then I need to have target virtual. Target vertices. What's the target vertex? A target vertex of height L. First, sorry, let me get back to these vertices with label zero are called three vertices. We call them three vertices. And And here these vertices are called array vertices, and Z0 and Z1 are called centers. Here I want to construct a tree with sibling number 2. And sibling number n is constructed similar. The strategy is similar. If I start from a center and go through one of these labeled trees, then the height of that vertex, if I have a vertex here, the height is the maximum label of the vertex through the path connecting this. The path connecting this center to that vertex. So, this is the notion of height. And now, suppose I have a tree vertex, for example here, I start from center and go through this path to reach that tree vertex. Then, if the last consecutive pair through this path has label L, then Has label L, then this vertex is called a target vertex of height L. For example, the target vertex of height 2 is that one such that if I start from z and go through this path, the last consecutive pair has label 2. And this one is a target vertex of height. Is a target vertex of height one because the last consecutive pair through this path connecting center to this vertex is one, has label one. And this is the notion of target vertex. Then I need to have the notion crater. Craters look like you know the this bunch of you know hills having You know, hills having height less than L. So if I have a vertex of a target vertex of height L, suppose it's here, it's the target vertex of, suppose it's the target vertex of height L, then any vertex in these paths such as Such that the height of that vertex with respect to V is less than L is called in the set of crater of V. So the crater of V is the set of all vertices in this local finite tree such that the height of that vertex with respect to V is less than L. To V is less than L. So, but what's the application of this crater? Because crater allows us to construct the example inductively. But how do we construct it? Suppose T so the first system we had T00, right? zero, right, with a double ray and copies of those label trees attached to any ray vertex. Now suppose T0K minus 1 for k greater than or equal to 1 has been constructed. Then I want to construct T0K as follows. I choose a target vertex of Target vertex of height k. Then I start from the center and go through that path to reach V. And if I see any vertex with height less than k, then I attach a copy of T00 to through the target vertex of Through the target vertex of height one, T a copy of T01 to the target vertex of height two, and so on. So if I attach a copy of T0K minus 1 to this vertex, which is the target vertex of height k, then T0K is T0K is constructed. And finally, I take union of all T0K to construct T0T. One is also constructed in this way. And these trees with these properties. These properties are so that any non-isomorphic sibling of T0 is almost equal to T0. So their difference is in some, you know, some, the difference is a finite set. So any sibling of T0 embeds at some stage and the partial isomorphism And the partial isomorphism extends to the whole structure. And we say that partial isomorphism because the difference, as I said, is a finite set. And this implies that any sibling of T0 is isomorphic to either T0 or T1. So T0 has sibling number 2 and any and similarly the sibling number of T1. The sibling number of T1 is 2, so these two T0 and T1 are mutually embeddable but non-isomorphic, and any other sibling is isomorphic to isomer. And any path in those trees can be adapted to partial orders by putting order in this way: that suppose we have a path, no matter No matter if it's finite or infinite. We can construct for an infinite path. If I put this order on those paths, I get a partial order. And we can directly construct partial orders with the same results. So we can construct a partial order with sibling number 10 or so. So, all conjectures of Buenos Aires, Dev Tiomkin, and Somese are false. So, by here, we understood that there are counterexamples to these contradictions. So, what's the next step? A natural question is to ask that, so what can we do for the next project? Uh next uh project. Um uh here I want to uh generalize the concept of siblings under embeddability to any relation. For example, a graph minor or topological minor in graphs. We can consider those relations. And if two structures are mutually related under that relation, then we say that they are siblings. Siblings. So here we don't restrict ourselves to embed ability. We can go further. And if, and we say that given a relation, a collection of structures has a sibling alternative property if each element of that collection under R has one or infinitely many signals. Then we can think about the connection between quasi-orders and sibling notion. A quasi-order is a reflexive and transitive binary relation, and we say that a quasi-order is a Bell quasi-order if any finite sequence of elements of Q contains an infinite increasing sub-sequence. It's been proven that the class of countable chains is well-quased like order under imbelity, and sibling alternative property holds for that class. And also, it's been proven that the class of countable cogs is real quasi-order under embeddability again. And sibling alternative property holds for that class. But embedding is not real quasi-order, and we already saw. And we already saw that SAP is false under this relation. And there is one more fact about Wellquasi orders under topological minors. It's been proven that the class of trees is well-quasi-ordered under topological minor, and the class of locally finite trees has sibling alternative property under this relation. So it's natural. So it's natural to ask that what's the relation between these two. Suppose we have a relation on a collection of structures such that that collection under that relation is real quasi-order. So does sibling alternative property hold for that collection? And finally, we may consider on the sibling end we may consider this question that what's what's the what's the connection? What's the connection? How can we characterize the role of real quasi orders under the structural sibling flow rings? And what are the connections, what are the boundaries? And questions like this. And yeah, that's it. Thank you so much. Any questions? I will get up there. Green is finishing on that. Great talk about history. Okay, we'll put no questions about the technical speaker.  Okay, now bring it