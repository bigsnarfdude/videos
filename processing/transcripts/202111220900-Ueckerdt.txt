So, it's about the planar graph product structure theorem. So, we focus on planar graphs like the one that I have here on the title slide. And we want to find it in the product structure. So, we basically want to get from the top there to the bottom, from the planar graph to the product of H and P, whatever H and P are I'm going to tell you. Okay, so this is. I'm going to tell you. Okay, so this is joint work. Most of it was done at this meeting in Barbados with Vida, Gwen, Piot, Pat and David. And then actually earlier this year, David and Wendy and I, we extended a little bit on this. So I'm going to tell you also about this extension, the improvement in the constants. So maybe you've heard of the Maybe you've heard of the planar product structure before, but maybe you can learn something new today, even in this talk. Okay, let's see. What is it about? It's about the product, product of graphs. So in this term, it's the strong product of two graphs. So let's say these two graphs are for now A and B. And I'm going to use this box time symbol for the strong product. And I take these two graphs and I take the I take these two graphs and I take the Cartesian product of the vertex sets. So every vertex in G is an ordered pair of vertices, one from A and one from B. And two such pairs are adjacent in G if and only if both of these conditions hold and both are ors. So on the A coordinate, they either have the same vertex or they have at least adjacent vertices. And at the same time, on the B coordinate, At the same time, on the B coordinate, they either have the same vertex or at least adjacent vertices. Yeah, so like the most simple example is this: if the A graph is just an edge and the B graph is just an edge, then we get four vertices in our G and we get all the edges actually, which resembles this symbol. So maybe let's do a little bit larger example. So if A is a path and G is also that B. It's a path, and G is also that B is also a path, but I've written it a little bit different, then this would be a strong product. Okay, so and I'm also gonna always use this visualization with the vertices of the green graph being the rows and the vertices of the red graph being the columns. And then the vertices of the graph that we are trying to find in the strong product are the cells, so to say, the Cells, so to say, the entries of this matrix. Okay. And then what is important, so that this is proper that every blue edge, if you cast it, like you project it onto the y-axis, so to say, so if you project it along the rows, then you want to see either the same vertex or adjacent vertices in the green. And if you project it onto the x-axis, so vertically, I'd say. So vertically up, say, then you see either a red edge or the same red vertex. Okay, and now here's the theorem. The theorem says that whenever you have a planar graph, then you can find it as a subgraph of a strong product of a graph H and a graph P, where H is a graph of three bits at most eight and P is a path. P is a path. Okay. And the previous will will change a little bit during the talk, but this path will always be a path. So the green graph throughout the talk will be a path and it will be the vertices of the columns, of the rows. And the H graph can be a little bit more complex and will be the vertices of the columns. Okay, so this is one particular example how to find this planar graph as a strong product. Planar graph as a strong product of a path and a relatively simple graph H. Okay, and yeah, the rest of the talk is, or most of the rest of the talk is devoted to proving this, or at least convince you of its correctness. And so there's basically two ingredients. So the one is the green and the other is the red stuff. So how do we find the rows for the vertices and how do we find the columns for the vertices? Columns for the vertices. So, starting with the planar graph, each vertex should be assigned to a row and to a column. And the row is actually easy. So, we take so-called layerings. So, in general, layering is just the partition of the vertex sets into layers, L0, L1, and so on. I don't care how many. With the property that whenever I have two vertices, one and layer I. Vertices and one in layer i and one in layer j, then the difference between these indices is at most one. So two adjacent vertices. I should have said this here. So this is, of course, only for UV being an edge. So any two adjacent vertices are either in the same layer or in consecutive layers. Okay. Of course, there's like layerings always exist. Like there's the triple layering. You could put all the vertices into one layer. That's proper layering, but it's not. Proper layering, but it's not of any use here. What we take as layering is the classical DFS layering, breast-first search layering. So you just take one particular vertex, V0, as the root of a breast-first search, and then you partition the vertices into the layers according to their distance to the root. Yeah, so a vertex is in layer i, then if it has distance exactly i to v naught. Okay, and then it's it's clear that whatever graph. It's clear that whatever graph you take, no matter whether it's plana or not, whatever graph you take, this layering gives you this property. And you can already see that like if I embed all the vertices on these rows, then like this coordinate is already looking good. Whenever I have two adjacent vertices and I project them onto the y-axis, I either get the same green vertex. Get the same green vertex, or I get adjacent green vertices where the green graph is a path. Okay. Then before I tell you how to find the red vertices, let's talk a little bit about tree-bits. So the red graph should be a little bit more structured, a little bit more complicated, not just the path, but still not very complicated. So still have small tree grids. So, what is a tree grid? So, what is a tree bit? We talk about tree decompositions. So, this is a basic example, some graph H and the tree decomposition of H. Tree decomposition, you have bags arranged in a tree fashion. So the bags are the vertices of some big or underlying tree, and each bag is actually a subset of the vertices of the graph that you represent H. So you see here that some bags have two vertices and some. Some bags have two vertices, and some bags have three vertices with H. And then there's these crucial conditions: namely, that each vertex appears on several, one or more bags of this tree, but the bags that it appears in should be a connected subgraph of the tree. So it should be a sub-tree of the tree. And the second condition is whenever you have an edge in H. Whenever you have an edge, an H, then there should be a bank where the two sub-trees meet. Okay. So again, tree decompositions are not hard to find. You could, for instance, take the tree on one vertex and put all the vertices into one peg. So the challenge is to find something non-trivial. And for us, the measure of how complex or nice this tree decomposition is is the so-called width, which is the maximum size of the bag minus one. Size of the bag minus one. Okay, so this in particular has bags of size up to three, so the maximum bag size is three. So the tree width of this graph H here is at most two. And in fact, it is two. You won't find a better tree decomposition. Okay, so I do assume that you already know what tree width is and tree decompositions are, but still let me spend one extra slide on it: how we use the tree decompositions. Basically, there are two natural ways how to find 3D compositions. So, we're going to find this graph H and we're going to prove that it has low pre-bits by finding a 3D composition of small maximum back size. And one way to do it is like what I call the inductive method. One is, well, you have some tree decomposition of something already represented because we're going to proceed by induction and then we. And then we augment this tree that we find, but that we already found by, say, adding a leaf. Okay, that would be the most classical one, and that's the way many proofs work for small tree bits. And then what you have to take care of is that the bag that you attach the leaf to, it has some vertices, say some vertices X and Y, and some of them you want to pull. Some of them you want to pull into the leaf, and maybe adding new vertices, Z into the leaf, and letting X not go into the leaf. Okay, and no matter how you do it, you see that this is going to be a tree decomposition because the vertices, the new vertices will be just single vertex sub-trees, and the Y vertices will be extended by a leaf, so still sub-trees, and the rest doesn't change. Okay, but But we're not going to add leaves to tree decompositions, but instead we're going to do the other natural thing is namely we add roots to the trees. Okay, so we're going to do proceed by induction, but we're going to call induction not only on one smaller subgraph, but on several smaller subgraphs. So we get several trees and we want to combine them into one tree. And we're going to do this by adding a new root that is. A new root that is the common root of the new tree. And when I say root, it's not really rooted trees, it's just one marked vertex. So, for instance, we have already like three different positions here. And maybe actually what will happen is that these subgraphs that we get from induction, they share vertices. So, they might be the same vertices, some of the vertices might be in both trees. And then, in order to make this a proper tree, we can tree. To make this a proper tree decomposition, we have to make sure that these vertices, which I again call y here, they are in these two bags, both in these two bags, and I have to pull them out to the new root to connect these sub-trees to make it all proper and work. Okay. Of course, inductive method one is kind of a special case of method two by just having one subtree, but yeah. Yeah, so far, so good. So, this is tree decomposition. So, let me tell you a little bit the proof idea how we find this graph H that represents the columns of our product structure. Okay, so again, the task is given G planar, find H and P so that G is a subgraph of the strong product of H and P. Product of H and P. P is clear, it's just a path, and H must be such that the tree width is somehow low. Okay, so without loss of generality, we can start and say G is a triangulation. And like this there. And then I already told you, okay, we're going to use BFS layerings as the rows. So we fix a BFS tree at some root. Let's say the root is an outer vertex. Say the root is an outer vertex. So we already fixed the rows of all the vertices, and these are actually not going to change. This is a final decision already. And what do we take for the columns? So the columns, each column, each vertex of H is basically associated to a subset of the vertices of G that go into this column. And the idea is that these columns. That these columns are vertical paths in T. Okay, so in the BFS tree, a path is vertical if it's like a root, like just a set of vertices in the N cancer descendant relation. So it's only going up the tree, say, or down the tree. Okay. So for instance, any path from the root to a leaf is a vertical path, but also every subpath of such a root leaf path is a vertical path. root leaf path as a vertical path okay say this is a vertical path these three vertices um which are these three vertices in this picture there and i want to put them into the same column so it should basically look like this yeah so when i decided for this vertical path i have one vertex of h in particular this is the one that contains the root okay why not and then i continue i'm gonna identify a next vertical path like this guy and uh This guy and get a new column of H. Okay, and now I implicitly get edges in H because I might have edges in G between the vertices of these two paths. And then for all to work out, whenever I have a vertical part here and another vertical path here, where at least one edge of G goes between the two, I have to have the edge of H. Okay, so. Okay, so maybe let's do one more vertical path, maybe something like this. Yeah, so these two guys have at least one edge between them, so I have to have an edge in H between the two columns, but the last one is actually completely independent of the first vertical path that I used. So here I don't have to add an edge in H. So, which makes me happy because I want H to be simple. Okay, that's the rough idea. idea so let's do it uh oh yeah one one um sorry one more uh remark so um we're going to find this partition which we call um graphic p of the vertices of g into vertical paths just number them one up to whatever so these vertical paths correspond one to one to the vertices of h and moreover since these are actually um connected subgraphs i mean these are paths Connected subgraphs, I mean, these are paths. This adding edges of H, if there's an edge of G is exactly taking the minor by starting with G and contracting each path of the partition into a single vertex. So, and then the minor that you obtain there, this is the graph H. So, H will be planar in particular. Okay, but we are, that's not. But we are, that's not the subject. The subject is that H has small triplets. Okay. So here's the main lemma. So how do we find these vertical graphs? And how do we bound the triplets? So what is the situation that we're in? We have a planned triangulation like on the top right here. Let's call it G plus. We have BERT's first search tree. Have a Brett's first search tree fixed, rooted at some outer vertex. So, this gives me the layers. And I want to proceed by induction. So let's immediately start with the steps. So I assume I already have a, this is the tree. I'm sorry. I'm already kind of down to a subgraph. Okay. And the situation will be, the general situation will be. Be the general situation, will be that I have an interior triangulation of a simple cycle that I still would have to deal with. And the boundary of this is composed of a set of paths that I have already chosen as vertical paths in my path repetition. Okay, so there is a set of parallels disjoint, vertex, disjoint, vertical path. Disjoint vertex disjoint vertical paths and p1 up to pk uh k at most six. So, like this is an example how it might look like. And together they form a cycle and we consider the near triangulation G on all the vertices on and inside this cycle. Okay, okay, so this is the setup. The setup. Then, under these circumstances, the statement is that there is a partition of this inner triangulation G into vertical paths, vertical paths with respect to the chosen BFS tree, and with the property that these up to six paths that bound the cycle are in the partition, so S paths. So, as calves, so I'm not allowed to change them, not allowed to extend them or shorten them or anything. So, these are in the partition in the way I'm giving them, I'm giving them. And when I contract all the paths, so I build this graph H, which is G, contracted all the paths in the path partition, then this has a tree decomposition of a width, which is at most K plus 3 minus. k plus three minus one so uh let's uh talk about the numbers so i said k is at most six so the width there is k plus three minus one so it's eight yeah so that's the the bound i'm heading for and uh i have to be prepared for you know putting uh three decompositions together so i want to have a bag that contains p1 up to pk because this is kind of the interface to the outside world. Is kind of the interface to the outside world. So I need to have those in one back to be accessible for later. Okay, so that's the main lemma. How do I proceed? I consider the parts of the BFS tree that are inside my graph. So the BFS tree lives actually on the large graph. So it has the root somewhere outside, maybe on the cycle, but definitely. Be on the cycle, but definitely not inside. So I consider these parts that are in G. I group these paths that I have. So I said that I have up to six. So I make sure that I group them into exactly three groups, each group having at most two of those paths. Okay, so if it's six paths, like in my example, then I group them. Example, then I group them like this, and these groups should be consecutive along the boundary of this G. Okay. So K is at least three? No, strictly speaking, K is at least two. Well, it cannot be one because these are vertical paths, okay? But it might be two, and in the special case of two, we actually split one path into two and say, okay, this is the grouping. Is the grouping, um, yeah, okay, yeah, but I'm actually kind of avoiding these uh degenerate cases, but yeah. Um what's then with the three groups? Okay, thanks. Can you see this? But the online guys cannot see it, so with the three groups, um, I get a three covering of the vertices of G. Covering of the vertices of G basically by going along the tree, the BFS tree T to the root. So everybody has a unique path to the root and the root lives either on the cycle or outside. So at some point this path must go on the outer cycle and it must go into one of the three groups and this is the color of the vertex. So in particular each vertex in the blue group is also In the blue group is also blue, but also some interior vertices are blue if their paths lead them to the blue group. So, this way I get a three coloring of the vertices, and I'm actually in the situation where I can apply Sperner's lemma. Sperner's lemma is a little bit of an overkill there, but anyways, what the result is we get a three-colored inner face, so we get an Face. So we get an inner triangle, all three of whose vertices have distinct colors. And actually, in this particular setup, it's unique. There's exactly one place where the three colors will meet. Like one way to do it is to enter basically between two groups and simply follow the blue-orange edges until you see the first pink buttons. Okay. And then Okay, and then I have this triangle, and for the three outer vertices, I know that their paths towards the root lead to the three respective groups. So they might be very short, might be just one vertex. Actually, this triangle might have an outer vertex, but this is again a degenerate case that I will not really talk about, but it also works there. So for each of the three vertices, I consider the path. The three vertices I consider the path towards the root until it's about to hit the boundary. These are three vertical paths. Yeah, so maybe trivial, maybe just a single vertex, maybe not even a vertex. And what I do is I now split my graph along the three paths into three components. Components. Okay. So I get G1, G2, G3, three new triangulations, inner triangulations with a simple outer cycle whose outer cycle is composed of up to six vertical paths. Okay, so I commit to say, okay, these three paths will be in my path partition. Partition and then I split and each new graph has two exactly two of these new paths on the boundary. Then there might be some old paths on the boundary that are like just carried over. There might be some that will be shorter or like cut. For instance, like for P1, only one vertex survived here in G3, but it's still, it's a sub-path of a vertical path. It's a subpath of a vertical path, it's a vertical path. Okay, and there is at most six of them because I want to see paths of two groups in each of those G1, G2, G3, paths of two groups, which is in total at most four, and exactly two new paths, which is together six. And here's the point where I also want to mention the first improvement. So you can improve on this. So, you can improve on this k at most six to k at most five. Okay, so let me spend a slide on how to do this, and maybe this also gives you another different point of view of how to see this argument, actually. Okay, so I want to do basically the same, just I want to keep not six paths, but five paths always on the boundary. Okay, so say, well, induction base is always not a problem. Induction base is always not a problem because we have an outer triangle, there's three paths. Say we so far we came up to here with five paths and we want to maintain this. So we do the same thing. We do the grouping. So this will be three groups. So a group consisting only of P1, a group of P2, P3, and another, a third group of P4, P5. And then I take this vertical path. Then I take this vertical path and I might be unlucky. Yeah. So it might be that this Sperner triangle and the vertical paths lead me into this situation. And then when I go into counting the paths that bound each of the three parts, I see, oh, there's a six. Because I'm so unlucky to actually capture from two groups both paths and two new paths, which is in total six. Actually, this is. Is in total six. Actually, this is the only bad situation, kind of, in this case. So, all the other like combinatorially different ways how this Sperna triangle could connect to the five paths would be good. There's only one bad case, this one. Okay. And since, in a sense, since it's only one case, we can circumvent it. And let's have a little bit a closer look. Okay, so how did we get the square triangle? Did we get the square triangle? So we had these paths and we grew the BFS tree inside the graph and we colored basically these subtrees of the BFS tree by color. Yeah, so notice, so the back paths are actually paths in the BFS tree. So this is one component of a BFS tree that is in this blue component, and then there's another blue BFS tree component, and there's another two orange ones. Another two orange ones and one pink one. Okay, and it's just so bad that these three meet there. Well, actually, let's consider this graph where we contract for each of the five outer paths these grown trees into a single vertex. So, again, this is a connected subgraph. So, this will be the result will be. So, this will be the result will be a planar graph. It will actually be an outer planar graph because everybody has a vertex on the outer face. It will actually be a triangulated outer planar graph because we had an inner triangulation. And our triangle, our spurred triangle, will correspond to a triangle in the contracted graph. Okay. And this triangle is bad because we can basically see how many paths in... How many paths in the part will be there by looking at the three sides of the triangle and counting how many vertices of this contracted graphs are on the side of the triangle, counting both endpoints of the triangle side with it, and adding two for the two new parts. Okay, so here we have for this vertical green edge, so to say, we have the side of this triangle has all. The side of this triangle has all has four parts plus two new makes six. Okay, but the other triangles of my protracted graph are also triangles in this here. So, what I propose is let's not do this partitioning into groups. Let's just look at the paths without cutters and just look at these trees. Just look at these trees, how they grow in there. So it's five things. Contract them, get an outer planar graph, actually, maximal outer planar graph, triangulated, and just now decide for the triangle where each side has at most three parts. Okay, and there's always one such thing. So actually, it's a five-vertex triangulated alterplanar graph. There's only one such guy. So this is the triangle. So the This is the triangle, so the now greenish triangle between P2, P3, and P5, which corresponds to this interface here where the three trees grown from P2, P3 and P5 meet. And then taking this as the three new vertical parts, I can see that I have four, five, and five again bounding the smaller components. Okay. Yeah, so this way I can maintain always at my So, this way I can maintain always at most five paths, okay, which is already good because it saves one in the end in the tree that's bound. So, let's get back to the main lemma. Now, with k at most five, the rest is identical. We have the five paths, we have identified these Sperner triangle with the three new vertical paths. We split. Now, let's give them names: Q1, Q2, Q3. Now, do the tree decomposition. Okay, so we do induction. Okay, so we do induction on each of the three smaller graphs. So we get three decompositions, three separate trees, satisfying our assumptions, namely that there is a bag containing all the paths that bound the other cycle. So for what is it? This is G2 is the leftmost here. There is a bag containing P1, P4, P2. Containing p1, p4, p5, q1, and q2. Okay, and maybe something more which I didn't put. Also, the same for G1. This is the middle guy. There's a backup thing, Q2, Q3, P2, 3, and 4. And the last one is for G3. Okay. And now I do the add a root method. So I add one new root. Here, this is. Here, this is the situation that I have vertices showing up in more than one of those 3 decompositions. These are namely the ones that play a role in both more than one of those graphs, like Q2, yes, and G2 and in G1. So I have to pull Q2 into the new root in order to make the subtree of Q2 really a tree and not just a subwood. And I have to. And I have to put P1 up to P5 into this new root back in order to maintain my invariant that I have back containing P1 up to P5. Okay, so this makes, now you see why the width comes in. The K paths are the ones that I have to put in the back. Three are the new ones, which I also have to put in the new root back. And the minus one is because we always subtract one. Because we always subtract one when computing the mid the widths. So the maximum back size is k plus three. So together with the k at most five, this is already a width of at most seven. So let me also show you how to get a little bit better here. So instead of this thing, we can actually reduce the widths by yet again one by saying that we have the widths of k plus two. We have widths of k plus 2 minus 1 only. And this is basically instead of adding the root and just collecting everything that we have to collect, we can do a little bit more clever and do this. So we can see that, for instance, Q3 appears, like all the Q's appears on two of those, but not on the third. So we can first make this Q3 a connected subtree. A connected subtree, pulling everything else up, and we can make it such that one of those two only has two paths. Because this was a five before, so at least one of those has at most a four. And so then we have here actually only k plus two, so k minus one plus three in a sense, and then we can drop the q3 for any. Can drop the q3 when we go up. So here we have the k plus 2, which is enough for us. Okay. So that's the main lemma. So let's maybe do the proof at a little bit detail. So we wanted to prove D, the planar graph. We find H and P, P curves one. P, P corresponding to the rows, H corresponding to the columns, so that G is a subgraph of this strong product of H times P, and the three-widths of H is here at most six. I have already put the updated bound of six there. Okay, so without loss of generality, we're considering a triangulation. We fix this BFS tree rooted at some outer vertex. We find with this main lemma that I just showed you, we find this partition of the vertex. This partition of the vertices of G into vertical paths. This corresponds to our red vertices. So, and we have the property that when we contract these paths, we get the graph H and it has previous at most six. So, let's double check that this makes sense, that we indeed find G as a subgraph of the strong product there. So, every vertex of G is mapped on Is mapped onto an ordered pair of vertices, one in H and one in P. The vertex in H is the path in the path partition that contains this vertex V. That's the column. And the vertex B is the layer in the BFS layer ring that contains the vertex V. So that's the coordinate vector for vertex. And now why is G a subgraphable? Why is G a subgraph of this? So whenever I have an H V1, V2 in G, I have for V1 this pair A1B1 and for V2 this pair A2B2. And I have to verify that indeed, because these two are adjacent, they either have the same column or adjacent columns in the column graph in H. And at the same time, they have the same layer or adjacent layer in the layering graph, so in the path. Graphs or in the path. Okay, so let's do the easy stuff first. Since this is a layering, we know whenever two vertices are connected by an edge, one from layer I and one from layer J, that I minus J is at most one and at least minus one. So that's already the part down there. And now for the red component, when I have two When I have two vertices of G connected by an edge, vertex U goes into path I and vertex V goes into path J in the path partition. Well, then either they end up in the same path, that's nice, or they end up in paths, but then I have two paths that have an edge between them, namely the UV edge. So it means that when I contract this, this graph H has an edge between them. H has an edge between them. So Pi, PJ are connected by an edge in H. And this is what I want. Okay, so this completes the proof of the product structure G being subgraph of H times P. I still have a little bit of time, so let me also tell you about this second part. Second product structure theorem. So it's basically two of them. So the left one I already showed you. So now I'm quoting also Wendy and David here for the improvement to six. And the second part is this one on the right. So every planar graph is a subgraph of a product now of three factors. One factor is still P here. One factor is still a path, and one factor is still a graph of small tree bits, but now the third factor is a very small graph, it's just a triangle. And so to the expense of this third factor, we can actually reduce the bound on the tree bits of the graph H. Okay, and we can reduce it to three. And this was already in the original paper. So, how do we do this? Well, let's recall how this This every all how all of this looks like. At least, this is the picture I have in my head when I'm thinking about it. So, we have this five cycles, we find the Sperner triangle and the paths to three of the five outside vertices. And when we actually now track down how this triangle and the three paths are laid out in here, then it will look something like this. Will look something like this because, uh, like remember, these uh, these paths are vertical paths. The root, which is very high in the row, is outside. So, going inside inside the blue region is going down in the tree, is going down in the rows. And of course, these three vertices here for the triangle are pairwise adjacent, so they are either they span at most two. They spend at most two layers, say they spend two layers, say something like this. And then they go into separate paths of the path partition, so into three separate columns. And then these three paths are just straight up the columns. They might be of different lengths. There's no control about it. Okay, so this is how such a thing looks like. And now such a thing. And now, such a thing. Oh, yeah, let's not forget about it. There might be edges between these. So it's not so super simple as if drawn it. So there might be edges between these guys, actually. So then it might look a little bit more complicated. But of course, every such edge is between two of these three columns and either within the same layer or between it. Either within the same layer or between adjacent layers. Okay, now this complicated more, a little bit more complicated thing is a subgraph of this path times a triangle. And when you think about the path times a triangle, you can think about this beast here. It's a path of triangles with all the connections between consecutive triangles. Consecutive triangles. Okay. And now you can think of this product here as H times this graph. So that the second component is basically this graph. And then the picture would look something like this. So every row would be now corresponding to a triangle. And every column corresponds to one such guy. I can put in the column not only a path, I can put a path. Path, I can put a path times a triangle. So I can put this entire structure here into one new column. Okay, so let's make it a little bit more precise. Tripods. So these things we call tripods. So a tripod is the union of up to three vertical parts whose lower endpoints form a client. Lower endpoints form a clique and G. So tripods with three legs look exactly like you've seen on the previous slide, but there's also like these degenerate cases of tripods with only two legs or tripods with one leg. So a vertex path itself is also a tripod. So the lower end, so in the BFS layering, lower end, they form a clear. Okay. And now we have basically, instead of the main lemma, we have something like a tripod partition lemma. Something like a tripod partition lemma, which has the similar setup planner triangulation, BFS tree rooted at an outer vertex. And we are in the middle of such an inner triangulation of a cycle. And now the cycle is not composed of vertical calves, but the cycle is composed of tripods. Actually, at most bipods, so tripods with at most two legs. T1, T1. T1, T2, and T3, and that's only three of them. So I hope you can see this. So this is, I try to indicate also the legs. So T1 has two legs, and T2 has also two legs, and T3 has only one leg. Why not? And inside this blue circle, there's again some inner triangulation. And the statement is that there's a partition of these vertices into tripods such that these three. Such that these three given tripods, now it will be exactly three always. Not sure, can also be whatever. That these three given tripods are part of the partition. And when I contract a tripod, I get again a minor. This is my graph H. And now this is again planar, but it has additionally three bits three. Widths three, so it has a tree decomposition of with three only containing with a back containing t1, t2, and t3. Okay, so how do we do this? Well, based on the tripods, I grow the BFS tree in the beginning. Now it's going to be three of those trees. They're going to meet in a unique triangle. This triangle is going to be kind of the base of my tripod. And now, if the triangle has a vertex from the outer cycle, Outer cycle, so something that is already in a tripod, then it's going to be a tripod with only two legs or one leg and so on. I go from the three vertices of the triangle along the PFS tree, identify the legs of the tripod and cut along this tripod, this one tripod, making it a two-legged Making it a two-legged tripod in each of the three things that I cast induction on. Okay. And again, you can see every part that I apply induction to is a cycle, inner triangulated, and is bounded by three tripods only. So, by induction hypothesis, I get this partition into tripod of the remaining vertices and these three decompositions. Decompositions where I have all the three tripods always in this designated back, and I do the simple trick of adding a root, collecting everything together. Okay, so I have T1, T2, and T3, and I have to also collect T4 in order to make T4 a connected subtree in these separate components. So that's why the width is three, so it's k minus one, so to say. K minus one, so to say, k plus one, so to say. Okay, so last slide. So just a different visualization of this thing. So in general, this looks like this. We have these three tripods, maybe with two legs only seeing here on the other face. And we have this graph that we obtain as a minor by contracting the tripods. So in this case, it's so far just a triangle. And when I put a tripod. And when I put a tripod basically in the graph, H, it amounts to putting a vertex into this triangle, connecting it to all three vertices of the triangle, because there is always an edge from here, from the end of the leg to the tripod and here, and here, and there. So these three edges are definitely there. And then I continue inside each of the three regions. For instance, I find another tripod here, making a new vertex and H inside. A new vertex in H inside this triangle, another tripod here, tripod here, and so on. Yeah, and this goes until everything is every vertex of G sits in one of those tripods. And what we can see is that this graph H, well, it's indeed planar and it indeed has tree-bits three. So, and if you know a little bit more about tree-bits, then you might have seen those graphs already. So, these are three trees, so maximum graphs. So, maximum graphs of tributes three, and moreover, a planar three tree, or in other words, a simple three tree, where the simple condition for three trees means that every triangle separates the graph only in at most two components. Or any two bags share, no, the same triangle appears only in at most two bags, if you want. At most two bags, if you want, in the 3D composition. In this simple condition, this generalizes, of course, to larger tree-bits. And if you look into the proof, then you actually see that the graphs that we dwelled here of tree-bit six actually have simple tree-bit six. And this is the tripod thing. Maybe this is helpful, and it is actually helpful for some applications that you know that the tree is simple because. Because it's a little bit more constrained than just having a small triple. Okay, that's it for me.