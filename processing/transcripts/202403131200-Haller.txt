Hi, I'm Ben Haller and I work at Cornell University on a software package called Slim, and that's what I'm going to talk to you about today. I'd like to thank the organizers for this opportunity to speak. I want to start by acknowledging my main collaborators on Slim, Philip Messer and Peter Ralph. Philip wrote the original Slim 1 back in the day, and I work in his lab at Cornell. Peter is a major contributor to Slim, particularly in areas such as spatial modeling and tree sequence recording that I'll be talking about today. That I'll be talking about today. But many, many more people have also contributed to SLIM. And so I want to show my acknowledgments slide up front to thank both funding agencies and the many people who have filed bug reports, contributed new feature ideas, and much more. Slim really benefits from its community of users. So here's an outline for this talk. I'll start with an overview of what Slim is and why you might want to use it. Then I'll give a quick introduction to Slim, including the Edo scripting language. To Slim, including the EDOS scripting language that it uses. After that, we'll get into some more advanced Slim topics that you might not be familiar with, even if you've used Slim, including continuous space models, tree sequence recording, and multi-species models. At the end, I'll show you a couple of example applications of Slim to illustrate what it can do and give some closing remarks. So, here we go. What is Slim and why would you want to use it? Slim is software for forward. SLIM is software for forward genetic simulation. Let's break that down word by word. Forward means that the simulation runs forward in time from an initial ancestral state, in contrast to the coalescent, for example, which runs backwards in time. Genetic means that SLIM simulates every mutation explicitly at specific positions on a chromosome with recombination and linkage and all that good stuff, so you can do pretty realistic genetics. And slim. And Slim simulation here means that Slim explicitly simulates individual organisms, their birth, death, movement, and even interactions between individuals. There are lots of reasons to do simulations. If you have empirical population genomic data, simulations might allow you to analyze the past evolutionary forces that produced the patterns seen in your empirical data, or predict the future evolution of your system. If you're a theorist, If you're a theorist, simulations can let you predict the consequences of a new theory, particularly by relaxing assumptions that you needed to make in an analytical model. And simulations can also be useful for those working on statistical methods, as a way to test the accuracy, bias, or power of a statistical method using simulated data that's generated by known evolutionary processes, or as a way to generate training and test datasets for machine learning. For machine learning, there are other ways to approach population modeling, such as analytical models and coalescent simulations. So, why do forward simulations in particular? The answer is essentially that evolution is complex. Real-world biology typically involves all sorts of complexity, such as the examples listed here, that are hard to handle in analytical or coalescent models, especially if not just one but several of these types of complexity are important. Are important. If you want to model a system with this kind of complexity, forward simulation is often necessary, even though it can be time-consuming and complex. But you might still ask why use Slim in particular, rather than using some other simulation software package, or perhaps even writing your own model from scratch. There are several reasons. One is that Slim is very flexible and customizable because it's scriptable with a language called Eidos. This allows you to Called Edos. This allows you to do almost anything you want in your model, overriding Slim's default behaviors with your own custom script. Eidos is a simple language that's easy to learn. It's based on R and uses similar syntax and function names. Another reason is that Slim is very fast. I've spent a great deal of time and effort optimizing Slim's underlying C code, and it uses specialized data structures and algorithms under the hood for extra speed. If you use speed. If you use Slim, you never need to look at that underlying C code. You just get all the benefits of my optimization work for free. Another reason is that Slim provides an interactive graphical modeling environment called Slim GUI. SlimGUI provides live visualization of your model's dynamics as it runs, in addition to a full-featured code editor, online documentation, and much more. The value of this for model development, for visual debugging, Development, for visual debugging, and for open-ended exploratory work is enormous. Slim is open source on GitHub under the GPL license. That means it's free to use with all of the advantages of open source software, and if you wish to do so, you can even get involved in its development. For all of these reasons and more, Slim is pretty widely used in the community, with about 1300 citations so far. So perhaps I've convinced you that Slim might be worth using. Slim might be worth using. Let's move on to an introduction to Edos and Slim to see how it works. The EDOS scripting language was created for Slim, but as I mentioned before, it's based on R, and it's quite easy to get into if you've worked with R, Python, C, or really any mainstream modern language. It has a pretty unsurprising set of data types, null to represent the absence of a value or to request a default value, logical for Boolean true-false values. For Boolean true-false values, integer for whole numbers and float for floating-point numbers, string for text strings, and object for everything else, including individuals, mutations, subpopulations, and so forth, all the entities that you're actually simulating. The operators available in EDOS are also pretty typical. Arithmetic operators, including modulo exponentiation, and a sequence operator like Rs. Logical operators like AND, OR, and NOT, comparison operators, and options. OR and NOT, comparison operators, and other familiar operators like equals for assignment, parentheses for grouping, and brackets for subsetting. For flow control, EDOS has if-else statements, for loops, while loops, and do while loops. It uses braces to group sets of statements together into compound statements. That's the same as R, but will be a bit of a switch for those coming from Python, which uses indentation instead. In Eidos, indentation is purely for aesthetics and has no Is purely for aesthetics and has no semantic meaning. Edos has lots of built-in functions for things like math, statistics, and drawing from distributions, and as I mentioned before, these functions often have the same name as in R. But Edos is also object-oriented. As I mentioned before, objects represent entities in your simulation, like mutations and individuals. You use the dot operator to access properties and methods within objects, so this very operation. Within objects. So, this variable named individual might refer to a specific individual in your model, and you could get its age, the number of simulation ticks it's been alive for, through its age property with individual.age. Objects also have methods which ask the object to perform some kind of work. So you could ask individual to search through its two genomes, two because it's a diploid, and tell you whether it possesses particular mutations that you're interested in. That you're interested in. EDOS provides a couple of built-in object classes, including a dictionary class that lets you store and retrieve values easily, a data frame class representing a spreadsheet-like table of data, and an image class for working with images, which is very useful for reasons we'll see later on. But most of the object classes you'll work with are defined by Slim on top of Eidos. Let's look at those now. One set of classes in Slim comprises what I call Classes in Slim comprises what I call the chromosome hierarchy. In this hierarchy, there's a top-level object called the chromosome that defines the genetic structure of your model as a sequence of genomic elements. In the diagram below, you can see a depiction of a chromosome object in SLIM as a mosaic of genomic elements shown in different colors. Each of these genomic elements belongs to a particular genomic element type, and that's what the colors represent. Colors represent. In this simple example, we have genomic element types for non-coding regions, exons, and introns. But Slim itself doesn't know anything about exons and introns and so forth. You choose the genomic element types that you need for the simulation you want to do. Slim doesn't dictate them to you. If you want a genomic element type for UTRs or the centromeric region or whatever, you can do that. Genomic element types govern what kind of mutations occur in a region. Of mutations occur in a region by drawing their mutations from particular mutation types that provide a distribution of fitness effects, or DFE. In this example, we have non-coding regions generating only neutral mutations, while exons can generate neutral, beneficial, and deleterious mutations, and introns undergo only neutral and deleterious mutations. But again, all of this is up to you. Defined by your EDOS script. Slim doesn't dictate this genetic structure to you. Doesn't dictate this genetic structure to you, and what's shown on this slide is only an example. Another set of classes provided by Slim comprise what I call the community hierarchy. At the top level of this hierarchy is an object called the Community Object. It can manage one or more species objects representing different species in your simulation. Each species contains subpopulations, which contain individuals. Individuals contain genomes, two per diploid. 2 per diploid, and those genomes contain mutations at specific positions along the chromosome. That hierarchy is illustrated here from the species objects in the community all the way down to the mutation objects in the genomes of individuals. Each of these levels is represented by a different class defined by SLIM. Together, the classes of the chromosome hierarchy and the population hierarchy pretty much embody your simulation. When you make a SLIM model, When you make a SLIM model of your own, the first choice you confront is WF or non-WF. SLIM supports two model types, the Wright-Fisher or WF model type, and the non-Wright Fisher or non-WF model type. These two model types are radically different. They're different in the tick cycle that Slim runs over and over as the simulation progresses, and in the way they generate offspring and regulate their population size, in their age structure and demography, the way they treat them. Structure and demography, the way they treat fitness, and so forth. Understanding this difference is pretty foundational, so let's look at it a bit more closely. Wright-Fisher, or WF models in SLIM are much the same as they are in the original literature. Population size is a top-down parameter that you dictate to the model, so population regulation is automatic. Slim just makes the number of individuals you told it to make. Since the population size is fixed by that parameter, Size is fixed by that parameter, fitness affects mating success, not mortality, and so selection is soft, meaning that relative fitness is what matters. Generations are non-overlapping, and there's no age structure. In each tick, the parents reproduce, die, and are replaced by their offspring. Migration is also dictated by top-down parameters. So WF models are quite parameter-driven and inflexible, but they're simple and standard, and they have their place. Standard, and they have their place. Non-Wright Fisher models, or non-WF models, are kind of the opposite in every way. Population size is an emergent property of the model, resulting from the balance between births and deaths in the model. This means the population regulation in non-WF models is scripted. Your Eidos code governs who is born and who dies. And so you need to think a little about the ecology of your system and what regulates the population size. Regulates the population size. Fitness in non-WF models affects survival by default, not mating probability, and that means that by default, selection is hard and absolute fitness is important. Generations can overlap and age structure, like population size, is emergent from births and deaths. Migration, too, is scripted and emergent. Your code dictates which individuals move and to where. So the big picture is that non-W. So, the big picture is that non-WF models are very individual-based, emergent, flexible, and script-driven, but they're also somewhat more complex. Whichever model type you choose, your model is run by what I call the Slim Core. This is the optimized C ⁇  code that runs the tick cycle, moving time in your simulation forward tick by tick. The Slim Core provides default behaviors for things like fitness calculations, mate-choice gaps. Calculations, mate choice, gamete generation, including mutation and recombination, mortality, and so forth. And then beyond the slim core, there's your Edo script. Your script is divided up into events, which run at particular scheduled times to make things happen in your model, and callbacks, which more directly modify some default behavior in the Slim core, plugging into Slim to change its behavior. There are a bunch of kinds of callbacks in Slim. There are a bunch of kinds of callbacks in Slim, as shown on this slide. These different callback types let you modify the Slim core's default behavior in specific areas, such as mate choice, reproduction, survival, or the effects of mutations on fitness. So with callbacks, you have a great deal of control over what Slim does. That's Eidos and Slim in a nutshell. Now I'd like to do a quick live demo in Slim GUI to show you what all of this looks like in practice. This looks like in practice. This is a very simple, slim model of neutral drift in a population of 500 individuals. If I click play, the model starts to execute. It's going somewhat fast, about 5,000 generations already, so I can slow it down a little with this slider so that we can see what's going on. The central view here is the chromosome view. It shows the simulated chromosome from end to end. Each yellow bar. End. Each yellow bar represents one mutation that's segregating in the population. The position of the bar left to right is the position of that mutation on the chromosome, and the height of the bar is the frequency of that mutation in the population. So what we're looking at is the dynamics of neutral drift. You can see that often whole sets of mutations rise and fall in synchrony. That's because they're close enough to be somewhat physically linked, and recombination hasn't broken them up, so they travel. hasn't broken them up, so they travel together. When they reach the top, they're at a frequency of one, and so they fix and get removed from the active simulation. The haplotype structure of the model is more clear if I pause and create a haplotype plot. Each row of this plot is one genome in the population, and the genomes are sorted vertically according to their genetic similarity. Let's make this a little bigger. You can see the patterns. You can see the patterns of linkage disequilibrium visually in the plot, and SlimGUI has lots of nice plots like this built in. The view at the top of the main window with lots of little yellow squares is the individual's view. There's one square for each of the 500 individuals in the model. All the squares and all the mutation bars, too, are yellow. That's because yellow is the color Slim GUI uses to indicate neutrality, and this is a neutral model. Let's switch to a more interesting model. Let's switch to a more interesting model to see more. I'm going to start playing this model to go to tick 15,000. Let's do 15,000 here. Okay. So that it's running as I'm talking. So away it goes. Again, we're seeing neutral dynamics here, but this is a two-subpopulation model with migration between the two. Subpopulation P1 has 500 individuals, while P2 has 1500 individuals, as set in the script here. As set in the script here, I can open a population visualization plot and see the model visually. You can see that P2 is larger than P1, and you can also see that the migration between them is asymmetric, as we requested over here in the script. I'm planning to tick 15,000 because at that point, this late event introduces a new sweep mutation. The script The script chooses one target genome from P1 using the sample function, and then a new mutation gets added to that target. The new mutation is of type M2. If you look up in the initialization code, mutation type M1 is beneficial with a selection coefficient of 0. But mutation type 2 is beneficial with a selection coefficient of 0.5. So we expect it to sweep if it So, we expect it to sweep if it isn't lost early due to drift. In this model, I've actually set the random number seed so that I know that the sweep mutation will fix, so that I can give you a good demo. Okay, so we're about to reach tick 15,000, and the sweep mutation is about to be added. Let's just wait a moment for us to get there, and I can close this window. So, the sweet mutation is about to be added. If I step forward one take, you can already see one individual has turned. Already see one individual has turned green here. That's because it is the carrier of the sweet mutation. So remember that yellow is the color of neutrality in Slingui, and that individual no longer has neutral fitness, and so it has changed color. And if I step forward a little more, we get some more green individuals circulating as I go. So the sweet mutation itself is this red bar in the Is this red bar in the chromosome view? We can zoom in to see that a little bit better. There it is, right there. I colored it red in the script so that it's a little more visible. So, zooming back out, you can see that we're losing genetic diversity, right? As the suite progresses, hitchhiking is pulling one haplotype along with the suite mutation genome-wide. Let's step forward a little more to see that. I can open the haplotype plot again, and you can see that more. Again, and you can see that more easily. If I make this big again, you can see that in the portion of the population that the sweep has reached, almost all of the genetic diversity has been lost. Here's our red sweep mutation over here, and one haplotype that was the background of the sweep mutation has been carried along by hitchhiking. So, this is still, you know, quite a simple model overall. But we've got a selective sweep going, and we could measure that and look at how the population. Measure that and look at how the population's structure affects its progress and so forth. So we're on our way to having an interesting model, and we can watch it all here in Slim GUI. I'm going to go back to my slides now. Okay, so that was the live demo. What I've shown you so far is just a tiny taste of what you can do in Slim, and this slide is about some of the other things that you can do that I don't have time to show you. You can model different kinds of ployds. You can model different kinds of ploidy, including more complex systems like haplodiploidy. You can model hermaphrodites, separate sexes, or more complex mating systems. Biparental sexual mating is supported, of course, but also cloning and selfing and more. You can have more or less any genetics, including multiple chromosomes, rate maps for recombination and mutation, and onward, including not only Mendelian traits, but also quantitative traits, and genomic entities. Traits and genomic entities like transposable elements. You can model pretty much any fitness effects or modes of selection that you want, so not just selection coefficients, but also selection on phenotypes like stabilizing selection or frequency-dependent selection. Particularly in non-WF models, an individual's genetics, resources, or experiences can influence its behaviors, like mating and dispersal. And you can model all the standard population genetic stuff. All the standard population genetic stuff that you'd expect, like selective sweeps, background selection, and even speciation. So, this is a long laundry list, and the complexity of Slim can be a bit daunting. But the manual has example recipes for all this and much more, over 200 recipes now, in fact. So whatever you want to model, you can probably find at least one recipe in the manual that will show you a path forward. Now you've seen the foundational features of Slim. The foundational features of SLIM, so let's start talking about some advanced capabilities. The first of these topics is continuous space models. It's widely recognized these days that spatiality is important to population genetics and to evolutionary biology more broadly. It has all sorts of important effects. It limits the speed of sweeps, since they have to sweep through space as well as in frequency. It produces local kinship and inbreeding. There are fascinating rangefront dynamics. There are fascinating rangefront dynamics going on, such as allele surfing and drift effects, as well as selection for high dispersal. And we know, of course, that space can promote local adaptation, adaptive divergence, and even speciation. So we need to be thinking about spatiality, and in some cases, at least, we need to be including it in our models. Slim provides lots of tools for that. A continuous space model in Slim entails a couple of things. You tell Slim that you want to model a 1D Tell Slim that you want to model a 1D, 2D, or 3D landscape. The individuals in your model need to be assigned spatial coordinates, and you usually need to think about boundary conditions. What happens if individuals attempt to move off the edge of the landscape? You generally want some kind of spatial interactions between the individuals. For example, individuals should choose mates that are nearby in space, and often individuals compete with each other, with other nearby individuals for resources or territory. Slim makes Slim makes modeling spatial interactions like this easy with a spatial interaction engine called Interaction Type. And finally, you often want to model variables that change across the landscape, variables like elevation or temperature or habitat type. Slim provides this capability with a class called spatial map. So let's look at all of this in more detail. Here's a trivial continuous space model in Slim. We tell Slim that we want a two-dimensional landscape. that we want a two-dimensional landscape with a call to initialize slim options. We make a new subpopulation, as we've seen before, but now we need to set the spatial positions of the new individuals. Here we set them to random positions in the landscape generated by the point uniform method. And finally we need to set the positions of new offspring each generation. New offspring are set by default to the position of their first parent, the maternal parent. Here we deviate those default positions using Those default positions using random draws from a normal distribution with a standard deviation of 0.02 and apply reprising boundaries to that process. Reprising boundaries means that if a deviated position lands outside the landscape's bounds, we'll just redraw the deviation until we get a position that's inside. So now we've got a model in which individuals live at particular positions on a continuous spatial landscape. It's not really a very spatial model, though, since the individual Spatial model, though, since the individuals still choose mates from anywhere on the landscape and don't interact in any way with their nearby neighbors. So now we'd like to add spatial interactions. To do that, we use the interaction type class. This is a spatial query engine that's built into Slim. It serves queries like a database, but these queries involve a receiver that's receiving some interaction, a sub-population. Interaction, a sub-population of potential exerters that are exerting that interaction upon the receiver, a maximum interaction distance, and in some cases a spatial kernel that's applied to the strength of the interactions. We'll see how all that works on the next slide. Interaction type is highly optimized. It uses spatial data structures such as KD trees and sparse vectors to find nearby individuals and quantify their interactions very efficiently. There are three basics. There are three basic types of queries that interaction type can serve. One is queries involving neighbors. Neighbors are individuals near the receiver within the maximum interaction distance, as you can see here. The next level is interacting neighbors. Here constraints apply in addition to the maximum distance. These constraints might require the receiver or the exerters to be of a particular sex, or within a particular range of ages, for example. So only a sexual external. Example, so only a subset of the receiver's neighbors will be interacting neighbors. And the third level involves interaction strengths. Here, interaction type finds all the interacting neighbors and then calculates interaction strengths for each of them. These interaction strengths are a function of the distance between the receiver and the exerter, as specified by a spatial interaction kernel. Nearby neighbors will typically interact with. Nearby neighbors will typically interact more strongly than distant neighbors, as seen here. So you can use interaction type to find nearby mates, to calculate competition from nearby individuals, and so forth, and you can do it very efficiently. And then, also, we'd like our individuals to live not just in some shapeless two-dimensional void, but on a real landscape with characteristics like terrain, elevation, and so forth. You can use Slim's spatial map class to Use Slim's spatial map class to model that. A spatial map represents a 1D, 2D, or 3D grid of values, and that grid gets overlaid across the model's spatial bounds to produce a map of sorts. Spatial maps can represent any spatial variable you need. These might be environmental variables like elevation or temperature, but they might also be calculated values like local density or resource availability that might influence your model dynamics, or they might be modeled. Dynamics, or they might be model parameters like dispersal or fecundity that you want to vary across the landscape. So here's a spatial map, a 2D grid of values. The colors represent the values of the grid in some abstract way. And spatial maps can be either uninterpolated or interpolated. Without interpolation, the value of the map at a given point is equal to the nearest grid value, and so you get a blocky, pixelated map. You get a blocky, pixelated map. With interpolation, bilinear interpolation calculates a weighted average of the four closest grid points, producing a continuous-valued map with effectively infinite resolution. Spatial maps can be loaded from PNG image files, and this is where the image class in Eidos that I mentioned before comes in handy. The image files might come originally from Google Maps, ArcGIS, or anywhere else. In any case, you can load them into Slim. Case you can load them into Slim and use them as a spatial map. So here's an example map that represents the South Island of New Zealand, with colours coding for elevation. Spatial maps can also be created or modified algorithmically in Slim, including combining them, interpolating them, smoothing them with a spatial kernel, and so forth. You can use spatial maps however you want, because you are the script writers, and you are the dreamers of the dream. The next advanced feature I want to talk about is tree sequence recording. A tree sequence is a data structure that records the local ancestry at every position along the genome as a sequence of ancestry trees. The diagram at bottom shows a very simple tree sequence. Note that the axis scale isn't uniform. The trees are just evenly spaced for display. The ancestry trees are not the same everywhere along the chromosome because of recombination, of course. Because of recombination, of course. Recombination breaks up inherited tracts and changes ancestry relationships. In these trees, leaves are individuals with no descendants. They're often the extant individuals alive at the end of a simulation run. Internal nodes are ancestors of those leaf individuals. In SLIM, the roots of the trees are typically the first generation of the forward simulation. The tree sequence data structure comes originally from coalescent modeling. Originally from coalescent modeling, and in particular from the MS Prime simulator. It has a number of general advantages. It's an extremely compact representation of genetic variation because the trees in the tree sequence are highly correlated, often differing by the effect of just a single recombination event. Because of these correlations between trees, the tree sequence is also very fast to traverse. And calculating common statistics along the genome, like for example to gene. The genome, like for example Tejimus D, can be done very efficiently using the tree sequence. But tree sequences also have three major advantages in the context of slim simulations specifically. One is that at the end of your simulation, you have a complete record of the true local ancestry for every individual, and that can be very useful in itself in your analysis. The other two advantages are speed advantages, coming from two techniques that tree sequence recording enables. Tree sequence recording enables. These techniques are called neutral mutation overlay and recapitation, and I'll explain them in a moment. This is a simple but complete slim model using tree sequence recording. We turn it on at the start with a call to initialize tree seek, and at the end we write out a recorded tree sequence with tree seek output. Slim does everything else for us. The only other thing to note here is that we use a neutral mutation rate of zero. A neutral mutation rate of zero, we don't need to forward simulate neutral mutations anymore, for reasons that will become clear. If the model had non-neutral mutations, we would still need to simulate those. In this slide, I'm going to show you how tree sequence recording works in Slim. In this first frame, we see the forward simulation as it proceeded in Slim. The initial generation is at the top, and forward time goes towards the bottom. Forward time goes towards the bottom. Each generation of diploids, shown as circles containing two genomes, inherits from the previous generation in ways recorded by the tree sequence and depicted by the gray edges connecting them. For a simulation with many individuals over many generations, the amount of information recorded in this way would rapidly explode, but much of that information would be useless for our typical purposes. In particular, it would record whole branches of the evolutionary history. Whole branches of the evolutionary history that left no descendants. So we can control that explosion of information, which would cause us to run out of memory quite quickly, with a process called simplification. Here is simplification in action. Slim simplifies periodically for you by default automatically, but you can also control it completely in your model if you want to. Here, some ancestors that left no extant descendants have been pruned away by simplification. Have been pruned away by simplification, keeping the tree sequence slim. You can always choose to remember individuals in your model, preventing them from being simplified away if there are particular individuals that you need to retain in the tree sequence for your analysis. So now, after this simplification, we've completed the forward simulation in Slim, and we save it out to a tree sequence file. There's a problem with this tree sequence, though. The first generation of forward simulation First generation of forward simulation contains individuals that have no relationship to each other. In other words, there's no deep ancestry to this population. Typically, such ancestry is created in forward simulation with what's called burn-in. Burn-in is just a very long period of simulation that builds up genetic diversity in the population and builds ancestral relationships between the individuals in the population before you start your main simulation that you're interested in. Your main simulation that you're interested in. A rule of thumb called the 10N rule says that you ought to burn in for roughly 10 times as many generations as the population size. So for a population of a million individuals, your burn-in needs to run for 10 million generations. That can take a very, very long time with forward simulation. So burn-in is a big problem. Tree sequence recording solves the burn-in problem, at least to some extent, with a technique. To some extent, with a technique called recapitation. So now we're over in Python and we've read in the tree sequence file that Slim saved out. The green nodes at the top were generated by recapitation, which basically constructs a coalescent history backwards in time from the first generation of forward simulation. So we do our burn-in with the coalescent, which is typically much faster than forward simulation. Recapitation will construct the ancestry. Will construct the ancestor trees all the way back to coalescence. So, as long as a neutral burn-in is sufficient for your needs, it provides a complete solution, often an order of magnitude or more faster than forward simulating the burn-in. But there's one remaining problem with this tree sequence. Remember that we turned off neutral mutations in our slim simulation? I said we didn't need them, right? And that made our forward simulation much, much faster. All the work of simulating all those neutral mutations. Work of simulating all those neutral mutations was saved. But now we probably want them to use in our post-run analyses. How do we get them? Here we see the last step in the process, neutral mutation overlay. Basically, we can just take the ancestry trees, including the bits added by recapitation, and sprinkle neutral mutations along them. This is mathematically equivalent to forward simulating them, but it takes vastly less time, in part because we only Less time, in part because we only need to think about the branches that led to the final extant generation. All the branches that went extinct had neutral mutations on them too, but those mutations disappeared with the branches they were on, and so we can ignore them. Again, this typically provides an order of magnitude speed up or more compared to forward simulating the neutral mutations. Tree sequence recording in Slim relies upon several very powerful technologies. One is the TS-Kit frame. Technologies. One is the TS-Kit framework, which provides a foundational toolkit for working with tree sequences, and Slim relies upon it heavily. Another is the MS-Prime Coalescent Simulator, which performs recapitation and neutral mutation overlay for us in Python. And then finally, there's the PySlim package by Peter Ralph, which basically bridges the gap between Slim on one side and TSKit and MS Prime on the other side, helping them to work well together. them to work well together. So when you use tree sequence recording in Slim, you use all of these packages together, fusing forward simulation and coalescent simulation techniques into a new hybrid approach that's greater than the sum of its parts and enables some very exciting new modeling approaches. The third and final advanced topic I want to talk about today is multi-species modeling. This is the most recent addition, new in Slim 4. New in Slim 4. In single species models, there's a species object that manages all of the simulation state that's related to the species itself, the objects for the chromosome hierarchy and the population hierarchy in particular. The top-level community object represents the simulation as a whole and manages some state that's not species-specific, such as interaction types and log files. This object-oriented design makes it very easy to simply add more. Makes it very easy to simply add more species objects under the community object to produce a multi-species model. Each species object manages its own state, and the community object manages the simulation as a whole. So each species has its own explicit genetics and its own private state, unrelated to the other species in the model. But of course, the species can also interact with each other to produce co-evolutionary dynamics, eco-evolutionary dynamics, community dynamics. Eco-evolutionary dynamics, community models, and biodiversity models. So, this means that you can start out with a model of ecology without genetics, like this slim model of host parasitoid ecological dynamics. This model is based on a mathematical model from Foray and Schreiber 2014, and it's been converted into individual-based form. The plot here shows time in ticks on the x-axis and population size on the y-axis for the host species. Axis for the host species in blue and the parasitoid species in red. You can think of the host as caterpillars and the parasitoid as wasps that lay their eggs in the caterpillars, killing the caterpillars and producing new wasps. This model exhibits population cycling, as is often observed in ecological models like this. But since this is a slim model, we can now add genetics and take things up a notch. Here, I've added a quantitative trait to both the host and the parasitoid species, each based on many QTLs of fairly small effect. You can think of this model biologically in terms of the caterpillars having a particular phenotype, like a smell, and the parasitoids having a particular preference for the smell they like to hunt. The plot here shows time on the x-axis again, but the y-axis is now phenotype. When the model starts, the host is a little bit more than a huge When the model starts, the host species evolves away from zero, away from the parasitoid's initial hunting preference, responding to the selection pressure exerted by the wasps. The wasps chase after them in phenotypic space, and we get some interesting red queen chasing dynamics over time. So now we have co-evolutionary phenotypic cycling happening in the model, in addition to the population cycling that was happening already. This is the complete co-evolutionary. This is the complete code for that model. I realize that the font here is probably too small for you to really read the code, and that's kind of intentional. The point here is the brevity and simplicity of this model. We've got two species, each with a quantitative trait based on many QTLs, with recombination and linkage and all that, ecological interactions between the two species, as well as a competitive interaction among the hosts that I didn't mention, selection due to the parasitoids. Due to the parasitoids, and also stabilizing selection on the traits that I didn't mention. And there's also reproduction code and even logging of data to an output file, all in about two pages of Edo's script. This model is an example in the manual, by the way. So as we've just seen, intraspecies interactions are scripted. That host parasitoid model had some explicit Edos script describing exactly how the parasitoids hunt the caterpillars and the fitness. Hunt the caterpillars, and the fitness consequences of that interaction for both of them. You can script whatever kinds of interactions you want. Predator-prey, competition, mutualism, symbiosis, and community web and food web models are all possible. In fact, you can write even more complex models, such as epidemiological models, models of within-host reproduction and evolution, and models of multi-host life cycles. With scriptability, the foundation that Slim provides for multi-species. That Slim provides for multi-species modeling is flexible enough to accommodate all of these possibilities. And this really opens up the whole world of evolutionary ecology to modeling in SLIM. You can imagine writing models of all kinds of co-evolutionary and eco-evolutionary systems, bringing modern population genetic data to bear on questions in these systems that were previously quite difficult to approach with modeling. And I find this tremendously exciting. Exciting. So that finishes up the advanced topics portion of the talk. Now I'd like to show you a couple of example applications of SLIM. They're projects that I've been tangentially involved in, just because I'm more familiar with those and so I can talk about them. The first is a paper led by Mikhail Matz, a professor at UT Austin, on coral reefs and climate change. The focal question here is: can standing genetic variation and adaptation Standing genetic variation and adaptive gene flow rescue coral reefs. To study this, Misha built a slim model of coral reefs across a broad swath of ocean in the western Pacific. I'll show you a map in a moment. The model starts with a burn-in period to develop standing genetic variation in QTLs that influence temperature adaptation. And because the reefs have different mean temperatures, some of that standing genetic variation is locally adaptive. Adaptive. After burn-in, climate change begins following standard warming scenarios. The warming period runs for 200 years, and then the coral cover at the end is observed as the main outcome of the model. Here's a map of the initial state of the model. Each dot is a coral reef, colored by its initial pre-warming temperature. The turquoise arcs represent gene flow between the reefs. Corals have pelagic larvae that are carried passively. Pelagic larvae that are carried passively by oceanic currents. And these gene flow arcs are estimated from empirical data about those oceanic currents. So it's a pretty realistic situation. And this is the milieu in which the initial non-neutral burn-in is conducted. Here's a depiction of year zero, just before warming begins. Coral cover is mostly around 50%, which I guess is pretty typical of healthy reefs in the real world. In the real world, so the corals have achieved a reasonable degree of local adaptation to their particular reef's temperature during the burn-in. Then warming kicks in. At the top right is year 200, with gene flow between the reefs turned on due to those oceanic currents. The reefs in black have died. They have zero coral cover, but some reefs are still alive, and a handful are actually reasonably healthy. At bottom right, At the bottom right is a control scenario in which GeneFlow is turned off. In this scenario, all of the reefs have died. So, GeneFlow can rescue some coral reefs, particularly GeneFlow that carries warm-adapted alleles, towards reefs that started out relatively cold. Now, this is a pretty simple model. We make no claim that it's an accurate prediction of the future. It doesn't include any other species, like algae or starfish, and it doesn't include other species. Or starfish, and it doesn't include other effects from humans such as pollution or sea level rise. But it's a beautiful model that suggests that adaptive gene flow between coral reefs can help reefs adapt to the rising temperatures of climate change. And it points toward specific conservation and management measures we could explore, such as assisted gene flow from warm-adapted reefs, that might make a real-world difference. The second example I'll show you was led by Sarah Schall. I'll show you was led by Sarah Schall, working at that time as a PhD student with Katie Lauterhaas at Northeastern. The focal question here is: how and when do chromosomal inversions facilitate local adaptation? And this is an important question because empirical data often suggests that inversions can play a key role in adaptation and speciation, but the details of exactly how that works aren't well understood. The slim model that Sarah wrote. The SLIM model that Sarah wrote is conceptually similar to the classic Levine model, with two populations selected for different optima, evolving towards being locally adapted to those optima, but with migration causing gene flow that opposes that local adaptation. In Sarah's model, adaptation is governed not by a single locus, but by a quantitative trait influenced by many alleles of small effect. The model parameters are the degree of polygenicity of that quantitative trait, Of that quantitative trait, the strength of migration, and the strength of selection. The twist that Sarah added was to also model multiple emergent chromosomal inversions that influence recombination quite realistically. Now, Slim has no idea what an inversion is. There's no built-in support whatsoever for modeling inversions. So, this model is a demonstration of the power of scriptability. With just a few lines of Edo's script, Sarah was able to essentially. Sarah was able to essentially teach Slim what an inversion is and how it influences recombination and reproduction. In the parameter space that Sarah explored, there were three basic outcomes. For the first two outcomes, in red and orange, the amount of local adaptation observed in runs with inversions was equal to the amount observed in control runs without inversions. So the inversions didn't promote greater local adaptation in those runs. In those runs. But for the third outcome shown in blue, local adaptation was higher with inversions than without them, sometimes quite a bit higher. So in that blue regime, inversions promoted local adaptation. Here's a schematic of when those different outcomes were observed. The three panels show weak, moderate, and strong selection, and you can see that inversions could promote local adaptation across that whole range of selection strengths. The x-axis within each The x-axis within each panel is the migration rate. And for our purposes, it mattered only for strong selection, where inversions promoted local adaptation only in the face of very high migration. And the y-axis in each panel is the degree of polygenicity, and you can see that inversions promoted local adaptation only in the top row when polygenicity was high, with thousands of loci of tiny effect. This is a very elegant model that's deepened our understanding. This is a very elegant model that's deepened our understanding of the theory surrounding inversions, local adaptation, and speciation. My third and final example is work that's still in progress, led by Anna Clark, a PhD student at the University of Otago in New Zealand. Anna visited the Messer Lab at Cornell for a year and developed this multi-species model with us. The focal question here is, how do ecological interactions influence gene drive outcomes? Gene drive outcomes. The SLIM model is of four different invasive mammal species in New Zealand: mice, rats, stoats, and possums. Those four species interact ecologically in various ways, including both competitive and predator-prey relationships. I won't go into detail on that, but suffice to say that this is the most ecologically complex slim model that I'm aware of anybody having built so far. The community is strongly driven by resource. Strongly driven by resource availability in the form of tree masting, which produces a surge of edible seeds every five years in the model that causes a big spike in population levels, mirroring the real biology in New Zealand. These four species are all invasive, and they're driving a bunch of local endemic species extinct. The New Zealand government therefore has a strong interest in eradicating them, and they're looking at gene drive technologies as a possible means. Drive technologies as a possible means to that end. A gene drive is essentially a genetic construct that can copy itself between homologous chromosomes in the germline and thereby spread faster than normal Mendelian inheritance would allow, potentially rapidly reaching fixation even if the drive is deleterious, as shown in the diagram at right. Honestly, it's rather scary. So in Anna's monel, she introduces a gene drive into the mice, for example. She introduces a gene drive into the mice, for example, and observes the drive fixation time. And in her model, she can turn the ecology off and on. She can basically turn it into a one-species model of a gene drive in mice, or keep it as a multi-species ecological model with a gene drive in mice. And what she's observed is that the ecology matters. The gene drive fixes significantly faster in a multi-species context. These are preliminary results, but it shows. These are preliminary results, but it shows that the ecology of the system matters to the population genetics of the system. The two needs to be considered together to make accurate predictions about how a gene drive release in New Zealand might play out. So this is really exciting work by Anna, I think, uniting population genetics with ecology in a way that might influence public policy and conservation management. I think I need to finish up, so now I'll give you some closing remarks. I'll give you some closing remarks. In summary, I hope I've shown you that SLIM is a fast, flexible forward genetic simulator that's suitable not only for studies in population and quantitative genetics, but also for ecological and ecoevolutionary modeling. It has a full-featured graphical modeling environment, advanced support for spatial models, and can record tree sequences with TSKit for all kinds of exciting possibilities, and it's free, open source and cross-platform. And cross-platform. To get started, you can read the Slim and Eidos manuals, but together they're about a thousand pages now, so that's a bit daunting. A lot of that length is in the form of example recipes. There are more than 200 of them, as I mentioned. But still, it's a steep learning curve. To help with that learning curve, I developed the Slim Workshop, which gets you up to speed with a couple of days of work. I give the workshop in person from time to time, so if you can make it to an in-person So, if you can make it to an in-person workshop, that's great. But for those who can't, all of the workshop materials are also available for free online. So, you can do it by yourself or run your own workshop with a group. You can also read about SLIM in our various papers, which provide a quick introduction to the major features that we've added over the years, including tree sequence recording, non-rightfisher models, and multi-species models. And there are various other resources available, too. The Slim Home. Available too. The Slim homepage has downloads, including the manuals, but also quick reference sheets, recipes, and more. The Slim Discuss Google Group is a place where you can ask questions and get help from myself and others in the Slim community. And there's my email address there if you want to contact me directly. And that's it. I'm happy to take questions.