Okay, well, thanks Jake for that nice overview. So now that we've talked a little bit about the interplay between combinatorics and moduli curves, we wanted to say a little bit about the zoo of combinatorial techniques that might come up throughout the week. And one idea that was apparent to us was sign-reversing evolution. To us, was sine-reversing evolutions. So, in algebraic geometry, we like positivity results and like effective divisors. And side and reversing evolutions are a way to, say, cancel negative signs that come up all the time in algebraic comic twice. So, some highlights of applications are Adriana Garcia's proofs of Rogers-Ramanugian identities, and it's also come up recently in our. It's also come up recently in our joint work on combator. So it's flat varieties, affluent spring or fibers. And yeah, I'll let you take it away. All right, thanks, Sean, and thanks everybody again for being here. I'm so excited to be here after, again, two years of planning this. And so we're trying to give little introductory talks and sort of illustrating what ComeRock is all about. Jake gave an overview of all the objects we're going to see, and not all of them, but a lot of the objects. And not all of them, but a lot of the objects that we're going to see in your groups, things that the type of curves and moduli spaces we're going to be studying. And besides objects, another thing that I think we have a very diverse group of people with different strengths, another thing we can list is techniques, right? So there's also techniques to which you approach a problem in math. There's degenerations, you've seen some of that. There's recursion comes up a lot in these sort of modules spaces. Up a lot in these sort of botulized spaces, push forwards and pullbacks, and bijections, I mean, in common charts. So, there's lots of techniques that I think everybody here probably has a couple of techniques to bring to the table, right? And I can't draw a zoo of all the techniques because that would take a lot longer than I think than drawing a bunch of pictures. So, I'm going to focus on one technique that, like Sean said, came up in my work recently and does have a lot of applications to summations and things you might see. Things you might see. And it's also, I want to illustrate that it's sort of a were of sphere technique that some people might not have seen before, sign-reversing evolutions, that could illustrate how some of the combinatorial techniques that are going to be seen today could help with some of these geometry problems that you can translate them into combinatorials. So sine-reversing evolutions are very good for dealing with alternating sums. And these are just basically sums with negative signs. So when I think alternating sum, you think sort of plus minus plus minus, but I also think more generally just any sum that has some positive and some negative terms. And maybe you'd like to simplify this and either get a single positive number or a single negative number. And especially if they're all integers, but some of them are unfortunately negative, how do you deal with this, right? What is that? Fine. Yeah, let's do five. So, yeah, I didn't really think about that, but that's a good question. Let's just pretend it's fine for now. So, let's see. So, these come up in, you know, some geometric scenarios that these might come up in, besides the ones that Sean already mentioned, are, for instance, Are, for instance, computing orderly characteristics of some geometric object. You know, in three dimensions, you have the faces minus edges plus vertices formula, and so that's already an alternating sum, and in higher dimensions, you get bigger alternating sums. Then there's sort of some rings associated to geometric spaces, like the K-theory rings, that have a lot of negative signs coming up, and they do come. Lot of negative signs coming up, and you do computations in them. And then one I think everybody can appreciate here is determinants. Determinants, by their definition, certainly have alternating signs in them. And I wanted to mention this one especially because there are two famous results in pumping for it, the matrix tree theorem and the gues-BNL lemma, both of which have proofs using a sine-reversing evolution to simplify the determinant and get a single number out of that. So sine-reversing evolutions. So sine reversing evolutions, I'll write as SRI. Sine-reversing evolutions, these are methods, this is a method for simplifying sums. We're altering these sums. And I'm going to show an example that comes up in January. I'm going to give sort of a toy example to illustrate how this can be helpful in the context of the kind of objects that Jake was talking about. So the toy example we're going to So the point example we're going to use is considering an alternating sum that counts something in a poset. Let's consider the poset of the strata of M0 and Bar, so Jake's first animal in the zoo, the very first one where he had trees as a comment to our object. So the strata for M, zero, and bar, so you can do it sort of by inclusion. So if you have a big Sort of by inclusion. So, you know, if you had the big moduli space where you had the generic component that was 100% of the space, and then you had, you know, this sort of its closure includes all these boundary places where you have different trees. And so I'm going to draw the post-set of inclusion of like this edge will include like these boundary points and things like that. So combinatorially, the elements are trees that are at least trivalent, so no degree 2 vertices. Trivalence, so no degree two vertices, or no valence two vertices. And the leaves are labeled. So we saw that. And the covering relation in the closet is edge contraction. So this is just a purely combinatorial interpretation of this postet. And let's just say for three Let's just say for three marked points, the only tree we have is you have three leaves, and they have to be connected at a degree three vertex. And so that's the entire process, one element. For n equals four, it looks a little more interesting. You have the, at the top, you always have this element that's sort of a scar of leaves around a single vertex. And then it covers three different trees, which look like X-wing. X-wing finish or something. And they have two leaves paired at this vertex and two leaves paired at the other vertex. And there's three of them because it's just a matter of which one pairs with the leaf one. And so you get a nice little cosette like this. And I'm just going to draw one more, just a piece of n equals 5, because it gets much more complicated after this. So, if you have five leaves, then the easiest way to put it together into a tree is like this. But then you have trees that look like so you can pair one and two and then have an edge connecting it to, say, leaves three, four, and five, something like that. Something like that. What I want to do is organize, this postet is going to basically be rank-graded by the number of internal edges. So here's a leaf edge, here's an internal edge. So this one has no internal edges. One internal edge. And then the next row is going to have two internal edges. So it's going to be a great-graded process. And this line is going to have 10. 10 different things on it. You can do, you know, if I choose two ways of figuring out which ones are sort of the two leaves side and the three leaves side. So there's ten elements in this row, et cetera. And on the bottom row, in this case, they all look like sort of this shape tree. And I just want to illustrate this edge contraction, but I'm not aware. Contraction phenomenon where if you contract an internal edge, you contract this yellow one, then the one, two, and three go together, and you end up at that tree. And if you contract instead the other internal edge, then the three, four, and five should go together, and you end up at that trip. So that's what I mean by the cover information is that edge contract. Okay, so there's the post set, and there's lots of things we can do with post-sets. One thing we like to do is take One thing we like to do is take its rank generating function, which as Sean pointed out, this postet is rather nice. When we were talking about this, Sean pointed out to me that the Mobius function of this postet, if you calculate the intervals starting from the top, they're all plus or minus one. It's all Boolean sublattices. And so actually, the rank generating function up to substituting in minus Q is going to be the characteristic polynomial of this set, if that means something. So anyway, the rate, more concretely, More concretely, you're going to have 10 elements here. There's actually 15 elements on the bottom row of the doctor. This one we have a formula for. If you're on the bottom row and you have all degree three internal vertices like this, the number of elements you have on the bottom row of poset is the product of the odd numbers from one up to something. And this one is harder to compute in general. This one was one. And the rank generating function just means you say, one, there's one thing in the top row. 1, there's 1 thing in the top row, and 10 in the next row, so you'd say 10q or something like that. And then 15 in the third row, so you're right, 15q squared. This rank generating function, you can try to compute it. You can try to see if there's any nice formulas. Plugging in q equals 1 counts all of the trees. No really known nice formula for that. But actually, plugging in q equals minus 1, actually this is something that me and Jake were just playing with to try to make an example. This turns out to be quite nice, and it is a This turns out to be quite nice, and it is an alternating sum. 1 minus 10 plus 15 is, in this case, 6. Let's see what it is for these. So for n equals 3, we just have 1, so nothing discompute there. And the alternating sum for n equals 4 is 1 minus 3 is negative 2. So our sequence of alternating sums so far by n, or should I put this up here? So our sequence of alternating sums is 1, negative 2, 6. Okay, so we were looking at this and we had a very hopeful guess for the next one. You can guess in your head what you want to think it is, but I'll tell you what it is for n equals 6. I'll tell you what it is for n equals 6 without drawing it. n equals 6 is too large to bother me drawing everything, but I'll tell you what the ranks are. So if you're n equals 6, you'll have the alternating sum 1 minus 25 plus 105 minus 105. Now this 105 again does this like product of odd number. Is this like product of odd numbers? You just add the next odd number each time. So that's that one you can compute. These are harder to compute. There's no real explicit formula out there of every rank of this plus set. But these 105s cancel and you get negative 24. Okay, now I want to ask the audience if this is familiar. So, what should the next number be in the sequence? What comes next? 120, probably. So, yes, and Probably. So, yes, and it does continue like that. I don't even know if this is known or not. Well, all right. The NJ just sort of stumbled across this as we were trying to find a fun sign-reversing evolution that made a good example. And so we would like to take this funny alternating sum, which this is a coincidence. Usually they don't have two of the same number. And we would like to sort of figure out how to get these factorials out of it, right? Get these factorials out of it, right? So the conjecture is that it's plus or minus n minus t factorial is what you're left with. So I want to show the method of sine reversing involutions for doing, for proving this kind of conjecture. And when, so I'm going to sort of tell a little story. Me and Jake were working together to plan these introductory talks, and we stumbled across this scene. We stumbled across this seeming fact. And I was like, well, maybe there's a sign-reversing evolution because of a similar problem. I know a sign-reversing evolution hold. And so I'm going to start by showing you that similar problem because it's a known famous sign-reversing evolution, and then I'll show you the one that works for this. So we're going to consider Consider a related problem or related sum, I guess, where we're actually going to consider a sub-poset of the coset that we were looking at, what I'm going to call caterpillars. This is a term that people in MZRN Bar like to use for certain types of trees, but I'm actually going to Trees, but I'm actually going to specifically do a certain type of caterpillar. I'm going to call Petapan a set of caterpillars, caterpillar trees that look like you look at the path from one to n on your tree, and all of your other vertices along this path, they only have leaves coming out of them. You can't have like a branch coming down like that with other leaves. You have to have just, you know, some leaves like that. So, this is a kind of So, this is a caterpillar because it's like a spine of legal height. So, we're going to consider that set, and this is a subpoen set because if you contract an edge of the caterpillar, you're going to still get a caterpillar. So, that's okay. And if you consider the same alternating sum, you also get something nice. And I knew you did because these caterpillars correspond to something that combinatorialists like to work with, called ordered set partitions. So, for instance, one, two, three, four, five. Oh okay, so this caterpillar, for instance, would correspond to the ordered set partition, which we call OSP, you call it corrupt. 25 is the first block, and then 378 is the second block, and then 4. Is the second block, and then four and six. It's just an ordered partition of the numbers two through eight in this case, ordered from left to right, but the ordering within the blocks doesn't matter, so we just order it. So that's just sort of showing all the leads attached to each vertex, from left to right. So I knew there was a sign-reversing evolution that cancels all the ordered subpartitions when you assign plus or minus one based on how many blocks they have, except for one of them. So in particular, Except for one of them. So, in particular, the alternating sum for this poset, for n equals 5, I'm going to schedule very quickly. This sub-poset will look like you have your, you still have your star at the top, which I'll draw like this. You can draw it like your particles. And then you'll have caterpillars that look like, you know, you have your two, three, and four in some order, paired in some way, the second row, and you have sort of permutation caterpillars down here. Caterpillars down here, like four, two, or something like that. And so you have, you end up having one element in the top row and six elements in the second row and six in the third, and you get an alternating sum one minus six plus six, and it's just one. So actually, it's simpler than the factorial. In particular, for n equals six, without drawing the picture, the alternating sum you get is one minus fourteen. is 1 minus 14 plus 36 minus 24. And if you calculate that out, that's negative 1. So actually, this alternating sum is always either 1 or negative 1. It's actually minus 1, 2, 0, and minus 1. And so you'll notice you can't just like, like in this case, it's tempting to just cancel these sixes, but in this case, the answer is negative one. So actually, this one is not like the one that survives. It actually comes for the last term, believe it or not. And we're going to take a special element. And we're going to take a special element on the bottom row and kind of keep that one fixed and then pair everything else with each other so that all the positives and negatives cancel. Because essentially this, you know, I'm alternating the sign I control. Okay, so how do we do this? This is a classic, this is in Bruce Sagan's book on introduction to combinatorium. So I learned about this sine inversing evolution here. So the method, so I'll state the theorem in the sketch. I'll stick the theorem and sketch the proof here. So sum, but if you sum over caterpillar trees of minus one to the number of internal edges, so I'm really thinking instead of these big sums, I'm thinking this is like 14 negative ones, they're mad in together. And 36 positive ones and so on. Um this is plus 2 minus 10. Plus or minus 10. That is the theorem. Particularly it's the proof sketch is we construct an evolution, say phi, from cat of n to cat of n with the following properties. So first phi is an evolution, meaning it's its own inverse. So phi being its own inverse visually. So, phi being its own inverse visually, what I like to think of is if these are the points of your set, either phi has only two cycles or one cycles. Because it's its own inverse. If phi maps this point to that point, then it maps that point back to that point. But it also can have some fixed points. And so we want this property, we want it to have exactly one fixed point, and the rest two cycles, because I want this to be plus or minus one in the end. I want all the other two cycles. Minus one in the end, I want all the other two cycles to be canceling, and then I want it to reverse sine. So sine reversing evolution. Meaning, if you're not in a fixed point, then you have one plus and one minus in that time cycle. So this way, everything will pair up, and then you'll have just one. So, how do we construct this v in this case? Well, I actually want to identify the fixed point first. The fixed point is going to be, if you're on your path from 1 to n, it's where all the other numbers are decreasing. And I know I wish I could have changed notation to make it the increasing one I put out, but it makes the evolution more messy. So just bear with me here. So this is going to be my fixed point. My fixed point. Phi is going to send this to itself. And then the rule for phi on all other elements is the trick of side-reversing evolutions is basically you identify what fixed points your goals are. And for the other ones, you look for like the first bad thing that happens and change it. So the first thing that's not like this sequence. So let's let V be the leftmost vertex. So I'll say the leftmost bad vertex. So I'll say the leftmost bad vertex after the longest run of decreasing singleton leaves. So the maximal initial run of the form, you start with your one and you have like say B1, B2, I'm using B2 branch, B3, up to BI. And these are decreasing, just like our fixed point, we want that to be maximally increasing. That's going to be maximally increasing, but if we run into a vertex V that violates that somehow, either you have a singleton that increases, or you just have multiple branches or something like that, multiple leaves, then V is our first battery text. And we're going to either contract or expand an edge in order to cancel the signs. And so what we do is we let V, capital B, be the branch here, at V, like all the leaves at V. And when you set m, let's say little m is the minimum element of the battery. The branch being at the battery sets b. So it's like bad branch b. When I say branch, I just mean all the stuff that. When I say branch, I just mean all the stuff that attached to B. Maybe it's just some. I should say block, maybe? Anyway. So M is the sort of smallest thing attached to the bad vertex. And then you have two cases. So if Bi is bigger than M, then you split M off and you make it part of that longest run. So split M off as its own singleton. On singleton, singleton loop. And then otherwise, if vi less than m, we merge this leaf vi with. So let me just do an example to show how this works. Okay, so our longest run of decreasing singleton is 732. So this is our bad vertex, V. Here's our branch. The minimum element m is 5. And 5 is bigger than 2. And so we merge. So we take the 2 and we put it in the set, which also means we contract this edge. I'm going to draw the edge that we contract like red. That's another way you can think of it. And so he. Um and so he sends this one to seven three two five six four eight. And we can see that phi is its own inverse because if we just apply this rule to this output, we again look for our longest decreasing sequence is just seven and three. And then two is m. But this time m is less than the last element. Is less than the last element, so when we have 7, 3, 2 as a decreasing sequence, that means we can split off the two and go right off there. So I'm not going to go through all the details of the proof. You can work that out. It is an evolution. And it also alternates signs. So this one has 1, 2, 3, 4 internal edges. This is a positive element. This is a plus 1. And this has 1, 2, 3, because we contract on an edge. And so this one's minus 1. And so these terms cancel. And so going back to our sum, all the plus and minus ones cancel. Sum, all the plus and minus ones cancel except for this one, which phi doesn't do anything to because there's no bad three terms. So that's the idea of a sign-inversing evolution. You have your fixed point goals that you think you cannot be answer. You try to cancel everything else by looking for the first bad thing and talking. So finally, let's finish up with the short mystery of the factorials in a big pro set, which actually turns out to be a much easier sign of this thing evolution than this one. Than this one. So, but it's sort of inspired by it. It's just different, though. It's not like a technological job. So that theorem now, going back to the main proposet, what we really found is that the sum over t being a dual tree and j2, m0, and bar, the combinatorial. In M0 and F bar, a combinatorial object describing those strata of, again, minus 1 to the number of octanel edges. Now it doesn't have to be a catapolic, but you can still count the octanel edges is plus or minus n minus 2 factorial. And in terms of the sign, it's just, again, like minus 1 to the n minus 1. But we want to focus on n minus 2 factorial spin. On n minus 2 factorial specific trees that we might want fixed points. And so we construct a sign-reversing implication whose fixed points are all the n minus 2 factorial caterpillars where you have some permutation here, 1, 2, 3, 12, 6, 7. Like Okay. So there's n minus two factorial ways of rearranging the numbers from two to n minus one. And so we're going to just consider the councils where all the leaves are simple things. All the branches are simple things. So there's n minus two factorial leaves. They all have the same sign because they all have the same factor of internal. Sign because they all have the same type of internal. And we want to cancel all the other ones. So we want to cancel the non-fixed points. So again, we're going to look through the leftmost bad vertex. In this case, the leftmost bad vertex is just going to be the first time that it's not just a single leaf off of here. There's two things that can happen. So let me. E, so let T be a tree, and B the leftmost breakout that's not a single week. Then there's two things that can happen. So you can either have something that looks like if you have the same That looks like if you have some singletons, here's your first vertex V, you can have a branch that's not just a singleton because it keeps branching. So you can have an internal edge. You have a single internal edge. So one internal edge, alpha V, or you can have multiple branches. Multiple branches. It could be multiple leaves. It could also be other branches. And these are going to pair with each other. And the way you do it is actually maybe apparent from the two examples I drew. You can just take this edge. If it's this case, you contract it. And now you You contract it, and now you might necessarily have multiple branches because this vertex down here is at least valence 3. And so then you have multiple branches. If you have multiple branches to contract going this way, if you have multiple branches, then you just sort of take your leftmost V as the same V. To go back, you just add an internal edge at V and attach the branches. So you sort of pick these up, add this edge, put them down. And I think I must be out of time, but I've just finished the evolution. So one, two, three, this has three internal edges. This one's a minus one. And this has one, two, no, four. This one. Sorry. This is a plus one. And this one has three. And so it's mine. I missed the rep. Wait. Oh, oh my goodness. Wait, I'm also missing this one. I was right the first time. One, two, three, four, five. Did I get that right? Okay. For five. Did I get that right? Okay, now it's minus one. And this one is plus one. And so they cancel. And yeah, because we're contracting or expanding it out. So that means that everything in this term cancels, all the plus n minus ones cancel. We have these n minus two factor at once left. And that's a segment. Say this rule again? Yeah, so you march along the path from one to nine in your tree. That's always a path, right? There's always a new path from the nine. You look for, is this other branch off of this branch? Is this other branch off of this vertex just a singleton leaf? Yes, okay, so you keep going. Singleton, singleton, non-singleton. The non-singleton can be of two different types. Either it has multiple branches, or it doesn't. If it doesn't, though, it branches more because it's not just a singleton. And so if it's a single branch like this, you just contract this edge. And if it's not, you pick up these branches, you take them off the tree, you add a little edge, and you stick on the bottom. I don't know if that made sense. Okay, how can I? This is a good example because we're going to have a lot of different people from different backgrounds, and the way I'm explaining things might not make sense to everybody. So, Diane, you didn't understand what I did here. Okay, well, then let me draw another picture. Okay. So, what I'm doing is I am splitting up these branches. Off these branches, I'm like picking up each branch off of V, which are these two. I'm picking them up and just disconnecting them. At another vertex that's like floating in space. And then I am leaving everything else the same. And I'm adding an edge like that. Does that make more sense? Okay. There's probably some geometric language that I could use to say, like, I'm smoothing a note or something, and I wrote. Like, I'm smoothing a note or something. And I honestly can't do that in real time. So, what am I doing? In the file design, you have at least files in four, which you have at least one of them in three of them. You can be generated. So, you have to generate. Degenerate, because these branches are like attachments, and so you degenerate them together. That's good. That's right. There we go. Thank you. And this is a great example. This is something that I hope everybody in your group feels comfortable asking each other. Like asking each other, just keep saying I don't understand until you do. And that's, yeah, that's in my experience how I work with the geometric. So I don't understand. Is it possible for this anomaly to have, for both of these things to happen at the first vertex, really have one that's going off, but also another only on the other side, it goes like a bunch of things. Oh, oh, so you mean like, can I have another branch going? Oh, so you mean, like, can I have another branch going up or something? It will, yeah, yeah, or like two of them. Yeah, so if I do, maybe I should just do more examples. Um, because maybe not, but um, the cases are like it's valence three or it's not valence three. Yeah, yeah, yeah. Okay, so maybe I should write the rule. Okay, I think this is a case where I'm a prominent, and what I do to explain things is I do a million examples, but what I should do is write down the rule. And so I thought I did it, but I didn't. Did it, but I didn't. So the rule for B is: so let B be the leftmost non-signal gene vertex, non-signal team vertex. Okay, are we okay with that definition? So it's the non-valence three. No, because it could be valence three without being a leak. Oh, right, because it's got a. Three without being a leaf. Oh, right. Non-signleton leaf. Oh, man. Non-signleton leaf. Non-signleton leaf. Okay, two cases for an. Okay, maybe this is more complicated than the other one. So if you have, there's two cases, right? And I have, again, I'm drawing pictures. Sorry. So one, B is valence three. B's like pair. What's that? V's pair. V is we. What's that? These pairs. These weak. You're counting the two edges to left and right. Yeah, yeah, yeah. Oh, valence one coming off the tree, but there's two edges. Yeah, the whole thing is a tree. So you have your V. V could be valence three, but this can't be a leaf, which means there have to be at least two more things coming out here. Maybe there's three, right? Maybe this one branches more, something like that. And that's case one. Case two, again. Case two is B has valence bigger than three. Because we can't have valence two, model out, b is model E. And so if it has valence bigger than three dotted, that's these two examples, right? This one has valence bigger than three, and there's valence equal. And so then in case one, so if you're in case one contract the edge connected to B. The edge connected to B, which, the edge going down from V, right? The edge at B not on the path 1 to U9. So it's this unique edge. You can track it. And that's what P does. And if you're in phase two, we How do we say this? Move all of them off. Move all branches off of V to attach to a new edge from V. Say E, uh E. And this way you're back. So this doing number two will put you back in case one to do it, starting from number one, you'll be interested. Is that more clear? Okay, great. That was a good exercise in this communication. Yeah. And we'll have a discussion about communication between giant patient combinatorics tonight. So think about everything I did wrong and tell me it tonight. Jake mentioned stability conditions without really saying what they were, but also without knowing what they are. Are there any situations where you can set up a stable object as a takes place of such function? Does the stability conditions basically refer to, in this case, not having a degree to revert to the case? Not have any degree through vertices? Yeah, it seems like sort of another extreme old thing, right? I got your friend, I'm not quite sure what you're asking. Are you just asking, are there other animals? Yeah, I'm asking about Jake Sock, so that's great. Oh, can we do another side versing evolution for other animals in the zoo? We were just playing with this on the bus from Boundary Airport, but we have no idea. So that's a good question. And if anybody wants to explore this, I think it's a fun question. So you mentioned some applications of this. Could you just say it again? Could you just say again? Like applications of sign-diversity. Yes, the two biggest examples of sign-diversity evolutions that I sort of teach in my classes is the guesselvia no level. This is rather general and applicable to lots of counting problems where you're sometimes literature, yes will be a no. It depends how general you do. This is about counting non-intersecting lattice paths between a set of sources and a set of sinks in a lattice. And then there's the matrix tree theorem, which counts standing trees of a graph using a determinant. And actually, you can prove matrix tree using Geselfino. So, really, Geselvino is like the classic example of using sign-overs and evolution to compute determinants. And then Sean mentioned the proof of Roger-Germanogenes, right? Combinatorial proof, of course. Yes. So combinatorial proof, yes. And sometimes it's nice to have a combinatorial proof of things, even if they are already known. And in fact, I'm curious whether this n-2 factorial thing has some kind of geometry. Two-factorial thing has some kind of geometric proof. Yeah, not the proof, but what about an algal tradition of like what is the time? I have no idea. Can you tell me? Sorry, go ahead, Renzo. Exactly. Because I wanted to ask Huey, so isn't that n minus 2 factorial plus or minus 1 related to the other characteristic of the link probably spread? Well, it doesn't make it. But it's like, so I guess my question is. What is it? So, I guess my question is to you, and now that we have some results about the topology of some of these moduli spaces, being like what spheres and stuff like that, are we how far into the end do we