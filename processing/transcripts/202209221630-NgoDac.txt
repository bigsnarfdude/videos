So thank you very much for the introduction. So first of all, I would like to thank the speaker, the organizers, for the invitation. So today I will talk about my So today I will talk about my short work with Joko Vasatski from Jerusalem. So I will divide my talk into four sections. So first of all, I will give a sort of introduction. Then I will introduce the notion of stukas and then the generated stukas. And at the end of my talk, And at the end of my talk, I will state the main results and try to sketch, give a sketch of the proof. So, introduction. So, why do we need Schookers? So, I will take X is this tough to be smooth. Projective geometrically connected curve over a finite field Fq and I will denote F to be the function field of X. So in the seventies, Prinfe introduced Introduced the notion of Stukas and he studied what we called drinfell stukas. So I denote by drink fell. This is a kind of stukas, a rank two of X. And this is the analogs of simura varieties that we heard this morning in the Andre's talk. Andre's talk, and then he used this kind of stuff to prove the so-called Langland correspondence for the group GL two over the function field. Over the function f. So, this is in the 70s. And the most important here is you have the line two. But after that, in the 90s, Logan LaFour generalized this work to train for Stukas Planck R. Rank R over H, and he proved the Lambland correspondence for CLR over F. So, in this talk, we don't care about the E, I just don't. I just mentioned the Langland correspondence for the motivation. But in this talk, we will try to look at the difficulties on the geometry. So what happens if we look at the geometry? So the most the hardest part on the geometry Geometry is that if we look at the stack or moduli space, Stuka classifying 25 modules of rank R. This is not a finite type. So, the central problem on the work of Laptop and On the work of Laptop and Prinfel on this geometry is try to compactify this one. Yeah. This is Archie stack. Yeah, locally a file type. So, what do I mean by compatify this one? This is only locally a finite type. So, the first step is to try to find interesting open substat, a finite type. And then we try to find a classification of this one. So, the solution of LabFog and TrinFail. Train file is to use the evaluative criterion for properness. But by doing this, his proof is very complicated, so he needs to go back and forth and modify. back and forth and modify the modify the condition condition on the boundary and at the end of the diify a condition but which is not natural so there are two extensions that we can ask the first extension is that we can replace or generalize this notion so replace So replace stuca of print file of blank R by something more general. We call it simply Stuka of rank R, arbitrary modification. And we can ask exactly the same question. So the second extension. So we look at what has been done on the Shimura varieties. So we try to replace CGUNR by a twisted version. By this, I check ID to be a division unseparable of dimension R2. dimension R2 R square over F and we take D to be a locally free OH and Shepherd whose generic fiber is B And we can do the same the same game. So we replace stuca of twin file of rank R by Stuka of D. So this is a kind of twisted version. So if you look at the problem for simula varieties, Simula varieties, the twisted version is always proper. But this is not the case here. So this is done by it's not always proper. So this is the work of Lafarge. Lafarge Mou and Ekolau. So the goal of our work is in some sense to give the answer to both extensions. So I try to draw a picture here. What we try to do. So here you have Stuka, print file, a prank R. So in this way, it's done by Melanfoch. So here I put Lambton and GIT. So as you know, we have two ways to construct or to prove problems. Or to prove properties. One way is by CIT. You take a projective variety and you take an action of a group and you take the quotient. So the quotient, if you take by quotient by a prospective variety, then the quotient is proper. And the second way to do is by lambda, by the valuative criterion for properness. So. So, in this way, it's done by Laver. And we can do by the GIT. This is my thesis long time ago. So, we can try to get something here and for Sukka D. So, in this way, by CIT is possible. But the language, but to do CIT for Stuka, for D Stuka is very complicated. So, this is so what we try to do is to fill out work is to fill these two two boxes. Two boxes. So we try to do a lengthen for both of these stacks. So now I will move to the definition of a stukas. So, properly speaking, stukas. Properly speaking, Stuka is not something very far from vector bundles. It's just a vector bundles, then plus a modification. So now I take the one R. I take R to be an integer greater than two. One R One R is just classifying the following data. It's classified for every scheme S of FQ the data vector bundles of rank R of X Ah here we fetch a scheme. Here we fetch a scheme, so over x times s. So this is one R. And now we try to modify a little bit. So I consider the hiker stack R. Just classify. So for every scheme S of FQ, the following data. So the first data, we get a point of X of S, and the second data, we just take a modification. By this, we have a two vector bundles E and E prime in one R of S and we take a modification. We take a modification. So, what does it mean? A modification I take so here you have rectangles of rank R. And if you look outside the graph of X, they are they are I'm going to like to control the modification of this point. So, what does it mean if you have an isomorphism Outside X. So, for simplicity, I will take S to be a geometric point. So, you take spectrum of K with K a field. So, then you get an isomorphism outside X. So, if you look at the generic fiber, you get an isomorphism for generic fiber. And outside, inside, you get two lattices. So, you have two lattices inside the latest. Inside a vector space, and you can compare these two lattices. So if you compare these two lattices, what do you get just called invariant? invariant if I denote by this by phi so the invariant of phi will be an uh say an element mu which is a dominant cost Is it okay? Yeah. Here you have this is a two fx vector space. I don't know f is the local ring at x. So this is a D VR. So, this is a DVR. So, you have two vector spaces, a point R, a dimension R of F, and you have two lattices, and you can compare it. You look at the relative position, it gives you a dominant cost. This by this, I mean here you get a basis and here if you take a uniformizer you can write our h mu one Um Mu one E one Okay, that's okay you normalize and make it yeah so I guess P what you're calling this the identity more you said invariant is P is what's P on just the whole data? Yeah, trust. Data, yeah, just you just take mu one to mu r. No, I get that, but that's being as random. No, this is the isomorphism. Yeah, you you arranging so that mu one is greater than mu two. So for each modification, you can get an invariant and you can look at the substack height of R. So we fit. Say lambda to be a dominant covet, and we define to be the substack. So this is a substack of modification such that the invariant of phi Variant of phi is smaller or equal to lambda. What does it mean? It means if you write mu one, mu two to mu r and here lambda one to lambda r this means that you ask mu one smaller than Smaller than lambda one, mu one plus mu two smaller than lambda one plus lambda two up to r minus one and for R each Now for R is not an equality, but it's not an inequality, but in an equality. So the sum from mu1 to mu r will be equal to lambda 1 plus lambda r. So this is the condition to define the substack hecker R of lambda. So, this is you, this is a hiker stack if you modify at one place. Then you can continue to play the game with you, you may have modification, many modification. So, if it's So if you take a bunch if you take a bunch of dominant costs, you can define iterated modification. So if you have lambda one, lambda bar. Lambda bar This is not N so you have and dominant co-weights you can take the successive modification you can move like R lambda bar is just Is just this is classified so you have a bunch of H1 to HN you have n part of your curve then you have the modification zero one 0 1 0 0 E 2 up to E n such that you have phi I a modification from EI minus one outside H I to E I H minus with With the condition that the invariant of phi is bounded by lambda i. No, this is the dominant cost. It's no longer a number. So, this is the modification. So, now I define what does it mean by Schukas? So, Schukas is almost like hacker stack. What do we need to add? It is to ask, you modify by one step, two steps, and step. Step, two step, n step, and at the end of the day, you would like to have get back to the first one, but a twisted version. So, Stuka applying R with modification lambda classifies. So, you have the bunch of X here. So, this is stand for H1 up to Hn and then I put E bar this data E bar and then C So the first data is in Haiti. In Hyper of Lambda. And the last one, we would like to have an isomorphism. You take identity over X and the probinus on S, you take the pullback. pullback of easier and it requires that you get an isomorphism with E n so you go you modify from E0 to get E1 modify E1 to E2 etc to EN and you require that for E n this is exactly the true Exactly, the twisted the pullback of E0 by this isomorphism. So this is goes to cars. It's a kind of if you take the um the graph of uh The graph of four minutes. But the miracle is that if you just take, you don't do any modification, you just take isomorphism of the pullback of E0 to isomorphic, isomorphic to E0. You get nothing. You get just one R. So if you had no modification, what What does it mean you take this one? And it requires that it's isomorphic to E0. So what does it mean? It means that E0 is in fact coming from one R of F Q because you get something. Because you get something fixed by the flow beneath. This means that you just come from the bottom. So you get nothing but a finite set of points. So the most important thing here is you just put one or two modification, then you get everything. So this is the most important part of the work of TrinFile. Of the web of dream file. You just to find the right notion, and after that, you get everything. Yeah, no, dream fail. Thank you. So, dream fair stuka. So, if you look at the decree. The decree condition. You can get a condition on the lambda because here you get the same degree. So each time you modify, you can control the degree. So treat is when you get. Is when you have lambda, you take two modifications, lambda one, lambda two, where lambda one is given by zero zero zero one and lambda two is minus one zero zero zero so you take two mini scale dominant code weight and this is called three infiltration. This is called free influx to gas. So you can then you can put any kind of modification to get the ask. We need a similar condition in order to have this last thing in the end. You have to add up to zero of the total number total. Total number of total weights of the modification has to add to zero. Yeah. Yeah. Because you can control the degree when you pass from E0 to E1. You just put, you just add the degree of Lambda one. And so to get to En you, the degree will be degree of Lambda one plus degree of lambda two up to degree of lambda n. Up to degree of lambda n. But here you have an isomorphism. This means that you get the same degree, so the total degree will be zero. So you can put, you can define the substack. So this is a substack of Stuka of degree D by simply asking degree of ECL to be D. D. So this is a fact is that this stack this is an artin stack locally, a finite Locally of finite type. So now because we had only locally a finite type, what do we want is to get something of finite type. So this is why we need the polygon of Hadonara Sima. So, this is you ask the polygon of E0 is less than P. So, what does it mean? It means the following things. So, by P, by Hadonara, Siman Polygon. So this is hard neural CMA polygon. You just take a convex polygon. You have zero, one, up to the R and you take a poly. And you take a poly. This is what we all know about this. So this is P from 0R to say R such that you get P0 equal to P R equal to 0 and P converts. And I really note delta We denote delta P at I will be Pi minus P I minus 1 for all I from 1 to R. And what does it mean? The condition P E 0 less or equal to P this means that for all sub-pando F of E zero. zero you get the degree of F is less than equal to the rank of F over R of degree of E0 is D plus P a rank of F so this means that the you get an upper bound for the sub bundle of Upper bound for this bundle of E0. And by this way, you get here something I subtract a finite type. So if you type P to be bigger and bigger. Be bigger and bigger. You can recover all the stack together a bank R. So the main point is that this is not enough. This is not proper. So, the question is: how to compactify this substack? So, if we look at the condition here, you get something in the Heiker stack, and then we get an isomorphism. So, the idea is to degenerate two gas by in us by in certain sense to relax the isomorphism. We will try to replace isomorphism by some minor condition so that we get something which is not prop which is not separated, but we can construct the in some sense limits. Subdue generated So, to do so, we need to look at the following morphism. So, I take the map from GLR MR minus one into the product of isomorphism R R of endomorphism of lambda I of IR time. You just type Z alpha one up to alpha R minus one and you send to you one U R U one you are minus one Where so you one will be see you one this this one you say you two Yeah is equal to lambda one. is equal to lambda one u two and so alpha one r minus one alpha two r minus two up to r u r so you have a map from here to here and you define v to be the closure Of this one, this is inserted C L R C M R minus one inside the right hand side. You just take a schematic closure of this one. So, this is called the Vinbo. So, this is called the Vinmark semicool. And this is in certain sense, this is the iPhi version of the the Conchini processy compatification. Compassification compactification of PCLR here, you have C group. This is from CL. This is from CLR. So it's very related. But what do we need? Is that we would like to replace an isomorphism. This is an element in CLR by a bunch of morphism. So this is exactly what we are trying to do. We are trying to do here. We replace, we defy the generated two cars, classify exactly the same thing and replace the isomorphism you see here by a bunch of morphism. So, yeah, I write down the whole definition. So, for we need not only see, but you have to see prior definition is the same as the. Right definition is for every one i from one to r minus one. L i is a but a lie bundle of s L i is a global section of L i and then you get a bunch of isomorphism UI From E0 tensor L I I minus J J from one to I minus one you twist sigma is a pullback by identity time flow benefit to lambda the i of E n i a bunch of A bunch of right so here you you get only an amorphism from this one to this one no you I get some simple conditions yeah such that Such that value for every trivialization trivialization of E0 E N L I L I is a family so you get So you get the family E one to E R R one R minus one This is an element in V so when you trivialize you get the section will place the role of lambda i. The advantage of the city is a very important thing. So, this is a very complicated definition, but we should. We should what we should keep is the following things. So you can get a stratification of this stuff. You can stratify it by asking what you mean by oh this is. This is R1 less than R2 less than R k minus 1 less than R and I will put R 0 here. So how to define this stratification where we require R to be zero. To be zero if equal to outside and invertible otherwise. So look at this is over a geometric point. So over the a geometric point, your Lie bundle, you can take the trivial Lie bundle. And this is an element of your field. element of your your field so if n i equal to zero you touch the index otherwise you forget the index so when uh equal to empty you get back see substack of sugars because Because everything is invertible. So this means that you will get the isomorphism. Otherwise, when you are not empty. So these complicated things, you can replace by two situations. The first one, you take the pun back. You take the pullback of zero. This is denoted by E0 bar. You get the first increasing penetration of sub-bundles of a co-rank R1 to Rk minus one. The second one, you get a Second one, you get an increasing filtration from zero here, not of En R one to E n R k minus one of E n And the last, but the most important thing is that you get back the isomorphism. An isomorphism from E zero R I minus one over E zero. One over E zero I So, in certain sense, you replace one isomorphism by a bunch of isomorphism. Isomorphism change the take a trivialization of E0, right? Yeah. One trivialization of E and it satisfies this condition. And it means that the U's are essentially all the U's is determined up to a scalar by the UY. Yeah. But then if you change the tributization on En, it changes lambda. n it changes lambda i of the n alpha scalar unless i is the right how is this possible no here i i don't i i don't defy the isomorphic in data so when you change uh just change by the scalar yeah yeah but i'm saying if you change the trivialization of en for all trivialization You have said for all trivialization, right? Yeah, you fix one and everything is fine. Now you change the trivialization of EN that will modify lambda i of E n by a non-scalar. Yeah. But you're only allowed to change the u ties by a scalar from what they were before because the u1 stays the same up to okay. No, okay, I guess it's a Oh okay, I guess it's a I'm not sure. When you change um the yeah, you change the lava uh alpha i too. Yeah. Some of them could be sealed, right? Yeah. Yeah, but So I will state on the decrease in the pressure you are taking the zero of. Yeah, you know that the co-rank of sub-bundles is exactly R1 to Rk minus one. So what are you doing there together with practice? You just taking the zero logic or what are you doing? No, I'm what I don't talk about is that. You can, this is I take a sim a closure in the sense of scheme. But there is a big fact. In fact, it's a theorem due to Winberg and many people, which give a modular interpretation. Modular interpretation of V and by using the modular interpretation of V, you can get this kind of stuff. It's not trivial. So now I define the capacification. So now you would like to know how to compactify things. things. This means that if I give a boundary condition D less than P so what happen to the boundary so how to define this one So we'll uh so I try to define this uh condition submit stability. Condition: some instability over a shuttle. So I fix a stratum. Say R. I take exactly the same data here. You get a decreasing filtration, a increasing filtration, and I will define the summit stability condition on this filtration. So, the condition is as follows. So, we ask for every F is a bundle of E0. We get the following condition. So, the degree Degree of F less than equal to rank of F over R of D plus a sum I from one to k of lambda p of r i minus one plus one plus delta p of r minus one plus two. Up to delta P R minus one plus the rank of the F intersect with E zero R minus one portion by F sigma and E zero R So, this is the thermostability condition. So, for example, if you look at the F equal to E zero R I is said that the degree of F of E zero R I is bounded by It by this thing plus P of rank of E0 RI. So this is RI. So this is the normal thing. But if you take F to be zero or on then the decree Will be this one, but minus. So here you have a minus. So this is the effect of this summit stability condition. stability condition this means that you're not for the for this filtration uh you get uh bounded by for the increasing uh filtration you get bounded by by the normal polypony but for the decreasing uh filtration you get bounded by the symmetry of the polypon Of the polyp So the theorem If P is convex enough. Enough, then this generation stuca body type P is proper so to I think I don't have time to sketch the proof, but just to mention that some trivial remark is the first remark is that the thermistability condition is that I. That I give here. Just to, in the case of drilling ferros to gas, is equivalent to the service stability condition given by LaFoc by Trinfer and LaFoc. For Stuka print file for blank R and this is not this result is not easy the proof is already complicated so the the big part of so I I would say the main advantage is that we in some sense the GIT method give you method give you a natural condition. You cannot see this kind of condition in the paper of LaFoch, but if you use the CIT, you will get this condition. But now to pass from CRCAS to these two cast, you cannot apply CIT because it's too complicated. So we So we need to move by to lengthen and by lengthen by length by semi stable reduction, it's very easy to pass from COR Stuka to niche trukas. So the way to get around is not direct, but I don't know a shorter way to do this. So this is the end of my talk. Thank you very much. Thank you, Mauk, for the microphone. Are there more functions of the element here in Pakistan? Well, in the case of T-shooters, what do you have a Lambda anymore, right? So, in the case you use instead of GLR, you use this D, then there's no more Lambda, I guess, right? No, you still, you still have Lambda, but you don't. But you don't have a tourist, yeah, but you can still modify. You have a division and shape block, but you just ignore the ramified places at the unramified places, you can get the group CLR. I'm not quite sure. For these two casts, I think it's done in the Palacis of a blog. Health is a blog and it's a work about show, but for general stuff, I don't know. So, from the people in the class, seems to be no questions. So, let's thank all this time. Thank you.