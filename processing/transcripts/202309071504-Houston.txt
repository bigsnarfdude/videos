Thanks so much for having me. And today I'm going to talk about my work to build the classification tool for cell morphology simulations. So as we all know, cell morphology has many applications. It can be the indicator of structure-function relationships. It's also involved in signaling disease as well as tissue development and regeneration. So, our goal is kind of to So our goal is kind of to improve the current tools we have to study the cytoskeleton, which is one of the most important things that determines cell morphology. So an improvement upon still images would be time-lapse data, for example. This is an example of some data that I have taken. These are actin filaments. Also, we want to do quantitative analysis instead of just visually. Analysis instead of just visually inspecting moving cells. And we'd hope that we could do some high-throughput methods with that quantate analysis. So a little bit of background. We chose to look specifically at the actin cytoskeleton. Actin forms a complex web of filaments. It's one of three filamentous polymers that make up the cytoskeleton, and notably, it's the most. And notably, it's the most dynamic, it's really important and characteristic of shape change. Also involved in the cytoskeleton are proteins. So two of the most important ones are cross-linkers, which link together the mesh of actin filaments, and motor proteins, which exert force on the actin filaments. So, we're using simulation here as it provides. Here, as it provides a way to study complex systems in a controlled way. So we can use a forward approach where we put different parameters into a simulation tool and get out multiple models. We can also use an inverse approach where we have those simulated multiple models and we try to distinguish just from the simulation output data. We're using Cytosim. Cytosim is a cytoskeleton simulation tool. It models the internal structure of a single cell, so uses building blocks like points and substructures to create simulations like this on the right here, where you see those filaments in white and molecules as points over time. Overtime. So I created three different models, each with a different ratio of motor proteins and cross-linkers and a fixed number of filaments. So model one has more motor proteins, whereas model two has an equal number of motor proteins and cross-linkers, and model three has more cross-linkers. So here are some snapshots from those three different From those three different models, one of the first things that visually we notice with this forward approach is that model one has straighter filaments, whereas model two and three, you see those motor proteins are kind of getting all bunched up in the center in this bunched up conformation. The next problem is So, the next problem is how do we do that inverse approach? We have this simulation data, this output, and now we need to quantify the filaments over time, and specifically the filaments because in an experimental setting, we're going to be imaging actin, not the proteins. So, we use this idea of one of the models being distinguished by filament straightness, right? Straightness, right? How do we capture the straightness of the filaments in a single frame and over the course of time? So for each frame, we look at each specific filament. We get the director, which is the average direction that that filament is pointing in. We then look at each segment of that filament and get the angle between that segment and the director of it. That segment and the director of its mother filament, basically. For each frame, we then get all those angles, bin them, we got histograms. So this is an example of a histogram at an early time point, MT in one of our simulations. You can tell it's a pretty uniform distribution. But as time evolves, this histogram is Histogram is going to evolve too. So we want to be able to capture this high-dimensional data long in time in a simpler way. We want to reduce the dimensionality. So we make a matrix of our histograms over time. And then we do principal component analysis and get out just the first principal component. So now we have this signal variable, PC1. So, the time evolution of PC1 is able to differentiate these models. For example, here is a graph of PC1 in time for model 1 versus PC1 in time for model 3. We notice they have similar ranges of PC1 values. They're covering similar-ish trajectories, but a really good question. But a really good question. Quick clarification. Yeah. Do you apply the PCA on the data from different models combined or separate? No. So we do. So this matrix is created for each separate model, each separate simulation. And then we get different time evolutions of principal component one. Main thing to notice here. Main thing to notice here, one of the big differences is this kind of skinniness of PC1 and time here. And I'll get to why we're seeing that skinniness. To quantify this a little bit more, we look at the frequency of each transition. We get these heat maps. You can already see there's some difference in the way that this principal component fluctuates. There's a difference in these transitions. Difference in these transitions. Model one is a little bit more spread out along that diagonal, whereas Model 3, really skinny, really right along that diagonal. But to further investigate the actual transitions, transition size of PC1 and time, we're going to create another metric. So, a change in PC over time using this equation here. Here, if we capture that distribution, we get a graph like this. So, this is, again, going over different simulations, different models, and binning how that PC is fluctuating. If it's making big jumps, as we see down here, from one time point to the next, or smaller jumps. That's skinniness with that trajectory. Yeah, question. Left and jacket, yeah. Question: The x-axis here, that's the linear time throughout the simulation. The delta is always of one delta t. So, yes, right now, this is of one delta t, but also the x-axis is just the distance, the size of the jump in PC. So, I see, okay. Yeah, but basically, if we're going from here to here, it's a small jump, whereas here to here would be a big jump. Here, here would be a big jump. So that's what, this is basically what is the distribution of those jump sizes. Yeah, another question. I'm wondering if your simulations, do you have to wait a certain amount of time for them to converge to some continuum state? Yeah, so that's a great question. So they do eventually all converge if we let them run long enough, but because it's a simulation, it's one real, they all will go to a similar Similar confirmation. We're looking at the first 10,000 time steps. It's about 30 minutes in real time. Direction, and you look at the the deviation from what this exactly is measuring? If you look at points on the t box left, do you look at on the cylinder on the point? So this is the principle this is basically the PC1 what it's doing is capturing the how I mean it's coming from those binned angles. Yeah, so with that microchange where they come from the complexity. This is an angle, this is another angle, and you integrate that over your filaments, and you combine all the filaments, and that's basically your data. Yeah, we calculate this angle for every single segment compared to its filaments director. So imagine we have no integration. No integration. Yeah, but why do we have this fifty? Because you have 28 and in between we go as rather than each other, that's not. Yeah, so we would get uh twenty-eight for the for the example this has this made-up filament has five segments, right? And we then calculate the angle between each segment and this director, which is the average direction. Yeah, yeah, so there are other measurements here. Yes, there are. These are just two examples. Okay, but we take all of them. Yeah, we take all of them. Then we do it for all filaments, and that's how we get this histogram. At a given snapshot. Yeah. We do this for every single frame of the simulation. The PC applies to all the simulations in the matrix? So the PC is applied to one single simulation run. And we build the matrix. So these bins equate. These bins equate to these rows. And then the columns. No, filaments are a fixed length. Yeah. I think they are fixed in the image already, so they are not changing. They are not changing filaments. So there's a fixed number of filaments, and each filament has a fixed length, but the filaments do move over the course of the signalization. So one axis of the matrix is the different angles beamed and the other one is the time. So it's the time evolution of the angular distribution and this. But will that will be that is every time there is an image? Or is it different? Yeah, at every time there is an image, right? A snapshot. Yeah. And then from that snapshot, you do the distribution and then you do it for every process. My last question is: what do you curve here? The loadings? Here? Yeah, this is the load. Well, it's the IT we look at how all the data tanks project around the telescope. Exactly. Alright. So back to this distribution of speaker. This is looking at how PC works. Looking at how PC1 is fluctuating, the actual size of the fluctuations in time. And point, as you see, is model 3 has very distinct way that PC1 is fluctuating from model 1 and 2, which is different than our initial observations, right? Initially, at the beginning of these simulations, 2 and 3 look far more similar than 1. Similar than one. But this metric, looking at the actual fluctuations of the filaments of the PC1, describing the filaments, model 3 is distinct. And really what we think that's getting at is some underlying kinetics of this system, where, you know, Model 3 has a lot more cross-linkers, it has less. It has less, those fluctuations are smaller. It has less room to explore the space. And as you watch the simulation go on, where Model 2 starts in this conglomerated conformation, but has more, it can explore the space, the fluctuations are larger, and it ends up more like Model 1. Yeah, you have a question, Jay. Do you have binding on binding diffusion of the cross-linkers? Are they static? They are also. They are also binding and unbinding, yes, but at a much slower rate than motor parties. Yeah, so our main conclusions are that we did successfully create a single metric that distinguishes complex models. And that's just, this is just one metric that we came up with. I'm sure there's many other metrics that we could use. I'm really open to other ideas, other metrics to test out. To test out. And that, secondly, that the fluctuation patterns themselves go beyond visual inspection. And we're getting at something that we couldn't see by just observing these models. Lastly, we want to build upon and expand these methods to experimental data. So lastly, I want to thank my advisors so much and love to answer any questions. So myself, then Jay. So would it not make the... Why not just look at what is happening when we reach steady state? Is that at some point that they all will end up with the same conformation? So this simulation is not exactly like it's not a perfect idea for it. It's not exactly modeling your own life. Modeling real life. Like, this is a simple model with just filaments and two different kinds of molecules. And if you let the simulation run long enough, basically, they all, the filaments all just go to the edge of the cell. So this is just an exercise basically in seeing if we can capture and distinguish this initial part of the simulation, which has different dynamics and isn't just reached in equilibrium. Isn't just reached in programming. But I don't understand. They have a different number of linkers. So, how come the steady-state distribution would be the same? They have different number of linkers, different number of motor proteins. It's inherent in the way that the simulation works. I can, you know. Because of that, it's imposed by the geometry of the bump. Yes. But it will fluctuate also on the bump. It was also on the bump. It's going to be fluctuating. So, the measure of fluctuation will be different for these models. That's actually a good point. This is something we could also look at. But it may not be strong enough to become approach. That's something we haven't looked at also. That's something that some people. Because if you want to compare it to actin, so you want to compare the steady state, not the steady state state is artificial. No, no, I understand. That's why we try to ignore it actually. You're actually giving us a good idea. If you play with the on and off rate of those binders compared to the relaxation time of the polymer, so you will not have that on some machine. You see what I'm saying? Because what you actually have is polymer relaxation. So just play with the other thing to negate this in terms of time stage. The gain is in terms of time scales. Yeah, you had a question. Maybe while uh okay, I have some questions for it.