So, yeah, so on the other side, we have these much more olders inside P and infinity, which is basically defined something that we can define depending only on P. And if you don't know what that is. If you don't know what that is, it's not really important, but we just know that we can do that. Like, think about a Q vector space of dimension four, essentially, if you just want to get the idea. And then lattices, the Q vector space is the quantum algebra, and then the maximum orders are simply like lattices inside of that. So yeah, we have this thing, and it's kind of explicit in the sense that we can get the maximum order related to the curves. Related to the curves by looking at the isomorphism class of the on the morphism of the pain. So, yeah, that's like the basic part of it. But in fact, we can give more things. Other objects that are going to be useful for us, obviously, are isogenies. Let's say from E0 to E1, and on the other side, I get this kind of audio that I'm. This kind of ideal that I'm going to write here like from O0 to O1, where here O0 is going to be isomorphic to the endomorphism ring of E0, and O1 is isomorphic to the morphism ring of E1. Okay, so these are other types of objects, once again, lattices, and once again, it won't really matter what those objects are exactly, but just they kind of exist. And we have this kind of correspondence between the two, and it's really like. Correspondence between the two, and it's really like one-one, meaning that every object on one side has an equivalent on the other side. Uh, okay, so that's like the basic results about that. But this is all theory, and then the question is that, okay, but what do we have in practice? What can we do with those objects? And so, this is where I can talk a little bit about algorithms that we have and what kind of like problems that we know to solve. That we know, solve, and those that we don't really know. So, first, we can say like the kind of translation problem, meaning that I have something in one side of my table and I want to go to the other side. So, first, I can start from a curve and I want to compute the corresponding order, or I can do the same with like an isotony. With like an isotony with the corresponding ideal. Then we have the reverse problem going from small order to a corresponding curve and from an ideal into an isogeny. And I also add other problems which are not directly related to the During correspondence, at least one of those, but I think they are going to be, I know they are not to be useful. So we have the so-called isotony problem, which is The so-called isotony problem, which is given two curves, E1 and E2, I want to find an isotony connecting them. Okay. And then the translation of each problem of the quaternions, which is going to be I have like two orders and then one kind of idea for anything books. For anything else. And it turns out that some of those problems are actually hard and we can base cryptography upon those. And some of those problems are actually easy. And this kind of duality is actually nice because in cryptography, we kind of need both. Some things that we can do efficiently and something that we cannot do efficiently. So in fact, whenever I start from the quaternion world, it turns out that all those Turns out that all those omnipot are kind of easy. So, easy in the sense that, in let's say, like in the right setting, we have like efficient polynomial time algorithm to solve them. And on the other side, those problems are believed to be hard in the sense that, yeah, there are some very hard instances, and by hard, I mean like the best-known algorithms are exponential. Okay. Okay, so this is a little bit of our setting for, let's say, the ski sign family of schemes. And now I'll try to explain a little bit, maybe it's better that both me. I guess you cannot see anymore. It will be more than that screen so that Okay, so now let's talk a little bit about Ski Sign. So the idea of Ski Sign is essentially to use those kind of things that we know how to do. Maybe just quickly, so those problem, those fast algorithms, I'm not going to talk about them today because they were quite complicated and it's, I just want to give the Complicated, and it's. I just want to give the intuition about the protocols. So I'm just going to use them as kind of black box, and I'm not going to get to too much of the details. Okay, so saying that, so ski time, what is the idea about ski time? So this is a signature scheme, okay, so and that we're going to build from an identification protocol. So the idea of identification is that you're going to have some public information, which is your identity, and you want to prove that you're really. And you want to prove that you're really the person behind that public identity. And usually, in public key credit directly, this means that you're going to have some kind of public key and that everyone knows and can see, and then some kind of secret key associated to it that you only you know. And the goal of this identification protocol is like to prove that you indeed know the secret key. The secret key. So, in our case, the public key is going to be some curve E, and the secret key is going to be its on-demorizing. Okay, and the hardness of recovering the secret key basically is based on this on the Morphistering program here, where the goal is to you have a curve and you want to compute its on the Morphister main. And this is supposed to be hard. So, this is why recovering the secret key is hard. So, this is our. So, this is our setting, and there is another hard problem that we are going to use for our protocol, and it's the isogeny problem. Okay, and we see that from the word of curves, so when I have only two curves, this problem is supposed to be hard. But when I start from quaternions, meaning when I know the endomorphism rings of my two curves, basically I will be able to solve this problem quite efficiently. And ski-sign is all about making that happen. Is all about making that happen. Like the prover is going to be able to solve this isogeny problem, whereas everybody else will not be able to. So, yeah, the goal of SkiSign is basically to set up some kind of instance of the isogeny problem that only the prover can solve. So, this is the idea, and for that, we are going to use this kind of three-round interactive protocol that is quite classical in cryptography. Classical in cryptography. So let's start from some curve E0, which is going to be like some kind of constant of a scheme. I start by doing some kind of secret log toward my public key that I'm going to write EA here. So this is the figure of EA. This idea is supposed to be secret, and this knowledge basically is going to be equivalent to the knowledge of the undermost. Yeah, the two are actually equivalent because once I know the multi-domain, I'm capable of like computing asertines and this kind of stuff. So yeah, so this is the point. I have my secret. So this is what happens at the beginning of my identification protocol. Then I have the first round, which is the commitment. So I choose the first, I just psi going from a curve E0 to a curve E1. The curve E1 and this curve E1 is going to be sent to the verifier, but not the commitment. This part needs to be secret. Then there is going to be a challenge. So this is the part where the verifier is going to send something to the prover that will force the prover to solve an instance of my isotony problem. And the idea, of course, is that this challenge cannot be guessed by the prover, and this is why it will fall. Prover, and this is why it will force him to behave honestly, essentially. So, this is done by the verifier. This is another isogeny pie. And this leads to a curve E2. So, this isogeny pi is sent to the prover. And then here we are our setup. And now the goal of the prover, as I said earlier, is to solve this isotony problem. So, you can do that by computing some isotony sigma, collecting EA and E2. And then the verifier can just take this isotony. The verifier can just take this isotony and verify that it is indeed an isotony between the two things. And if that is the case, then basically by the hardness of the isotony problem, it must have been computed by the prover. And so this is really the idea of scheming. And so this works for both the original ski sign and the new ski sign HT, which is simply a variant of this. A variant of this first scheme where we use basically the new ideas introduced with the attacks against SIDH and the Canislema and everything. And we just use those ideas to modify the way we do things. So to understand the difference between the two, I need to go a little more into the details of how do we do this concretely and obviously the the more efficient the more efficiently possible. The more efficiently possible. So, for that, I need to explain to you what was the idea behind the first ski sign. Okay. So, I guess at that time, so before we became really aware of Kenny's lemma, there weren't like many ways we had to actually give How to actually give and efficiently compute an isogeny. So essentially, the best way is to have something which is smooth and where the smoothness bound is actually the smallest possible. So this is why in the original ski sign we decided to take like the degree of sigma to be the power of two. Because in that case, verification will be very, very efficient. Because the main job of Because the main job of the verifier is to compute this isotopic sigma to check that it goes from EA to E2. So we wanted the verification part to be quite quick, and this is why we choose this degree. The problem is that, well, this is like a very strong constraint, and it's actually very hard to find isotones of these forms. So I said to him, yeah, don't worry, we have a polynomial time algorithm. Have a polynomial time algorithm, so it's true, but this algorithm is not like performing miracles. So we can do things and we can find a suitable solution, but it's going to be actually very big. In practice, the size is going to be, at least in the setup of ski time, almost equal to p to the four. Whereas the optimal solution, we can expect it to be like approximately of time p. P. So, this is much bigger than what we could have. But the thing is, that's the only size we know how to find efficiently. So, this size, like this very big size, it's going to be an issue and it's going to make the computation, the actual computation of this isotonic sigma by the prover quite costly because. Because I don't want to get too much into the details, but essentially, how we find this isotopy is that we perform a bunch of operations over the quaternions. So we use this algorithm here to get from the two on the Morph symbols to some ideal. And then we translate that ideal into an isogeny and the isogeny signal. And then we reveal that isogeny to the verifier. So this part we can perform it when the site is pretty big, as I said. The site is pretty big, as I said, and then we need to do the translation part. But the translation part is not free either. So it costs actually a lot, and we have to like so for efficiency computation of sigma we need to choose a very, let's say, weird arrow. Let's say weird parameters, we need to have, so I'm not going to explain why, but just take it as it is. We need to find some big smooth odd number t that divides p squared minus one, where t is roughly p to the five divided by four. Okay, uh, yeah. Okay, yeah, the best algorithm that we have for performing this translation needs these kinds of parameters to be run as efficiently as possible. The problem is that this T is actually bigger than T. And so this means that it will be very hard to find a T that is very smooth. Why do we need T smooth? Because in this algorithm, in this complex mechanism, we need to perform T isogeny computations. And as I said earlier, the smoothness of the degree is the key. Smoothness of the degree is the key in the efficiency of isogeny computation. So, this is why we need this setup. And it's quite problematic. So, we can find some T, but obviously the smoothness bound is going to be quite big. And this is the main bottleneck, in fact, behind the efficiency of the first ski sign. So, I think in ski sign. So, I think in ski sign, we choose parameters to make some kind of trade-off. We choose to have the fastest possible verification because, usually, in signature schemes, this is the part that we want to be as fast as possible. And the problem is that it comes at the cost of a very slow signature process where we have to do this translation for a very long isogeny, and this is quite painful, and we need these parameters, which are very hard to get. To get. And another problem, I guess, is that this does not scale very well because the smoothest bound of T, I think you can prove it's like growing sub-exponentially in the size of P. So as big as P will get, then in the end you'll end up with the T which is not very smooth and this is not very nice because if we need to scale parameters, the efficiency will be a lot better. The efficiency will be a lot worse. So, our ideas with SkitHan HP was to try to overcome this obstacle by using the things that we learned with Canny's lemon. And in particular, I think the main results. I think the main result that is very useful for us in this setting is the fact that so for any assertion signal okay, so here from EA to E2 we can We can, and here I'm going to try to pay, but represent in some way sigma by the following information. First, it degree object and then points and the image of those points under stigma. Under sigma, where PQ is a basic of, let's say, a well-chosen torture, but in our case, we are going to try to use like a power of two. Okay, and here the size requirement that we have on this two to the f is that two 2 to the f must be bigger than essentially square root of the degree of sigma. Okay and here the important thing is that there is no kind of restriction on the degree of sigma. We don't need it to be smooth anymore. And this is the part that's going to be important because That's going to be important because, as you see, like the only requirement is on two to be held here, and it's just meant to be big enough. But on the degree of sigma, so if we reverse the inequality, we have another bound on the degree of sigma, but we don't have any more constraints on its smoothness, which means that we can avoid this complicated operation that we did earlier to find a suitable isogeny of smooth none here. Isogeny of smooth zone here, we just have to find like the smallest isogeny that we need essentially, and this is where this becomes quite interesting because now we can avoid this complicated mechanism and we are going to be able to select parameters which are, I mean, much friendlier, I'd say. I'm sorry, I'm sweeping a lot of details under the rug. I don't really have the time to explain exactly how this representation form uh works. Sorry. Uh maybe I can just mention that it's it's really using TP this Really, using heavily these new techniques by essentially the idea is that you can embed in some sense sigma inside a higher degree isogeny of dimension D and degree like the F to the D. And yeah, that basically we can kind of compute this hybrid quite efficiently because it has really a power of two. Has a degree a power of two and yeah is the two degree of torsion is this rational or is it a high exact oh so yeah okay yeah so the the question was that uh what is the like the requirement in terms of uh field of definition for this 2 to the f so obviously to to keep things as compact as possible and also to to enable the efficient computation of this 2d f to the d dimension d and certainly we are going to dimension D and certainly we are going to want that to be defined over IP squared. So this will be part of our parameter selection. Yeah, so okay, so yeah, we have this thing and it works with like these dimensionally isotonic computations, which are not completely trivial, but we have algorithms that are somewhat efficient. Maybe, yeah, I can explain a little more like how the signature process is supposed to go. So, I think that the signature part, so if you look at the diagram that we have, and as what I said to you, so this basically this information is going to be the signature of this is. It's going to be the signature. This is the part that we are going to reveal to the verifier. And so the job of the verifier is going to be to compute this like higher dimension isotony. And the role of the prover is to compute all those information. So well, the degree of sigma is going to be quite easy to get because it's just like, once again, we are going to use ideal. So you just take the norm of the ideal. And as I said, you can just take it basically very, to be very small. It basically to be very small. So, yeah, maybe. So, the first part is like compute a small analytic ideal. And here, like the smallest that we can hope for, basically, will have a roughly size square. So, if you compare that to the almost. So if you compare that to the almost pixel that we had before, in terms of size, it's going to be much better. Then the second part, let's say, is to use like toe, sine, and sine that gives me a path from EA to E2 to evaluate. To evaluate somehow my ISOGB sigma on my basis PQ and then I'm done actually. So this is the good part. Like in ski sign NTD, the signature process is much easier. So of course there are a few technical details about how do you choose pi, pi, and toe in a way that allows you So, in a way that allows you to make that computation from EA to E2 quite efficiently. But yeah, I'm not going to explain how those works, but you can do that. And then this is just like pushing the points and essentially you're done. And then we have the verification which is going to be one step. So Step so compute essentially the five-dimensional assembly embedding signal. So, in terms of concrete efficiency, this part, as I said to you, is much easier, much simpler. It's much easier, much simpler. It's going to be much, much faster than what he had for Skisa. That's not part of the verification part is a bit trickier because, well, we are only at the beginning of the real study of the efficiency of these high-dimension isogeny computations. And in particular, in our case, we are going to need dimension at At least four. And this is like the big problem because dimension two, it's it has been studied. We know how to do some things. Dimension four, it's still like basically unexplored territory. And so there are a lot of efforts right now to actually make those computations efficient. We have some estimates that the actual complexity might not be. The actual complexity might not be completely crazy, and that we could actually run this thing, but it's never been actually implemented. So, this is like a big question mark about the efficiency of this new scheme. Because we know, yeah, signature is going to be much faster, verification, we don't really know. We don't expect it to be faster than ski sign, but we expect it to be not so bad and maybe like a little bit slower than ski sign, but yeah, not like 1,000 times. 1000 times slower, but only actual implementation will answer to that question. I guess I'm running a little bit out of time, so I'll just wrap it up very quickly. Yeah, I'm just going to mention very quickly that another advantages of this new scheme is the security. For some reason, security is a bit cleaner. In particular, one Bit cleaner. In particular, one part that is very important for the security is that this isotony sigma is actually kind of random in the sense that it does not reveal any information about the secret. Okay? And in ski sign, it turns out that like the original one, this isotony is not random at all. It's computed in a very specific way. And basically, our security assumption is that, well, even though it's very specific, to the eye of an attacker, it's going to seem The eye of an attacker, it's going to seem random. But this is not like a clean and nice security assumption. So, one of the advantages of our new scheme is that essentially we can take sigma to be essentially the smallest isotones there is between EA and E2. So in fact, to make it work, we have to tweak it a little bit so it's not the smallest, but it's really one of the smallest. And it makes the distribution of sigma much cleaner. So we got a better sense of. We got a better sense of the security with this, and so we introduced new problems. But that seems more plausible than the one we had for a ski sign. And yeah, I'll stop there. I don't know if we have some time for some questions. So you can ask questions while I change the setup so that I can. Up so the next talk is in bow. Oh, wait, let me unmute the people. Okay, I muted you guys because you were still talking about the recording after it was recording. Sorry. But you're now unmuted if you want to ask questions. Yeah, so the question is: Does the new attacks against PSIDH affect the security of SKISAN? And the answer is no, absolutely not. The setup was quite different for PSIDH and here it does not apply at all. Yeah, I guess this is the tricky part, but it's all like hidden behind what I written here that you only need like the evaluation of the isogeny of those points to kind of represent the isogeny. I guess I don't really have the time to get into the details, but the idea is that there is some kind of isogeny of high dimension that kind of embeds sigma in the situation. That kind of embeds my understanding because, like, this high-dimensional isogeny, you can make it so it could be an isogeny between like a product of EA and the product of and you can fit that as some kind of matrix here. And one of the components of this matrix includes this hytotonic Emo. And you can actually compute the kernel of this high-dimensional hytony from those points. Then you just point then you just compute the isotony from the point and checks basically that one of its components is indeed an isotony between EA and yeah I don't have time to explain more on that sorry yeah do you still use the generalized LP algorithm to compute sigma and then push the points through or did we use the other one Push the points through, or it may use the other ones more adjusted. So, the question is: do we use the generalized KLB to compute the sigma or we just use another method? So, in the first original sk time, we use this kind of generalized KLB stuff. The reason is that, well, this is the only way we know how to compute something of Smooth NOR. But the thing is, as I said to you, I can take Sigma as one of my small. I can then see my as like one of my small, one of the smallest, essentially between EA and E2. And how do we find one of the smallest? But it turns out that this is one element inside one of the ideal lattices that I have. And I can find smaller elements just by doing some lattice reduction. And since those lattices have dimension four, I can actually find the smallest elements very easily because the dimension is very small. And this is how we get the sigma in that case. This is how we get the sigma in that case, in the ski-sign HD case. So, we have a question from Peter. Yeah, Peter, you can speak. Can you hear me? Yes, we can. So, my question is, is there any hope of, so currently right in the verification, you need to stay either in dimension four or eight, I guess, if you mostly in four, if you I guess it's the sum of two squares issue, whether it's four or eight. Whether it's four or eight. But is there any hope of tweaking the item gene representation idea to get down to dimension two, like the tricks that are used in Testa, for example? Yeah, so that is a good question. Oh, yeah, sorry. So the question is: can so right now we're using dimension at least four, as I said, and obviously the complexity of this algorithm grows very grows very like exponentially in the dimension actually. So obviously we would like to keep the dimension as small as possible and so the question is can we have can we make it work in dimension two? So this is something we considered obviously the thing is that so it's really related to the way this kind of stuff works but it turns out that if you want to do that in dimension two you need two atoms. This sigma Two atoms, this sigma, and then another one beta here. And computing this isotony beta is kind of hard because you don't control its degrees or you don't control the smoothness. It's legal in Canada. And this is what makes it difficult. Not legal to do it there. It's legal to buy it. It's maybe not going to have it in public, I don't think. Oh, yeah, sorry. But yeah, we've talked about going into that. About uh going into that, we have some ideas, but uh, it's uh not so easy. So, like, I can do it for future work. How could the soundness ass function play in any case? Uh, so the good part is that the soundness stays essentially the same. Uh, the soundness relies on the fact that it's hard to find all the morphisms, essentially. Essentially. And well, this remains the same in both Ski Sign NT and Ski Sign, because in any case, we were kind of solving the same problem. So of course we are not giving the same solution, but in terms of verification, you're kind of accepting any isogeny that works between the two. And so it does not change the two settings of similar in that sense. Sorry, is anybody? Sorry, I don't know why it's not displaying anything. You know, not the webcam. It just should be displaying what's on my computer and stuff. So, of course, the webcam is not the same. But it's not up there. I don't know why it's not up there. I don't know why it's not a fun. Is this something that you thought about? Like example, is it going to be something of these formats? So I guess since this whole diagram is really similar, it's just that the difference between SkitHan and Skit Han X, we're just changing the way we perform this computation, but the idea is the same. To answer your question, I thought about doing group signatures or other types of signatures with C-time. Types of signatures with C-time. For now, I've failed to do so. And I'm not sure using this high-dimensional stuff will really help. I think in the sense that the scheme mostly remains the same, and this is just detailed about how we perform actually the computation. So, but this does not mean there are some clever ideas that we could use in the future to do more than that. But my experience for having For having different things, is that this FAN framework is not really easy to modify to make like group signatures or other types of signatures, I guess. Sorry, Antona, you're getting very many questions because we're having technical problems. We're just trying to get our display working here. Sorry, Andrea. Do you want to take five minutes but get it displaying? We could just grab coffee. Yes, please. Okay. Go very quick because we've actually got it working. Go grab your copies and come back in five minutes, yeah? And come back in five minutes, yeah? Yeah, that's that's it, that's it.