We talk about the 3D lattice defect and efficient computations in topological measurement-based quantum computations. Thank you very much for this nice introduction. Today I will present a work I have done in collaboration with Martin Schwering, Robert Rausendorf, and Sven Bachmann. And I will talk about a three-dilator span efficient computations in topological measurement-based quantum computation, which I wrote. Computation, which I wrote MB2C daughter. So, the outline of the talk is that is as follows. I will first introduce what is measure band-based point recommendation, especially in the 3D process state. Then I will introduce a lattice defect in the 3D process state lattice and see how that allows us to implement the other bargains. To implement the ADA bargain. And in the same framework, I will look at how we could optimize the circuit, especially for magic-state distillation, because this magic state distillation can be resource-consuming, and we would like to optimize that. So let me just say what is measurement-based quantum computing. Is measurement-based quantum computation on the 3D closer state, and for that, I would begin to introduce what is a 3D closer state. So, here I'm focusing on the RIHG lattice, which is a cubic lattice, and I've shown the unit cell here. So, on this cubic lattice, we will put some qubits on the faces and on the edges of the lattice. Edges of the lattice. And the first thing we can note is that this lattice is central, meaning that if I map a vertex to a center of a unit cell, then the lattice would remain ancient. So the only thing that would change is the color of the qubits will be swapped. So here I have red qubits that I have put on the primal faces of the The primal faces of the lattice, but they are also on the dual edges of the lattice. And similarly, the black qubit will sit on the primal edges of the primal lattice and they will also sit on the dual faces. So, this is for the physical structure of our state, but the quantum state will be prepared as follows. State will be prepared as follows. So, first, we prepare all those qubits in a product state of plus state. And then we will turn on nearest neighbor interaction represented with those blue lines. So that the qubits are all entangled with their nearest neighbor. And the interaction will be of the type of the control-Z gate. Gate. And those controls, that gate, they all commute with each other. And so we can actually prepare this state, even though we have a lot of those units that we can still prepare the state in a finite depth circuit. So the resultive state is shorter and tangled, which is quite interesting. Also, the resultant state is a stabilizer state, with stabilizer being Stabilizer having Pauli X on one of the qubit and Pauli Z on its neighbors. This can be for a red qubit here, but also for a black qubit here. So everywhere in the lattice I will have stabilizers that are of the type X on the face and Z on the boundary of the face. And that on the boundary of the face. And I can also generalize that to any surfaces in the cluster. So if I take, for instance, a primate surface that is a collection of red qubits, the stabilizer associated to this surface will have X inside the surface on the red qubit and Z on the boundary of the surface on the black qubit. Of the surface on the black qubits. And I can also define that for a dual surface that is made of a collection of black qubits and define exactly the same stabilizer, which has X on the black qubit inside the surface and Z on the boundary of the surface. And the surface will be super important for the talk. So this is So, this is a resource state for measurement-based quantum computation because we will use this state to measure it in the bulk. We will measure almost all the qubits in the bulk, except maybe some on the last surface of the closing state, to project on this last surface a toricode. So, how can we see that is because We see that is because here, if I take a phase of a unit cell of the glycostate lattice, I have a square, well, I have a square, and the black qubits here all around this space can actually be the qubits of the placket of the toricode. And we can enforce the placket stabilizer of the toricote. Stabilizer of the total code by measuring here this red qubit in the middle in X. As the measurement would commute with the classroom stabilizer, the measurement would project the placket stabilizer on the black qubit all around the plackets. Here the red qubit will kind of be disentangled because it is measured, it is projected. Because it is measured, it is projected in one of its ion states and will no longer be entangled with the other qubits around, but the four qubits around the packet, they will be entangled with each other. Similarly, if I measure all the qubits before this last phase here in X, so the red qubit there and also this. The red qubit there, and also this black qubit here, I can actually enforce a site stabilizer of my tory code. So here we have a short-range entangled state that we measure to create a tory code, which is a long-range entangle state. So, measurements here are quite powerful to create more complexity in our state. Also, it is known that a toricode, well, if it's on a torus, it has only two logical qubits, which is maybe not that much. So, we would like to encode more information on that Tori code. And for that, I will introduce new boundaries inside the Tori code so that I can have more logical qubits. And for that, I need to. And for that, I need to increase the degree of freedom of the code space. And what I can do is remove some of the stabilizer here and there. So for instance, I remove two blacket stabilizers and I say, okay, these operators here are no longer stabilizers of my core code. And then I can see that there are like two logical boundaries. Like two logical Pauli operators that are defined thanks to those two roles. So the first one will be the former Z placket stabilizer here. It's no longer a stabilizer, but it's still commuting with all the stabilizers around. So it doesn't it leaves a code space invariant but still acts non-trivially on it. And I have also a X To an X operator that is a product of X on a line of physical qubits between those two holes. And this X will commute with all the remaining stabilizers because here I have removed two stabilizers and it will anti-commute with my Z operator here. And so it acts not trivially on the code space, but also here. Be on the code space, but also leave the code space invariant. So those two are good candidates to be like logical Pauli operators. And I can do the same with site stabilizers as well, where here the new logical Pauli operators would be X of a loop around the hole and Z on a line stretching from one hole to the other. So we can note that. Hold to the other, so we can note that those are dual to each other with the z here being a line, but here the x is a line. So how we create those holes from the cluster state? Well, instead of measuring some qubits in X, well, we can actually measure the qubits in Z. So here, for instance, if I want to create a package hole, Packet hole, I can measure the red qubit in the middle in Z, and that won't commute with the remaining, with the former cluster state stabilizer, and so the placed Z stabilizer here won't be enforced. So, by really tuning the measurements, I can either create stabilizer. Create stabilizer or not. Also, this scheme can be made fault tolerance in the sense that the information is encoded on like holes in the Tori code, and the logical operators are lines of operator on physical qubits. And I can make those lines as big as I want by first taking first taking these two holes as far as far apart as I want, and also I can create bigger holes by measuring more qubits in Z in the class state. And this is how we go from a class state to an encoded Tory code, but what I would like to do as well is to process information. It is to process information from an input to recode to an output tory code. And for that, we can come with an input tory code, entangle it with a cluster state. And then if we measure all the cluster states in the bulk, we can actually project an output tory code on the last surface, and we might. And we might be able to implement a gate from the input to recode to the output to recode depending on the measurement pattern inside the bug. So to formalize that, I will first need to introduce compatible surfaces. So a compatible surface is when the stabilizer associated to each The stabilizer associated to it will commute with the measurements. So for instance, here I have taken the example of a primal surfaces that has X on red qubits and Z on black qubits. And this tabulator will commute to the measurements if the red qubit inside I've been measuring X and the Z qubit outside I've been measuring Z. And we can say that a measurement pattern. We can say that a measurement pattern implements a unitary gate if there are compatible primal endural surfaces that link the input Pauli X to the output Pauli X rotated by the U gate we are interested in, and similarly for the Z input and output, and that for each logical qubit. Encoded in the Tori code. So, to illustrate that, I would just give two examples. So, first the identity gate, which is a simplest gate. So, we come here with an input to recode that has only one logical qubit encoded in it. So, I have represented two. Two side holes by two gray dots here, and it will be entangled with the cluster state there. And then inside the cluster, everywhere I will measure the qubit in X, except on those two lines here, where I will measure black qubits in Z. And we can find that for this specific measurement. Specific measurement pattern. We can find a surface that has a red qubit in between those two lines, and its boundary lies on the measured lines here. And also, its boundary will also lie in the input and output to record on the line that defines the input Z. Input Z and the output Z. And we have a surface, this surface is completely compatible with the measurements because it has been measured in X here and in Z here, and it links the input Z to the output Z. And so Z in is directly mapped to Z out, which is what the identity gate does. And similarly, I can find a dual surface made of black qubits. Surface made of black qubits that wrap around my measurement lines here and that goes from X in to X out. So this is quite nice because we have the identity gate that is well implemented quite simply by just measuring qubits in Z. Bits in Z, we can also see that at the time evolution of Tori code. So if this is the time direction, then the input Toricode doesn't really evolve in time. It stays quite the same and it is still the same at the end, so nothing happened to it. So it's really the identity gate that has been performed. A bit more complex is a synod gate that is entangling two logical qubits together. So for that I will have like four side holes in my input Tori codes. So this first pair Um so this first pair encodes one qubit and this second pair encodes the other qubit. And then I will measure uh Z's um uh qubits in Z in the following way. So here I will measure a line of Z I will measure a line of black qubits and this line I will braid it with a line of red qubits that are also measured in Z. Measured in that. And I will break a bunch of those lines. And here, what I can show is that there is a surface shown in gray there that takes that finish or begin in X in of the first qubit that wraps around my first line here. And then, as it can, it's bounded. Its boundary can be on red qubit. I can extend this surface so that it lies on the red measured qubit there. And then, but this surface cannot cross black lines because it has X on black qubits, but here those black qubits have been measured in Z, so it's not compatible with it. So it needs to wrap around. It needs to wrap around this line and it will end up in the x out of the first qubit. And similarly, this well, for this line, it will also wrap around it and it will end up in the x arch of the second qubit. And this is what the Synod gate does: it takes the X of the control qubit and maps it to the X of the control qubit times the X of the. Control qubit times the X of the target qubits. Here I haven't shown them, but there are also a lot of other surfaces mapping all the other input paulies to the right output paulis, and I would be happy to discuss it. So that concludes my first part, the first part of my talk. And here we see that in this framework, we can In this framework we can do actually well two gates, so the identity gate and the senor gates, but we would like to have more gates to go towards universality. And for that, I will introduce a lattice defect and I will show how that implements the HADA market. So first let me consider a dislocation defect in the lattice. Defect in the lattice. So I will go back to the unit cell level where here instead of having a nice cube of unit cells, well, I will remove some qubits here in between and take this unit cell. Before this unit cell was, its vertex was here, but I take it and translate it to the middle of another unit cell. Of another unit cell, and here we can see that the duality I have introduced before is no longer well defined in the sense that if I take a line of black qubits here and a line of black qubits there, well they won't be on they will be on well the edges of this uh unit cell correspond now to the face of this unit cell. The face of this unit cell, which breaks the nice bicoloring I introduced before. And so there is a conflict, and what we can do to solve that is introduce an arbitrary slit that lies against the defect here, where before the slit, the bicolouring is well defined, and after it's also well defined. Defined and after it's also well defined, but on this slip, I cannot say if my qubit is black or red. And that is useful because if I have a line of that measurement here that was first on black qubits there, then it becomes a line of then measurements on red qubits. And so at first it was implementing a side. A side hole, and now it's implementing a packet hole. And similarly, all the surface that will go through this lid here will be mapped from a primal surface to a dual surface. That is quite nice. And why are we doing that? It's because we've seen that if I have a logical x on a side hole here, well, then the logical x is x x. Well, then the logical that is implemented around the blacket hole is now a Z power. So I can map a primal hex to a dual Z and it's what the Adama does, right? It takes X to Z and vice versa. Now this is really local, but I can make it. Can make a tube out of this defect and wrap it onto itself so that here, if I unzoom and I go to the cluster, the full cluster picture, I can make the defect as I can run the defect so that it's quite localized in the cluster. And then I will take two Z measurement lines that encode one logical qubit in the input state, and I will make them go through this defect. They are mapped to like red lines, and just out of consistency, we would like all our qubits on the output to be encoded inside holes and not packet holes. This is just well, we preferred it that. Well, we preferred it that way, but that doesn't have to be. And so I would just braid the red lines with the black lines to do the identity between like a bracket qubit and the side qubits. And we can look at a compatible surface with those measurements. So first we have a surface coming from the Z inputs that Inputs that cross this boundary here and is mapped to a dual surface there. And the dual surface cannot close on this line, so it has to wrap around it. And it ends on the X out about the X out here. So my input Z is mapped to my output X, which is the other mount. Which is the other amount. And similarly, like just to compare with another pair of measurement lines that doesn't see this Hadamard defect here, nothing happened to it. And so we are able to implement actually a Hadamard on a single logical qubit. So now with that, we have the full default group. The full default group, as we can have the Pauli, the CNOT, the ADAMART. We can also create the complex S-gate by using a trick of rebit encoding. So that is quite nice because everything here can be done fault tolerantly in the sense that every time I can make those lines as big as as I want and as far as as far apart as I want, so that the information is well protected. Information is well protected. But we are still far from universality, as we will need still the T-gate, and for that we need to use Magic State distillation. And Magic State distillation can be quite resource-consuming, so we need to optimize that. So, in the scheme, before I In the scheme before, I've shown like only we can measure only X and Z. We can only measure the physical qubits in X and Z. And here we would like to do the T gate. And for that, we need to inject in the circuit this kind of state that has a phase of pi over 4 here, and this case. And this cannot be created with all the gates I have presented before. And so for that, we can actually create this logical state on the output Tory code by here measuring two lines of said, well, black qubits here, and those lines have to shrink down. To shrink down into one singular qubit, and this one singular qubit will be measured in the x plus y basis. But as here, only one qubit is measured in this basis. If there is something wrong happening on this single qubit, well, our output state here is not the one we want. So, this is clearly not fault tolerant. Fault tolerance and to reduce the noise of this single qubit, well, we can use magic state distillation where we take 15 of these noisy ancillas and we encode them in the red miller coat and then we will measure them to project this state on the output state. State on the output state here with a radius error probability here. And this circuit is actually a pre-fold circuit, and here I have shown the measurement pattern that was first proposed by Robert Rausendorf. And this measurement pattern is quite intricate with a lot of lines. With a lot of plans and it takes a lot of space as well, and so it's quite resource-consuming and it has a huge overhead as well. So, we would like to optimize this circuit here and this measurement pattern here to reduce dramatically the volume. And for that, we have been thinking of: okay, so first, like those measurement patterns that can always be. Patterns that can always be deformed topologically, and then we can maybe think about non-topological equivalence between two measurement patterns. And two measurement patterns will be equivalent locally if the measurement lines that encode the qubits are the same at the boundary of the volume we are considering. We are considering, and also the non-trivial loops that are at the boundary that encode the logical operators are connected similarly through surfaces. So, yeah, I can just give an example here quickly. So, for instance, this measurement pattern that is quite simple, but really it doesn't do anything like logically, but just a nice example is that here That here I have two measurement lines that stretch from one boundary to the other, and here as well. So I have two pairs of holes that are actually well defined the same way. And I can find a surface here that take the Z Pauli here. Pauli here to the Z Pauli there, like exactly like the identity before. And actually, in this measurement pattern, I can also find a surface that takes a Z Pauli here to the Z Pauli pair. And that is true with all the Pauli encoded in those two pairs of both. But that is not really interesting. However, if I consider this. If I consider these big red loops around a lot of lines here, which appear actually in that complicated measurement pattern. Well, I can think of a similar transformation and actually I will find something that is kind of panel-like branching or something like that. Or something like that. So here it doesn't seem that we gain a lot by doing that, but actually by then deforming this pattern topologically and putting it together with other, we can actually gain from that measurement pattern almost 40% of the volume. 40% of the volume by just using those transformations and trying to shrink everything down topologically. So I will conclude my talk on that. So the goal of this project was to improve the performance of measurement-based quantum computation in the 3D plus state by exploring new geometries for further. Geometries for first the underlying lattice and also for the secret patterns and measurement patterns in the cluster. So, with that, we have been able to now implement the ADA margin and then embers the full default group. And we also found some equivalence rule between measurement patterns that allowed us to reduce dramatically the practical cost. The practical cost of the computation. I would like to also mention a work I've done with Marvin Schwering, which was to write a program that checks that the measurement patterns actually implements the desired circuit. Because, as you might have seen, the measurement patterns are quite complicated and the circuit as well, and it's quite hard to follow. And it's quite hard to follow by hand if a measurement pattern does what we want it to do. So having a program that checks it automatically was really useful. But there are some open remaining questions. Here, also, all the volume compaction and optimization was done by hand, and in the same vein, also verifier. The same vein of the verifier, maybe we could try to build a program that actually does the compaction for us. Also, I have introduced one type of defect in the lattice, but are there other defects? Can we classify them? And what are their computational power? And finally, we've seen that with this With this specific cluster state, well, only the X and Z measurements can implement things like QD fault tolerantly. And can we find a cluster state maybe that is linked to another code than the Tori code, where we could have non-powerly measurements that could also do more interesting gauge. Do like more interesting gauge, and that could be also topologically protected. So, thank you very much for your attention and let me know if you have questions. So, this initial cluster say you say it's a short-ridge entangle. Angle, but yet measurements produce this topological liquid on the boundary. So, is it in some sense like an SPT? Yes, yeah, yes. The closer size is an SPT, so I think it will be a Z2 pro Z2 symmetry with, but I think people call it a one-form symmetry because the symmetry will be different. Because the symmetry will be defined on closed volume. So, for instance, here, my symmetry will be actually x on all the red qubits around my unit cell. Because if I take the product of all the stabilizers that are associated to the red cubits, well, all the Z will be will be cancelled, and I will have only X on the On the well, on the faces of my closed volume, and that will be the symmetry associated to the SPT. And yes, and the same for black qubits around a closed dual surface. So I will have two symmetries that are the Z2 cos Z2 symmetry. But then to answer the question you're asking at the end, is it known whether other SPTs give rise to different codes on a boundary? For example, you can have different. Yeah, that is an open question. There are some elements of answers. So I'm trying to work on that now, which is, okay, if we have, for instance, we so the answer on So the the answer on the 1D for instance chain has been answered for MPS states where actually if you have a SPT and you measure part of the symmetry, then you can produce long-range entanglements. But it's hard to show it for larger systems, but there are Systems, but there are a lot of examples that show that okay, if we have a SPT that is complex enough and we measure part of it, then we can create long-range anti-regulators out of it. Yes. But the generalization has not been done to my knowledge. I'm not sure with quantum computing at all, so now we. About so now we're now we ask mainly but the concept of measurement using the whole idea or can you realize that like physical? So for me it's really like theoretical but I think some people are trying to do it. For instance there is a company in Canada called Xanadu that is trying to use those types of latches with I guess for ladies with I guess photons and GKP yeah GKP encoding so they they create exactly this cluster state but maybe with less like for me I would like to have maybe millions of qubits physical qubits and they do it on a smaller scale and then well they make those photons interact with them Interacts with beam splitters, so there is some attendees, and the beam splitter actually implements the CZ gate here, and then, well, they measure it. And as photons are really short, have a really short life, it's quite easy to triple them, then make them um like entangle them with few other qubits and then multiple them. So it's Virtual band. So it's, yeah, they are trying to do that. I had, yeah, now I understand. I had, I was imagining a solid state based realization and that I couldn't imagine how it would be possible to measure something layer by layer. Yeah, yeah, it would be more like with uh devices that are maybe more mobile. But In particular, can you understand as a defect in the context of the bug as they to plus A2? That is a good question. I think, yeah, it's something we would like to investigate. Why? I think the defect geometrically we really see like if we if we look at the um um really at the unit cell of a Really, at the unit cell level, we really see what is happening, but then if we kind of try to go more into this SPT phase, yeah, I know we don't know yet, and that is a question we probably would have to answer at some point. Yes? Yep, very nice. And at the very end, you were talking about algorithmic circuit verification. Yes. And I mean, circuit if your setup is extremely algorithmic. If your setup is extremely topological, you know, the measurement lines seem to correspond to what I would call chains or co-chains. Yes. Somehow, the output of the circuit is looking at the image down to the operator. So is that what your algorithm algorithm verification is? Check on the circuit as your co-homological output. Yes, yeah, yeah, yeah. It would be that actually. So for the verifier, The verifier, what we do, we give the lattice to well, it's easy to build a lattice like that. And then what we say is we say that those lines are actually boundaries out of the lattice, and then we would try to see if there exists a surface that's that can go from those boundaries to exit the designer chain at an end. Back to the end. But yeah, Marvin, my feeling, my collaborator, is the one really working on that. Yeah, let's machine on the third slide I was shown before. Measure in the X space. But you have to select for some measurement outcome or you have to. No. You can both process it. So you will, you kind of need to still know what is the measurement outcome. Then some kind of correction to the measurement outcome you want and then actually implemented up to some Paulis given by the Given by the measurement outcomes of your surface here. So you need to keep memory of all the measurement outcomes, but you will know it so you can post-process it all.  