I'm pleased to introduce him officially, to give his talk the second time of the day here, and without further revealed, Mark Muda. Okay. Welcome everyone to the second talk, which is a very different topic from the first talk. So, this is mainly a computing science talk, but we're using some mathematical concepts from combinatorial game theory to hopefully. To hopefully improve our solding. So, we're interested in computer search to solve games such as Clarber, which have this extra structure of combinatorial games, which I hope, I believe, will allow us to solve these games much, much more efficiently than random other games that don't have this property like chess. Okay, so this is uh very early uh stage of this work. Stage of this work. So, this is mostly work done by graduate and undergrad students from my courses in recent years. And I worked on it before that a little bit, and now I'm finally trying to put all these things together into a single system. And this is kind of the plan. Okay, so I'll talk a little bit about these games, commentarial games, and the structure, the main structure is the sum structure, which I'll explain. Structure, which I'll explain what it means in this context. I'll talk about canonical forms, which we'll hear about more in later talks, I believe, which is the main concepts of combinatorial games. And it's very important, but for the kind of stuff that I want to do, it doesn't work very well. So I'll talk about a different approach where we can solve these games by tree search, like we know from. Research, like we know from computing science. And the trick will be to make this research efficient by using this mathematical structure and some of the basic ideas from combinatorial games. Nothing complicated. I don't think I have a single theorem in my talk. Okay. And then as a case study, that's the one game we tried the most so far is this game of Klawber and even a special case study. And even a special case where it's just in one dimension, so one long strip of stones will be the board. And the plan is to move this work towards a general solver for combinatorial games that's based on these simple first principles as opposed to the canonical form, which for this application is just not practical. And yeah, that's what we have just started to work on this summer. Okay, so complete. Okay, so combinatorial games. If you look up Wikipedia, it's kind of weighed. Lots of games that are called combinatorial games by some people or others. So just games with some kind of structure that allows some level of mathematical analysis. That's maybe the most vague definition I can possibly give. There's three classic texts. There's On Numbers and Games by John Conway, which is the mathematical treatment, developing the theory of these. Treatment developing the theory of these games from a single line of definition by the amazing Winning Ways by Burlingham Conway and Richard Guy, who really analyzed hundreds of these games and proved hundreds of theorems and observations about them. As I said, the class of commentary games is quite large. Focus on the most traditional core part of it, because that's also easiest to That's also easiest to write computer programs for. So we'll have two players. We call them black and white, if we use black and white stones. We call them left and right because the way we write them down, one player will be on the left side and the other on the right side. We also relate games to numbers sometimes. So left will be positive numbers and right will be negative numbers. So that's just the convention followed in all these texts. It's perfect information. It's perfect information, no chance elements. Suppose players know everything about how to play the game, what is the current situation, and so on. Last player to make a move wins. We'll restrict ourselves to finite games, those are easier for computers. And the main structure is these sums that I've already mentioned a few times. So, what is a combinatorial game? Well, a game is defined in terms of left and right options. Those are the moves that the And right options, those are the moves that the both players can make, and each move leads to recursively a game, which in finite games would be a different game than the one you started from. And so this is the one-liner dimension from which Conway develops the whole theory. A game is a pair of sets, the set of left options, which are the games that left can move to, and the set of right options, the games that the right player can move to. So here's the simple So here's the simplest examples. This is the game where both sets are empty, so no player has any options. And we can join the zero that that corresponds to the number zero. It behaves a lot like the number zero with numbers. By the way, numbers are a subset of the class of games, but there's other games that are not numbers. This is the number one. Left has one move to move to zero, and right has no move. Or if you flip it around, this is the game minus one. If you flip it around, this is the game minus one. Right has a move to zero, and left has no move. So the advantage is one move. And similarly, you can get two, three, four, and so on. You can get all the integers and you can get all the dyadic rationals and so on. This is the simplest game that is not a number. So both players have a move. So left can move to zero, right can move to zero, and then it's over, right? Because zero means the game is over. So in this case, the first player, no matter which player this. No matter which player it is, has a move. And it turns out this game is not a number, you cannot say this is equal to any positive or negative in any reasonable sense. Okay, so that's the mini introduction to games. Let's talk about sums. So if you have several games defined recursively in this way, there is an additional operation, so you can play a sum of arbitrary many of these games. And what is a sum? To play in a sum, you make a move in exactly one of these games and you leave the other ones alone. For example, if you know the game of NIM, you have several heaps of tokens, and to make a move, you have to pick one heap and take any number of tokens from that one heap. So, with this definition, any NIM game can be written as the sum of each of the heaps, because there is this independence of sum. Is this independence of subgames? If you make a move in one heap, all the other heaps stay the same. And to make a move, you cannot take multiple tokens from different heaps at once, because that's against the rules. So this is one of the simplest and most traditional sum games. This one happens to have an efficient mathematical solution as well, so we don't need such for this one. But most other combinatorial games, there is not such a Torial games is not such a strong compact COVID. So I already started before the talk talking about the game of Clawba. So, quickly, it's a two-player game. It fulfills all the conditions I have on the first slide. It's played on the grid, you can play about stones, the club by neighboring stones. And usually it's played on a 2D board like this. But to make things simpler, we'll just play Clover on a strip, on a one-pipe. Cover on a strength on a 1 by n line, and usually we start with alternating black and white stones, like on the larger grids. Okay, so one observation you can make in this game that once a point is empty, it remains empty, right? Because the only operation is you move a stone onto another stone. You never move onto an empty sphere. And so, in the case of 1D, that means you get sub games, right? Because any empty point. Because any empty point, whatever happens on the left side of the empty point, will never affect what happens on the right side of the empty point. So, this fulfills the definition of independent sum here. So you can write a long Faber string by breaking it up and removing the empty blanks. So you can write, this is the sum of this first little bit and the middle bit and that bit on the road. And yeah, that's nice to know because now we can start using the machinery of We can start using the machinery of combinatorial games to help us analyze these games. And we're trying to solve pretty long strips, think 50, 60 stones in a row. Okay, so why did we pick this game for our study? Again, the ambition is to make it more general, but I think this is a good starting point. Each move leaves one robot point empty, and unless if you only if you play at the end, you Only if you play at the end you keep the strain in one piece. If you play somewhere in the middle, it splits into two parts, just about every move, except the moves at the very ends of the board. So it's anyway a best case if you want to work on solvers for thumbs of games. With a very small number of moves, you get lots of little pieces. And that's a typical behavior. And the more little pieces you have, the more you can hope to use the mathematics, the theory, to simplify. The COVID to simplify your game. So it's a good first test for an engine that wants to solve some games. All the concepts I talk about will still work in TOD and so on, but it just takes more time until the board falls apart into smaller pieces. All right. And many other games, you can also define the one-dimensional version of them. So it's a good starting point, I believe. Okay, back to some games. The main question, of course, we're interested in is who wins in the game series. Who wins in the game theoretical sense? If both sides play optimally, who will win the game with best play? And that may, of course, depend on who goes first, right? If maybe black can, like that simple game I had in the beginning, if black goes first, black can win, if white goes first, white can win. But that's not always the case. In general, there's four things, four cases that can happen. If black has an advantage, black can always win, even if white goes first, no matter who goes first. Black wins, in terms of momentarily interesting. In terms of method games, we say the game is positive. It's better than zero because, again, black is positive. If white can always win, we say the game is negative. If the second player always wins, that's the really interesting case. So that's a game where going first is a disadvantage. Even you go first, you lose, right? Like zero is the best example. There's no moves, so whoever goes first loses, right? And then the last class is where the first player wins. Where the first player wins, which are games which are not numbers, so I didn't write the comparison with numbers. Okay, so in the most general sense, we're given some game, and we want to figure out who wins, right? That's what we're trying to do. And the result will be one of those four classes. Who wins if black was first, who wins the white close first. Okay, so that's our goal. Okay, how to answer the question? In computing science, we've obviously. In computing science, we have an algorithm to solve this problem. There's a number of traditional approaches based on combinatorial game theory. They all go through something called the canonical form of those games. We compute the canonical form maybe of each little sub-game, and then we keep going until we know the winner using mathematics. There are many approaches based on this using other concepts that I won't go into today, like mean temperatures, thermal gas, atomic weights. Atomic weights. There's a large number of concepts in these, in the COVID, that you can use for certain games to simplify things. Like I said, I'll talk about a completely different approach. Well, mostly different approach here, which is based on just search Minimax type entry search. And yeah, we can do that, right? Everyone who takes an undergrade course in search can write alpha beta or some program like that. Alpha beta or some program like that, it will solve all these games. The question is just how long it takes, right? It will typically take too long for the larger games. So we try to do the same thing, but much, much more efficient by using the fact that these games quickly break down into sums of much smaller games. Okay, anyway, canonical form very quickly. So, given any combinatoric game, right, in terms of left and right options and this whole recursive tree-like structure, we Three-like structure, we can do some simplification, dominated options which are bad moves, reversible moves, which are cases where both players go through a sequence of moves before they hit something simpler. And then when you cannot remove anything anymore, that's the canonical form of your game. They can be much smaller than the original game, so that's the strong point. They are very powerful in the sense that they always. Powerful in the sense that they always contain enough information to find the winner of that game plus any other. If you have that game that you have the canonical form for, any other arbitrary complicated game X, which would be another sum of 27 other games, there's enough information in the canonical form to figure out the winner of G plus X. Again, no matter who goes first. So that's very nice property to have. Very nice property to have, but it's too much for us because we're just interested in solving one particular sum. And that's where the mathematicians lose interest because they want something more general. Oh no, we're good, we're good. Sorry, I didn't mean to point in your direction. I did. Okay, yeah, we just here we have more modest, we want to just solve some particular sums, but we're not modest because we want to solve big sums, right? Okay. So the main problem here is that if we're just computing the canonical form, even for a little The canonical form, even for little pieces, can just completely blow up in complexity. Just quickly show you an example. We just start making these drawboard strips. I add two stones at a time, so two stones, the value is star, right? One player makes a move and then it's over, first player makes a move. If you have a strip of length 4, it's a little more complicated. If a strip of length 6 is actually a second player, so this game is 0. So very nice simplification. Nice simplification, yay, canonical forms. And then, you know, it gets a bit more complicated and it gets simpler again. So, looks okay. But if you make it a little bit longer, I have to use a lot smaller fonts to put the canonical form on my slide. So, this is about two full pages on my screen. I just had to use, I think this is five-point font to fit it in my box. So, there's exponential growth. Growth in the size of the canonical form as a function of just the length of the board. So that's bad, right? If we have a sum, which is four or five of these things, we end up with four or five gigantic expressions, and then we need to figure out who wins the sum of those gigantic expressions. It's not really a nice task to think about. Okay, so let's do something else. Traditional media. Else, traditional minimax search. We have the game tree now for the whole game, not just for writing commentary, game theory. The nice thing is we can just look at one sub-game at a time and build a canonical form for these little pieces. And sometimes that's simple. And sometimes, as we see, it's not. Here, the downside, the big downside of minimal search is we have to look at the whole game, all of the pieces together at once. The good thing is now we can do the usual alternating play. I go, you go, I go, you go, right? Which we have when we play a game. Right, which we have, and we play a game, we take turns. Because if you look at one little piece, it's not guaranteed that we alternate play in each little piece, right? Because if I play in the left half, then maybe you'll play in the right half, and I'm going to get two moves in a row in the left, and so on. So the searches are different. Anyway, so we're doing a minimac search of the whole game at once. We'll have Boolean outcomes right if the search game is over. Whoever made the last move wins. Whoever made the last move wins. And yeah, the end of the game is simply if the current player has no move. And so now later, these are finite games. We're going to reach that state in each branch of the search. You probably know that the complexity of these searches depends on the breadth and the depth of the game tree, right? The breadth is how many moves are there for the current player. The depth is how many moves until the game is over. And so naively we have something like order of b to the d. Order of B to the D. Best case, like alpha-beta pruning with perfect move ordering, you can reduce the depths by half. Basically, because for the winning side, you'll only look at the best move and prove it's a win, and you don't have to look at all the other moves. So, for the winning side, you can have a branching factor of one, but for the losing side, you have to try everything. So, make sure they really do lose. Okay, so what about our drawback board? Well, both the breadth and the depths are basically Breads and the depths are basically linear in the board size. Most of the stones have two moves, so it's something like 2n minus 2, because the end points only have one move. So the branching factor is 2n minus 2. This symmetry here, maybe at the beginning you can cut a little bit, but not a lot. And the depth is a more difficult question because what can happen is that you get these isolated islands. Let's say this stone core was there. Let's say this stone claw was there. You get these isolated islands of stones of one color, and there's no more moves ever possible for those stones. So the game can be over pretty quickly. I mean, if you look at the extreme case, if you have a long strip and you put all the black stones on one side and all the white stones on the other side, the game will be over after one move. Because then both sides will be separated and there's no more clubbering possible. But still, in general, But still, in general, the depth is some fraction of the blood size. And it doesn't go. Yeah, it goes linearly with the blood size as well. Okay, so traditional minimal exertion is too slow simply because you can basically board size to the power of bault size in your expression. Okay, so we want to exploit some game structure to break that down into much smaller. How can we do that? Right, we want to use this sum game structure to speed up the search. And the main reason we can do that is we can simplify these sum games in the middle of the search. If you recognize that some pieces, for example, are zero, there's no more moves, you can throw them out. If you recognize that some pieces are opposites of each other, inverses, as we say, we can throw them out. So I'll talk a little bit about some of these. Talk a little bit about some of these basic ideas now. There's other little bit higher-level ideas that I won't talk about in this talk. You can compute bounds on the value of a sum by using values of these sub-games, very similar to if we have numbers that we don't know exactly, but we know an interval of the value of a number, we can use that sometimes to say the whole sum is greater than zero or not. I won't go into that in this talk. And maybe the most important thing in practice we can Thing in practice, we can build databases of little strips, of small boards, and we can analyze these small games much more deeper, much more exhaustively, and that helps us find simplifications of the previous steps. Okay, so how do we simplify? We're giving the sum of games. The first case of simplification, like I said, is if we have two of these games with the inverses, so one of them is minus the other. Inverses. So one of them is minus the other. I haven't explained what minus means, but let's think about simply switching colors. Or if the games are numbers, it's just the same thing as with numbers. And if two of the subgames add up to zero, it means we can simply skip, drop these two subgames from the whole sum. Okay, so what are inverses? By the most basic definition, the inverse of a game is if you swap the colours. Of a game is if you swap the colors. So to get from g to minus g, all you need to do is change every black stone to a white stone and vice versa. So without knowing what is the value of this game, we can say that this plus this is zero because one of the games is the inverse of the other. It's really easy to see that it's a second player win. Remember, zero was a second player win, because the first player can choose any of these games, make a move, the second player will just copy in the other game what the first player wins. In the other game, what the first player did, and so eventually the second player will have the last word, make the last move. No matter what the first player does, the second player will copy it in the inverse of the first thing. Okay, so we can in our server, we do recognize these things simply based on the board. And again, for strings of black and white, it's not it's easy to compute the inverse. You just flip the zeros to the ones and compare. Concare. We can also do it with search. Sometimes there's games that look different, but they're still inverses of each other. And so we can do it, if we already have a search engine, why not use it? We're using the search engine, but not for the whole big, long sum, but only for the small sum of two little subkins. So if you happen to find any two elements in here that add up to zero, we just drop them from the rest of the calculation. You may ask me, isn't that really expensive? And unfortunately, the answer is no. And unfortunately, the answer is yes. It's really expensive if you have a large sum of n games, you have like n choose two pairs that you need to test in general. So that's part of our job as the algorithm engineers to figure out when is that a good idea, when should we try to do that, and when is it better to not spend n squared time on looking at all pairs and none of them add up to zero anyway, right? So that's a kind of, I would say it's an open question. I would say it's an open question. We know some specific cases where it's certainly a good idea, but we don't know in general how far we should go with that. Okay. Another approach is sometimes we can replace one of these gains in the sum by a simpler one. So again, the analogy in mathematics: if you have 5 plus 7 minus 3 as an expression, then everyone would replace that expression with 9, because that's equal. Because that's an equal, simpler expression. It makes the rest of your computation easier. The same here, if any of our games is equal to some other game H and H is simpler than our game, we can replace it. And again, it won't change the outcome of the sum. Because if you replace equals with equals, like with arithmetic, the game outcome is preserved. The best case, of course, if you find out one of these sub-games is zero, you can just replace it by zero or just drop it altogether. Drop it altogether. For example, we've seen in the table that this game happens to be zero. So if at any point in your search your board breaks down into a length 6 board plus, let's say, a length 4 board, you know, this part is 0. You can just drop it and the whole game is equal to just whatever else this length is. Okay. There are other cases which are still good where your game is equal to another game which is not zero. game is equal to another game which is not zero but it's simpler than the original. Okay, some sounds, but I think it's okay. You may ask me, how can we find that, right? If I give you a long string, how can you find out that's equal to some length six string, for example? And again, that's an algorithm engineering question, but the most powerful thing we know by far is we build it. Is we build a database of all the small strings and then we can spend time basically pre-processing the database and finding such relations that happen often enough. Okay, so let's talk about the database. So the starting observation is the reason I chose these games is after a few steps of search, typically the game breaks into many, many sub-games because almost every move gives you two parts. Move gives you two parts. And some of them, just by random chance or by where you choose to try first, these pieces could be quite small. And we can pre-compute and do simplifications and analysis on these small games in a systematic way. If you think about these drawba strings one by n without empty points, right? Because when there's an empty point, we can split it. So a string of length up to 20, each point can only be black or white. Each point can only be black or white, so there's only two cases. You have only about a million cases of strings of size 20, but I guess two million of strings up to size 20, right? Okay. So, and then we can store a lot of useful information about these games just in a table. For example, which are all the good moves? Because many of the moves, even locally, are bad. They will never be played by a competent player. Moves that are not part of the economic. Moves that are not part of the canonical form, for example. Or there's two equally good moves. We don't need to try both of them because they're exactly the same. We just store a small set of non-nominated moves. And then we know if this game is part of our big sum locally, we don't have to generate all moves, just the ones that our table tells us to. Yeah, we can, if we find that some gains in our table are equal to a smaller game in this table, we can just point to it and replace it. We can just point to it and replace it when we encounter it later on in the sum. We can store the inverse of a game in the table, and then it makes it much easier to recognize we have the game and its inverse in a sum. If we have the, whatever, just the binary code of these things, right? If we have black is zero and black is one, we just flip it and then we know what is the inverse. You can also flip forwards and backwards. All right. You can do other things again that I'm not talking about here, like you bounce on the value of these. About here, like you bounce on the value of these games and you attempt to estimate the whole sum has to be greater than zero because each piece is greater than zero, for example. All right. In other words, it's quite likely that if we play a large game, very quickly we have lots of little games, and if you have a database with lots of information about them, we have many chances to simplify and reduce the game. Okay. All right. Alright, so here's that case in a little bit more detail, right? So we look again at any pair of games in here. The best case, the sum of them is zero, and we can drop them both. But there's many, many other cases where the games are similar but not quite the same. So you could say the game gj is like minus gi plus something simple. But then if you add them up, the game and the inverse plot cancel and we're just left with the sum being something simple. Sum being something simple. Hopefully, something very small that's also in our database already. And so, yeah, offline we can compute such simplifications of sums of two database entries. And one of the student programs does that, and it's part of the reason it's much stronger than all the other programs, including my own. Okay. So let's spend the last two minutes, three minutes, talking about progress so far. Again, this is very preliminary. Okay, this is very preliminary. I wrote this over a couple years back. I taught two grad courses on algorithms and CGT a couple years back. I used Taur as the main example in the course, so they did assignments and things like that. And some of the student teams also did a final project. And one of the final projects was this one by Taylor and Fateme and Sarah. They call themselves this all was confidence. And I'll show some results. I'll show some results of this one just to give a glimpse of what we can do with this approach. And now, this summer I have an undergrad, Mark Usmanov, who did really well in my algorithms course. And so he's now working on a number of these topics. Just take the different solvers that we have. We have a couple other students' overs, combine them, extend the ideas for the different solvers, kill one super solver from them. And the other thing. And the other thing I asked him to do when he started doing that is separate the Clover stuff from the general combinatorial game ideas. So make it a, you know, a tool, a system, you have a general engine, and then game-specific plugins. And of course, implement and test other games. But for now, we stay with the one by end strips because, again, they quickly produce many little games, and that's good for testing. Martin, Martin, we have some flexibility. Pardon, we have some flexibility, so very close to being done. Okay, I'll try. So, this just shows an example of the results that this student team got. So, this axis is time in seconds. This axis is board size. So, the largest canonical form I showed was for board size 20, right? There were 10 pairs of black and white stones. So, up to some way here, it's just a database lookup. Here it's just a database lookup, so this is a little bit cheating, right? This is pre-computed results from the database. But then the first version just did the naive thing, Negamux, which is a form of minimax search with a transposition table, whole board, ignore the summary structure. So it can solve up to lengths 30-ish. This is integrative deepening, which is another traditional search method, so a little bit better. So it's a little bit better, but then the big chunk really comes from using Common Torreg's concept. So instead of size 30, 35, they can now solve with their first version 40 something, and with their final version, 50 something, 55 mics. So I think just the gap between here and there shows the power of using the combinatorial games concepts for solving these games. Again, if you just try to use canonical forms, And if you just try to use canonical forms, I suspect it'll be stuck somewhere here where the canonical forms really not big. I haven't actually tried that. All right. Okay. So we have short-term and long-term goals. I already mentioned this, separate the game-specific robot stuff from the general stuff. So independent things are things like the rules of the game, what are the valid moves, the details, how a game splits into sub-games, right? Into sub-games, right? In Globa, you can split based on empty points. In other games, such as Nogo, you can split based on black and white stones adjacent to each other, and other games may have other rules. So that's game-specific. The geometry of the board, right? We have some symmetries we can take advantage of by flipping a board by 180, which we may not be allowed to in other games. Most of the other things I talked about are completely game independent. They're really on the level of working on sums of games, no matter where. Working on sums of games, no matter where these games come from, which specific game they come from. So we showed we can improve previous performance on solving COVID. If you study the little literature that there is about COVID, there's some conjecture about the value of these repeated positions. So if you have black, white repeated in times, or black, black, white repeated in times. There's some conjectures of what the values should be. And we can certainly push into some of the Certainly, push it the sum of the values of n that's larger than what's published in the literature. We certainly done this case, the conjecture here is weaker, it's just basically the first pair wins most of the time, except for the pace of three pairs. But for this one, it's a more specific conjecture that the value of these games is actually equal to a much simpler combinatorial game. And that'll be one of the next things we have to try. Okay, solve other games on these boards, like Nogo is probably our next target. Is probably our next target. But also, we want to make it work for more general commentatory games. And the next thing we'll try is NIM because it's very different. It's not even played on a board like that. And it's an impartial game. And anyway, it's just we want to make sure there's no hidden assumption in the solvent that it has to be on a board and things like that. Okay. Longer term, of course, you want to support the real 2D games as well. 2D games as well, maybe other structures like games not played on the board, like NIM. We have some other previous software that also avoids canonical form. For example, we can compute thermographs, which are very useful concepts for many of these games. So hopefully we could combine these different toolkits. Yeah, we worked in the past on a game called Amazon using these databases of thermographs and the specific Amazon solver. Specific Amazon solver, maybe we can pull out the common parts and simplify things. Eventually, the limit, only the limit, I think we could