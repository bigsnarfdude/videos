And Chloe. So I'd like to introduce Andrea here, who is going to be talking about FESTA. Is that how you say it? Yes, yes. And just one reminder, if you're online, try to make sure that you are muted. Okay. Hi, everyone. My name is Andrea Vasso. I'm a postdoctoral researcher at the University of Bristol. And today I would like to tell you a bit about. And today I would like to tell you a bit about this recent project called Festa, which stands for Fast Encryption from Super Singular Trotion Attacks, and where we try to build a PKE protocol using the SADH attacks in a constructive way. Festa means party in Italian, and just as a small caveat, the FAST in the title is most despirational. Okay. Okay, a little bit of background. Throughout this talk, we're going to be using the SATH attacks quite extensively, but for the most part, we can not care about the details of how they work, how they function, we can abstract them away in a black box. So, for the purpose of this talk, you can see the SADH attacks as some black box machinery that takes an input. Machinery that takes an input two curves, the degree of an isogeny between those two curves, two points of sufficiently large order which are linearly dependent on zero, and there are images under the secret isogenify. And when we feed all of this to the SADH attacks, machinery dispatches out the isogenify. And this is enough to understand how Fast Star works. Works. And while the concept of using some recent, some new attacks in a constructive way may seem somewhat peculiar, somewhat strange, it's not a novel idea. It's been done in the past, especially in the exogeny world. We have sheta that use their whole knowledge of attacks in a constructive way. And the way that this process of adapting an attack into a constructive application A constructive application usually follows this kind of path. We start from an attack which we want to be classical, first of all, and we want it to be somewhat efficient. We then identify some kind of information that the attack relies on that can be kept private. Usually this may be the endomorphism ring of some starting curve. And then we can design an attractor function where evaluating the tractor function is, say, computing an. Function is say computing an isogeny, and using the secret information that we identified before, we can apply the tag and invert the tractor function. And once we have a tractor function, we can then apply some generic constructions to obtain anti-K. However, there is a catch, because in the context of the SIDH attacks, the second step, identify essential, possibly secret information, is not really possible. The attacks rely on all public information. All like public information, it doesn't require knowledge of an endomorphism ring, it doesn't require knowledge of any information that can be kept secret. So, if we want to use them in a constructive manner, we need to use them in a bit more complex way and devise some kind of mechanism that, on one hand, allows to have some kind of thing where everyone else cannot just run the attacks easily and break the security developer protocol. And break the security of our protocol, but at the same time, we still generate some secret information that allows the one party to actually invert this function. And the way that we sort of get around this issue is by, as usual, in isogeny-based construction, introducing a new assumption. And before we had something like this. So in SIGH, for instance, we have a synchronous isogeny phi, we have two points. We have two points and we reveal their images. And as we've seen, if we feed all this information to the SNH attack black box, then we can extract the sexogenify. So this is clearly not secure. So what we propose doing is instead we mask the points, we scale the points. So we sample some random value alpha, some random value beta, and then we simply scale them. And once these exact points images are not known anymore, if we try to fit this to the More. If we try to fit this to the SIDH attack machinery, this won't work. Now there's a small catch because through some pairing computations, it's always possible to extract the product of alpha and beta. So for simplicity, we limit ourselves to the case where the product is 1. So we just take alpha and 1 over alpha. And so, okay, we know that now we assume, we hope that this is secure, but it's still not clear. But it's still not clear how we can use this to introduce some kind of tractor mechanism. And to do so, we rely on a particularly important property. The idea is that if we start with this kind of computation, so one party samples a random isogenifi and then maps the two points and scales them by alpha over alpha, and reveals this information. Then a second party can repeat the same process using a different isogenic psi, using a different mass dependent. Using a different maximum value beta. And if we do this, because we scale by scalars and because isogeny acts linearly, this commute. So this means that this is the same as computing the composition of psi and phi directly on P0 and Q0 and scaling them by alpha beta and 1 over alpha beta. And more importantly, if we do this a third time, if the same person that computed the first isogeny does a third isogeny sigma, and these three isogenies are completely. And these three isogenes are completely unrelated from each other. They have different degrees. It's nothing like an SIDH where they need to be parallel or this could be any isogeny whatsoever. Then if the first person does this third computation using exactly the inverse of alpha, because again, everything commutes, what we obtain is that this is the same as mapping the points V0, V0 under this composition isogeny and scale them by only beta and beta. And scale them by only beta and beta versa. Which then means that one party, the party that knows beta, has access to some kind of information that allows them to remove this masking, undo this masking, and obtain the exact images under this composition isogeny of D0 and T0. Does this make sense so far? And the main idea is then we can, this is basically how FastDAR works. Then we can just move everything in place to Then we can just move everything in place to look more like a trapdoor function, but this is the main fundamental mechanism that underlies VESTA. And just as a small note, this is a specific example. In this case, we scale by a value here. So this is basically equivalent to scaling these two points by a diagonal matrix. But this is just one case of many where we can actually consider any sort of matrix here as long as the matrix that you Here, as long as the matrix that you sample here and here believes. Okay, so now let's look at how the fest attractor function looks like. And just as a small reminder, attractor function is a function that for everyone else it's hard to invert, but for the one person that has knowledge of the tractor information, then it can be inverted in efficiently and recover the original input. Cover the original input. So we start off by doing exactly what we seen before. We fix a curve and some points as parameters of the protocol and then one party computes a random phi isogeny and reveals the codomain curve together with the images of these points scaled by some random value alpha. And in the context of the tractor function, this constitutes the public key, the public parameters of the function. Parameters of the function. Then our function takes three inputs, psi, sigma, and beta, where psi and sigma are two isogenies and beta is the scale of them. To evaluate this function, we compute psi from E0 and map the points P0 of U0 under this isogeny and scale them by beta. And we do the same with sigma starting from the second curve, map the points and scale them by beta. And the output of this tractor function is the two curves here together with the points that we obtain. And because we assume that when you reveal these scale points, it does not reveal any information on the isogeny, we can expect that this is hard to approach. If you're given this information, then you're just given the points scaled and their curves, so we expect. Curves, so we expect that it starts to recover psi or secret. But if you have the tractor information, which is the secret value alpha, then you can look at this green isogeny, the composition of the three isogenies. And what we obtain is that if we apply this to P1 and Q1, it's exactly the points P2, Q2 scaled by this value alpha that we have here, and then some other fixed. Other fixed value just for some technical reasons. Which means that if you know the value alpha, then you can obtain the images of P1 and Q1 under this green isogeny exactly. And once you have that, then we can fit this into the SADH attack machinery to obtain the green composition isogeny. And once you have the green composition isogeny, you can extract psi and sigma. Once you have psi and sigma, by solving some simple discrete log of. Simple discrete log over a smooth order group, then you can also recover beta. Which means that this function is hard to invert for most people, but if you do know the value alpha, then you can use the SADH attacks to recover the image of the function. Any questions so far? Okay. So once we have a tractor function, we can apply some Can apply some standard transformation to obtain a PK. And the idea is that we rely on a slightly stronger notion of a trapdof function, which is the idea of a partial domain one-way function, which means that not only it's hard to extract, recover the input, it's also hard to recover part of the input. And the way you show this is that by having either like one of these three components. Like one of these three components, you can always recover the other two. Because if you know either psi or sigma, then you can recover beta. And if you know beta, you can unmask the points and recover the two isogenies by applying the issue parts on the two specific size. And once you have this partial domain one-way function, we have the so-called OAP transform, which automatically gives us a PKE that is in CCA to secure. That is institutive secure, which is the sort of the strongest notion of security we can hope to achieve in the quantum random Oracle model. And without going too much into details, this is sort of how this transfer will look like. It doesn't really matter, like the details don't matter too much, but the key takeaway is that this is basically just consisting of evaluating some random random oracles, some hash functions a couple of times. But from a computational point of view, this doesn't really add any. Point of view, this doesn't really add any significant overhead over the computation of the chapter function. Alright, so far we've been using the SIGH attacks in a very black box manner, but once we actually want to implement this, we want to have a practical protocol, then we sort of need to look into the black box and decide which attacks we want to consider. And we can sort of split the We can sort of split the different techniques that we have into two big broad categories. Does that rely on isogenies in dimension two, and does that rely on isogenies in dimension four and higher? And in dimension four, or actually in dimension two, what we have is that these are relatively fast and efficient isogenies to compute and they're relatively simple to implement, relatively in the sense that this is still significantly more complex than the dimension one isogenies that we're used to. One isogenist that we're used to, but it's still like a very doable task. However, this comes with a big caveat, which imposes very strict requirements on the degree of desogency that we're using and the order of the torsion points that we're using. So this makes someone like finding parameters a lot harder. If we go in dimension four, we sort of get rid of the requirements on the degree. So this gives a lot more freedom to A lot more freedom to choose all the parameters however we want. But the computation of such isogenies is a lot significantly slower and it's also much harder to implement. So much so that so far we have no concrete usable implementation of dimension for isogeny as far as I know. And if we were to use dimension for isogeny, were to use dimension for isogeny in FESTA, then we could get something that is very, very small, very, very efficient in the sense that the prime that we would be using is like 400, 500 bits, so comparable to what we used to have in SAPH. And because of this, then key generation and encryption, which only use dimensional isogeny, would be extremely efficient. But then decryption would need to evaluate this dimension for isogenies. Dimension for exogenies, so it will be extremely slow. And because we wanted to have something that was concrete, implementable, and hopefully practical, we decided to rely on the on-dimensional two isogenies. And this comes at a cost in terms of parameters because we are using 1300-bits points rather than 400 bits, so like three times as large at least. But then this allows us to get practical running pops. To get practical running costs and concrete limitation. And this brings us to the next question: since we have these strict requirements on the degrees and the orders of the points, how do you find parameters? And first of all, the complexity of running attacks and computing these higher-dimensional isogenies depends on the order of the torture points that we'll be using. For that reason, we For that reason, we limit ourselves to points that have a power of two order because computing 2,2-isogenies is significantly more efficient than computing 2,3-isogeny, 5,5-isogenous, or any other degree isogeny in dimension 2. Then we've seen that in the SADH attacks, when we wanted to use dimension to isogeny, we sort of had to fit this equation. So the degree of the isotenin. Equation. So the degree of the isogeny that we want to recover must add up to 2p, which is the order of the points. And we also need to evaluate isogenies of degree C, so we also want C to be very smooth. So we want two numbers to be very smooth and such that their sum is equal to a power of 2, which can be fairly hard to find solutions. But one interesting aspect that we can exploit is that this is sort of similar. Exploit is that this is sort of symmetric. So, rather, like, you can also recover an isogeny of degree C if you can compute isogenies of this degree. So, we can, rather than having one isogeny that we are recomputing and one auxiliary one that we are only using for the tax, we decide to basically split the isogeny that we want to recover in two components such that their sum is a power of two. So, basically, we put sine on one side. We put sine on one side, sigma on the other, and the top isogeny phi is split into two parts. And besides, like, this is also the benefit that allows us to use significantly smaller torsion points, because if you note, then here the value b is 2 to the b is roughly the same size as this degree, but now the value 2 to the b is about square root of this, because we're using smaller resogenes on each end. Result in his own each n. And then we also introduced the fact that we can use scalar multiplication to get some squares here and there, which allows us some more flexibility in finding parameters. And the way that we end up solving these equations, finding solutions for this is a very adult method that relies on Carmacis algorithm and kind of like brute forcing all possible piece. And while this method may not be And while this method may not be necessarily producing the optimal solution, it's very efficient in practice, which allows us to easily find parameters. And what we get in the end is that our prime is about 1300 bits. The degrees of disogeny used during encryption are 2 to the 12th smooth, so fairly efficiently computable. And the degree of dysogeny using during key generation is a bit less smooth, 2 to the 16th, so it's a bit slower to compute. But since this is key generation, Compute. But since this is key generation, this is only used once, so it's less important. Okay, so we actually sat down and implemented this implemented entire protocol and currently we have a proof of concept implementation. This is only in stage, so it's still very far from being optimized. And what you can see here is that the What we can see here is that the sizes are still fairly large, at least for isogeny standards, and that's because we have to rely on a particularly large prime. But on the implementation side, we still get things that, like some running times, that are in the orders of a few seconds, which is not too bad, especially considering this is based in Sage, and we can hope for at least an order of magnitude. At least an order of magnitude improvements when we switch to significantly, like a lower level of optimization. One thing to note here is that, as you can see, the decryption takes, the most takes around 10 seconds, but there is some ongoing, amazing work by a bunch of people, including Pierre-Richter, Luciano Marino, Giacomo Cope, Sabrina Kenspeiler, and Sabrina Kensweiler and Damien Robert that uses theta structures for computing dimension to result genes, which allows us to significantly reduce the running times from more than two seconds to less than three. So not only this is somewhat promising already, but there is plenty of room for improvement, and we can hope that by using different optimization and tricks and switch Different optimization and tricks and switching to a lower level language, we can actually obtain some concrete running times. And just to wrap up, as a quick summary, in this work we introduced some new constructive applications for the SIH attacks. We also presented FESTA, which is a completely different PKE scheme than any of the other encryption protocols that we had before. And while the Before, and while the results are encouraging, there is still lots of room to grow and improve, and there is many different research directions that can be explored to improve faster and obtain a more practical. If you're interested, check out the paper or the source code. They're both freely available. And if you have any questions, And if you have any questions, ask them here, or feel free to reach out to me or any of my co-authors who channel my email and jump along. Thank you very much. Maybe questions from Ben first? Just a quick question about parameter generation. Is there any hope of Is there any hope of like an elementary problem? Is there any hope of like where is there any does it make sense to try to improve on that? Or that's not really important? No, I mean the where is it? The parameters is actually one of the main bottlenecks. And it does make sense to look at that. As I mentioned before, the technique that we use so far to find solutions. That we use so far to find solutions is so the technique that we use is in one sense nice because it can produce lots of solutions very efficiently so it's very easy to play around with but we I mean we don't even know how close the solutions that it produces are to the optimal solution. Or I mean it for sure we could expect For sure, we could expect to get a much smaller solution. I mean, just by looking at this, for instance, if we introduce this scaling band, you still have some more leeway. But if M1 and M2 were both set to 1, then we would have smaller solutions, which would be ideal. Because then we also get smaller piece here, so like smaller torsions, smaller primes. Yeah, so I mean, one of the big questions is how do you? So I mean one of the big questions is how do you find better barometers for this? Any other question? How about Bristol? Are there any questions of your employee? I think we're all very tired. It's got five days. Sorry, Australia. Oh wait, there's one remark from Damien. Do you wanna remark from the Oh, okay. That's good to know. I didn't know. Or I guess I've had a remark. All the three isogenies in any dimension are implemented in AV isogenies, just not R2 isogenies. I don't know. Thanks. Great, and Amado, I think we'll see you tomorrow. 