We have five moments right to to chat to do other things. Right, this will oh yeah, yeah, I I would And by the way, what about pre-talk surveys? Does it still make sense to fill them out or continue filling them out if you haven't done so? Yeah, so indeed let me remind everybody that there are pre-talks. Remind everybody that there are pre-talk surveys. They are posted as links in the schedule after each abstract. So if you are going to attend the talk, please feel it because it really helps speakers to get a sense of the audience because in these online meetings, it's a bit harder to predict who will actually come to the talk. And we are pretty numerous. So it looks very helpful so far. So please, please. So please, please participate in these surveys for the next days. Earlier you feel them, more time speakers will have to adapt this information. So it will be for everybody's good. Oh, Tom, you're here. Tom, could you just? Yes, I mean okay great then uh Tom Scanlon will be chairing the the today's session okay so according to my according to my watch we have we still have four minutes yes yes well my watch three minutes but yeah by the way easier way to make this slide The slides much smaller and the video stream of faces much larger. Is there a way to go back and forth? Yes, there are like above the faces. So I think you have now faces on the right in a column. Above this column, there are buttons that change the type of view. There's also a command at the top of the screen. Commands at the top of the screen, you'll see something which says you were viewing David Ellis Marker's screen, and then to the right of that it says view options. You pull that down, you can change the size of how big his screen is. I'm asking about this so that, for example, if the speaker wants to see the reaction of the audience, like by looking at them, can the speaker actually see more faces rather See more faces rather than the screen. That's that's that's why I'm not I think the speaker can do that too, but I don't know where that button is. Shows the colours and the colours of the colours. I have just sent in the chat the link from the title slide, so everybody can open the presentation. You can open the presentation if you wish. Okay, so Dave, are you ready to go? Sure. I think so. Welcome, everyone, to the first lecture of our virtual version of the summary. Version of the seminar. I think, as Gleb has already pointed out, we're quite a diverse group. And Dave is going to try to explain what model theory is for the rest of us. And if you have questions, please post them in the chat window. I'll interrupt Dave to ask those as they come up. And I shouldn't say just if. And I shouldn't say just if you have questions, you should have expect that you will have questions. And Dave is ready to answer anything that's anything that we might want to ask. All right, so Dave Marker will begin now on model theory, quantum condemnation, differential algebra. Great. Thanks a lot. And thanks for inviting me to give this talk. Before I get started, let me just notice I did have this URL at the bottom. I have my slides for today are posted there, but also a number of surveys that, if you're interested in more information on some of the background and things I'm talking about, there's some information there that might be interesting to you. Also, I should preface this. I was asked by the organizers to try and give an elementary talk, fairly elementary talk, under the assumption that a large part of the audience will have no background. Part of the audience will have no background in logic, and that's what I'm going to do at the risk of boring my model theory friends who are here today. To get in the mood for this, I want to share with you a quote from the representation theorist and great mathematician David Kazdan, who did some work with Hershovsky around motivic integration. And after that, he became a little bit fascinated with model theory and has written several lecture notes on it. And at the beginning, he says, I don't know any mathematician. Beginning, he says, I don't know any mathematician who didn't start as a logician for whom it's easy and natural to learn model theory. For a short while, everything's so simple and so easily reformulated in familiar terms that there's nothing to learn. But suddenly, one finds himself in a place where model theoreticians jump from a tussock to a hummock, which I say, a valley to a small hill, while we mathematicians don't see where to put foot down and are at a complete loss. So we have two questions: why is model theory? So we have two questions. Why is model theory so useful in different areas of mathematics? Why is it so difficult for mathematicians to learn it? But really, those two questions are almost the same. It's difficult to learn model theory since it appeals to a different intuition than a lot of other areas of mathematics. But exactly this outlook leads to the success of model theory. And then he says that model theory is somehow the disappearance of the natural distinction between formalism and substance. And substance. So you start talking about structures, then you start thinking about the way you talk about structures. So the outline for my talks, today I'm going to do basic concepts from logic and model theory. I'll discuss quantifier elimination in one particular case and see how it can be a useful tool to gain new information. Wednesday, I'm going to describe. Wednesday, I'm going to describe a model-theoretic way of how we, as logicians, like model theorists, like show theories, have quantifier elimination. And then I'll finally get into talking about differential algebra, introduced to the notion of differentially closed fields, sketching the proof that they have quantifier elimination, giving some applications of that, and if time permits, which I can't imagine it will, also introducing some other useful model theoretic concepts. Okay, so let's get started. Okay, so let's get started. And again, I encourage you to send questions in the chat room. And Gladwin, Tom can interrupt me. Okay. So in model theory, we use first-order languages to study stats definable in mathematical structures. So the first question is, what's a structure? And I'll start by just giving you a list of examples of the kinds of things we might look at. You can look at the ring of integers, the complex numbers, the real numbers as. The complex numbers, the real numbers as an ordered field. I could add exponentiation to the real numbers. I could look at the complex numbers with exponentiation. I could look at the field of meromorphic functions, say on the complex line with where I have the field structure and the derivation d by dz. So, what have I done in all these things? I've identified a basic set that I'm looking at, and I've picked out some. And I've picked out some functions or subsets that I think are useful. So, informally, that's all a structure is: it's a set, and I've distinguished some functions, some relations, and some elements. So, just to go through this, for RXP, the data here is the set of reals. I've identified two binary functions and a unary function. I've identified a binary relation less than. A binary relation less than, and I've distinguished elements 0 and 1. In the ring of integers, I have the integers, the two binary operations. I haven't put in any relations on it, and I have the distinguished elements 0 and 1. Now, the examples I've given, I've only distinguished finitely many things I'm looking at. There's no reason not to do infinitely many, countably many. Many, countably many. Some natural cases, you even do you add continuum many functions and things. So, this is the idea of a mathematical structure. Once I have a structure, I'm going to fix a language that describes the structure. So let's just do an example where we look at the reals with exponentiation. On the reals with exponentiation, my language, LXP, I'm going to have special. I'm going to have special symbols that describe the things that I think are important about the structure, namely addition, multiplication, exponentiation, the ordering, and the two constant elements. And now I'm going to build up, following some simple rules, a notion of formulas, which use the special symbols in the language, the symbols I've specified for this case, and just what I call logical symbols. Symbols. So I can always use equality. I don't have, that's not a special binary relation. It's always there. I can use logical connectives and or not. And if you want to use a couple more like if and only if or implies, that's fine. I have the two quantifiers that are existed for all. I have variable symbols, which formally I would be using something like V0, V1, V2, but all. One, V2, but I'll be informal a lot in this talk and just use XYZ. And I use parentheses to make things readable. Okay, so here are some examples. x sub x is bigger than 1 plus x. So these are all formulas in the language of exponentiation. There is a y, y times y is equals x. So this is a formula that says x is a So, this is a formula that says x is a square. For all x, if x is greater than 0, then x is a square. So, this says every positive element is a square. There is a y, x times y, x of y is x. This says x has a logarithm. This one has three levels of quantifiers. And if you read it, what it says is the limit as x approaches 2 of x. says the limit as x approaches 2 of x squared is 4. Where you know 2 and 4 aren't exactly symbols in my language. I think of them as abbreviations for 1 plus 1 and 1 plus 1 plus 1 plus 1. Okay, so these are the notions of formulas. So Dave, in this example, example five, there are many things in your formula that are not actually part of the usual part of the language. Language, like the quantifier for all epsilon greater than zero, or the squaring function, or I'm cheating. And so on. Well, but it's important, cheats. Maybe you want to say something to everyone else about what kind of cheating we allow ourselves to do. So here what I would really say is for all epsilon, if epsilon is less than zero, then, blah. And of course, I don't have if then in my language, so I would actually say for all epsilon. Which, so I would actually say for all epsilon, either epsilon is less than or equal to zero, or this last next condition. Okay, similarly, I'd have to deal with the delta greater than zero that way. x minus two squared is really an abbreviation for x minus one. Let's see, I don't have minus in my language either, so we'd have to work again by expanding. Work again by expanding these things, you can sort of see how to relate how to get x minus 2 squared in the language. But all of these things can be expressed just using, so this would say, I would really write this as x times x plus 4, which is 1 plus 1 plus 1 plus 1, is less than delta plus x plus x. But again, we can sort of get anytime we have a polynomial equation or inequality, we can regularly write those out. We can always express those in language, so we do that here. There's a technical definition that distinguishes some types of formulas from others, and that's the notion of a sentence. So, a sentence is a formula where every variable is inside a quantifier. Is inside a quantifier. Okay, so in the first example, there are no quantifiers, so this x is not in a quantifier, so this is not a sentence. In the second formula, again, x is not inside the scope of a quantifier, so this is a formula but not a sentence. Here, all the variables are bound by these quantifiers, so this one is a sentence. This is not because x is free. Because X is free, isn't bound. And here, once again, this is a sentence. Everything is inside the scope of a quantifier. Say that three and five are sentences, the other two are not. What's the difference about a sentence? It's sort of easy. I'll say this on the next slide, but if you just look at it here, I mean, sentences are declarative statements. Every positive element is a square. Every positive element is a square. The limit as x approaches 2 of x squared is 4, where 2 is expressing a property of x. It's saying that x is a square, that x of x is 1 plus x, and it doesn't make sense to ask whether these are true or false until I give you an instantiation of x. What am I talking about? Why would this be true or false? So I say this on the next slide. Sentences are declarative statements. Next slide. Sentences are declarative statements. In any particular structure, they're either true or false. So the sentence that says there is an x for all y, x times y is x, is true in all of the structures I'm talking about. You just take x to be 1. The sentence that says that for all x there is a y, x times y is 1. Says that every element has a multiplicative inverse. Well, that's false in z, but true in the rationals, the reals, the complex numbers. Well, not quite. Pardon? Not quite. I mean, if x is zero. Oh, right. Oh, yeah. Sorry. It should be for all x, x not zero implies. Sorry, thank you, Tom. Yeah. I'll fix that on the slides. The sentence that says every x is a square will be false in z or the reals because in z 2 isn't a square and in neither is minus 1. And in neither is minus one is square, but it'd be true in the complex numbers. So sentences are declarative sentences that express a property of a structure. Okay, a theory is just a set of sentences. For example, I could take a, you know, one way to get a theory is just take an interesting set of axioms that you know. So I could take the axioms for fields or the axioms for Groups or the axioms for ordered rings, something like that. Now, I'm going to give you a bit of notation, and this is, as we'll see, this notation is overused, but unfortunately, this is how it is classically. If phi is a sentence, I write M double turnstile phi to say that phi is true in M or that M is a model of phi. If T is a set. If t is a set of sentences, we also write m models t to say that it's a model of every sentence in that set. Okay. So, as I said, one way to get a theory is to just take an interesting set of axioms that you care about. Another is take a structure you care about and look at all the sentences that are true in it. That's called the theory of that. That's called the theory of the structure. It tells you every first-order property, every first-order sentence, whether or not it's true or false in the structure. Of course, if I ask you, if I gave you something and asked you, is this one of the axioms for fields, you'd give me an easy yes or no answer about that. If I ask you, is something true about the complex numbers, that might be a priori a much harder question. So this is. So, this is what I'll call fundamental problem one. Given a structure, can we understand the theory in some way? So, here are two kinds of questions you might ask, since a lot of people here are interested in algorithms. I'll state this one first. Is there an algorithm which, when given an input phi, the algorithm will halt and give you a yes or no answer whether phi is true in the structure? If there If there is, we say that the theory is decidable, that there's an algorithm that decides this. A second question, and intimately related, is can we give a simple axiomatization of the theory? I've got a complicated structure, but maybe there's a way to give a simple set of axioms. In some cases, it might even be a finite set of axioms. Cases it might even be a finite set of axioms. In many cases we're interested in normally be an infinite set of axioms, but where it's easy to, if I give you something, it would be very easy for you to tell whether that was an axiom or not. If I had something simple like just the rationals with less than, I could actually axiomatize that just saying it's an ordering with no top or bottom element, and between any two elements there's another element. Okay, so what do I mean by anaximatization? I mean, just can I write down some easy set of sentences, something that we easily understand, and that that set of sentences completely describes the theory. Okay, namely, anything that's a model of the theory is also, anything that's a model of this set of axioms is also a model of the theory. If the last condition holds, this would say that any time I take an n that's a model of t. Take an n that's a model of t0, it would be a model of every sentence that's true in m, and it would model exactly the sentence that's true in m. And that's something we call being elementarily equivalent. I think I won't say those words anymore, so I'll just stop at that one. But this is saying, can you write down a set of sentences, a simple set of sentences, T0, that will completely tell you what the sentences are that are true of M? So that anything that models T0 models exactly the things that are true of M. Things that are true of. Okay, that's the first problem. For the second problem, I need to tell you what a definable set is. So I said before, if a formula has a free variable, then rather than being a declarative sentence that's either true or false about the structure, it's expressing some property of the free variable. There is a y, y squared equals x asserts that x is a square. Okay, yeah, so if I ask you whether or not this is true or false, I need to know what structure I'm working in, but also I need to know what x you want to know about. So in z or q, this is true for 9 and false for 3. In the reals, it's true for any positive number, but false for negative 3. In C, it's true for everything. Okay, so suppose I have a formula that has variables in it, and I has variables in it. And I write it this way just to emphasize that x1 up to xn are the free variables. Okay. And I take a structure m, what I can look at is the set of points a1 up to am in n-space where this formula is true. And this is what we call a definable set. Well, one more condition, but it's an example of a definable set. It's an example of a definable set. Namely, I'm taking a formula and looking at what tuples in the model, what vectors in the model satisfy this formula true. I want to allow a little bit more. So in fact, I want to take a formula with has more free variables than n, and I'm allowed to put in some elements from the model. And now I want to look at the elements a1 up to am and n, such that phi is true of a1 up to am with these. Of A1 up to AM with these fixed elements B1 up to BM as well. So then I say the set's definable using the parameters B1 up to BM. And I think for all of today, when I say definable, I'm usually going to mean definable with parameters. So for example, look at the set of reals that are greater than pi. Obviously, I can define this set using pi. I think it takes a little bit of work, but I mean, once you know something. Bit of work, but I mean, once you know some things, in fact, you could not define this without using pi. Just you just talking about the real field, you could not define this set. So, Dave, there were a couple of questions that were raised raised in the chat. First question that's raised is, how is this notion of definable sets different from affine variety? If, say, you're working in the structure C as a field? Okay, so it would include affine varieties. I'll say that in a minute, but it would also do things. That in a minute, but it would also do things. Oh, sorry, it would also include things like the projection of an affine variety, or it would include Boolean combinations of affine varieties. A priori, in principle, you could say things with several quantifiers about affine varieties. Ultimately, we'll see that it's just for the complex numbers. For the complex numbers, it's just a little bit beyond affine variety. But the quantifiers give you the potential to have a lot more structure. I mean, go back here. You see that for the reals, I mean, I'm allowed to do these quantifiers, which maybe allow me to discuss limits, which isn't a priori. I could do just talking about solutions to equations over the fields. The fields. So let me give you some examples. There was a second question, which is exactly about the slide about how is it that, what's the difference between a parameter and a variable? Okay, so a variable, so when I say a parameter, I'm fixing elements of the model. So here I'm allowing the x's to vary, the x1 up to xn to vary. Those I can do. Xn to vary. Those can now be anything in the model. When I define the set, the b1 up to bm are fixed. So for example, let's look at this example. I've got the formula phi xy, which says x is bigger than y. But now I'm taking the variable y and sticking in an element from the real field, pi. So I'm defining a subset of one space, just the elements in x that are bigger than pi. Okay, so let me give some examples of definable sets that are. So, as you say, in the complex numbers, an example of a definable set with parameters would be any algebraic variety. I just take formulas expressing finitely many polynomials and say that x vanishes at all those polynomials. This would be a description of a So, this would be a description of a simple description of a definable set. I want to give some examples and other structures where we're actually using the quantifiers. So, suppose I just look at the integers as a ring. The ordering is definable. So, I don't need to have the ordering as a separate symbol or a distinguished relation. It's already there. Namely, I can, by Lagrange's theorem, every non- Grange's theorem: every non-negative element is a sum of four squares. So x is less than or equal to y if and only if there are four elements, and x plus the square of those four elements is y. So again, you see something definable, but you need to know something about the structure to see this. The integers is definable in the complex numbers of exponentiation. Namely, it's the stabilizer, it's the multiplicative stabilizer. It's the multiplicative stabilizer of the kernel. This is an example, even without parameters, of defining the integers in the complex numbers. If I'm working in the reals or anything bigger than the reals, here's a property of definable sets that if a set's definable, so is its closure. Take a formula that defines x, then I can define its closure by saying that for all epsilon greater than zero, Saying that for all epsilon greater than zero, x is in the closure if and only if for any epsilon greater than zero, there's an element y such that phi of y, namely y is in x, and the distance from x to y is less than square root of epsilon. So the sum of the xi minus y squared is less than epsilon. Okay, so these two. Okay, so these three examples show that you're not just taking equations and inequalities, that in principle, looking at adding quantifiers gives you a great deal of expressive power, can give you a great deal of expressive power. Okay. A deeper example, and this is one of the beautiful early theorems in logic from the 50s of Julia Robinson's, is that the integers Julie Robinson's is that the integers is definable in Q as a field. This is a tricky result that I think more or less went 50 years before it really got improved on. More recent work of Punen and Koenigsman have gotten this down to better gotten it down to definitions I could fit on a slide, but it's still a tricky and difficult number theoretic result to show. Difficult number theoretic result to show this. Okay, so this leads me to my second fundamental problem. Can we understand the definable sets? Can we give some kind of simple description of them? And can we prove that definable sets have good properties? So I want to start with a bad example. So this is, oh, okay. So our two fundamental properties: trying to understand the theory, trying to understand the definable sets. Sets. So in some sense, the worst case is the one that at some level looks the simplest. But if I look at the integers z plus times, these problems are hopeless. And this goes back to Goethe's incompleteness theorem, that the theory of z is far from decidable. And you can give no, there's no simple decidable theory that I can use to try and axiomatize z. Use to try and axiomatize the, you know, I mean, at one point, you the thought was might be that sort of the basic piano axioms where you say some simple things about plus and times and say you can do induction will be enough to do theory of z. And in fact, it is enough to prove, you know, those axioms are good enough to do almost all elementary number, all elementary number theory. But Girdle showed that there'll always be things beyond that. Be things beyond that. So we're never going to have a good understanding of the theory of Z. To see how bad it can be, fix a coding of programs by integers. So pick your favorite programming language and think of some way of coding up the sets in this language so that if I tell you program seven, you'll know what you can figure out what program seven is, etc. And the results due to The results due to Madiasvich, finally building on earlier work of Julie Robinson, Martin Davis, and Hilary Putnam, is there's an integer polynomial, P of X, Y, and nine more variables, Z1 up to Z9. So that if I ask you, does program E halt on input I? It'll be if and only if there's a solution to this Diophantine equation. Now, Now, this tells me that if I could decide whether a Diophagian equation has a solution, I could decide whether a program halts on a given input. And this, of course, is Turing's example, first example of a thing that is undecidable, a thing that can't possibly be done by a computer program. So this tells me that, so this gives a negative answer to Hilbert's tenth problem. Hilbert asks, is there an algorithm which will decide? An algorithm which will decide whether a Diophantine equation has a solution. This says the answer to that is no. But it also says that the definable sets are going to be chaotic. The halting problem is the definable set. So the designable sets aren't going to have, there's not going to be any nice number theoretic or finite combinatoric description of what kind of sets are definable because you're going to get things like the halting problem and much, much worse. So for both of the fundamental problems, the answer here. Of the fundamental problems, the answer here is no, we don't, you know, there's you're in a hopeless situation. Okay, I want to talk about a good situation in a minute, but first I'm going to do a digression with, okay, sorry. So this is the lesson. Quantifiers lead to complexity. Or quantifiers can lead to complexity. Here, the existential quantifiers in this Diophantine equation are as bad as doing unbounded searches. As bad as doing unbounded searches in any kind of computer program you would want. And what we're going to look for places where our theory works well are theories where we can get rid of the quantifiers. So I'm going to begin with a digression to two of the basic theorems of logic. Okay. This is again horrible notation, but classic. For any L-theory, I'm going to write that. That t left double turnstile phi and say phi is a consequence of t to mean that anytime I have a model of t, I have a model of phi. Now this is a priori a quite complicated concept. You know, I'm asking questions about all the structures that are possibly models of T. So I'm asking, you know, and the structures, you know, if I'm And the structure, you know, if I'm if T were the axioms for groups, you know, they're groups of all cardinalities. I'm diacring things over a proper class of structures. And what Gödel's completeness tells you for is that this is that phi is a logical consequence of T, if and only if there's a finite proof. So the left-hand side is this semantic statement. It's about truth and structures. It's about truth and structures of all possible. It's about truth and structures of all possible sizes. It's definitely not a finitistic thing at all. But on the right, it's saying: well, there's going to be a finite string of symbols where you have to check whether each line of the proof is an axiom of t or if it follows from the others by a simple rule. So this is some kind of finite, easy-to-check thing. Deciding whether there is one might be hard, but check one given a purported proof, checking that it's a proof is easy, whereas this is a Of proof is easy, whereas this is a very semantic thing. And model theorists often downplay this, but I think this is one of the great intellectual contributions of logic. I mean, really, it's just a stunning theorem. There's a version of, there's a restatement of this. I say that a theory is satisfiable if it has some model. And a rephrasing of the completeness theorem says that a theory is satisfiable if and only if I can't. If and only if I can't prove a contradiction from it. So, certainly, if I could prove a contradiction, I couldn't find a model. On the other hand, if I can't find a model, then vacuously, every sentence is a logical consequence. So by Goethe's completeness theorem, every sentence is provable. That's a little weird, but it's true. Now, that has a simple consequence that is deceptively simple. Deceptively simple. So a theory is satisfiable if and only if every finite subset is satisfiable. And the proof is: well, if there was a proof of a contradiction from T, that proof is a finite thing. It only uses finitely many of the sentences in T. So if I can find a model of every finite subset, T is going to be consistent. And just to see how And just to see how, I mean, that's such a simple consequence. I'll just give you one application of it. It's already kind of interesting. I want to find a model of the theory of reals. So something that's where every sentence true in the reals is true in that model, but that contains an infinite element. This is like the beginning of non-standard analysis. And the way I do this is I'm going to add one symbol A to my language. My language. And the theory I'm going to write down says the theory of reals: plus A is bigger than 1, A is bigger than 2, A is bigger than 3, etc. Okay. And now I claim this is satisfiable. If it's satisfiable, there'll be a model. It'll be a model of the theory of the reals, and this element A will be bigger than every natural number. Why is it satisfiable? Well, by compactness, I just have to check the finite subsets. Have to check the finite subsets. If I take a finite subset, it only contains finitely many of these sentences, so there's a maximum assertion it makes that A is bigger than N. And now I can find the model of delta just by taking the reals and thinking of A as being n plus 1. For every different delta, I'm picking a different number, but that's fine. I've shown that each finite subset is satisfied. Shown that each finite subset is satisfiable. So, by compactness, the theorem is satisfiable. In fact, this ends up being very non-constructive, but it's a very powerful tool. You can go a long way and do a lot of interesting model theory without using many more powerful tools than the compactness theorem. Okay, so now I want to go back to, these are my digressions, I want to go back to. I want to go back to an example. What about the theory of the real numbers? I want to start by giving you some axioms that are true of the real numbers and that in the end are going to be sufficient. Okay, so these are going to be the axioms for what's called a real closed field. So, first, there are finally many axioms saying it's an ordered field. And now, what we all know. And now, what we all know is if I could say it was a complete ordered field, I would describe the reals up to isomorphism. But that's exactly what you can't do. My quantifiers only, like I should have stressed this earlier, my quantifiers only quantify over elements of the field, elements of the structure. They don't quantify I can't quantify over subsets of the structure. So I can't say for every subset of the structure, if it's bounded above, it has a least upper bound. If it's bounded above, it has a least upper bound. So, what I'm going to do is I'm going to take one consequence of completeness, namely the sign change property. That if I have a polynomial and I have a less than b, and f has different signs at a and b, then there's going to be a c between them where it's zero. Now, at first glance, you might say, well, this is quantifying over polynomials. I can't do that either. Over polynomials, I can't do that either. And you're right. But what I can do is I can express this by infinitely many statements, where phi n is basically going to say for any polynomial of degree d, as you can see, I can sort of quantify over polynomials of degree n by quantifying over the coefficients. I say for all a's zero up to a n, a is less than b, and this is sort of saying that, this is saying the polynomial of those coefficients changes sine at zero. Changes sign at zero. So there's going to be some place where that polynomial vanishes. So this is something that comes up constantly in the model of your fields. You can't quantify over polynomials in a single sentence, but you can quantify over polynomials of degree D in an infinite sequence of collection of sentences. Now, here's the theorem of Tarski's that says that ultimately, here we don't have to worry about. Says that ultimately, here we don't have to worry about quantifiers. That real closed fields has quantifier elimination. For any formula, there's going to be a formula without quantifiers, such that in any real closed field, these two formulas are equivalent. They're true of exactly the same elements. And we'll talk more about how you might prove these things Wednesday. Prove these things Wednesday, but for now we're just going to take this for a given. So it says that any definable set is definable by a formula without quantifiers. So what's, you know, if we want to see what the definable sets are, what are the quantifier pre-definable sets? Well, all you can say without quantifiers, again, using parameters, is you can say that a polynomial, some polynomial vanishes at x1 up to xn, or that some polynomial is positive at x1 up to xn. Is positive at x1 up to xn. So all we can do is take Boolean combinations of polynomial equations and inequalities, and this is something that's already well studied. I mean, these are the so-called semi-algebraic sets from real algebraic geometry. Semi-algebraic sets are exactly the sets you get by Boolean combinations of polynomial equations and inequalities. So, what kind of things does this tell us about definable sets? Well, this is one of what it tells us. Well, this is what it tells about semi-algebraic sets. The Tarski-Seidenberg theorem says that the image of a semi-algebraic set under a semi-algebraic function is semi-algebraic. Basically, if you think about it, taking the image is just putting in an existential quantifier, and quantifier elimination tells you you don't need that existential quantifier. In fact, this theorem is exactly a restatement of quantifier elimination. It says that if It says that if, for example, that I can't take a projection, if I take a projection of a semi-algebraic set, it's going to be semi-algebraic, which is exactly saying the quantifier I need to do that projection isn't really neat. Dave? There was a question raised, and I think I'll let the person who posted it pose it to you directly by voice. So, Alexei, would you like to raise your question? Sure. So you mentioned there is quantifier elimination, but in some prior slides you still keep using quantifiers. Why? Why don't you stop? Well, this next statement I made is exactly this reason. I'm going to say the closure of a semi-algebraic set is semi-algebraic. If I give you a definable set, I showed before how adding several quantifiers to it, you can define the closure. I mean, so that tells me that the closure of a semi-algebraic set is semi-algebraic because definable is exactly the same as semi-algebraic. On the other hand, if I just gave you a semi-algebraic formula and asked you to write down a semi-algebraic expression of the closure, this can get very complicated. I mean, there can be some kind of, I think even at that level, there can be some kind of exponential blow-up. Some kind of exponential blow-up in how long it takes to write down, take a simple formula and try to write down the closure of that simple formula. You know, the quantifiers give you a lot of expressive power. In the end, they can be eliminated, but there'll be some cost in that you'll get something that's fairly complicated in terms of length and size rather than complicated in terms of. Are you saying that quantifier introduction rather than quantifier elimination is also easy? I'm saying that quantifiers give you natural expressive power. There are things that are much easier to, they're much more natural to say with quantifiers, and something can uniformly be said with quantifiers. Thank you. Okay, so as I said, we showed before the closure of a We showed before the closure of a definable set is definable. Definable equals semi-algebraic, so this follows immediately. But again, as a practical matter, this is not necessarily an easy thing to actually try to do. We want to know what definable sets look like. So here I want to stress that I'm looking at the real line. Just what's a definable set in one space? Well, it's given by polynomial equation p of x equals zero. Polynomial equation p of x equals 0 and q of x greater than 0 and Boolean combinations like that. Well, p of x equals 0 just defines a finite set. q of x greater than 0 defines a finite set of intervals. Then I'm taking Boolean combinations of those. So all I'm going to end up getting is a finite union of points and intervals. In fact, I get something very simple. So, in particular, this tells me that I can't define the integers in reals, in the reals. Now, Now, a theme of modern model theory that I will just talk about for one slide is that o-minimality captures a great deal about definable sets. It gives us a lot of good geometric properties of the semi-algebraic sets. And let me just, so here I'm giving two theorems that you can either think of as being about semi-algebraic sets, but in fact, they're true at any time I have an omelet. They're true at any time I have an o-minimal structure of the real, so anytime this last condition is true. Let me, if I take a definable function, I can partition the reals in definable sets such that f is continuous on each of set in the partition. And in a general minimal theory, I can make this m times continuously differentiable. In a semi-algebraic set, I can go further and say analytic, real analytic. It also tells me that definables, even Me that definables, even though I'm only making a condition about definable sets in one space, it gives me tremendous information about definable sets in n space for all n. Namely, I can partition things into finitely many disjoint cells. In particular, cells have, in particular, only have finitely many connected components. And I've given you some high-tech images of cells in R2. So the graph of a definable continuous function, the area. Definable continuous function, the areas between the graphs of two definable continuous functions. And this is sort of what things look like. So you get these idea that you get simple pieces. Okay, what about the theory? So I've said something that quantifier emination leads to a very good theory of what definable sets look like here. A corollary to this is that the real cloud field axioms actually tell you everything about. Axioms actually tell you everything about the theory of the reals. So if K is any real closed field, everything that's true about the reals is true about K. So let Phoebe set any sentence. By quantifier elimination, it's going to be equivalent to a quantifier-free sentence, psi. So in any real closed field, whether phi is true, will be equivalent to whether the psi is true. And psi is a sentence without quantifiers. Sentence without quantifiers. Now, if you think about what sentences without quantifiers are, these are kind of trivial. I mean, here's one. I mean, basically, all I can do is take 0 and 1 and express some arithmetic properties of them. And I can easily check, well, and they're going to be true if and only if they're true in q, for example, or in the integers. So the reals is a model of psi if and only if q is a model of psi, if and only if my real closed field k is a model. If and only if my real closed field k is a model of psi. So by quantifier elimination, phi is true in the reals if and only if psi is true in the reals, if and only if psi is true in k because it's the simple quantifier free sentence, which is true if only if k is true in phi. So this says, you know, while the original definition of Of the theory of the reals, just say, look at everything that's true. In fact, you can give a simple description of it. It's the things that are axiomatized by the axioms of real closed fields. And now this gives me a proof of decidability. And I'm going to give you what I call logician's algorithm, which is an algorithm that is completely inefficient. Okay, let phi be any sentence. Either phi or, so I need an algorithm which, given phi, will tell me whether or not phi is true. Okay? I know that phi is either true or false at every real closed field. And by the completeness theorem, that tells me there's a proof from the axioms of real closed fields of either phi or of not phi. Now, what I'm going to do. Now, what I'm going to do, my algorithm is going to one by one generate all finite sequences of symbols. And one by one, and almost all of these are nonsense, but one by one, I'm going to check to see if it's a proof of phi or a proof of not fee. Checking whether it's a sequence, checking whether these are legitimate symbols and whether these symbols are a proof is easy. I just have to see if these are the right format. And then I have to see, well, if it looks like it might be a proof, I have to check whether each. Like it might be a proof. I have to check whether each line is either an axiom of real closed fields or follows from the previous axioms. And this is something that would be easy to check. And now, in this search, I know I'm going to find something. I'm either going to find a proof of phi or a proof of not phi, and then I'll be able to answer the question. This is what I call a logician's algorithm. It's based on doing this unbounded search. So there's no hint of efficiency in this. Now I'm I'm downplaying Tarski's. Well, okay, let me say this again. So let me finish this part. So this tells me also that there's an algorithm that transforms a formula into a equivalent quantifier-free formula. Namely, I just search for a proof. I search for a phi implies psi for some quantifier-free psi, and eventually I'll find one, and my algorithm will hold. Now, this is, in fact, not what Tarski did. In fact, not what Tarski did. Tarski actually gave an explicit algorithm that does quantifier limit. It's based on there's now this idea of cylindric decomposition, although it was a weak form of the cylindric decomposition. And this gives us a way of transforming things. And once I transform things, Things. I can start with this. I can, once I know that this could be done, once I have an algorithm to do this, I also get an algorithm to do the theory. Namely, I take a sentence, transform it to a quantifier-free sentence, and then it's easy to check whether that quantifier-free sentence is true. And this is actually what Tarski did. Now, his algorithm, I think, is his original argument is sort of stacks of exponentials. Stacks of exponentials complicated. And every quantifier you eliminate gives you a new level of exponential. I mean, there are better algorithms now, but I mean, you know, Fate's cruel trick is that the things that Tarski was able to prove were decidable are sort of the first types of things that complexity therapists were able to prove intractable. So I think even if you look at the theory of the real with just addition and less than, I mean, this is. Just addition and less than. I mean, this is known to be, I think, doubly exponential complex. So there's, I mean, you're always, you're not going to have extremely, you're not going to have efficient algorithms for doing any of these things. Okay, so in the last minute, I just want to give an and beyond part of this. I want to look instead of the reals with exponentiation. Now, we don't have quantifier elimination here. It was known early on that we did not have quantifier elimination here. That we did not have quantifier elimination here. But Wilkie proved the next best thing. Okay, so one way to state this is: take any definable set, there's an exponential algebraic variety. By exponential variety, I just mean you're allowed to take equations like this. So you can do the normal algebraic operations, but you're also allowed exponentiations, iterated exponentiations, et cetera. So this V is some kind of. So, this V is some kind of solution set to finitely many systems of equations. Every definable set is the projection of such a thing. So, this says I can get definable sets. I can't, I know that I can't do them quantifier-free definable in this language at least. But all I need is a string of existential quantifiers. I don't need universal quantifiers. I don't need negations. I can write them as this kind of positive exponent. them as this kind of positive exponential thing. This is already good enough by Ethereum of Zvonsky proved that any kind of exponential variety like this has finitely many connected components. And any definable set in the line then will be a projection of such a thing. So it'll have finitely many connected components. So it'll be a finite union of points and intervals. So this tells me that Rx was o minimal. So all this good Exposo minimal. So, all this good theory of definable sets that I have in that I have for semi-algebraic sets I have here. So, you might ask, what about the theory? Is this theory decidable? I mean, this is basically an open question. McIntyre, Wilkie, and Wilkie showed the answer is yes, but assuming results in transcendental number theory. I would say that. I would say that even deciding whether, finding a uniform way to decide if quantifier-free sentences is true is probably still would still be considered an open problem. Finding a good axiomatization for this theory is an open problem. McIntyre and Wilkie give one assuming Chanuel's conjecture, but it's incredibly complex. We know from general theory that there's an axiomatization that just uses for all their is for all there exists sentences. For all x1 to xn there is y1 to yn blah sentences. But these use quantifiers of arbitrary complexity. So this is an example where you can't get rid of quantifiers but you don't have quantifier emulation but you have quantifier simplification. You can get down to this sort of just existential quantifiers rather than. Okay so I think I'm out of time and we'll stop here. My program next time is I'm going to give you a general A general model theoretic test that in many of our cases will be good enough to give quantifier elimination in many of our cases without having to do something most of you will find wrong-headed. It'll give you a way of doing this without having to do it explicitly. So it will give you a general test for finding out when there is a quantifier elimination. Then the goal is to try and find it. You should try and find an efficient way of doing this. An efficient way of doing this, but okay, so I'll do that and then I'll start talking about what this means in differential fields. Okay, thank you very much. Okay, so uh, thanks, Dave. Uh, I suppose that we can we can all clap either with the actual hands or with the device here, just the clap. There have been a number of questions that were raised throughout the talk, but we have time now if people want to raise a few more questions. I think that's one question which came up. I think that's one question which came up, which was slightly discussed at the end here, was about o-minimality. So you had defined it earlier, and you've given us this corollary that Rx is o-minimal, but maybe you just want to remind people what that means and why that's important for Rx. So o-minimality means exactly this, that any time that I take a definable subset of the line. Know how to take a definable subset of the line. So, again, I'm restricting now to one variable. It's just a finite union of points and intervals. So, this is kind of this says that anything you can define in the line, I can define just using the ordering. I'm not using any of the others' structure. The remarkable thing, and this comes from a long series of work by von Andries, Knight, Pillay, Steinhorn, and others, is that the results of the Is that the results on this slide are true just under the assumption of o minimality? So, o-minimality, even though I'm just talking about saying that sets on the line, if they're definable, they're simple, they'll tell me that I have good structural properties of sets definable in n space for all n. Excuse me, good properties of definable functions. Can I interject something? Yes. Okay, I think. Yes. Okay, I think there was somebody called Alicia who was asking on the chat for a general definition, which means the underlying context here is of an arbitrary structure in some language with a distinguished dense linear ordering. And that's the general context, which I think that Alicia was asking for. I think. The general context is: I have a set M, I have a linear ordering relation less than on it, which let's assume is. Less than on it, which let's assume is dense, and I have extra structure, then any definable subset of one space over M is going to be a finite union of points and intervals with endpoints in the structure or plus or minus infinity. Thank you. Okay, yeah. All right, so I think that maybe we should wrap this up now so we can have a wrap this up now so we can have people can take a take a short break and we'll um we'll start up again in five minutes uh with our next tutorial are you are you on the is it is it the same zoom link yes it's the it's the same link for the whole week really for the talks for the talks for the talks yes gracias thank you hello hi right Hello, hi Rhine.