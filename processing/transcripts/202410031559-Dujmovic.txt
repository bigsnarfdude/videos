Okay, thank you. Thank you to the organizers for inviting me. Such a lovely conference. So this is joint work with usual suspects, at least in my case, Joan, Piotrek, Pat and David. So this is the last talk of the conference. So I asked Chad GPT to make a joke about being the last speaker in the conference. It's a little bit lame, the joke, but still I. Joe, but still, I hear says being the last speaker at the conference is kind of like being a dessert at a long dinner. By the time you arrive, everyone is already full, a little sleepy, and just hoping you're sweet and short. So let's hope I'm short and sweet. But given that I made like 15 slides, I hope it will not disappoint all of you. I'll try to stop nevertheless, no matter where I get. Okay, so the story. Okay, so the story I want to tell you starts with separators. So, what, or rather, balance separators. So, when I say separator, I always mean balance separator. So, what is a separator? It's a subset of vertices of a graph such that if you remove that set of vertices from the graphs, each connected component has a constant function of the vertices. I put here two, but that's not very important. Not very important, at least not for this talk. So that's what a separator is, and they have a tremendous number of applications in algorithms, combinatorics, and so on. They kind of became depicted in this as a tool. And probably the most famous or well-known result is the result by Lipton-Tarjan from 79 that says that every planar graph has a separator with most root end vertices that end here for me. Vertices that end here for me, n is always number of vertices in a graph. This was then generalized to all proper minor closed families in 19 by Alan, Seymour, and Thomas. It's also true for some non-minor close families like K-planar graphs, have separators of size through 10, and so on. So given how important these separators are, we would like to think about: can you say anything stronger? I'm being very vague here on purpose. So if you buy stronger, So if you by stronger, if you mean the size, can you improve the size of a separator? Let's say in case of lanar graphs, can you do better than root n? This is known, but you cannot say anything stronger. So what we mean by stronger is, so you can rip out these separators from a graph, but can you say something stronger about how these separators fit in a graph? Again, very vague. Okay, so. Okay, so what do I exactly mean by this? So, here's a question that I'm going to try to address in this talk. So, what is the simplest class of graphs H? Think of something super simple like trees. And we will see that it's not true for trees, but I'm trying to prove. So, what is the simplest class of graphs such that every planar graph, so mostly this talk, I will just talk about planar graphs, but what we obtain works out for bounded genus, apx minus 3, k planar. a px minor 3, k planar, and so on. So what is the simplest class of graphs, h, such that every planar graph is a subgraph of some graph in that simple family, strong product, a complete graph of root n vertices. Okay, so what is this? So let's see first what this looks like. You simply take a graph H and blow up every vertex by root 10 verts. So let me be So let me be a little bit more specific. So here a B blow-up of a graph is simply of graph H. It's H times strong product of complete graph on B vertices. So that graph simply you obtain that B blow up, in this case phi blow up, by replacing each vertex by V vertices and then, or rather not V vertices, K B, complete graph on V vertices, and graph of the vertices and between them every node of h you put this complete join. Okay, so that's what's a block of h is. So what we are asking here is what is the simplest graph family of graphs such that every planar graph is a blow-up of H, root n blow-up of H. Okay? Alright, so here's the immediate thing. You immediately get from the separator theorem that every planar graph is a subgraph of H times complete graph on root n vertices, where h is the closure of some tree of height log n. In fact, if you allow in that separator, definition of separators, components of size two-thirds, you can have here binary tree. Binary tree. Okay, so it's very simple. So, first of all, what is the closure of a tree? What is the closure of a tree? You take any tree, and then from each vertex that's not a root, you connect it by edges to all its ancestors. And then a very easy, recursive procedure gives you this. You rip out your separator size of the plane, you put it in your vertex, and then you repeat in the components. Okay, so you get that every graph is an enclosure of such a tree. Such a tree. Okay, but that actually this log n can be proved to log log n. That's already not immediate. That is a result by Stenek and David Wood, and they prove that that is true if you take trees of height or log log n. Okay? All right, but in this, when we're looking, I'm really looking for the simplest possible graph H. And in this case, we have disclosures of trees of high. Closures of trees of height, log log n, such graphs h will even have clicks of size log log n. And in fact, we quantitatively lose something, if you're saying, with this in comparison to separators. Because by the result of Zdenek and Sergei, we know that if a graph has, every subgraph of a graph has a constant size separator or separation, in this case, In this case, but then the triviator of the graph is at most 15 times that super H. In this previous example, you lose that because this graph H has 3-width log n, and then you multiply it by the square roots that you have in a blow-up. So, somehow you lose something. You're really not strengthening in a sense that we want. Okay, so what is it that we actually want? So, here's the So here's the easy fact. So if a graph G is a subgraph of a blow-up or rather subgraph of H, strong product, concrete graph on B vertices, then the three-width of H, there are some constants here that I deleted. So there's a star, there's minus one, minus one all over the place. So forget that. But the three-width, so if the three-wheel of this graph H is at most the three with the graph G is at most three bit of graph H times the number Graph H times the number of vertices in the meat. That's really immediate. Plus, some minuses and pluses. So, in that sense, if we have here a tree with a constant and v is a root 10, we are not losing anything. We are really somehow strengthening the statement about separators. Okay, so what we want is we want, when we say we want some super simple class of graph H. Simple class of graph H, we want first of all that it has absolutely constant tree width, which was not the case with that log-log n closure of a tree. Okay, and we actually proved that in 2022, long list of orchestras. I'm not going to, these are the last names about nine orchers. Somebody already listed them. I think David, when he gave an open problem on the first day, he actually listed all his names. So sorry, I would have. Stop story, I will fail. So that's why I'm afraid to start listing them. So what we proves there that indeed the statement is true with three with, at least for planar graphs, with three with h, three with two graphs. So there are three with, for every planar graph, there is a three with two graph, such that that planar graph is a subgraph of that H blown up by root N. By root n things. And that is a quantitative strengthening of separator theorem. Okay, and that's also true in that same paper. In fact, this was a merger of a couple of papers. So in that same paper, we get 3D2 for bounded genus graphs. For graph which glue, KST is a minor. And for all proper minor clause families, the statement is still true, but you replace 2 by 4. Okay, so all of these statements are kind of, in a sense, strengthening of the separator theorems. Okay, so we know that, so let's go back, just talk about planar graphs so I don't get broken down in too many graph classes. So we know that this is true for tribute two. What about tribute one? Is it true that every plane of a graph is a subgraph of a global some tree? A subgraph of a global some tree. So that is not only not true. So this conference is title is structure and coloring. So this is going to be my only coloring dimension of the coloring. So if you have a blow-up, if you have a subgraph of a blow-up of a tree, then you can colour that implies immediately, because when you can colour a tree with two colours, it implies that you can colour the graph with two colours, such that each component has at most true ten vertices. Has at most true 10 vertices. So even that's much stronger or much weaker thing, it's not true. Namely, you cannot, there are planar graphs that you cannot color with two colors such that each connected component has at most rotent vertices. And the example was proved by Linia, Matusek, Sheffett, and Targos in 2008. And they actually showed that there is always There is always there are planar graphs. If you took our monochromatic component, there is a monochromatic component with at least n to the two-thirds vertices. So trees are not possible. Okay, so in fact, they even looked at the upper bound and they showed that there is a two colouring that such that each monochronatic component is entered to two-thirds, so it's basically tied to descend to two-thirds, but their proof. To two-thirds, but their proof gives actually star partitions. So if you allow to relax, if you want to relax n to the one-half, but then again, you're not going to separate it. But still, if you want to relax n to the one-half, then you can even get a star partition. So every planar graph is a subgraph of a star where you hold the sub at n to the two-thirds. So they have that proof in their paper, but that was actually already in the original paper by Lipton and Tarjan. They had this. And they had this that planar graphs have this type of partition where if you pick here one-third, you get that result. So, okay, so threes don't work. So, three-wheel to two is best possible result for this. And of course, root n is also best possible. So, in terms of three-width, we have the best possible result, but we still don't know, again, still the question: what is the simple possible? Still, the question: what is the simple possible class of graphs? Let's say simpler than trivia tool graphs. So, here's a question David posed on the first day. And this question with the little asterisks is still open, but without asterisks, it's still open. Asterisks being logs. Okay, so if you want logs, that's what we're going to show you today. If you don't allow me logs in the blow-up, this is open. So, it's asked: does there exist a constant C? Does there exist a constant C such that every plan of graph is a subgraph of a blow-up of a graph H that has constant path width, some absolute constant times root n. So we don't know the answer to that question. What we do know, oh yes. Well, yeah, so back what we do now, erase what I said, but we do know. Let's think of Do not. Let's think of what is the simplest graph you can think of that has absolute constant path. Probably you would say a path. And we know that the answer is no for the path. We cannot have the statement here which says path because we cannot have it for a triple. So what would be the next simplest class of graph of bounded pathway? If it's not a path, maybe you would say a fan. You would say a fan. So it's a part, but just one dominating reference. This graph has parted 2 and I guess it's much simpler than some general graphs of path 2. So is this statement true for a fan? So we answer kind of, we answer this question. So here's the question. So kind of the simplest graph we can think of for which the statement is true. Think of, for which the statement is true, does every planar graph, a subgraph of a fan, blown up by root n? And we answer this with asterisks, with a star. And a real meaning, in the big O notation, you put a star when you're hiding the logs. So we answer this with yes, if you allow me here, log squared then. Here, log squared n. Okay? And otherwise, we don't even know it for any cartridge graphs. Okay, so how do we, I'll give you a little sketch of how we do this. So this is an actual result that we proved. So we have root n times log n squared. And this modulo, if you ignore this log n, this would be, this blow-up is tight even for bounds. Blow-up is tight even for bounded, even for binary trees. You cannot include this and stick it on a fan, embed it on a blower of a fan. All right. And the same statement is true for all the graphs for which product structure holds. In fact, we proved the result using the product structure. Boundary gene is apex minor for k planar. So we didn't have a proof for kt minor. So we didn't have a proof for KT minor free graphs, but once we had a proof for product structure, Disto, who I think is David's student, still, proved the for KT minor free graphs using heavily this product structure thing that we did. So now we know this statement is true for all proper minor cost families. Alright, so how would you solve a problem like this? So your graph has to fit somehow in a Somehow, in a blown-up fan, it looks like that. And each of these blow-ups has roughly root n vertices times some logs. That means that your graph has a root n times log square n vertices such that when you remove them, the rest of the graph has a path partition. It's a subgraph of blown up path. Okay. Okay, so what do these graphs look like? So this is very restrictive in a sense. So if your graph is a subgraph of a blow-up of a path, say you have B vertices in each, that immediately implies that this whole thing has bandwidth at most 2B minus 1. Because if you pick any vertex, you pick any ordering in this wall number. In these blown up pieces, an edge can go only 2B away. So if you are in a B blow-up of a graph, your bandwidth is at most 2B minus 1. And the other way around is also true. If you have a bandwidth B, then you just take the first B verses, put them in a globe, next B versus, put them in a globe, you get that graph that has band, we have multi-subgraphs. Bandwidth of mostly subgraphs of a V block of a path. So basically, being in a block of a path is the same as bandwidth of the size of the vertices in that block. Okay, so this basically almost all of the, so that means that almost all of the graphs is here in our proof. So let's see what are the necessary conditions for your graph to fit into something like this. For your graph to fit into something like this. Where you have a path and you have root and blow up for the path. So I'm putting B here, but that's in our case roughly root n. So if you pick any vertex here and you'll say, ah, let me see how far I can get with the parts of length r, I can only get to two bits. To 2b times R vertices. Probably this B here where I was born. So that kind of defines naturally R balls around any vertex is basically all the vertices that you can reach with the paths of length at most R. And if you fit in a graph like this, that means that your reach is roughly 2 times B times R plus B vertical. 2 times B times R plus B vertices where you see each crease. And it motivates the notion of local density that has been introduced before, which is basically you take your, for every R, you take these balls, you divide it by R, there's a pesky minus one, ignore that, and it gets, if you do that here, 2B times R divided by R, and B divided by R, you can ignore that. So you get. You can ignore that. So you get that roughly local density of graphs that fit here is roughly a function of b. So the graph that fits in a blow-up of pieces root n has local density root 10. Okay, so this is unnecessary condition. So what we have to do here is we have to remove the vertices such that we get local density root n. Local density, root n intermediate of the graph. Okay, so notice that even stars don't have bounded root, bounded, bounded density, local density. Okay, so we go down to bounded local density, and then you hope, okay, that's a necessary condition. Bounded local density is necessary, or root and local density in our case is a necessary condition. But in general, if you have a bounded local density, you can ask, but you're not going for bounded density. You can ask, but you're not going for bounded local density, I need bandwidth. Does that imply that your bandwidth is bounded? So, does local density B imply that your bandwidth is some function of B? Well, it turns out that's false even for trees. So, there exist trees, by result of Shvatalova from the 80s, there exist trees with local density at most three and bandwidth at least long. Log n. So, this necessary condition is not sufficient to get bounded bandwidth. In fact, even trees of part width 2 that have low condensity 9, they also don't have bounded bandwidth. It's low again or login by result from by Chang and Siemens from 89. All right, but still. But still, somehow here we have logs, and we're still hoping, you know, we are shooting for root n. Somehow you can hide maybe logs under the root n or for something. If we go down to local density root 10, the hope is that we can still get a bandwidth roughly root 10. So the goal, so the whole idea plan to solve this is to first Is to first sparsify the graph. So you chop out the vertices that are bad. For example, in a star, you will definitely chop the root of the star. You remove the vertices of your graph such that you bring down, in the rest of the graph, that you bring down the local density to roughly root n times whatever algorithm is. Okay? And then we want to show that once you remove, and that you, of course, don't. You remove, and that you of course don't chop up many of them still, log n-time polylog. And once you remove these vertices, you want to then show that now you have local density root n polylog, that in that case, that you have boundary bandwidth. Okay, so the first step is how do you sparsify the graphs? How do you make local density go down to root 10? Remember, even To root n, remember, even a complete binary tree has local density n over log n. So this is kind of the main technical thing that I will mention in the talk. And it shows you that how do you achieve your desired local density? So if your desired density Local density. So if your desired local density is D, in our case, that's going to be root n polywolf. If your desired local density is D, and if you are any T Baker graph, so by T Baker graph you mean graphs where you have a layering such that each layer has three with at most T, and if you take any K consecutive layers, then you have three with at most K times T. Planner graphs have this, honogenous graph has this, and so on. So here's your desired local density. So, here's your desired local density. Here's your Baker, your T-Baker graph. We showed that you can remove a set of vertices such that the remainder of the graph has your desired density. And the amount of vertices that you remove is your trimmed of one layer times n log n divided by your desired density. So this is root n and this is a constant. You get root n log n, for example. Lotel log n, for example. So that's the main tool. Well, so step one. That's the main tool for step one. And this one is actually simple and maybe it's going to be useful for something else. So I'll briefly show you how. That's going to be the only technical proof that I'll try to show you. And then I'm going to the really hairy stuff, I'm going to completely skip the step two. Okay. Step two. Okay, so in our case, we're going to pick D actually to be root n over log n, and then we get n log squared n. That's not important. So here's a little tool that we actually so far ended up using in several papers, and that's that if you have a graph of boundary tree width and you want to somehow chop out some bags such that each connected component has n over p. So you have some. Over P, so you have some P is your integer. If you want each component to have N over P vertices, P could be root N, for example, that then you can find P bags such that if you rip out all of these P bags, so you remove P times T vertices, each connected component has at most n of a P vertices. So that's a little tool that we're going to use. Okay, so how do you sparsify this graph? Sparsify this graph. The thing with sparsification is that it has to be true for every little place. You may have a little dense part of the graph and you don't want to miss it. So in fact, the proof is quite simple. You use kind of usual tricks of if you need to look at every small enough and big enough pieces. So what we do, think of it as dividing the graph into pieces in rounds. And these pieces will be. And these pieces will be disjoint. In round one, we're going to take a graph induced by first two layers, next two layers, next two layers, and so on. These will be your graphs. Okay, so graph G1, G2, so on to the end. In round two, we're going to double how many layers we take. We're going to take four layers, graphing used by first four layers, next four layers, next four layers, so on. Round three, first eight, and so on. First eight, and so on. So, in ith round, we're going to take two to the i, graphs and use by two to the i table. So, let's focus on, let's say, here, round two. That's what I'm showing. You have these graphs there. Okay, and now somebody shows you a ball. It says I pick a vertex here and take a ball of radius r. Then you determine, first of all, you determine that you determine that so your r is between 2 to the i minus 1 and 2 to the i. And just for simplicity, imagine r is 2 to the i. So if your r is 2 to the i, I'm going to look at ith round. So your r is 2 to the i, and I'm going to look at ith round, and I'm going to look, okay, here's this vertex i. It lives in this graph of i-th round. Of ith round, and maybe it can intersect the one before and one after, and that's all. So that's the ball that we have. So what you want, by the definition of this ball, this ball lives in some component G prime. So this picture here should say G prime. So if I can bound the size of that component by 2 to the i times d. 2 to the i times d, because r is 2 to the i, I replace this by r, I get what I want. So the goal really, this was probably a bit too fast, the goal really is to chop each of these graphs in each round, to chalk them using that little tool that we have seen, such that each connected component has at most two to the other times the vertices. I'm a little bit behind, but we managed to do that using this simple tool that I mentioned. Remember, the tool was saying that you can remove vertices such that each component, remember these, we are taking these two to the eye layers, therefore the three that is two to the eye. So we can apply this lemma and we get that each component. And we get that each component, what we want, has at most d times 2 to the i vertices. So we apply this lemma to each of these graphs that we created. And when you add things up, and I'm not going to go into this because I have only one more minute, it gives you that lemma that you wanted. Okay, so this we obtain the first step we The first step, we sparsify the graph by removing. If you plug in, if you choose root and a log n, we get exactly what we want. So you remove those vertices and you get a graph that has local density, root n over log n actually. But now you have to show that the bandwidth is at most root n. Well, it turns out Well, it turns out that for planar graph, so we have a local density that we want, and we want the rest of it to have bandwidth like that. Well, it turns out that somebody did it for us. In 99, Rao actually proved that every planar graph G has bandwidth. Can I have two more minutes? Every planar graph has bandwidth at most the local density time log to the 3n. To the 3n. And when you plug in that we chose the density root n over log n, you get the result. But his technique really works only for planar graphs, but there is a more general result. But with these extra root n log n times log log n, actually for the T baker graph, we immediately get it if you're willing to live with this. But you just gave me perfect in a previous. Just gave me perfect. In a previous talk, you said, Oh, there's a big gap, and the gap was logo again, so thank you. So, for the giving me an excuse why we now have 20 pages to actually prove that, but we go to what we proved, there was a bit of a lie. But think of it this: to prove, imagine that we are proving actually Rao's statement, but now not from so with really with log to the 3n, so local density time log to the 3n. Time logged in the 3N, but now not with planar graphs, but actually with products. But in fact, that's why we actually couldn't prove it. And that little specification allowed us to prove something that is good enough. We had to change them. So basically, it's using these volume-preserving equilibrium contractions. We had to come up with our own metric on the graph, and we could only do this metric if we are using product structure with our own specific cuts that we did. Specific cuts that we did for sparsification. Anyways, I'm skipping all that. So the result is, as I already mentioned, global fan by root n times log squared n, and we can achieve that together with these total results for all proper minor clause families. I think the idea is that we merge these results into one paper. And here are the open problems. I think David mentioned both of them. One is the Of them. One is to get rid of polylog, or if you cannot get rid of polylog, just prove it for bounded path with graphs, the same statement. And the other one is, actually, this is the one that David asked, what can you say about graphs that all you know is that they have sublinear separators, so separator of size n to the one minus epsilon. Can you prove that such graphs are in a blow-up of bounded tree-width graphs? Of bounded tree with graphs where each log is n to the one epsilon, and n to the one minus epsilon. Okay, thank you. Maybe start with a question. So, you asked this result where you have the extra vector of log to the 3n. Is it known whether you could put that or? Oh, yes, yes. I think if you Yes, yes. I think if you are going to go via this local specification, getting down to local specification, what was the word? Local specification called a local density route, I think it would be very difficult to get rid of the logs. First of all, to bring down the local density to anything reasonable, we needed logs. And then, once you have that local density in the rouse results, Audacity in Drows results, you have this 1 to the 3N depth standing now since 20-30 years. So I don't know if there's a proof that there is a proof that it's confidential or about. So it would have to be something different, I think. Yeah? So if you were to enforce some connectivity condition of the plants for the no, I don't think we can enforce any connectivity condition. Force any connectivity in the bag. No. It's not a minor, I don't think. I mean, there's the no, in the blow-up, you mean what we chop off that it's connected in a uh no, I was wondering for the graph H. So it does about a 3D composition, and then so in general, for boundary 3D compositions, you can pay a bit for some convectivity condition in the bags. But I think if you pay. But I think it's not. You mean if we pay if we can if we pay a bit, can we enforce that each uh each blob is uh connected? Yeah. I know it's an unfair question. I don't know. No, we definitely don't get it for a fan. We definitely don't. But whether you can now play with it and throw things out and still be on the tree with at least yeah, I know that was a mean question. No, no, no. The degree of the fun is severe and which are examples that you I don't have a dominating vertex what happens I somehow doubt it but I cannot give you counterexamples on top of my head because if you some the degree double it like you would like maybe I can Yo, I see like you would like maybe I can fold it such that the the the fan has root end degree. But you put it on the wait wait wait wait you're you're completely right. You're completely right. I forgot. This is actually universal. Not only that you get this partition, but this partition is universal. You're not guessing what is the graph. It's not, there is a graph H from this family. So you really can fill it up. So if your A doesn't have root and words, you can just throw in some. If your first bag throwing some if your first bag doesn't have enough verses you just throw in some so yes you actually your fan has root and your fan has root 10 notes yes it's universal yes yes yes we have universality results I didn't get there but it has n to the three halves edges it's not interesting but it's hiding it in in an edge it's hiding it in an edge It's hiding it in an edge. Yes, yes, root n. Yes. Yes, and this gives a universal kind of. You get some universal graphs and even some things about crossings, but I didn't think they were interesting enough even for a paper, let alone for a talk. What age connected the RCAN. If it's age of 10, you have some sort of connectivity. No, I think the question was about the connectivity. Can you ensure that actually each blob, let me find the picture, that what you put here induces connected graphs. Did I understand your question correctly? So if you take every node you throw in your vertices there, is this a con of your graph G, is this a connected graph? In that case, this would also be a minor of your graphs. But we don't ensure that. Or even though it has like loaded alternatives. Has like loaded answers in the entire graph. Yeah. I don't know if it's a sun. I don't know. Even, yeah. I was even thinking about your weak diameter. Do we preserve any of that? But yeah, I don't know. I was not thinking because it was a specific application. What about just three non-files coming out of a hood? I don't know how you do that to keep all the mixed together. Yeah. Maybe to be there, I think the open light source of the map. 