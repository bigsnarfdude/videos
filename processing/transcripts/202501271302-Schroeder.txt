The title of this talk again is Markham Numbers and Cluster Algebras. And the main goal we're going to have for this is really to give a kind of a crash course on cluster algebras. And then we'll use what we learned there to motivate a study of E of these Markov numbers. So, first of all, the main idea is that a cluster algebra Is going to be a subalgebra of the field of rational functions. And that'll be on end. And that'll be on n variables. Okay, so standard kind of thing. The thing that's going to make a difference is that we're going to derive the generators of this algebra combinatorially. And the thing we're going to use to generate these generators is called mutation. Alright, so these things were first introduced in 2002, I believe, by phone. 2002, I believe, by Foman and Zelovinsky. They originally used them to study like lead theory and canonical bases and stuff like that. And since then, they've been found to, I mean, have applications to just about everything, it seems like, when you look at the literature. And in particular, we'll see an application to our Markov numbers. So unfortunately, this talk, I kinda need to start with a million definitions, so bear with me. Definitions, so bear with me. We'll get into some examples immediately after. So, first, I want to define a quiver. I should say sometimes I tend to write a little too small, so if I need to write bigger, just feel free to let me know. So, a quiver Q is a pair Q0, Q1. Where Q0 is a finite set of vertices and Q1 is a finite set of arrows between vertices. Vertices. So, in other words, a quiver is just a directed graph. We call it a quiver because it's a collection of arrows, and historically, with quivers, we tend to care more about the arrows. So, an example could just have three arrows, or three vertices, rather, and maybe Put some arrows between them. So this is a fine quiver. So our quiver is going to be a part of a seed, which encodes information about our generators that, again, we're going to derive. That again, we're going to derive later on. So, a seed is a triple call them sigma a lot of times of x, y, and q, where x is an n-tuple. Is an M-tuple and this is called a cluster and the XIs Are called cluster variables so y is also an n-tuple. Of things called coefficients. So these things can belong to any semi-field, but for our talk, we're kind of not going to worry about them. And Q is a quiver with N vertices and no loops or two cycles. And no loops or two cycles. And x is an n equal of what? So these are just algebraically independent elements in your field of rational functions. So in particular, these can literally be the variables Literally be the variables x1 through xn that generate that. Are you going to be working over like C works? For this, we're going to be working over, but we're going to be working over Q, basically, is going to be our ground field. That can be changed if you have some complicated semi-field in here, but for our talk today, it's just going to be. Our talk today, it's just going to be Q algebra. So X's are algebraically independent restricted functions. Yes, right, yep. And loops are just one cycle? Yes, exactly. A loop look like this, and a two cycle looks like this. Yeah, so and we're going to end up not wanting any of those because when we define mutation, those are going to kind of mess us up with that stuff. All right. So, and as I said, I should write it down for today. We let our coefficients be all one. So our seed really is just defined by the double x and q. So some very interesting things can happen, I should say, when y is allowed to be more complicated, including things that are interesting in terms of like Diophantine equations and Markov numbers. But today I figure I'll just go with the basics and not get too deep into the weeds with that. So, now let me talk about mutation. So, for any seed Seed and any number k corresponding to one of the n vertices or one of the xi's, we can define the mutation at k As follows usually written mu k sigma. Okay. So for our cluster variables I guess I should say mu k sigma equals the pair mu k x, mu k q, and mu k xi, which a lot of times I'll just call xi prime for brevity, as two cases. So So it doesn't change at all if i is equal to k. And if i is not equal to k, it mutates to something different depending on what the quiver looks like. So we get this exchange relation, 1 over x k times the product over all arrows going into k. Multiply in those cluster variables for the arrows coming NQK, and then we add the similar product for all variables going out of K. Particle rational function. Yes, correct. That's That's for i. Oops, it's equal to k. This should have been not equal, I apologize, but yeah. For i equals k, we get something different, namely this, and with i not equal to k, it stays the same. So mutation just mutates exactly one cluster variable. And now for the quiver. What's that? Yeah. Then it doesn't. Yeah, yeah. And multiple edges are okay, I guess. Yeah, mm-hmm. Yeah, as long as that multiple edge is in a two-cycle. Oh, so you can have powers when you have size that you have a long way? Yep. Yes. Yeah. Yes. Yeah. We'll see an example of that in just a moment. But first, I want to define the mutation on the quiver. So with that, we kind of follow an algorithm. So mu k of q is obtained by following the following steps. So first For any path with K in the center of it, so directed path with K in the center, we add an arrow directly from I to J, the start of that path, to the end of the path. So, when you say a path here, there can be many curticies between I and J and K and J? No, like literally, like I. Literally like this. So you have a vertex i arrow directly to k and then an arrow directly to j. Yes. Good? We have a lot of multiple edges from the same source and destination? Yes, exactly. So we could have like something like that, and that would be completely fine. Thanks. Yep. So if you have a multiple edge menu So if you have a multiple edge, then you've got transition formula for the variables themselves in the product loss multiplicity. Yeah, yeah, you have multiplicity in there. So like, yeah, if we have something that looks like this, maybe there's two arrows here and three arrows there, and we mutated this vertex, this will tell us that we'll add six arrows. Add six arrows from the start to the end. That's the first step. The next step is we reverse all arrows incident to K. And finally, we delete any two cycles created. And two cycles are always going to be, if they are created, created by the first step. So that's what we do. That's what we do. And one note is that mutation is an involution, which is kind of what we would want and expect since we call it mutation. So mutation is an involution that is that mu k. That is that mu k squared of sigma is just your original seed. So this stuff is easiest to see like with an example, so let's do one. So let's take the seed sigma is our pair x and q, where x is our standard x. is our standard x1, x2, x3, and q is this quiver with three vertices and six arrows it'll end up being, so I say there are two arrows going from one to two, three arrows going from two to three, and one arrow going from one to three, or from three to one rather. And let's compute mutation at vertex 2 on this. So x2 prime, so since we're mutating at vertex 2, x1 and x3 will stay the same. x2 prime, we get a 1 over x2 times we have two arrows coming in, and they're both coming from arrows coming in and they're both coming from x1 so we get x1 squared plus three arrows going out and they're all going to x3 so we get x3q and so our new seed is going to be x1 x1 squared plus x3 cubed over x2 and x3 And now for our new quiver. So we really have six paths from one to three going through two in the center. So that means we'll need to add six arrows from one to three. I'll write this one in and six new arrows. And then we need to reverse all the arrows incident to two. That looks like that. And now we need to get rid of any two cycles. So I'll just take one arrow out of this group of six and cancel it with this arrow going the other direction. And so our new quiver ends up looking like that. Yes? When you canceled the two arrows, how did you know what? Canceled the two arrows, how did you know which? Anyone, yeah. Basically, just we have one arrow going the other direction, so you know, we just yeah. All right, so just to continue with this, let's mutate a 3. So if we looked at x3 prime now. 3' now. Now we need to use this new seed. So with that one, we have 1 over x3. And we have 5 arrows coming in, and they're all coming from 1. So we get x1 to the 5. Plus 3 arrows going out, and they're all going to 2. So we have now x2 prime to the power 3. 3. And so when we expand this all out, it becomes a little complicated. I have written down here that it comes to be x1 to the power 5, x2 to the power 3, plus the quantity x1 squared plus x3 cubed, all cubed, divided by x2 cubed. X2 cubed X3 and I are mu3 mu2q is going to look like this. So the arrows at three reverse, we have five here and three here, and we get 15 new arrows from one to Get 15 new arrows from 1 to 2. So 2 of those will cancel out, and we end up with just 13 arrows from 1 to 2. Alright. So I guess we can see here that in general, this kind of gets out of hand pretty quickly, which is going to make the definition of a cluster algebra feel kind of ugly, but there's going to be some nice results that. But there's going to be some nice results that simplify things for us a little bit. So, the main definition of a cluster algebra associated to a seed So we usually denote them by this curly 8 is the algebra generated by all cluster variables Obtainable from our initial seed via a finite sequence of mutations. So, yeah, this is what we're doing here. We're starting with a subset of our generators and we're performing mutation with the data of the quivers in order to get all of our generators. Not really all. Usually there are infinitely many generators, but that's what we do. So, in other words, this cluster algebra is going to be generated by x1. is going to be generated by x1, x2, x3, this x2 prime, this x3 prime, and an infinite amount of other things. Question? Yes. Is there a certain way of looking at cutoffs? Like here you're saying any finite sequence, but is there a way if you said at most k mutations? No, so when I say finite, it's basically just so that we don't think about like taking limits or anything. Think about taking limits or anything like that. But it's not like you could stratify this going up by all things at distance one, all things at distance two, three. That probably makes sense as a thing to think about. I personally haven't, but yeah, that's probably something that one could think about and could potentially tell me something. There are kind of two questions in this question. You can look at just the quiver. Look at just the quiver and see you're looking at mutations, and maybe there are two ways to get to the same quivers. And now you get to like the graph of quivers, the mutation graph of quivers. But then if you want also the variables to be to get by two parts to the same variables, I think that's much more true. Yeah. Yeah, and that's a good point to bring up because in cluster algebras we've got concepts of cluster finite things and Finite things and mutation finite things. So one is a subclass of the other. There are things with only finitely many cluster variables, which there aren't really very many of them. But then there are things that only have a finite number of not isomorphic quivers you can get through mutation. But those in general are going to have infinite cluster variables. You know, the quivers encode some information, but the stuff happening to the cluster variables changes somewhat. Cluster of variables changes so much that there's more information convening. All right. So I guess one thing I should say too is one way that we can look at the clusters that we get is through the cluster pattern, and this is just through the regular tree. And of course, this we can okay like break off in many ways and get a bunch of other clusters that way, cluster variables. And in general, this is going to be an infinite tree. In some cases, it's a finite thing, which is also an interesting. Thing which is also an interesting question, but yeah, this is the cluster pattern. So is it known that it's tree in the middle? No, in fact, it's not always tree. I think it's safe to say it's almost always a tree. But for a finite type thing where you only have finitely many cluster variables, certainly there's going to be some loops going around there because. Going around there because if it was an infinite thing, you'd have infinitely many cluster units. Yes? Why should I multiply or add different clusters? Basically, to be able to call it an algebra. That's the silly answer. Because these things, yeah, they were invented, I guess, to understand Lie algebra. Understand Lie theory and canonical bases and stuff. And so it's nice to just have all that structure in there so that one can say as much as possible. They already satisfy some relations, right? Like x2 times x2 prime is the sum of x, you know, in this example, x1 plus x3 times. Yeah, yeah, exactly. Like the the structure isn't arbitrary, basically. Basically, so since I maybe what I'll do is I would like to do one more mutation of this example over here, but maybe we can see all. Maybe we can see already that it's going to be something hideous. So let's mutate that 2 again. So here, x1 will remain the same. And then in the interest of time, maybe I'll just tell you what x2 comes out to be. x2 comes out to be, comes out to be this thing, x1 to the 13, x2 to the 9, x3 to the 3, plus x1 to the 5, x2 cubed, plus x1 squared plus x3 cubed, then all this cubed divided by x1 squared plus x3 cubed. plus x3 cubed, x2 to the 8, x3 cubed, and then x3 prime. So this is the new thing we get at x2 just by, you know, after three mutations. And if you're anything like me, when you like, first of all, compute this, but then write it up, you get this horrible sinking feeling that all this stuff is like terrible. And in a way, it kind of is, you know, like there's no. In a way, it kind of is, you know, like there's no world in which that's not going to be a complicated thing. But there is really an important theorem that lets us not worry about that too much or at least find some simplicity in it. So the theorem of the Laurent phenomenon and probably from that you can guess what it's going to say. From that, you can guess what it's going to say. This is due to Fuhman and Zalevinski in 2002. So, literally, like the first paper on this stuff, and the result that, in my mind, kind of motivated people that this stuff is interesting to study. So, this states. So this states that every cluster variable is a Laurent polynomial in every other cluster. Is that obvious from the example you gave? No. Well, if you use a computer, it is. But by looking at it, no, it's not obvious. And, you know, of course, as we keep on going, like, you know, when we mutate it, two again, we'll get like 39 new errors going from one. 39 new eras going from one to three, so that'll be like 34 from one to three. So mutating at three again will be something that's hopeless even for a computer to simplify, probably. I was thinking it's a little wrong. What's that? The new x2x2. So the way that this is going to work is that this numerator is some complicated thing, but it's not expanded out. So the idea is we can expand out the numerator and refactor it. And refactor it, and then that new factoring is going to have this x1 squared plus x3 cubed as one of its factors, so that'll be able to cancel. And in fact, that's exactly what's going to happen when you do this. The variable is going to have just this x2 to the 8x3 cubed in the denominator. And then in the numerator, you're going to have something with some number of terms. Some number of terms, 19 terms. So, a cluster variable in this case is just anything that you can get from mutations. So it's not just, so it's the cluster variable of a cluster algebra, not of a seed. I mean, yes and yes, both. It's a cluster variable of a cluster algebra, but those cluster variables also live in seeds. And obviously they can live in various seeds. They can live in various material. They live in the mutated seat. Yes, correct. So the statement is that, and they're Laurent polynomials of the other things in that mutated sequence that out. They're Laurent polynomials in any one seed. You can choose any seed you like. In this case, we are showing that this. We are showing that this is a Laurent polynomial in the initial seed we started it with, which is our x1, x2, x3. One could rewrite everything here, and it's actually not so bad to do that because a mutation is an involution, but you could choose the seed like x1, x2 prime, x3, for example, rewrite everything, and then this is going to be a little wrong polynomial in those three variables as well. Okay, so for every cluster variable, there is. Okay, so for every cluster variable, there is some possibly mutated C such that it is a wrong polymer in the C, in the cluster variable. So for any cluster variable, and for any C you like. Yeah, exactly. Right, so you get something, forgettable. But you can always restrict to the cluster variables of that of um of that same yeah right you you can you don't need cluster variables you can write everything in terms of whatever seed you Everything in terms of whatever seed you like the best. Yeah. Yes. Alright. So this is really nice. And obviously, even though we don't always want to do this calculation, it's nice to know that when things all cancel out, it has this nice form. So I think that this is like one of the two fundamental theorems of cluster algebras. Algebras. So the other big theorem is there an idea of why it's true. Like what's the probably. I mean, is it maybe what's the proof? Is it proof by induction? Yeah, it's a proof by induction on the distance away from your initial seed. From your initial seed. So you prove that everything a certain distance away from your seed can be written as a Laurent polynomial. And then you prove that if you go one more step, that new cluster variable can also be written as a Laurent polynomial. So these are mutations, they're kind of automorphisms of the algebra. Right? Because they're changing variables into new variables, so it's an automorphism of the algebra. So you've got a representation of this. So you've got a representation of this of this not not necessarily of the algebra because like the algebra remember is generated by every single cluster variable that we get. In particular you've got more patches. You've got more information there. Yeah you get more information. And so you've got evolution preserving the low-round. So you've got a group of involution preserving these low-round things. You know that if you go like this and you get your low-round, you can go back and you still get low-an. You can go back and you still get Laurent into the new ones. Is there some intuition there in terms of this representation? I think that Laurent are kind of integers and preserved by this group action by involutions or nothing of it as well. I mean, there probably is. I can't think of anything off the top of my head, but probably. I'll think about that more. Probably, I'll think about that more. Okay. And then the coefficients of the Sauron polynomial are from where? That is a great question. So the next theorem is positivity. So there's an easier, they're integers already. Yeah, they're already integers, yes. The things in the numerator again are integers, and well, I guess they're all integers because. All integers because you don't get any numbers in the denominator. So, yes, that is the short answer to the question. Thank you. All right. So, positivity, again, I think of this as kind of the other fundamental theorem of cluster algebras. This was proven much later by Lee and Schiffler in 2015. And what does this say? This says that all leading coefficients are positive. What's that? All coefficients in the w why do you write leading? Why do you write leaning? I enjoy being redundant. All coefficients are positive. Yes? That only has you chose one or the one that has been one? Nope, that is true in general. I'm sorry, so just to come back to understand this uh a little bit, so if you've if you've got a quiver and the U mutation are two vertices which are far apart, so this commutes right. So this commutes, right? Yes. So you can do 1 mu 10 or mu 10 mu1, same thing. I mean you tree actually, I mean that's the same thing. So then it's yeah, but graph because you get a square thing happening. Now what if you do two things which are connected by an edge? Then you get a grade relation of some kind? They're connected by a single edge that after five. Single edge, then after five mutations back and forth, you're back to the same seed you started to see. You see a pentagon on the speed. If they're connected by more than a single arrow, then you see infinitely many seeds. Yeah. Yeah, basically, like if the quiver is simple enough, then yes, but in general, no, because you, as you say, you have other complicated things that are going to mess things up for you. Things up for you. Are these kind of relations used for the proof of that? No, no, because this is a general theorem. Yeah, the proof of it is literally like, okay, suppose that you do D mutations and suppose that that's a Laurent polynomial, then do one more and show that that's a Laurent polynomial. And whatever your last cluster was, and then you can log it back. Okay, whatever the last one. So you call it U is okay. So you call it use okay. Yeah, I mean I I'm pretty sure that's how I remember it. Uh the the proof of this is such that I have gone through it like five times and chosen to immediately forget it afterwards. But yeah, that's the kind of general idea of what you do. You can roll with a computer. Yeah, right. All right. So that's kind of what we need to know about cluster algebras. So let's do Cluster algebras. So let's do an example which is coincidentally called the Markov quiver. So this one is a quiver with three vertices and two arrows between each of them. And so, first of all, I guess this quiver is really nice and symmetric, right? It's still three vertices, but it's a lot more symmetric than the last one we were looking at. And moreover, if we were to mutate at any one of these vertices, let's mutate at vertex 1, for example, the same vertices, but 1 is in the middle. But one is in the middle of four paths from three to two. So we had four errors from three to two. Two of those cancels, so we get two errors from three to two. And then reverse the arrows at one. So we get this quiver, which is isomorphic to our original quiver. In fact, it's the opposite quiver, if you'd like to call it. It's the opposite quiver, if you'd like to call it that. And the nice thing is that each vertex kind of sees the same amount before and after it, no matter where we are. So in this case, we can let x be x1, x2, x3 be any seed. So then the mutations are all going to look the same. It doesn't matter. This should be cluster. I apologize. Cluster. And the quiver is going to be similar enough that we don't really care what seat those things live in. So then we can say exactly. We can say exactly what the mutations of each of these is going to be. So mu1 of x1 is just going to be x2 squared plus x3 squared over x1. So two things coming into one from three, two things going out of one to two. And then if we were to do the other ones, it would look similar. So that's what we get. And this is any mutation we can do at any seed, we're going to have something that looks exactly like this. And now let us look at what happens if we specialize each of the initial processes. Each of the initial cluster variables to the value 1. So specializing x1 equals x2 equals x3 equals 1. So first of all, the Laurent phenomenon Is going to tell us that every cluster variable is going to specialize to an integer, and that's because the denominator is just a monomial and ones, so it's one. Okay, so this is good. And also, not quite so obvious just by looking at that, if we were going to do a lot of mutations. So that's a nice thing that this tells us. Positivity tells us that these are positive. Also, nice because cancellations can make things a bit complicated. So that's good. And then the important one really is that finally every seed under this specialization is going to satisfy the Markov equation. Let me just say that it's a squared plus b squared plus c squared equals 3abc where a b and c are Where A, B, and C are the first, second, and third things in your C, or cluster rather. So, all right. So, if we look at the cluster pattern of this, we'll have, in the middle, we'll start with 111, then we'll have like one. Then we'll have like one, one, two, one, two, one, two, one, one. Okay, and this goes on forever. And as a graph, this is exactly the same as what we saw in the last talk, which is the Markov tree. Can I ask a quick question, Ryan, before you? If in the quiver you replaced all the twos with threes, so that as you keep doing mutations, you get all the Markov triples scaled by three, is that not also like a Markov? Is that not something that's used to study Markov? Replace all the errors. Replace all the arrows with? Sorry, the number of arrows. Oh, you do three arrows instead of two arrows. No, because then your quiver won't have this nice mutation property because if 2 plus 2 is 4. No, no. This will still generate 3 times the Markov compression. I was going to remark that there is another it's another quiver that you can call the Markov quiver. So it is also steady. It is also steady and it's Also, study ten. It's totally different. Well, then four. Yeah, that would be nine here. So you get six heroes from one. Yeah, exactly. That's three times two. So you get three times the bar cost. The bar collection. Oh, okay. As the number of heroes. As the number of arrows after each afternoon. Okay. Yeah, and this grows out of control then, right? That's I don't know about this. I don't know. Yeah, the number of arrows is going to keep increasing because the seeds will still tell us information. Yeah, so what the cluster variables evaluate too is. So what you're saying is that you've got the representation of the Markov numbers purely in terms of the quiver. You're not even looking at the threat, just by counting the edges. That's right. Oh, I see what you're saying now. Yes, yes. That's right. Yeah, no, sorry, I misunderstood. Yeah, no, sorry. I think this is another reflection of how the markup numbers appear in two different ways within the same picture. Yeah, exactly. But it is a thing, like we have to think about it. Yes, thank you very much. Yes. So, yeah, we get that. So, that's very nice. We get that. So that's very nice. So, in particular, we know that this tells us that every Markov triple is some specialized seed or some specialized cluster, rather. So, also mutation. Mutation is the same thing as what we talked about before, this yet a involution. Okay, so that's good. For time, maybe I'll just say the last thing I want. Maybe I'll just say the last thing I wanted to say rather quickly. So, one thing to note is that this cluster pattern is also the same as triangulations of the punctured torus. So that's a torus with one marked points, and then triangulations of this guy. And triangulations of this guy can correspond to the clusters of this. And mutation is going to correspond to flips of arcs in the triangulation. The triangulation. And so, therefore, you can also think of Markov triples as being full triangulations of the torus with one point. And there are like some nice cometatorics that tie all these things together. But for time, maybe I will leave out some details and give you something to look for if you're interested. I guess the, I should say, the paper. I should say the paper to look at on this stuff is Fomen Shapiro. And there's some if you're interested in that. But thank you for your attention. I will stop there. So cluster algorithms have some geometric motivation for them to be created? Yeah, yeah. What is that? And does that tell you something new geometrically about model companies? So I'll be honest, I don't really understand it too well. I kind of avoid lead theory at all costs, which is completely a personal fault on my end folks. I guess the short but fake answer is: yes, it definitely tells you something. I just don't really know what that is. That is a good question, though. Yes? So, maybe related question. So, if you take your map of Quiver, the version that you mentioned with the variables, and you look at the lowant polynomials that you get in the initial C, you start with your initial. You start with your initial question, I think. Yeah, I use them interchangeably in my mind. Then you get each one with the implications, and then you get three polynomials in Z. Are these the same thing as the polynomials, the variable polynomials that we get trace uh the trace functions uh in terms of the initial variables. In terms of the initial variables um maybe some yeah probably take one maybe my part says no but I'm not sure if you take the representations of a function force it's generated by C3 the variables XYZ then you can take the length of any curve and it's gonna be a polynomial in XYZ It's not exactly this, but I don't think it's too far off from the exchange relation is very close to the trace relation. And there's a slight subtlety. These are actually associated with arcs and the trace relationships. This is more like Ptolemy's relation. In fact, it's exactly Ptolemy's relation. Yeah. Yeah, but it's closely related. I think there's just like it's related to the 111 versus 323. Yeah. That would make sense. In terms of geometric motivation, so the original Flaming Zelvinsky was about Ne theory, like you said, and I don't understand it either. But that paper went up to the surfaces. That one was related to hyperbolic. uh related to uh hyperbolic geometry um and uh bringing in looking at lengths of cur lengths of posters or of arcs on those surfaces. Any other questions we might have? Anyway We have a group of two here outside, and there's a coffee railway also.