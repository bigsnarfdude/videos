Joe Karan, Bagu, Masa, so I think they're very good. Okay, so this talk has two parts. In the first part, I'm going to present a couple of definitions and notations, and also I propose some questions. And I hope you feel both curious and motivated by the end of the first part because The first part because so Gabriel will continue the second part and he will explain nutrient and the background of these questions. Okay, so let's start with an easy example. So here we have a vapor C4 graph, a cycle of length, and the adjacency operator can be viewed in two ways. So one way is like the adjacency metrics. adjacent symmetrix so the entry ij is one if and only if so the vertex i is adjacent to vertex j otherwise zero or we can think of as a linear transformation linear map from fb finite dimensional vector space to fp and so they are equivalent so the next example is an infinite graph so we have a three regular t Three regular key. And so again, like finite case, there are two ways to think of adjacency operators. So one is like infinite matrix. And like finite case, so the entry ij is one if and only if the vertex i is adjacent to vertex j, otherwise it's zero. So here, so it is three regular, so and one is adjacent to two, three, four. So in the first row we have zero, one, one. First, so we have 0, 1, 1, and we have 0 for every. Yeah, and then this should be symmetric, so we have the same thing in the first column, so we have 1, 1, 1, 0, 4. So the next view is linear transformation or linear map. But here, so instead of finite dimensional vector space, you have infinite dimensional vector space. And in this talk, most of the time we talk about the finite space, you know, F2, F3, anything finite. Anything final. Okay, so now, next step, I'm going to define eigenvalues and eigenvectors for influenc case. But let's get back to the finite case when we have this graph C4. So we have the HNC matrix here, and then we have the vector J. So by vector J I mean 1, 1, 1. And this is the eigenvector corresponding to the eigenvalue 2. Yeah. Okay. In order to avoid weird situations, In order to avoid weird situations in infinite graphs, such as infinite sum or infinite series, we would like to restrict ourselves to the local finite graphs. So a graph g is local finite if the graph which vertex is fine. Okay, so now, so a non-zero vector x is the eigenvector corresponding to the eigenvalue lambda if and only if, so for every vertex v, so the sum of the corresponding So the sum of the corresponding entry of the neighbors of V should be equal to the lambda times the entry corresponding. So now I have two examples. So first example is two regular tree that we have seen, and the next one is two regular tree, or so it has another name. They call it two-way infinite path. Okay, so in the first example, so three regular tree, so every vertex has Every vertex has degree 3. So when I want to compute this, so the vector j here, as I mentioned before, is the vector that we have all one. So we have one, one together. And every vertex has degree 3, so we have 3, 1 in the left side, and the right side we get 3 times 1, which is 3. So in this case, so 3 is the eigenvalue, and j is the eigenvalue. And this is not very surprising because we know that in regular graphs, j is always. graph so j is always eigenvector corresponding to the eigenvalue corresponding to degrees. To the next case, so we have the two regular tree or two-way infinite path and this time so I choose this vector so we have 0, 1, 0, 1 repeated here and then so every vertex has two neighbors so either we get 0 plus 0 which is 0 but if we have But if we have 1 plus 1, I'm considering s2, you know, there's 52 elements, 0, 1, and again, so 1 plus 1, I get 0. So, in other words, this is the eigenvector corresponding to the eigenvalue, eigenvalue 0. Okay, so the next definition is support. Support of vector x is the vertices with non-zero corresponding integers. Okay, so the first question. Okay, so the first question for you. So can you find eigenvector a finite support for, for instance, a 3D polar 3 or 3? I mean, everybody except Gabriel because Gabriel knows the answer. Because, I mean, for instance, in the previous example, so J has infinite support. We have infinitely many 1. So in the next case, we also have. So, in the next case, we also have one infinite many bonds, so they don't have finite support. So, my question is: can we find the eigenvector of finite support? So, later, I'm going to show you, so I mean general trees cannot have eigenvector finance supports. Okay. Okay, so so far I talked about, you know, eigenvalues, eigenvectors, eigenstates operator, and there was not so much graph theory involved. Was not so much graft theory involved. So now I'm going to add a little bit of graph theory flavor to my talk. So I'm going to define a special colouring. So it is not proper coloring. So you have only two colors, black and white. And then so I'm going to color it in such a way that no white vertex is adjusting to exactly one black vertex. Okay? So let's get back to two regulatory or two veins. To two regular three or two veins in this path. So I can color, you know, so black and white alternatively. Yeah, so we have black, white, black, white. And then in this case, so it's not very hard to see that. So it is especially because every white has exactly two black vertices. Okay, so you can ask me, so Bobby, what's the connection between, you know, so special coloring and icon. Special coloring and eigenvectors, you know, and eigenvectors are finite support. So let's get back to this example: two-way infinite path. And we have seen that this is the eigenvector corresponding to the eigenvalue zero, because either we get zero plus zero or we get one plus one. In both cases, we get zero in field F2. And now I want to use this eigenvector to define. You know, to define a special color. So, what I'm going to do is the following. So, I'm looking at the vertex zero. So, the vertex zero, the corresponding value is one. So, I color it black. So, the next vertex is one and the entry is zero. Then I color it white. And so I repeat this pattern. So, if the corresponding entry is one, so I always color it black. So I always color black. I mean, if it's zero, I color it white. And then because I have, you know, zero, one, zero, one, so I get again like black, white, black, white. And we have seen that this is a special colour. So in general, you can do this technique for every graph. So if you have an eigenvector, so you look at the interior, if the interior is zero, so you color it white. If it is not zero, you color it black. For that, yeah, and then it's not very hard to say that this is a spatial curve. But recall that, so we are interesting, we are interested in eigenvectors of finite support. So for that regard, I have to add a little bit restriction on my special coloring. So I call special coloring finite if it has finitely many black vertices. Okay, so Okay, so the question is: Do you know any example of drugs that have a finite spatial colour? If I make it disjoint, could I get it? Or do you need it to be connected? So, for now, I need to connect it, but it's okay if you want to. I mean, I just. I mean, I just think somewhere, some finite component, I can put the blacks, and somehow I can be clever with the rest, but I don't know how to do it. Okay, let's see. So now I'm going to show you a couple of results and show that, for instance, in general, three, we cannot find such a color. So the first result is three. Tree. So if you have a tree with the mean degree 2, so I'm going to show you that we cannot have, you know, a finite spatial color. So the proof is very easy. So assume to contrary that. So your tree with mean degree 2 admits such a coloring. Now, so take longest path between two black vertices. So let's say I have this longest path with maximum distance. Longest path with maximum distance. So, this is u, this is v. But the next vertex should, I mean, all of the neighbors of the next black, this black vertex should be white. Otherwise, I can extend the path and I get the longer, you know, path. And then, so now we look at these neighbors. You know, all of them should be white, but since our coloring is spatial, so this means that we have another black vertex. And then in this case, you can extend your, you know, your path. And this is a contraction. So, so, in this case, So in this case, I mean, so this argument shows that in a tree with mini-brat is two, we cannot find any find the special harmony. Okay, so the next example is Kelly Grop on Z. So if you take, for instance, Z with the generating set plus minus one, you get two variants with path. And we know that, you know, so this doesn't act in any finite spatial coloring. But now I'm going to show you with any generating. I'm going to show you with any generator set, you know. So, if with any finite generating set, you cannot, I mean, they don't have finite special colouring. So, again, assume to contrary that we have such a special colouring. So, now S is finite. I can find the largest element in it. I mean, generating, so let's say S is the largest form. And then we have finitely many black vertices. Also, I can't find the largest black vertex in my graph. In my graph, yeah? So now I have the largest black vertex n, and then, so by definition, so I know that so n should be adjacent to m plus s. But I know that, so m plus s should be bigger than n. Yeah, so this should be, but this should be white, because by definition, m was the largest one. But remember, so this white vertex should have another black vertex, yeah? But whatever it is. But whatever it is, so it should have a, it should be larger than n. But this is a contradiction because n was the largest black vertex. Okay, so similarly, with similar methods, we can show that every Kelly graph of totally ordered group does not atmate finite spatial coloring. And as a coloring, we can conclude that torsion CD bottom groups does not atmos fine. Doesn't have atmospheric spatial colour. Okay, so I should, I already show you lots of negative examples, but you think that maybe it's very hard to construct a graphic, you know, find the spatial coloring, but it is not true. So I'm gonna construct a family for you, and I'm gonna use lexical graphic code. So you have two graphs, so G and H. So the lexographic product of G and H is a graph with the vertex is Cartesian product V G and D H. And two vertices, U, V, X, Y, are adjacent if and only if U is adjacent to X or if U is equal to X, then V should adjacent to what? Okay, so here. Okay, so here, so for, I mean, I choose G for infinite path, you know, two-way infinite path, and for H I choose K2. So the lexographic looks like that. Okay, so for my regard, so I want to find the family with a finite special colouring, so I take P infinity, so two range tax as G, and for H, I take the complement of K. I take the complement of k2. So only two single vertices, and so we don't have these vertical edges, you know. So it's only we have like two-way infinish path, and then we have like six edges. Okay, so now I want to introduce a special coloring for this one. So I take up this pair and then I color them black and the rest of the graph white. So these two vertices have these two black vertices in the neighborhood, and for these two vertices as well, so these two belong to the neighborhood. But the rest of the graph have only white neighborhoods. So by definition, this is a special coloring. And since we have only two black vertices, so this is an example of finite special coloring. And here, so also you can replace K2 complement with K. Replace K to complement with Kn complement. So it doesn't matter so much. In addition to find the spatial coloring, so we can also find eigenvector of a finite support. So I assign to this black vertex plus one, to this black vertex minus one, and then for the rest of the graph I assign to each vertex zero. And then it's not very hard to see that. So this vector is eigenvector corresponding to the eigenvalue here. Corresponding to the eigenvalue of 0, and since we have only 2, you know, so we have only 1 and minus 1, so this should be a finite support. Okay, so now I'm going to talk about the symmetries of this lexicographic product. So, for instance, if G is vertex transitive, so the lexicochukirophic product of G2 complements is also vertex transitive. If G is H transitive, If G is H transitive, the lexicographic product of G with K2 complement is also H transitive. And however, so if I add a little bit more, a stronger symmetry transition, so this example has failed. So for instance, if we put R transitivity here, so and S are in a graphic sequence of vertices, V0 up to Vs. says V0 up to Vs such that the consecutive vertices are adjacent and Vi minus 1 is not Vi plus 1 for every I between 0 and S. A graph is S arc transitive if the automorphism group acts on S arc transitive so the question is if we add for instance 2 arc transitive so can we find the Transitive. So, can you find a graph which is 2R transitive of finite support over some finite field? So, here we don't care about the field or eigenvalue. Our only concern is about the eigenvector of finite circuit. Or instead of two are transitive, I can ask for locally primitive. And a graph is locally primitive if for each vertex be the stabilizer of v on the neighborhood of the V on the neighborhood of the vertex is supreme. Okay, so I think this is a very good place to start. So last but not least, so we are interested of graphs with eigenvectors of finite support, but we don't care about, as I mentioned earlier, we don't care about the eigenvalues, media eigenvalues. Values no finite disease. Thank you. So we're switching over to Gabrielle and then we'll have questions at the end. Okay. Sure. Can I keep the same recording? Yeah. All right. Well, I'd like also to thank the organizers. It has been a while since I've been in Benff. It's really nice to be back. Actually, it's been a while since I've been in Canada. Since I've been in Canada in winter, and that's nice as well, especially for just a week or two. So, as Bobby said, I'll sort of explain a bit what the motivation for this problem was. And there'll be some sort of, the motivation will also help sort of clarify some of the details about what the question actually is. I think it's sort of interesting on its own to some extent, but the motivation I think will help. So, just a few quick comments, even though we're using the same slide. Comments, even though we're using the same slide, you can see that we're sort of from slightly different fields. Just, for example, he's using G for graphs, I'll be using G for a group. As you know, there's a split in the audience on this topic. And for those who know me, you might even be surprised at the whole topic because actually I don't often work with infinite graphs. That's not sort of my normal things. And I actually don't even work with eigenvalues either. I usually work more with symmetries, and you can kind of see that popping here at the end. But as I'll explain, this problem actually arose very naturally. Problem actually arose very naturally, like through a sort of series of steps from a completely different problem. So I'll start with a completely different problem and I'll slowly get there. Okay, so for me, gamma is going to be a graph. So it'll be connected and G vertex transitive. So G is some group of the automorphism group that's transitive on vertices. And for me, what will be very important is concept of local action. So for those who work in vertex transit graphs, that comes up a lot. It's super important. So what does that mean? I'll use an example here. So, well, Well, first let me do the generic case. It just means the permutation induced by a vertex stabilizer on the neighborhood of that vertex. So you have a vertex V, and then you've got some neighbors. I'll call them usually gamma V. And then you look at the vertex stabilizer. So it's respected that care, gamma G, right? So you have a specific group in mind. So G V fixes V, so it in particular preserves this as not necessarily as an orbit, but as a bunch of orbits, possibly. But it preserves it as a set. But it preserves it as a set, and then you just look all the automorphism. What can you do on the set? The induced permutation group. So, yeah. So, let's look at an example, a few examples. So, this will be just take the cycle, take the dihedral group, right? So, G is, say, the N. Then the point sublizer is C2 or SIM2, whichever you want. Let's say this is V. And then locally, you've got two neighbors, and you can swap them. So, here, the local action is also C2, so it's the same. Okay, so that's a little bit boring. Okay, so that's a little bit boring. But then do this operation that Bobby mentioned. So now take the lexical graphic product. In this case, I took the elliptical graphic product, but it edged this graph on three vertices. So that corresponds to sort of tripling every vertex. And above each edge, or below in this case, each edge, you put all the possible edges, and that's it. So the natural group here is what's called, well, one possible group you could take would be S3 read the N. I'll explain what that means, the read product, for those who haven't seen it, of cremation product. Means the read product for those who haven't seen it, the commentation group, because it'll come up a lot in the talk. So it's very important. It's not very hard. Another way to think about it is S3 to the N semi-direct the end. That means on every, I've got these blocks here, size 3, they're preserved as a partition. The sets themselves can move around, but the parts have to be mapped to parts. On each of them, I can do an S3, so I can promote these three vertices independently, and I can fix the rest, right? And you can do that in every of those, also independently. That's why you get a really large group. Independently. That's why you get a really large group. That'll be important. So S3 to the N, right? Like S3 here, S3 here, S3 here. And then on top, you've got the DN, the original DN you started with. Okay, so that's a very, that's a group of automorphism. That's very easy to check. All of these things are automorphisms. Okay, let's say I want to calculate, like I pick a vertex, say this V here, and I calculate the vertex stabilizer. Okay, what happens? We're inside the block here, I've got this S2. Like what happens to this 2 to the N? It becomes an S2 times S3 to the N. Becomes an S2 times S3 to the N minus 1. I can still do all the S3s, except in this one, I get an S2. And on top, you get a C2 that looks something like this. Because you can still do this reflection, but you can't do kind of cyclic promotion. And this C2 actually corresponds to this C2, more or less. Okay, and what's the local action? Because this is what I'm trying to explain. The local action is always a quotient of this. But basically, you just look at But basically, you just look okay. This is B. I just look at the next six Sorry, the six neighbors. What can I do just with these six neighbors? Well, I can still do like a full S3 here, full S3 here, and I can swap them. So that's like S3 times S3 semi-C2. It's actually a read product. It's S3 read C2. Okay, so this is just an example to give you. So, you know, in general, the local action is quite small because it's a permutation group of degree divalency. Of degree divalency, right? So it's, and whereas the vertex doubles are going to be quite large. Okay. Now, I'm going to say that a permutation group L, so L for local action, has exponential graph growth if I can find pairs, like a graph in a group, with this particular local action, such that the size of the group is exponential in the order of the graph. For example, this example, right? The graph here is orderadamo. Suppose I had this parameter was n, this is 3n. Know suppose this parameter was n, this is 3n, but the group you can already see here is really big, right? It's got like a 6 to the end here. So this is exponential in n, or even in 6n even. So here in this family, not in this family, for example, but in this family, the size of the groups grow exponentially by the size of the graph, and the local action is fixed, right? It doesn't depend on n. So I'll say that this is a witness that this group here has exponential graphical. So be careful, right? Exponential graph growth. So be careful, right? The group that I'm talking about when I talk about exponential graph growth is the local group. I'm assuming I'm looking at vertex transit graph and I'm looking for pairs that have this as a fixed local group. I'm not going to explain why this is important. This is the motivation to our problem, but of course the motivation has its own motivation and turtles all the way down and so on. But this is really important in a lot of the study of earth expensive graphs and size of groups and so on. It comes up a lot. So we'd like to know which local groups have exponential graph growth. Local groups have exponential graph growth. I should say they don't all have exponential graph growth. Sometimes you can prove constant bounds. For example, some of you know my knowledge touch theorem for cubic arc transit graph. It's an example where if you fix a local action, the vertex stabilizer is fixed size, you can get polynomial growth sometimes, and exponential growth. There's no other growth known, but it's not known that there shouldn't be other growths. But we'd like to get some exponential graph growth. And using these lexical graphic products is one of the easiest ways. So this is sort of the example which I've So, this is sort of the example which I just gave. So, this, you know, I took d is equal to 3 here, but you know, I could have done d is equal to 2 or d is equal to 4. So, you get that sim d read sim2 as exponential graph growth. You can also tweak this a bit, sorry. As I sort of pointed out, this C2 came from this C2, right? So, if I picked a family of graphs that like a different local actually, but in this C2, actually, this C2 comes from this C2, and this C2 comes from this C2. Okay, in this case, the volt C2. Okay, in this case, the voltage C2. But in general, if these two were different, these two would be different. And so if you start with a family that has a particular local action, you can play this trick. Like if it was L, you can get L here. So this C2 you can kind of control. And in fact, this S3 can also kind of control. For example, here, I can replace this S3 by C3, for example, if I wish. I can just agree. I'm not going to allow allodomorphisms. I'm just going to allow cyclic permutations here on these. And then this is going to propagate. You can get C3, C3. Proper data, and you get C3, C3, and C3. It's sort of very easy to see. And doing this kind of trick, it's not hard to show that any non-trivial reef product has an exponential graph growth. You still, there's a small technical point. You still need an infinite family with the correct sort of top local action to start with, but there's common tricks in the area to do that. Actually, once you have one, because you don't care about the size of the groups and those ones, right? The big group comes from the fact that you're taking the elliptical graphic product anyway. You just want some examples. Some examples, but there's covering techniques that's easy to build one examples, and once you have one example, there's covering techniques that you do infinitely many ones. And in fact, again, you don't care about the size of the group, right? Here, the group didn't grow much, but you still got exponential just from the fact that you were taking this physical graphic problem. Okay, so far it's really unclear what this has anything to do with what we're talking about before, right? We'll get there slowly. Now that, okay, we've done read products. I'm just going to tweak it a bit. I want to deal with a slightly different local action. A bit. I want to deal with a slightly different local action. I'd like to know instead of okay, so I'm going to fix the top group for now. It's always going to be sim k. I was just saving some trouble. Okay, so like this C2, you can think of it as S2. And I'm also going to always use at the bottom, here at an S3, I'm going to make it an S2. So it's sort of like writing H. Just to make things easier. So here the local action, for example, was S2 read S2. But in general, here, I'm going to allow it a lot to. But in general, here, okay, I'm going to allow to make this number bigger. So the graph might be not like two valent, but it'll be three valent. But I'm going to pass a subgroup. So instead of sim2 read sim k, I'm going to do this sim2 to the k minus one read, sorry, sim in direct symk. That's not a read product anymore. It is inside the read product. So what that means is now you have k blocks of size two. I'm just going to explain to you first what this means as a permutation group. So let's say k is four. So let's say k is 4. I've got 4 blocks of slice 2. Before, I was allowed to flip inside independently and then pre-move the 4 blocks. That was as 2 to the 4, so you get 4. I'm making a small tweak. Now you're only allowed to do an even number of flips inside. That's why you lose one factor of SIM 2. That's another group. It's another permutation group of degree 8 in this case. So in this case, I would get S2 to the 3 semi-s4. You're only allowed to do an even number of fluxation. So I would like to know: does this have exponential rule? Like to know, does this have exponential graph growth? In other words, can I find an infinite family of graph group pairs for an extra transistor so that this is a local action, but the group is still very big? Okay, how might I do that? That's the question. Okay, my plan is I'm going to use the same graphs. So I'm not even going to change the graph. I'm going to use the same graph I was using before, but I'm going to try and pass to an appropriate subgroup. I never, as I said many times, I don't have to use the full group. I'm going to pass a small group, sorry, a subgroup, but I need two things to go. But I need two things to go right. First, I want the correct local action. If I take the same group as before, it's not going to have the correct local action. But I still want it to be big because I want to get this exponential growth. So how am I going to do that? So I'm inside my read product, right? So now my bugs are size 2. So my read products look like. So, now my products are size 2. So, my reproduct looks like this. I've got a bunch of copies of SIM2, one for every vertex of the original graph, and then whatever graph I choose on top, this actually doesn't matter very much. The point is, I'm not going to take this whole thing. This part I'm going to keep the same, but I'm going to take a subspace, actually, of this sim2. So I'm not going to allow, just as here, I'm not allowing all the flips. In the big graph here, in this graph, I'm not going to allow every single automorphism that does all these flips. I'm going to take a subspace of that. That's a subspace here. You have a subspace S2 to the N. The subspace S2 to the N, I'm going to take something, I don't know what yet, M, a subspace of S2 to the N, to get the correct, still big, but to get the correct local action. Now, forget about the size for now. What property must M have to get the correct local action? Let me do a little picture. Suppose I started with a three-valent graph, okay? So this keeps going, it's some three-valent graph. Then I do this lexical graphic product operation, so I've doubled every vertex. So this is my new graph, right? Where I had one vertex, now I have two and one. Where I had one vertex, now I have two, and where I had an edge, I get like this four cycle, or this K22. Now, in the automorphism group of this, I can do all these flips here independently. But I don't want to allow that. I mean, I want to allow some of these automorphisms, but not all of them. So I'm going to need like a labeling to explain which ones I include or not. So suppose I don't know, this is one automorphism, right? In red. I'm flipping those two, flipping those two, and maybe fixing the rest. I'm going to think of that as a labeling of the original vertex. I'm just going to put a one when I flip the vertices and zero when I. When I flip the vertices and zero when I don't. So that's a single automorphism. I can think of a single automorphism in this kernel, we're the one that fixes all the blocks, as a zero, one labeling of the original vertices. And I can think of this, it makes sense to think of it as being over F2, right? Because, for example, if I add this one to itself, if I do it twice, I get the one times one becomes zero, right? So it's, you can, you maybe starting to see where things are going to connect. So here I have a zero, I mean, I am basically labeling the vertices with the element of f2. Okay, so that's the Okay, so that tells me which automorphisms I have, and which automorphisms do I want? I want the crack-local action. What does that mean? If I fix a blue vertex, I should only be able to do an even number of flips here. That was one of the properties that I said I wanted. What does that mean? Then I'm just translating in this language here. If I see a zero, meaning if I fix a vertex, then around it I should see an even number of y's. So the sum around zero should be zero. That's it. That's the property that I want. That's it. That's the property that I want. So, my M, which should be a subspace, every element inside M should have this property. So, every element in M should have the property that the sum around zero, every element of M I can think of a zero, one label length of the graph. And every element should have this property that around every zero, the sum should be zero. Okay, so let's forget about the original thing and just define this thing. I have a graph, and I'm considering zero, one labelings, or over F2, if you wish, of the vertices, all of them. Vertices, all of them, but I only restrict to the ones that have the property that's some around 0 is 0. That's a set. Note that it's not a subgroup or subspace. That makes kind of things a little bit annoying to work with, right? If it was, then I could just take that. But it's not hard to see. You know, you could have something that has, say, one particular vertex that's fine. And the sum around one is zero. And another, sorry, one particular labeling. And then another labeling, which is kind of fine. It is fine. It's in the set, but the sum around one is zero. And then when you add them, sorry, did I say one first anyway? When you add them, you get. Them, sorry, did I say one for single? When you add them, you get the zeroth vertex, but now the sum is one around the and they were fine otherwise. So it's not closed under addition. But okay, that's that's life. But I'm looking for a subgroup or subspace, a large one, right? Because I want it to be, the size of the thing to be exponential and the number of vertices. And also it should be preserved by a nice group, but don't worry too much about it. Okay, does anybody know some nice examples of such a thing? And I think there's one or two people here that have seen versions. And I think there's one or two people here that have seen versions of this talk before. So if you have, maybe don't say it. But can you like a large subgroup or subspace such that everything in a subgroup or subspace satisfies this? Well, if you remember Bobby's talk, maybe that will give you a hint. Any eigenspace for the adjacent matrix over F2 has this property. It doesn't even matter what the eigenvalue is, right? Think about it. What's the eigenvalue? Value is, right? Think about it. What's the eigenvalue equation, as Bobby wrote? The eigenvalue equation for a graph means for an eigenvector, when is a vector an eigenvector? Well, you fix your eigenvalue, and then the sum of the labels around the vertex should be whatever the should be lambda times the value at the vertex. But if the sum is zero, sorry, if the vector itself is labeled zero, then and the sum is zero, then you know, zero. 0 around, then 0 times lambda will be 0. So eigen spaces always satisfy this. So if you take, pick your favorite, pick F2, say, and pick your, it doesn't actually matter much, I guess F2, by the way. Later I'll do some other things. It's not that important. Because you can define this thing over any field, in fact, over any Boot. And then pick your favorite eigenvalue, lambda. And then if you take the eigenspace for the graph over this eigenvalue, it will be a sub. It will be a sub, like it'll be a sub-space sitting inside the set, basically, continued inside the set. And what's really interesting, which we noticed recently, this is in a sense the best you can do, at least in the vertex transitive case. And you can prove this in a permutation group sense. You don't really need a graph. But anyway, if you have a vertex transitive group, then the eigenspaces are actually the maximal G modules inside here. That means you cannot pick, you know, if you take any subspace that is preserved by something nice. Preserved by something nice, basically, it's contained inside one of the eigenspaces. So, you might as well, the eigenspaces, you might as well take the eigenspaces because you want to make it as big as possible. So, we're getting closer and closer. So, now we've connected to finding these large eigenspaces. I still have a bit to explain how am I getting small support and these infinite graphs, right? Like to finish sort of making connections. Okay, so let's kind of sort of recap what we've got so far. What are we looking for before we do sort of more translation? So, suppose I wanted to show that this group had exponential growth. Show that this group had exponential growth. Now, I want an infinite family of graphs with some local action, don't worry too much about that for now. And what I want now with this new formulation is I want the dimension of some eigenspace, I don't even really care which eigenvalue, over F2, and I want the dimension to grow linearly with the order. I've switched to dimension, remember, so I wanted the size to grow exponentially. That's the same as saying that the dimension should grow linearly. I don't know if you've thought about this, but it's not, depending what kind of local action you put here, it's not that easy to do this. Action, you put here, it's not that easy to do this, right? So you, you know, suppose you say, let's say that the linearly means one-tenth, right? So you mean if your graph is over 10, the dimension of the eigenspace should be dimension 10. If it's 1,000, it should be 100, and so on. You want an infinite family, but with quite every restriction on the local action, right? Like, again, there's a way to do it using graphs like these, like super graphic products, but I don't want to allow that, and I'll explain that later. Okay, here's a very easy lemma. This is like half a paragraph. Half a paragraph a paragraph to kind of translate this. If you have, if you can find one eigenvector, because computing the whole eigen space, I mean, the computer is not that hard, but if you give you a graph, does it have large eigenvalue, you have an infinite family, is it tricky? I don't know. One easy way to solve this is that if you have a vertical expansive graph and you have an eigenvector of support x, then actually it's very easy to show that the dimension of the corresponding eigen space is at least of the order over x. It's very, very easy to show. Very, very easy to show in the thousand boards. So that's good. That makes it much easier because we only have to find now one eigenvector, right? If I want to prove the same thing as before, that the dimension is at least the order of a 10, I just have to find one vector to support 10. And I'm done. Okay, that's already easy. So I just have to find one vector. But this support has to be kind of fixed over the whole family. So I have my infinite family, and I should want to find a vector of support 10, sort of in each of those graphs. Okay, so now I can. Okay, so now I can kind of replace this with finding these eigenvectors above that support size. One of my PhD students has been working on, well, we've been working on this for the past couple of years. We were kind of making progress until this year, a few months ago. So we have examples, like we did some families, maybe we did a case with a three here, or maybe case with four or five, and we did some stuff and some related things until we realized that every single example we have, remember that examples are infinite families, right? Like for me, one example of one local action I need an infinite family, they all occurred. They all occurred, in fact, where the infinite family was kind of in a very natural way. They were all quotients of a single infinite graph. And basically, and I'll explain why that works. Because this is also a kind of easy exercise. If you start with a graph and an eigenvector and fix the field, fix the eigenvalue, and then you take a quotient. In my case, I'm usually quotienting by some orbits or some normal subgroups or whatever, but I think I'm not really good with a subgroup. But I think I'm not really good with this. I think if you do an equitable partition, whatever, it should work. A nice quotient in some nice sense. It's a very easy exercise that you can project the eigenvector just by summing over the fibers. You define a new map on the quotient graph, and that's also an eigenvector, or possibly the zero vector, right? Like some kind of trivial base. I don't know if that made sense, what I just said, but like, you know, suppose you have some labeling here, right? Like one, zero, and suppose I'm doing over one over F2, I don't know. Suppose I'm doing over one over F2, I don't know, zero, zero, zero, one, and I have a quotient, like you know, this graph is a quotient of this one in a very obvious way. You just write down the sum, right? Suppose I'm working over f2, I get this. Did I do it right? No, this one should be one. No. Yeah, I did do it right. Okay. If this one was an eigenvector, this one is an eigenvector. Or maybe the zero vector. So that's very useful. That's very useful, though, because it means if you're in your infinite graph, you find your small support element, and then you have a bunch of quotients. And then you have a bunch of quotients. Well, suppose you had the support 10. Sorry, I should mention, it's also very easy to see that the size of the support cannot increase when you do this, right? Like, if I only have 10 ones or 10 non-zero elements here, when I do this operation, I have at most 10 non-zero elements again, right? Like, because where it was zero everywhere, it gets mapped to zero. So it's really good. Because now, if you have one infinite graph, and you can find this finite support element, hopefully, you're Hopefully, your infinite graph has an infinitely many quotients. That's one small technicality. But if you do that, then all these quotients will all inherit an eigenvector of small support. Okay, again, a small technique, you have to avoid the zero vector, but that's usually very easy, actually, especially if you have an infinite number of quotients. So, and then all of these will have these eigenspaces growing linearly. And also, typically, the nice thing about if you quotient by Typically, the nice thing about if you quotient by normal subgroups and so on, you typically inherit the symmetry a lot of, like if this graph is vertex transitive and you're quotient by the orbits of a normal subgroup, this one will be vertex transitive. And same with the local action, actually. There's many natural situations where if you have the correct local action here, these will all have the same local action. So we've kind of, I don't know if I should say reduced, but yeah, I guess you could say reduce the problem to finding now one infinite graph with the correct local action. Infinite graph with the correct local action, the same one that we wanted to start with, with an eigenvector, sorry, an eigenvector of finite support, which kind of sounds easier because it's just one object, okay, but the object is infinite. But it does, like, that's not how we started. But we've translated all our results in this language, and it does make the proofs easier and so on. But it's still not that easy. We're still stuck, and this is where, you know, I'm sort of appealing to you. Maybe some of you know something about this. Again, I rarely work with eigenvectors, eigenvalues. I should mention, though, that. Value. I should mention though that, as Bobby said near the end of the talk, I'm mostly interested in the locally primitive case. What do I mean by locally primitive? Well, a primitive permutation group for those who don't know means you don't have blocks like this. I really mean, sorry, sorry, I should make a distinction, right? Like, the eigenvectors are in the Bayes graph, like this original graph, right? We use these eigenvectors to find the comorphism groups of the graphs of the graph where we take the lexicographic product. We take the lexicographic product. So the automorphisms are here, but the eigenvectors are here. And once we talk about eigenvectors, we sort of don't even think about this graph anymore, right? This is sort of like a substitution. So in this graph, this is the one we want to be locally primitive. And what I mean by that is, so a permutation is primitive if you cannot find what are so-called blocks, like a system of blocks. So a non-trivial partition of the underlying set that's being preserved. So if you take one part with all the points, that's clearly preserved. Are all the points that's clearly preserved? If you take every part being a singleton, that's preserved. Any other part as partition is usually called non-trivial. And if there is no such thing preserved by the group, it's called primitive. So that's what I mean. A very easy example, by the way, if you don't, if you take a transitive group of prime degree, then it will be primitive. So those would be examples, like, so I'd be interested, for example, in an R-transitive graph of prime valency, for example, and various local actions. And I've talked a lot about the field F2. Actually, it doesn't really matter. You can take any. You can take any, well, I mean, it does matter in the sense that I actually want to do it for every field. So I want to do it for F2, I want to do it for F3. If somebody finds a family for F2, somebody finds a family for F3, for me, those are two different interesting families. So I'd like to do it for every field. In fact, you can even do it for an abelian group. The language of the eigenvalues and eigenvectors is maybe not completely appropriate, but the equation that you have with is actually fine. And especially the sum zero again, around zero, that only requires an ability. You don't even need the multiple. Requires an idea. You don't even need the multiple field structure there. So, yeah, that's it. So, this is a question that I'm happy to discuss during the sort of working session. And if anybody, I didn't want to explain too much the examples that we know so far, because we're kind of stuck with those techniques, and I'm hoping to kind of, you know, go sideways. And so I'm hoping maybe some people have ideas about this. So, any questions to me or Bobby? Thanks. Thank you. Maybe stop the recording. I can do that, yeah. Questions? Chris, another question.