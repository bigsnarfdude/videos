Thank you so much. I'm going to share my entire screen because I'll be switching back and forth between my presentation and a web-based software that I'm presenting. So if something's not looking right, please let me know. Can everybody see a title slide? All is good. Okay, excellent. So thank you for having me here. I'm a mathematician and I'm honored to be in your midst and I'll be talking. Your midst, and I'll be talking about plants in lab, a modeling and simulation software that was specifically designed for plant biologies, but in fact has proven useful for modeling of other biological systems. So plants in lab, so this is the URL. This version is stable, it's been around now for a while, it's been used for training and research, and I admit I'm hoping to advertise it to you. I'm hoping to advertise it to you and also get some advice on future directions. There is a beta version of some of the features that I'll talk about. They're not in that version. They're under development. It's definitely a work in progress. So a lot of people have been involved in it. Over the years, you see a list. The main developer was the software engineer Sukha, and the PIs of the NSM grant were Brett Tyler and Reinhardt Lauber. Brett Tyler and Reinhardt Laubernbacher, and what you see here is the main paper that we published based on the software. Okay, so what is Plan Simlab? So it's a web-based application, and I'll do a demonstration in a moment. No download is necessary. You have to log in, but you can use your Google account. And the goal is to allow plant biologists to construct dynamic mathematical models of molecular networks. Those of molecular networks and to enable biologists to interrogate the model in a way similar to what they would do in their lab. So, also it's meant as a tool for biological hypothesis generation. So, the main goal, simplicity was a goal. Not steep learning curve was very much a goal because we're hoping that experimentalists will be able to jump straight into building. To jump straight into building models without assistance from mathematicians with little to no experience in mathematical modeling. And that also has proven it useful for introducing biology and math students to modeling. Okay, so I think a demonstration would be the best way to try to convince you that these goals have been achieved. So suppose we want to model a made-up network of, let's say, three genes. They don't need to be Of, let's say, three genes. They don't need to be genes, but let's call them genes: A, B, C. And suppose we know that A activates B, B inhibits C, and C activates A. So I'm going to switch to plant sim lab. So do you see a browser? Something that says plant sim lab? Great. Okay. So just with a few clicks, I can start doing this. So I'm going to create a node here and I'm going to call it A. So, and I can change a shape, color. I can also change. Shape, color. I can also change the number of possible states it can be into between two and five, but I'm going to leave it at two right now. And then I'm just going to click submit. And here it is, a note. Everything has default settings. Okay, so we're going to call the two states that we chose low and high, but we can call it off and on, absent present, and we can even come up with our own scheme. So let's make this note. So this is our first note. So, this is our first node. Let's now make node B. And I'm going to, I don't know, maybe change the color, but again, I'll leave it into two states and save defaults and quickly note C before I start introducing interactions between them. So I'm going to make a triangle and I don't know, red. Oh, sorry, I canceled instead of set confirm. So this was supposed to be C. See, and I want it to be a red triangle, let's say. There we go. Okay, so now introducing edges. So, let's say we have, we said A is going to activate B. So it draws an edge. And again, they're default values. I can customize it. Maybe when A is high and B is currently low, and the next step, I want it to remain low. But the defaults are. Law, but the defaults are chosen as the most straightforward, generic way of representing activation. And then I save it, I can label it if you want. And remember, B, we said, is going to inhibit C. So I'm going to leave the defaults here. We can change them later if we want. And finally, C activates A. So let's do that as well. I'm going to leave the defaults one more time. So here it is. Defaults one more time. So here it is. We have a network and we can run simulations. But before that, if we want to finely tune it a little bit more, we can click on each of the nodes and see what we call the big state transition table. So here we can, if we want to customize it, we can explicitly specify each transition. Again, the defaults are aiming at capturing the most straightforward way of representing either activation or inhibition, whatever we chose to be. Whatever we chose to be. So we can change those for each node if we want to. And so, what can we do with that? So, right now, it just looks only like a graphical model, which we can rearrange any way we want. We can run a simulation. So, even for three nodes with two states, the system can be in eight possible states, which very quickly increases with the number of states. So, we can run a simulation. So, it takes a moment, and here is one of the Is one of the types of outputs that we see. So, this is the summary of all steady states. And if there were any cycles, we would have seen cycles. So, it looks like that we have such a small system, but eight steady states. And we see a number and percentage of nodes contained in each component. And we can observe it more closely if we click on a specific component, connected component, and see here it's And see here it's color-coded the different states of each node. So remember, we have A, B, C, and here the legend tells us that blue is high and yellow is low, but we could have chosen some intermediate states as well. And then we can return to the main output table. We can also observe the entire set of transitions, the entire state space. So we see these little components that we generated. Components that we generated. We can also look at them in this pie chart if we want to, which explains what's happening with all of these components. And we also can do some experiments. So in particular, we can do knockouts. We can choose what an initial state is. We can do single, double, triple knockout, hit submit, and now it tells us that A is being knocked out. It tells us that A is being knocked out, and we can run another simulation which now we have a different transition table because we set A to be always zero. Okay, so this output is similar, just that one of the genes is knocked out. So we're hoping in the future to introduce other features for analysis. So this is still under construction. And in a moment, I'll tell you about the natural language. Tell you about the natural language parser beta feature that we've introduced. So, what is this good for? I'm going to switch back to my slides. So, we've actually used it in a paper in which we studied the innate immune response to ischemic injury with a collaborator from the University of Connecticut. She's a vascular biologist, Linda Shapiro. And we built a discrete multi-state model of the innate immune response to iskin. Of the innate immune response to ischemic injury that spans both tissue and intercellular scales. And the model captures the consequences of targeting various components of injury-induced signal transduction on pro-inflammatory and pro-healing outcomes. And really, why was and we use plant seamlab in that. So, one way we dealt with the mood. With the multi-scale needs of our model, was for cellular cellular processes are a lot faster than intracellular processes. So we ran the model of the cellular processes to steady state, and that was, and every time it reached a steady state, we input it into the tissue scale part of the model. And I included a link to the paper. I'm not going to get into the details of that. I'm not going to get into the details of that, but the software has been used for research as well as for training. So, I know I'm running a little bit out of time. The natural language parser is a beta version. It's still in its beta state. We would like input on it. I'm not going to dare show you live how it works because I'm worried that something will go wrong. But so far, it's been working great. Been working great, and the goal is to use more natural language to describe your network. So, this is an example of an input file that you see. So, it can be imported into Plant Sim Lab. The interface is very similar to what we had before. And you can see that you're inputting sentences describing your network. There is a tutorial. If you go to this URL, look for the help menu, and there is There is, you can click on the N LP part of the help menu, and it will tell you exactly how you can formulate your sentences. There is considerable flexibility, and then you can run FanSimLab and it will generate the same type of output that you've seen before. And one last thing I want to show you is that there are sample models already input into Into Plantsim Lab. And when you click on one, I hope you can see how the paper associated with it pops also. So you can see the network, you can run it again, you can generate steady states and do all of this analysis, and you immediately have access to the paper associated with the model. Okay, and so I'm out of time. So I'm going to go to the questions now that I would like to seek advice from you. So what other From you. So, what other, well, do you like the features we have, and what other features would you like to see? And one ongoing concern that we've had, and maybe you can, you have some experience and advice on it, when you have web-based software, of course it requires ongoing tender, loving care, or otherwise it stops working. But is there a way to ensure or at least increase the chances of proper functionality over time? Proper functionality over time without having to have someone constantly troubleshooting and making sure the software doesn't go down, which has been our unfortunate experience several times. So that's it from me. Thank you so much. Thank you, Elena. The floor is open for questions. Go ahead, Veronica. I have a question, Elena. Question, Emila. So, when you should show your Boolean network, I was wondering if you couldn't show the states in a graph, like going from how the evolution of the states of that. Yeah, yeah. So I believe we can. Yeah, yeah, I believe we can. Let me see if I can remember how that goes. Just give me one second because I stopped sharing. Let me start sharing. Possible too. Yeah, yeah. To yeah, yeah, it is possible, yes. Um, um, I believe it is possible. Um, network simulation. That's it. If you go, can you see my screen? Am I sharing again? I believe I am. Yeah, so if you go to the network simulation and you pause, if you start the play button, it should. Oh, I'm sorry, I'm not pressing. Okay, I don't know if you can see the whole screen, but it's updating, it's updating. Updating, it's updating how it moves. You see, each note, notes are popping bigger or smaller. Um, I think I did something that's okay, I have to stop it first, sorry. And then I'm sorry, are these notes the combination of the three genes? Veronica, Tony, I had two. Are these notes the combination of the three genes? Oh, so here they can, the notes each. That they can the nodes, each node represents a gene, and the reason it wasn't moving is because it reached steady state. I should have said that. Thank you. Go ahead, Shane. Thank you. Actually, I wanted to address the questions which Elna just raised. So if So, if I think that it is a very, very important question: how to assure longevity of research software such as that presented. And I think that if, well, the short answer to the question is to the question, in my opinion, and experience, whether it is possible to assure longevity without putting constantly time and money into this is unfortunately no. And if there are many. There are many reasons for this. One actually is that it is difficult to, and this is a general question, general issue, it is difficult to get funding for maintenance of software. It is much easier to get funding for new things. It is much more difficult to get funding for maintenance. And this is a systemic problem which has been many times described in the literature, well, pertaining to different types. Well, pertaining to different types of research software. And unfortunately, I don't know how to, what is the solution? Maybe putting things, including the sources, in public domain and hoping that the community in general will maintain it is an answer. But in the case of Biogeka software, it is difficult because the community of users is somewhat different from the community of developers. So those are not the same people. So, those are not the same people. So, I'm sorry that I sound pessimistic. I wish there was a more optimistic answer, and maybe someone knows it. But I think that if you want to have your software up and running, then you will have to constantly put some energy into this in the existing reality. So, this is just my comment and my answer to your question. Thank you so much. At least it confirms. Much and at least it confirms our suspicions, and that our experience is not unique. So, it's still good to acknowledge that it's a problem. Thank you. Thank you. So, Elena, in the one minute or so we have left, I'll ask you a question. Do you have mechanisms in the modeling software to connect, let's say, genes to mechanical properties? To mechanical properties. So, can a node be representing something like stiffness, right? Wall stiffness, or is that something that's a little bit more challenging to do than just building gene networks? So I don't know enough about how to represent stiffness with mathematical equations. If there is a way to model it through a finite number of states, I don't see why not. But if it's a more continuous process, It's a more continuous process which you would normally model with differential equations, and it doesn't lend itself to any sort of discretization, then maybe that's just not the correct framework. But essentially, any node can represent whatever you want as long as its behavior and dynamics can be captured through a sequence of updates through a finite number of states. 